

<HTML>
<HEAD>
<TITLE>HOWTO: Get a Window Handle Without Specifying an Exact Title </TITLE>

<!--STYLE_BEGIN-->
<style>@import url(../../msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="../../msdn_ie3.css">
<!--STYLE_END-->

<META HTTP-EQUIV="CONTENT-Type" CONTENT="text/html; charset=us-ascii">
<META NAME="ms.locale" CONTENT="EN-US">
<META NAME="Category" CONTENT="Support; KB Article">
<META NAME="KBID" CONTENT="Q147659">
<META NAME="KBModify" CONTENT="1997/09/30">
<META NAME="KBCreate" CONTENT="1996/02/28">
<META NAME="Keywords" CONTENT="APrgWindow vb432 VB4WIN vb5all vbwin GnrlVb kbprg">
<META NAME="KBArea" CONTENT="Support; KB; vbapps">
<META NAME="Description" CONTENT="  The Visual Basic AppActivate command can only activate a window if you know the exact window title. Similarly, the Windows FindWindow function can only find a window handle if you know the exact window title.  This article demonstrates how to searc...">
<META NAME="Product" CONTENT="vbapps">
<META NAME="Platform" CONTENT="Windows">
<META NAME="Technology" CONTENT=" ">
<META NAME="Premium" CONTENT="support">

<META NAME="nyms" CONTENT="QBS0,QA4H,QAGQ,QDL9,QBWO,QBWN,QAUD,QATX,QBWQ,QAH6,QAY5,QAMB,QAPF,QAH7,QAH4 V02180118">
</HEAD>

<BODY BGCOLOR="#FFFFFF" LEFTMARGIN="0" RIGHTMARGIN="0" TOPMARGIN="0">


<!--DOCBODY_START-->
<BR>
<CENTER>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" VALIGN="top" WIDTH="90%">
	<TR>
		<TD VALIGN="top">
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<H1>HOWTO: Get a Window Handle Without Specifying an Exact Title</H1>
			</FONT>
			<FONT FACE="verdana,arial,helvetica" SIZE="1">
			Last reviewed:  September 30, 1997</FONT><BR>
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<B>Article ID: Q147659</B>
			</FONT>
		</TD>
	</TR>
	<TR>
	<TD>
	<FONT FACE="Verdana, Arial, Helvetica" SIZE=2>



 
 
The information in this article applies to:

<UL><LI>Microsoft Visual Basic Control Creation, Learning, Professional, and
   Enterprise Editions for Windows, version 5.0
<LI>Microsoft Visual Basic Standard, Professional, and Enterprise Editions,
   32-bit only, for Windows, version 4.0
</UL> 
<P>
<P><h2>SUMMARY</h2>
 
<P>
The Visual Basic AppActivate command can only activate a window if you know
the exact window title. Similarly, the Windows FindWindow function can only
find a window handle if you know the exact window title.
<P>
This article demonstrates how to search for a window that has a title that
is like the title you specify -- but not an exact match. The sample code
searches through the available windows, comparing the window titles to a
pattern by using the Visual Basic Like operator. You can also use the
sample code to find a window based on its class name or ID. This can be
extremely helpful when you need to send keystrokes to other Applications.
<P>
<P><h2>MORE INFORMATION</h2>
 
<P>
<P><h3>FindWindowLike Function</h3>
 
<P>
The sample code provides a find window function named FindWindowLike.
FindWindowLike does a recursive search for windows matching the description
you give it. After completing the search, FindWindow returns the number of
windows it found that match your description. It also returns the window
handles in an array that you pass to it. Once you have a window handle, you
can call many Windows API functions to manipulate it. For example, you
could set the focus to it, or move it. The example in this article shows
how to set the focus.
<P>
<P><h3>Parameters Passed to FindWindowLike Function</h3>
 
<P>
The FindWindowLike function searches for windows based on the four
parameters you pass it:

<UL><LI>The hWndStart parameter specifies the handle of the window you want to
   search under. For example, if you gave the handle to a Visual Basic
   form, FindWindowLike would search through all the controls on that form.
   If you pass 0 for hWndStart, FindWindowLike searches through all
   available windows.

<LI>The WindowText parameter specifies the pattern used to compare window
   text. The Caption property of a Visual Basic Form is the same as the
   window text. The pattern is any string following the guidelines for the
   Visual Basic Like operator.

<LI>The ClassName parameter specifies a pattern used to compare a window
   class name. A window's class name identifies the type of window. You can
   find out a window's class name by using the utility SPY.EXE that comes
   with Microsoft Visual C/C++, or you can use the example given in the
   following article in the Microsoft Knowledge Base:
<P>
   ARTICLE-ID: <B><A href="../vbwin/q112649.htm">Q112649</A></B>
<PRE>   TITLE     : HOWTO: Get a Window's Class Name and Other Attributes

</PRE></UL>FindWindowLike uses the Visual Basic Like operator when comparing class
names.

<UL><LI>The ID parameter specifies a specific child ID. This parameter is very
   useful for finding specific controls in a window. A window's ID can also
   be found by using SPY.EXE or the technique described in the following
   article in the Microsoft Knowledge Base:
<P>
   ARTICLE-ID: <B><A href="../vbwin/q112649.htm">Q112649</A></B>
<PRE>   TITLE     : How to Get a Window's Class Name and Other Attributes

   The ID parameter can be a decimal number or a hexadecimal string. If you
   use a hexadecimal string, prefix the hexadecimal number with &amp;H. If you
   do not want to search for a specific ID, specify Null for the ID
   parameter.

</PRE></UL><h3>FindWindowLike Examples and Their Results</h3>
 
<P>
Here are several example calls to FindWindowLike and the results it should
return:

<OL><P><LI>r = FindWindowLike(hWnds(), 0, "*", "*", Null)
   Returns: All the available windows.

<P><LI>r = FindWindowLike(hWnds(), 0, "*Excel*", "*", Null)
   Returns: All the windows with "Excel" in the window text.

<P><LI>r = FindWindowLike(hWnds(), 0, "Microsoft Excel*", "XLMAIN", Null)
   Returns: All the windows having window text that begins with "Microsoft
<P>
   Excel" and that contains class name "XLMAIN"

<P><LI>r = FindWindowLike(hWnds(), Form1.Hwnd, "*", "*", "&amp;HA1")
   Returns: The child window of the Form1 window that has an ID of
   hexadecimal A1.

<P><LI>r = FindWindowLike(hWnds(), Form1.Hwnd, "*", "*", 2)
   Returns: The child window of the Form1 window that has an ID of 2.
<P>
</OL><h3>Uses for FindWindowLike</h3>
 
<P>
The FindWindowLike function can be especially powerful when used in a
series of searches. For example, you can search once to find an open
instance of the PIF Editor that comes with Microsoft Windows. Then once you
have the handle to the PIF Editor window, you can search again for a
specific control's window handle by using the PIF Editor's window handle
and the ID of the control's window. Here is an example:
<P>
<PRE>   r = FindWindowLike(hWnds(), 0, "PIF Editor*", "Pif", Null)
   ' Assuming the previous returned at least one handle
   r = FindWindowLike(hWnds(), hWnds(1), "*", "*", 103)

</PRE></OL>After you have the control's window handle, you can give it the focus and
send it keystrokes. In addition, there are a lot of other things you can do
once you have a window's handle.
<P>
<P><h3>Sample Code</h3>
 
<P>
The sample code listed in the example below uses several Windows API
functions to accomplish what was described above. Here are the key ones
including descriptions of their uses:

<UL><LI>GetDeskTopWindow gets the handle to the DeskTop window when 0 (zero) is
   passed as the hWndStart, so you can use it as a starting point for the
   recursive search.

<LI>GetWindow gets a window handle based on a relationship to another window
   handle, so you can use it to get child windows and their siblings.

<LI>GetWindowText gets the text of a window for comparison to the passed
   WindowText.

<LI>GetClassName gets a window's class name, which you can compare to the
   passed ClassName.

<LI>GetWindowLong gets information about a window. The sample code uses it
   to get the ID number of a window for comparison with the passed ID.
<P>
</UL><h3>Step-by-Step Example</h3>
 

<OL><P><LI>Start a new Standard EXE project. Form1 is created by default.

<P><LI>Add three Text boxes (Text1, Text2, and Text3) to Form1.

<P><LI>Put the following code in the Form1 click event:
<P>
<P><PRE>      Private Sub Form_Click()
      Static hWnds() As Variant
      ' Find window with title "Form1":
      r = FindWindowLike(hWnds(), 0, "Form1", "*", Null)
      If r = 1 Then
      Debug.Print "Found "; Hex(hWnds(1))
      ' Find a child window of "Form1" with ID=2:
      ' Notice that the handle from the first search is used.
      r = FindWindowLike(hWnds(), hWnds(1), "*", "*", "&amp;H00000002")
      If r = 1 Then
      Debug.Print "Found child "; Hex(hWnds(1))
      Debug.Print "Setting focus to child ..."
      ' Set the focus to the child window with ID=2:
      hw = hWnds(1)
      r = SetFocusAPI(hw)
      ElseIf r &gt; 1 Then
      ' This should not happen.
      Debug.Print "Found more than one child ID=2"
      Else
      Debug.Print "Did not find child ID=2"
      End If
      ElseIf r &gt; 1 Then
      Debug.Print "Found "; r; " Windows"
      End If
      End Sub
</PRE>
<P><LI>From the Insert Menu select Module to add a new module to the project.

<P><LI>Put the following code in the new module:
<P>
<PRE>   Declare Function SetFocusAPI Lib "user32" Alias "SetForegroundWindow" _
    (ByVal hwnd As Long) As Long
   Declare Function GetWindow Lib "user32" (ByVal hwnd As Long, _
    ByVal wCmd As Long) As Long
   Declare Function GetDesktopWindow Lib "user32" () As Long
   Declare Function GetWindowLW Lib "user32" Alias "GetWindowLongA" _
    ByVal hwnd As Long, ByVal nIndex As Long) As Long
   Declare Function GetParent Lib "user32" (ByVal hwnd As Long) As Long
   Declare Function GetClassName Lib "user32" Alias "GetClassNameA" _
    (ByVal hwnd As Long, ByVal lpClassName As String, _
     ByVal nMaxCount As Long) As Long
   Declare Function GetWindowText Lib "user32" Alias "GetWindowTextA" _
    (ByVal hwnd As Long, ByVal lpString As String, ByVal cch As Long) _
     As Long

   Public Const GWL_ID = (-12)
   Public Const GW_HWNDNEXT = 2
   Public Const GW_CHILD = 5
   'FindWindowLike
   ' - Finds the window handles of the windows matching the specified
   '   parameters
   '
   'hwndArray()
   ' - An integer array used to return the window handles
   '
   'hWndStart
   ' - The handle of the window to search under.
   ' - The routine searches through all of this window's children and their
   '   children recursively.
   ' - If hWndStart = 0 then the routine searches through all windows.
   '
   'WindowText
   ' - The pattern used with the Like operator to compare window's text.
   '
   'ClassName
   ' - The pattern used with the Like operator to compare window's class
   '   name.
   '
   'ID
   ' - A child ID number used to identify a window.
   ' - Can be a decimal number or a hex string.
   ' - Prefix hex strings with "&amp;H" or an error will occur.
   ' - To ignore the ID pass the Visual Basic Null function.
   '
   'Returns
   ' - The number of windows that matched the parameters.
   ' - Also returns the window handles in hWndArray()
   '
   '----------------------------------------------------------------------
   'Remove this next line to use the strong-typed declarations
   #Const WinVar = True
   #If WinVar Then
   Function FindWindowLike(hWndArray() As Variant, _
    ByVal hWndStart As Variant, WindowText As String, _
     Classname As String, _  ID) As Integer Dim hwnd
   Dim r
   Static level
   Static iFound
   #ElseIf Win32 Then
   Function FindWindowLike(hWndArray() As Long, ByVal hWndStart As Long, _
    WindowText As String, Classname As String, ID) As Long
   Dim hwnd As Long
   Dim r As Long
   ' Hold the level of recursion:
   Static level As Long
   ' Hold the number of matching windows:
   Static iFound As Long
   #ElseIf Win16 Then
   Function FindWindowLike(hWndArray() As Integer, _
    ByVal hWndStart As Integer, WindowText As String, _
    Classname As String, ID) As Integer
   Dim hwnd As Integer
   Dim r As Integer
   ' Hold the level of recursion:
   Static level As Integer
   Hold the number of matching windows:
   Static iFound As Integer
   #End If
   Dim sWindowText As String
   Dim sClassname As String
   Dim sID
   ' Initialize if necessary:
   If level = 0 Then
   iFound = 0
   ReDim hWndArray(0 To 0)
   If hWndStart = 0 Then hWndStart = GetDesktopWindow()
   End If
   ' Increase recursion counter:
   level = level + 1
   ' Get first child window:
   hwnd = GetWindow(hWndStart, GW_CHILD)
   Do Until hwnd = 0
   DoEvents ' Not necessary
   ' Search children by recursion:
   r = FindWindowLike(hWndArray(), hwnd, WindowText, Classname, ID)
   ' Get the window text and class name:
   sWindowText = Space(255)
   r = GetWindowText(hwnd, sWindowText, 255)
   sWindowText = Left(sWindowText, r)
   sClassname = Space(255)
   r = GetClassName(hwnd, sClassname, 255)
   sClassname = Left(sClassname, r)
   ' If window is a child get the ID:
   If GetParent(hwnd) &lt;&gt; 0 Then
   r = GetWindowLW(hwnd, GWL_ID)
   sID = CLng("&amp;H" &amp; Hex(r))
   Else
   sID = Null
   End If
   ' Check that window matches the search parameters:
   If sWindowText Like WindowText And sClassname Like Classname Then
   If IsNull(ID) Then
   ' If find a match, increment counter and
   '  add handle to array:
   iFound = iFound + 1
   ReDim Preserve hWndArray(0 To iFound)
   hWndArray(iFound) = hwnd
   ElseIf Not IsNull(sID) Then
   If CLng(sID) = CLng(ID) Then
   ' If find a match increment counter and
   '  add handle to array:
   iFound = iFound + 1
   ReDim Preserve hWndArray(0 To iFound)
   hWndArray(iFound) = hwnd
   End If
   End If
   Debug.Print "Window Found: "
   Debug.Print "  Window Text  : " &amp; sWindowText
   Debug.Print "  Window Class : " &amp; sClassname
   Debug.Print "  Window Handle: " &amp; CStr(hwnd)
   End If
   ' Get next child window:
   hwnd = GetWindow(hwnd, GW_HWNDNEXT)
   Loop
   ' Decrement recursion counter:
   level = level - 1
   ' Return the number of windows found:
   FindWindowLike = iFound
   End Function

</PRE><P><LI>Save the Project.

<P><LI>Run the code, and then click the form.
<P>
</OL>First, the program searches for Form1. If Form1 is found, the program
searches Form1 for a control with an ID of 2. It should find one because
Visual Basic numbers the IDs as you add controls. With three text boxes on
Form1, one should have an ID of 2. After finding the control, the code sets
the focus to the window by calling SetFocusAPI.
<P>
If you set the focus to one of your controls before clicking the Form, you
should see the focus shift, always to the same control, when you click the
form.
<P>
<P><h2>REFERENCES</h2>
 
<P>
Microsoft Developers Network Library. January 1997. Platform SDK
Reference.
<P>
"Visual Basic Programmer's Guide to the Windows API," Daniel Appleman,
Ziff-Davis Press, 1993
<P>

	</FONT>
	</TD>
	</TR>
</TABLE>
<P>


<!--DOCBODY_END-->

<!--FOOTER_START-->
<table cellpadding=5 border=0 width="90%">
<tr>
<td>
	<HR WIDTH="90%">

<BLOCKQUOTE>
<FONT FACE="Verdana, Arial, Helvetica" SIZE="1">
<SPAN STYLE="font-family:verdana,arial,helvetica; font-size:8pt">
Additional query words: Common API APIs<BR>
Keywords          : APrgWindow vb432 VB4WIN vb5all vbwin GnrlVb kbprg<BR>
Technology        : kbvba<BR>
Version           : WINDOWS:4.0 5.0<BR>
Platform          : WINDOWS<BR>
Issue type        : kbhowto<BR>

</SPAN>
</FONT>
<BR>
<BR>
THE INFORMATION PROVIDED IN THE MICROSOFT KNOWLEDGE BASE IS
PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND.  MICROSOFT DISCLAIMS
ALL WARRANTIES, EITHER EXPRESS OR IMPLIED, INCLUDING THE WARRANTIES
OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  IN NO
EVENT SHALL MICROSOFT CORPORATION OR ITS SUPPLIERS BE LIABLE FOR
ANY DAMAGES WHATSOEVER INCLUDING DIRECT, INDIRECT, INCIDENTAL,
CONSEQUENTIAL, LOSS OF BUSINESS PROFITS OR SPECIAL DAMAGES, EVEN IF
MICROSOFT CORPORATION OR ITS SUPPLIERS HAVE BEEN ADVISED OF THE
POSSIBILITY OF SUCH DAMAGES.  SOME STATES DO NOT ALLOW THE EXCLUSION
OR LIMITATION OF LIABILITY FOR CONSEQUENTIAL OR INCIDENTAL DAMAGES
SO THE FOREGOING LIMITATION MAY NOT APPLY.
</BLOCKQUOTE>
<P>
<center>
	<FONT FACE="Verdana,Arial,Helvetica" SIZE="1">
	Last reviewed:  September 30, 1997</FONT>
	<BR>
	<A href="../cpyright.htm" STYLE="font: bold 7pt Verdana,Arial,Helvetica">&copy; 1998 Microsoft Corporation. All rights reserved. Terms of Use.</A><BR>
	
</center>
</td>
</tr>
</table>

<!--FOOTER_END-->
</FONT>
</BODY>
</HTML>
