

<HTML>
<HEAD>
<TITLE>XL: SQLExecQuery and SQLRequest Limited to 255 Characters </TITLE>

<!--STYLE_BEGIN-->
<style>@import url(../../msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="../../msdn_ie3.css">
<!--STYLE_END-->

<META HTTP-EQUIV="CONTENT-Type" CONTENT="text/html; charset=us-ascii">
<META NAME="ms.locale" CONTENT="EN-US">
<META NAME="Category" CONTENT="Support; KB Article">
<META NAME="KBID" CONTENT="Q114992">
<META NAME="KBModify" CONTENT="1997/09/02">
<META NAME="KBCreate" CONTENT="1994/05/18">
<META NAME="Keywords" CONTENT="kbprg ODBCGen xlvbahowto kbbuglist kbcode kbprg">
<META NAME="KBArea" CONTENT="Support; KB; vbapps">
<META NAME="Description" CONTENT="  In Microsoft Excel, if you use the SQLExecQuery function or the SQLRequest function in a Visual Basic procedure to run a query on an external data source, and your query is larger than 255 characters, you may receive a general protection (GP) fault...">
<META NAME="Product" CONTENT="vbapps">
<META NAME="Platform" CONTENT="Windows">
<META NAME="Technology" CONTENT=" ">
<META NAME="Premium" CONTENT="support">

<META NAME="nyms" CONTENT="QAGU,QBVP,QAY5,QAUD,QBKN,QBJZ,QBWS,QBXS,QAY2,QAYL,QAB9,QBS0,QAH4,QBV8,QACF V02180118">
</HEAD>

<BODY BGCOLOR="#FFFFFF" LEFTMARGIN="0" RIGHTMARGIN="0" TOPMARGIN="0">


<!--DOCBODY_START-->
<BR>
<CENTER>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" VALIGN="top" WIDTH="90%">
	<TR>
		<TD VALIGN="top">
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<H1>XL: SQLExecQuery and SQLRequest Limited to 255 Characters</H1>
			</FONT>
			<FONT FACE="verdana,arial,helvetica" SIZE="1">
			Last reviewed:  September 2, 1997</FONT><BR>
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<B>Article ID: Q114992</B>
			</FONT>
		</TD>
	</TR>
	<TR>
	<TD>
	<FONT FACE="Verdana, Arial, Helvetica" SIZE=2>



 
 
The information in this article applies to:

<UL><LI>Microsoft Excel for Windows, versions 5.0, 5.0c
<LI>Microsoft Excel for Windows 95, version 7.0
</UL> 
<P>
<P><h2>SYMPTOMS</h2>
 
<P>
In Microsoft Excel, if you use the SQLExecQuery function or the SQLRequest
function in a Visual Basic procedure to run a query on an external data
source, and your query is larger than 255 characters, you may receive a
general protection (GP) fault when you run the procedure.
<P>
<P><h2>CAUSE</h2>
 
<P>
When you use a function in the XLODBC.XLA add-in, such as SQLRequest, and
you use a query that contains more than 255 characters, the query is
truncated after the first 255 characters.
<P>
As a result, you can convert your query string into an array, where each
element of the array can contain up to 255 characters; however, you may
receive a GP fault if an element in the array is larger than 127
characters. Note that this behavior does not occur every time you run the
procedure. The results are not consistent.
<P>
You can also use the Range object to reference multiple cells that contain
your query. Again, you may receive a GP fault if any of the cells in the
range that contains your query contain more than 127 characters.
<P>
<P><h2>WORKAROUND</h2>
 
<P>
To avoid receiving a GP fault, and to avoid having your query truncated
when you use the SQLExecQuery or the SQLRequest functions with a query that
is larger than 255 characters, use one of the following methods:
<P>
<P><h3>Array Method</h3>
 
<P>
Limit the elements in the array that you create to handle your query to 127
characters or less. This example uses the QueryToArray function to return
your query as an array of values that each contain 127 characters of your
query. This array can then be used as your "new" query.

<OL><P><LI>Insert a new module in your workbook.

<P><LI>Reference the XLODBC.XLA add-in in your Visual Basic module with the
   following steps:
<P>
   a. From the File menu, choose Open. From the Directories list, select
<P><PRE>      the \LIBRARY\MSQUERY subdirectory of the Microsoft Excel directory.
      From the File Name list, select XLODBC.XLA and choose OK.
</PRE><P>
   b. From the Tools menu, choose References. In the Available References
<P><PRE>      list, select the XLODBC.XLA check box, and choose OK.
</PRE>
<P><LI>In the module, enter the following code. Note that this example uses the
   NWind data source installed with Microsoft Query, and the query used in
   the example selects data from the Employee table. You can modify this
   example to use any available data source and table.
<P>
<PRE>   Sub Return_Data()

      ' Dimensions variables
      Dim chan As Integer, longquery As Variant, query As Variant

      ' Establish a connection to NWind data source and set
      ' value of variable 'chan' to channel number returned
      ' Note that in the following line, C:\WINDOWS should be your
      ' Microsoft Windows directory
      ' If using Microsoft Excel 7.0, the DBQ string will be different
      ' from that shown here.
      chan = sqlopen("DSN=NWind;DBQ=C:\WINDOWS\MSAPPS\MSQUERY;FIL=dBase4;")

      ' Set value of variable 'longquery' to query you want to run
      longquery = "SELECT employee.ADDRESS, employee.BIRTHDATE, " &amp; _
       "employee.CITY, employee.COUNTRY, employee.EMP_TITLE, " &amp; _
       "employee.EMPLOY_ID, employee.EXTENSION, " &amp; _
       "employee.FIRST_NAME, employee.HIRE_DATE, employee.HOME_PHONE, " &amp; _
       "employee.LAST_NAME, employee.NOTES, employee.REGION, " &amp; _
       "employee.REPORTS_TO, employee.ZIP_CODE FROM " &amp; _
       "c:\windows\msapps\msquery\employee.dbf employee"

      ' Use 'QueryToArray' function with variable 'longquery'
      ' Set value of variable 'query' to value returned by function
      query = QueryToArray(longquery)

      ' Execute query using variable 'query' returned by function
      SQLExecQuery chan, query

      ' Return data starting in cell A1 on Sheet1
      SQLRetrieve chan, Application.Worksheets("Sheet1").Cells(1, 1)

      ' Close channel
      SQLClose chan

   End Sub

</PRE></OL>Function QueryToArray(Q, Optional MaxLength) As Variant
<P>
<PRE>   ' Dimension variables
   Dim Shift As Integer, Size As Integer, I As Integer

   ' If no maximum string length is provided (MaxLength), then
   ' set maximum size of string in array to 127 characters
   If IsMissing(MaxLength) Then MaxLength = 127

   ' Account for Option Base default value
   Shift = LBound(Array(1)) - 1

   ' Determine the number of elements that will be contained
   ' in the array that this function returns by dividing the
   ' number of characters in the long query by the maximum
   ' size of the string
   Size = (Len(Q) + MaxLength) / MaxLength

   ' Dimension array 'TmpArr'
   ReDim tmparr(Size + Shift, 1 + Shift) As String

   For I = 1 To Size
   ' Load array 'TmpArr' with one value for each 127 characters
   ' of your query
      tmparr(I + Shift, 1 + Shift) = _
       Mid$(Q, (I - 1) * MaxLength + 1, MaxLength)
   Next I

   ' Assign array returned by QueryToArray function to temparr
   QueryToArray = tmparr

</PRE>End Function

<OL><P><LI>To run your procedure, choose Macro from the Tools menu. From the Macro
   Name/Reference list, select Return_Data, and choose Run.
<P>
</OL>The data returned from the query is now contained in cell A9 on Sheet1 in
your workbook.
<P>
<P><h3>Range Method</h3>
 
<P>
To avoid truncating your query when you use the SQLExecQuery function or
the SQLRequest function, you can also use the Range method to reference a
query contained in multiple cells on a worksheet. The following is an
example of using this method:

<OL><P><LI>Enter your query string on a worksheet in your workbook. For example,
   enter the following on Sheet1:
<P>
<P><PRE>      A1: SELECT employee.ADDRESS, employee.BIRTHDATE, employee.CITY,
      A2: employee.COUNTRY, employee.EMP_TITLE, employee.EMPLOY_ID,
      A3: employee.EXTENSION, employee.FIRST_NAME, employee.HIRE_DATE,
      A4: employee.HOME_PHONE, employee.LAST_NAME, employee.NOTES,
      A5: employee.REGION, employee.REPORTS_TO, employee.ZIP_CODE FROM
      A6: c:\windows\msapps\msquery\employee.dbf employee
</PRE><P>
</OL>NOTE: To avoid receiving a GP fault when you use this method in a procedure
in Microsoft Excel version 5.0, make sure that each cell in the range
(A1:A6 above) that contains your query, does not contain more than 127
characters. Also, add a space at the end of lines A1:A5. A6 does not
require the extra space at the end of the line.

<OL><P><LI>Insert a new module sheet in your workbook.

<P><LI>Reference the XLODBC.XLA add-in in your Visual Basic module with the
   following steps:
<P>
   a. From the File menu, choose Open. From the Directories list, select
<P><PRE>      the \LIBRARY\MSQUERY subdirectory of the Microsoft Excel directory.
      From the File Name list, select XLODBC.XLA and choose OK.
</PRE><P>
   b. From the Tools menu, choose References. In the Available References
<P><PRE>      list, select the XLODBC.XLA check box, and choose OK.
</PRE>
<P><LI>In the new module, enter the following:
<P>
<PRE>   Sub From_Worksheet()
      ' Dimensions variables
      Dim chan As Integer, query As Variant

      ' Establish a connection to NWind data source and set
      ' value of variable 'chan' to channel number returned
      chan = sqlopen("DSN=NWind;DBQ=C:\WINDOWS\MSAPPS\MSQUERY;FIL=dBase4;")

      ' Set value of variable 'query' to query contained
      ' in cells A1:A6 on Sheet1
      query = Worksheets("Sheet1").Range("A1:A6")

      ' Execute query using variable 'query' returned from worksheet
      SQLExecQuery chan, query

      ' Return data to cell A9 on Sheet1
      SQLRetrieve chan, Application.Worksheets("Sheet1").Cells(9, 1)

      ' Close channel
      SQLClose chan

   End Sub

</PRE><P><LI>To run your procedure, choose Macro from the Tools menu. From the Macro
   Name/Reference list, select From_Worksheet, and choose Run.
<P>
</OL>The data returned from the query is now contained in cell A9 on Sheet1 in
your workbook.
<P>
<P><h2>STATUS</h2>
 
<P>
Microsoft has confirmed this to be a problem in the Microsoft products
listed at the beginning of this article. This problem was corrected in
Microsoft Excel for Windows version 5.0c and Microsoft Excel for Windows 95
version 7.0.
<P>
Note that the 255 character limit when you use a function in the XLODBC.XLA
add-in still exists, but you will no longer receive a GP fault.
<P>
<P><h2>MORE INFORMATION</h2>
 
<P>
You can use the SQLRequest function to connect to an external data source
and run a query from a worksheet, and then return the result as an array.
The SQLExecQuery function executes a query on a data source with a
connection that has been established using SQLOpen. Both of these functions
are contained in the XLODBC.XLA add-in. You must establish a reference to
the XLODBC.XLA file using the References dialog box before you can use
either function in a procedure.
<P>
<P><h2>REFERENCES</h2>
 
<P>
For more information about the SQLExecQuery function, choose the Search
button in the Visual Basic Reference and type:
<P>
<PRE>   SQLExecQuery function

</PRE></OL>For more information about the SQLRequest function, choose the Search
button in the Visual Basic Reference and type:
<P>
<PRE>   SQLRequest function
</PRE>

	</FONT>
	</TD>
	</TR>
</TABLE>
<P>


<!--DOCBODY_END-->

<!--FOOTER_START-->
<table cellpadding=5 border=0 width="90%">
<tr>
<td>
	<HR WIDTH="90%">

<BLOCKQUOTE>
<FONT FACE="Verdana, Arial, Helvetica" SIZE="1">
<SPAN STYLE="font-family:verdana,arial,helvetica; font-size:8pt">
Additional query words: 1.00 5.00 5.00c 7.00 msquery sql addins addin<BR>
macro gpf<BR>
Keywords          : kbprg ODBCGen xlvbahowto kbbuglist kbcode kbprg<BR>
Version           : 5.00 5.00c 7.00<BR>
Platform          : WINDOWS<BR>

</SPAN>
</FONT>
<BR>
<BR>
THE INFORMATION PROVIDED IN THE MICROSOFT KNOWLEDGE BASE IS
PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND.  MICROSOFT DISCLAIMS
ALL WARRANTIES, EITHER EXPRESS OR IMPLIED, INCLUDING THE WARRANTIES
OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  IN NO
EVENT SHALL MICROSOFT CORPORATION OR ITS SUPPLIERS BE LIABLE FOR
ANY DAMAGES WHATSOEVER INCLUDING DIRECT, INDIRECT, INCIDENTAL,
CONSEQUENTIAL, LOSS OF BUSINESS PROFITS OR SPECIAL DAMAGES, EVEN IF
MICROSOFT CORPORATION OR ITS SUPPLIERS HAVE BEEN ADVISED OF THE
POSSIBILITY OF SUCH DAMAGES.  SOME STATES DO NOT ALLOW THE EXCLUSION
OR LIMITATION OF LIABILITY FOR CONSEQUENTIAL OR INCIDENTAL DAMAGES
SO THE FOREGOING LIMITATION MAY NOT APPLY.
</BLOCKQUOTE>
<P>
<center>
	<FONT FACE="Verdana,Arial,Helvetica" SIZE="1">
	Last reviewed:  September 2, 1997</FONT>
	<BR>
	<A href="../cpyright.htm" STYLE="font: bold 7pt Verdana,Arial,Helvetica">&copy; 1998 Microsoft Corporation. All rights reserved. Terms of Use.</A><BR>
	
</center>
</td>
</tr>
</table>

<!--FOOTER_END-->
</FONT>
</BODY>
</HTML>
