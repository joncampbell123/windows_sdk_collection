

<HTML>
<HEAD>
<TITLE>ACC: How to Determine When a Shelled Process Ends </TITLE>

<!--STYLE_BEGIN-->
<style>@import url(../../msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="../../msdn_ie3.css">
<!--STYLE_END-->

<META HTTP-EQUIV="CONTENT-Type" CONTENT="text/html; charset=us-ascii">
<META NAME="ms.locale" CONTENT="EN-US">
<META NAME="Category" CONTENT="Support; KB Article">
<META NAME="KBID" CONTENT="Q178116">
<META NAME="KBModify" CONTENT="1998/01/05">
<META NAME="KBCreate" CONTENT="1997/12/15">
<META NAME="Keywords" CONTENT="PgmHowto">
<META NAME="KBArea" CONTENT="Support; KB; vbapps">
<META NAME="Description" CONTENT="  Advanced: Requires expert coding, interoperability, and multiuser skills.  When you run the Shell() function in a Visual Basic for Applications procedure, it starts an executable program asynchronously and returns control to the procedure. This she...">
<META NAME="Product" CONTENT="vbapps">
<META NAME="Platform" CONTENT="Windows">
<META NAME="Technology" CONTENT=" ">
<META NAME="Premium" CONTENT="support">

<META NAME="nyms" CONTENT="QBS0,QAIJ,QAY5,QAB9,QBV8,QAJH,QA1S,QAH4,QDIV,QDN9,QBWS,QAH6,QA5F,QAMH,QADN P1 P2 P3 P4 P5 P6 T2 P7 V02180118">
</HEAD>

<BODY BGCOLOR="#FFFFFF" LEFTMARGIN="0" RIGHTMARGIN="0" TOPMARGIN="0">


<!--DOCBODY_START-->
<BR>
<CENTER>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" VALIGN="top" WIDTH="90%">
	<TR>
		<TD VALIGN="top">
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<H1>ACC: How to Determine When a Shelled Process Ends</H1>
			</FONT>
			<FONT FACE="verdana,arial,helvetica" SIZE="1">
			Last reviewed:  January 5, 1998</FONT><BR>
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<B>Article ID: Q178116</B>
			</FONT>
		</TD>
	</TR>
	<TR>
	<TD>
	<FONT FACE="Verdana, Arial, Helvetica" SIZE=2>



 
 
The information in this article applies to:

<UL><LI>Microsoft Access versions 7.0, 97
</UL> 
<P>
<P><h2>SUMMARY</h2>
 
<P>
Advanced: Requires expert coding, interoperability, and multiuser skills.
<P>
When you run the Shell() function in a Visual Basic for Applications
procedure, it starts an executable program asynchronously and returns
control to the procedure. This shelled program continues to run
independently of your procedure until you close it.
<P>
If your procedure needs to wait for the shelled process to end, you can use
the Windows API to poll the status of the application, but this is not very
efficient. This article demonstrates a more efficient method.
<P>
This article assumes that you are familiar with Visual Basic for
Applications and with creating Microsoft Access applications using the
programming tools provided with Microsoft Access. For more information
about Visual Basic for Applications, please refer to your version of the
"Building Applications with Microsoft Access" manual.
<P>
<P><h2>MORE INFORMATION</h2>
 
<P>
The Win32 API has integrated functionality that enables your application to
wait until a shelled process has completed. To use these functions, you
need to have a handle to the shelled process. To accomplish this, you need
to use the CreateProcess() function instead of the Shell() function to
begin your shelled program.
<P>
<P><h3>Creating the Shelled Process</h3>
 
<P>
To create an addressable process, use the CreateProcess() function to start
your shelled application. The CreateProcess() function gives your program
the process handle of the shelled process via one of its passed parameters.
<P>
<P><h3>Waiting for the Shelled Process to End</h3>
 
<P>
Once you use the CreateProcess() function to get a process handle, you can
pass that handle to the WaitForSingleObject() function. This causes your
Visual Basic for Applications procedure to suspend execution until the
shelled process ends.
<P>
Below are the steps necessary to build a Visual Basic for Applications
procedure that uses the CreateProcess() function to run the Windows Notepad
(NOTEPAD.EXE) application. This code shows by example how to use the
Windows API CreateProcess() and WaitForSingleObject() functions to wait
until a shelled process ends before resuming execution.
<P>
The syntax of the CreateProcess() function is complex, so in the example
code, it is encapsulated into a function called ExecCmd(). ExecCmd() takes
one parameter, the command line of the application to execute.
<P>
<P><h3>Step-by-Step Instructions on How to Create the CreateProcess() Procedure</h3>
 

<OL><P><LI>Create a module and type the following lines in the Declarations
   section:
<P>
<P><PRE>      Option Explicit
</PRE><P>
<P><PRE>      Private Type STARTUPINFO
<PRE></PRE>         cb As Long
         lpReserved As String
         lpDesktop As String
         lpTitle As String
         dwX As Long
         dwY As Long
         dwXSize As Long
         dwYSize As Long
         dwXCountChars As Long
         dwYCountChars As Long
         dwFillAttribute As Long
         dwFlags As Long
         wShowWindow As Integer
         cbReserved2 As Integer
         lpReserved2 As Long
         hStdInput As Long
         hStdOutput As Long
         hStdError As Long
      End Type

      Private Type PROCESS_INFORMATION
         hProcess As Long
         hThread As Long
         dwProcessID As Long
         dwThreadID As Long
      End Type

      Private Declare Function WaitForSingleObject Lib "kernel32" (ByVal _
         hHandle As Long, ByVal dwMilliseconds As Long) As Long

      Private Declare Function CreateProcessA Lib "kernel32" (ByVal _
         lpApplicationName As Long, ByVal lpCommandLine As String, ByVal _
         lpProcessAttributes As Long, ByVal lpThreadAttributes As Long, _
         ByVal bInheritHandles As Long, ByVal dwCreationFlags As Long, _
         ByVal lpEnvironment As Long, ByVal lpCurrentDirectory As Long, _
         lpStartupInfo As STARTUPINFO, lpProcessInformation As _
         PROCESS_INFORMATION) As Long

      Private Declare Function CloseHandle Lib "kernel32" (ByVal _
         hObject As Long) As Long

      Private Const NORMAL_PRIORITY_CLASS = &amp;H20&amp;
      Private Const INFINITE = -1&amp;

</PRE><P><LI>Type the following two procedures in the module:
<P>
<P><PRE>      Public Sub ExecCmd(cmdline$)
<PRE></PRE>         Dim proc As PROCESS_INFORMATION
         Dim start As STARTUPINFO
         Dim ReturnValue As Integer

         ' Initialize the STARTUPINFO structure:
         start.cb = Len(start)

         ' Start the shelled application:
         ReturnValue = CreateProcessA(0&amp;, cmdline$, 0&amp;, 0&amp;, 1&amp;, _
            NORMAL_PRIORITY_CLASS, 0&amp;, 0&amp;, start, proc)

         ' Wait for the shelled application to finish:
         Do
            ReturnValue = WaitForSingleObject(proc.hProcess, 0)
            DoEvents
            Loop Until ReturnValue &lt;&gt; 258

         ReturnValue = CloseHandle(proc.hProcess)
      End Sub

      Sub Testing()
         ExecCmd "NOTEPAD.EXE"
         MsgBox "Process Finished"
      End Sub

</PRE><P><LI>Type "Testing" (without the quotation marks) in the Debug window, and
   then press Enter.
<P>
   Note that Notepad starts.

<P><LI>On the File menu, click Exit.
<P>
   Note that "Process Finished" appears in a message box in Microsoft
   Access.
<P>
</OL><h2>REFERENCES</h2>
 
<P>
For more information about getting help with Visual Basic for Applications,
please see the following article in the Microsoft Knowledge Base:
<P>
<PRE>   ARTICLE-ID: <B><A href="../vbapps/q163435.htm">Q163435</A></B>
   TITLE     : VBA: Programming Resources for Visual Basic for
               Applications
</PRE>

	</FONT>
	</TD>
	</TR>
</TABLE>
<P>


<!--DOCBODY_END-->

<!--FOOTER_START-->
<table cellpadding=5 border=0 width="90%">
<tr>
<td>
	<HR WIDTH="90%">

<BLOCKQUOTE>
<FONT FACE="Verdana, Arial, Helvetica" SIZE="1">
<SPAN STYLE="font-family:verdana,arial,helvetica; font-size:8pt">
Additional query words: vba<BR>
Keywords          : PgmHowto<BR>
Version           : WINDOWS:7.0,97<BR>
Platform          : WINDOWS<BR>
Hardware          : x86<BR>
Issue type        : kbhowto<BR>

</SPAN>
</FONT>
<BR>
<BR>
THE INFORMATION PROVIDED IN THE MICROSOFT KNOWLEDGE BASE IS
PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND.  MICROSOFT DISCLAIMS
ALL WARRANTIES, EITHER EXPRESS OR IMPLIED, INCLUDING THE WARRANTIES
OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  IN NO
EVENT SHALL MICROSOFT CORPORATION OR ITS SUPPLIERS BE LIABLE FOR
ANY DAMAGES WHATSOEVER INCLUDING DIRECT, INDIRECT, INCIDENTAL,
CONSEQUENTIAL, LOSS OF BUSINESS PROFITS OR SPECIAL DAMAGES, EVEN IF
MICROSOFT CORPORATION OR ITS SUPPLIERS HAVE BEEN ADVISED OF THE
POSSIBILITY OF SUCH DAMAGES.  SOME STATES DO NOT ALLOW THE EXCLUSION
OR LIMITATION OF LIABILITY FOR CONSEQUENTIAL OR INCIDENTAL DAMAGES
SO THE FOREGOING LIMITATION MAY NOT APPLY.
</BLOCKQUOTE>
<P>
<center>
	<FONT FACE="Verdana,Arial,Helvetica" SIZE="1">
	Last reviewed:  January 5, 1998</FONT>
	<BR>
	<A href="../cpyright.htm" STYLE="font: bold 7pt Verdana,Arial,Helvetica">&copy; 1998 Microsoft Corporation. All rights reserved. Terms of Use.</A><BR>
	
</center>
</td>
</tr>
</table>

<!--FOOTER_END-->
</FONT>
</BODY>
</HTML>
