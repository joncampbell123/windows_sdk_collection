

<HTML>
<HEAD>
<TITLE>INFO: Late, ID, Early Binding Types Possible in VB for Apps </TITLE>

<!--STYLE_BEGIN-->
<style>@import url(../../msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="../../msdn_ie3.css">
<!--STYLE_END-->

<META HTTP-EQUIV="CONTENT-Type" CONTENT="text/html; charset=us-ascii">
<META NAME="ms.locale" CONTENT="EN-US">
<META NAME="Category" CONTENT="Support; KB Article">
<META NAME="KBID" CONTENT="Q138138">
<META NAME="KBModify" CONTENT="1997/09/29">
<META NAME="KBCreate" CONTENT="1995/10/12">
<META NAME="Keywords" CONTENT="IAPOLE VB4ALL VB4WIN vbwin GnrlVb kbprg">
<META NAME="KBArea" CONTENT="Support; KB; vbapps">
<META NAME="Description" CONTENT="  There are three kinds of binding that Visual Basic for Applications supports:  1. Late Binding.  2. ID Binding.  3. Early\Vtable Binding.  MORE INFORMATION  OLE Automation controllers can use the OLE IDispatch interface to gain access to objects th...">
<META NAME="Product" CONTENT="vbapps">
<META NAME="Platform" CONTENT="Windows">
<META NAME="Technology" CONTENT=" ">
<META NAME="Premium" CONTENT="support">

<META NAME="nyms" CONTENT="QAPN,QAGI,QBS0,QAW6,QAU3,QAMR,QBAB,QAIF,QA4H,QAFH,QAH4,QBD3,QBB3,QA9Q,QBBS V02180118">
</HEAD>

<BODY BGCOLOR="#FFFFFF" LEFTMARGIN="0" RIGHTMARGIN="0" TOPMARGIN="0">


<!--DOCBODY_START-->
<BR>
<CENTER>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" VALIGN="top" WIDTH="90%">
	<TR>
		<TD VALIGN="top">
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<H1>INFO: Late, ID, Early Binding Types Possible in VB for Apps</H1>
			</FONT>
			<FONT FACE="verdana,arial,helvetica" SIZE="1">
			Last reviewed:  September 29, 1997</FONT><BR>
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<B>Article ID: Q138138</B>
			</FONT>
		</TD>
	</TR>
	<TR>
	<TD>
	<FONT FACE="Verdana, Arial, Helvetica" SIZE=2>



 
 
The information in this article applies to:

<UL><LI>Standard, Professional, and Enterprise Editions of Microsoft
   Visual Basic, 16-bit and 32-bit, for Windows, version 4.0
</UL> 
<P>
<P><h2>SUMMARY</h2>
 
<P>
There are three kinds of binding that Visual Basic for Applications
supports:

<OL><P><LI>Late Binding.

<P><LI>ID Binding.

<P><LI>Early\Vtable Binding.
<P>
</OL><h2>MORE INFORMATION</h2>
 
<P>
OLE Automation controllers can use the OLE IDispatch interface to gain
access to objects that implement this interface. Although programmers know
object members (methods and properties) by name, IDispatch keeps track of
them internally by a number -- the Dispatch ID (DISPID). Before an OLE
Automation controller can find a method or property, it must have the
DISPID that maps to the name of the member.
<P>
Once it has the DISPID, it can then call IDispatch::Invoke to locate the
property or invoke the method, packaging the parameters for the property or
method into one of the IDispatch::Invoke parameters. The object's
implementation of IDispatch::Invoke must then unpack the parameters,
call the property or method, and handle any errors that might occur. When
the property or method returns, the object passes its return value back to
the controller through an IDispatch::Invoke parameter.
<P>
<P><h3>Late Binding</h3>
 
<P>
DISPIDs are available at run time and, in some circumstances, at compile
time. At run time, controllers get DISPIDs by calling the
IDispatch::GetIDsOfNames function. This is called late binding (or late
name binding) because the controller binds to the property or method at run
time.
<P>
Late Binding is the slowest and easiest to support, and it is the only
mechanism that Visual Basic version 3.0 supports. The target object must
support the IDispatch OLE interface for this to work. A typelib (a
repository of object property, object method, and object method parameter
information) is not required for the object as IDispatch::GetIDsOfNames is
first called at run time to bind the name to its DISPID and then
IDispatch::Invoke is called again at run time on the target object to
actually execute the property or method. As a result, there is no compile-
time type checking. You get errors like "name not found" only at run time.
<P>
Here's an example of Visual Basic code that implements late binding:
<P>
<PRE>   Dim obj As Object
   Set obj = New Class1
   Call obj.somemethod

</PRE></OL>Here the type of "Object" is not known until the Set statement is executed
at run time.
<P>
<P><h3>ID Binding</h3>
 
<P>
The DISPID of each property or method is fixed and is part of the object's
type description. If the object is described in a type library, an OLE
Automation controller can read the DISPIDs from the type library at compile
time, and thus avoid calling IDispatch::GetIDsOfNames. This is called ID
binding. Because it requires only one call to IDispatch (that is, the call
to invoke) rather than the two calls required by late binding, it is
generally about twice as fast.
<P>
ID binding is actually a form of early binding, as GetIDsOfNames is
logically called at compile time, so a typelib is required. The target
object must support the OLE IDispatch interface, so that Invoke can be
called at run time on the target object. The advantages of this are that
performance is better because no binding is needed at run time, you
get better compile-time type checking, and you receive more informative
error messages.
<P>
<P><h3>Early Binding</h3>
 
<P>
In early binding (also known as VTable binding), the target object need not
necessarily support IDispatch; it can support any custom interface. If the
object does support IDispatch, early binding works because the object now
supports a dual interface (a combination of an IDispatch and a VTable
interface). Early binding does not use DISPIDs and will not work on a
straight IDispatch interface implementation. A typelib for the object
is required in order get the DISPIDs. A compile-time binding generates code
to call any of the object's methods or properties through that object's
VTable.
<P>
The advantages of early binding are that you get compile-time type checking
benefits and the run-time performance is better, especially when an
in-process OLE Server is involved. This is because there is no need to
indirect the call to a member through an implementation of
IDispatch::Invoke. Basically, with VTable binding on an in-process server,
function calls are direct function calls. If the OLE server is an .exe
file, then it will be slower due to the remoting code that has to be
accounted for.
<P>
Here is an example of Visual Basic code that implements early binding:
<P>
<PRE>   Dim obj As Class1
   Set obj = New Class1
   Call obj.somemethod

</PRE>Note that it is up to the server object to determine whether it supports
early binding or not. All objects created in Visual Basic version 4.0
support all the three styles of binding. Visual Basic for Applications
will use early binding in preference to ID binding, so an object that
supports both will be early bound. If, in the previous example, Class1 were
implemented by an OLE server that supported only ID binding, then ID
binding would be used. There is no way to tell from Visual Basic code
whether you are using early binding or ID binding.
 
<PRE>Keywords          : IAPOLE VB4ALL VB4WIN vbwin GnrlVb kbprg
Technology        : kbole kbvba
Version           : WINDOWS:4.0
Platform          : WINDOWS
Issue type        : kbinfo</PRE>

	</FONT>
	</TD>
	</TR>
</TABLE>
<P>


<!--DOCBODY_END-->

<!--FOOTER_START-->
<table cellpadding=5 border=0 width="90%">
<tr>
<td>
	<HR WIDTH="90%">

<BLOCKQUOTE>
<FONT FACE="Verdana, Arial, Helvetica" SIZE="1">
<SPAN STYLE="font-family:verdana,arial,helvetica; font-size:8pt">
================================================================================<BR>

</SPAN>
</FONT>
<BR>
<BR>
THE INFORMATION PROVIDED IN THE MICROSOFT KNOWLEDGE BASE IS
PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND.  MICROSOFT DISCLAIMS
ALL WARRANTIES, EITHER EXPRESS OR IMPLIED, INCLUDING THE WARRANTIES
OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  IN NO
EVENT SHALL MICROSOFT CORPORATION OR ITS SUPPLIERS BE LIABLE FOR
ANY DAMAGES WHATSOEVER INCLUDING DIRECT, INDIRECT, INCIDENTAL,
CONSEQUENTIAL, LOSS OF BUSINESS PROFITS OR SPECIAL DAMAGES, EVEN IF
MICROSOFT CORPORATION OR ITS SUPPLIERS HAVE BEEN ADVISED OF THE
POSSIBILITY OF SUCH DAMAGES.  SOME STATES DO NOT ALLOW THE EXCLUSION
OR LIMITATION OF LIABILITY FOR CONSEQUENTIAL OR INCIDENTAL DAMAGES
SO THE FOREGOING LIMITATION MAY NOT APPLY.
</BLOCKQUOTE>
<P>
<center>
	<FONT FACE="Verdana,Arial,Helvetica" SIZE="1">
	Last reviewed:  September 29, 1997</FONT>
	<BR>
	<A href="../cpyright.htm" STYLE="font: bold 7pt Verdana,Arial,Helvetica">&copy; 1998 Microsoft Corporation. All rights reserved. Terms of Use.</A><BR>
	
</center>
</td>
</tr>
</table>

<!--FOOTER_END-->
</FONT>
</BODY>
</HTML>
