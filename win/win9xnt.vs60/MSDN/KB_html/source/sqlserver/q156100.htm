

<HTML>
<HEAD>
<TITLE>INF: Sample of SQL-DMO Connection Point Interface </TITLE>

<!--STYLE_BEGIN-->
<style>@import url(../../msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="../../msdn_ie3.css">
<!--STYLE_END-->

<META HTTP-EQUIV="CONTENT-Type" CONTENT="text/html; charset=us-ascii">
<META NAME="ms.locale" CONTENT="EN-US">
<META NAME="Category" CONTENT="Support; KB Article">
<META NAME="KBID" CONTENT="Q156100">
<META NAME="KBModify" CONTENT="1997/04/09">
<META NAME="KBCreate" CONTENT="1996/09/17">
<META NAME="Keywords" CONTENT="kbnetwork SSrvDMO">
<META NAME="KBArea" CONTENT="Support; KB; sqlserver">
<META NAME="Description" CONTENT="  The sample code in this article shows you how to:   - Create a connection point interface.   - Display detailed error information.   - Access Severity 0 to 10 error messages returned from SQL    Server.  It also contains a workaround to the Microso...">
<META NAME="Product" CONTENT="SQL Server">
<META NAME="Platform" CONTENT="Windows">
<META NAME="Technology" CONTENT=" ">
<META NAME="Premium" CONTENT="support">

<META NAME="nyms" CONTENT="QAUD,QBC9,QBC8,QANO,QAPN,QAI5,QAB4,QABM,QBG2,QAW6,QALW,QBBS,QAI4,QAII,QAY2 V02180118">
</HEAD>

<BODY BGCOLOR="#FFFFFF" LEFTMARGIN="0" RIGHTMARGIN="0" TOPMARGIN="0">


<!--DOCBODY_START-->
<BR>
<CENTER>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" VALIGN="top" WIDTH="90%">
	<TR>
		<TD VALIGN="top">
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<H1>INF: Sample of SQL-DMO Connection Point Interface</H1>
			</FONT>
			<FONT FACE="verdana,arial,helvetica" SIZE="1">
			Last reviewed:  April 9, 1997</FONT><BR>
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<B>Article ID: Q156100</B>
			</FONT>
		</TD>
	</TR>
	<TR>
	<TD>
	<FONT FACE="Verdana, Arial, Helvetica" SIZE=2>



<P><h3> </h3>
 
The information in this article applies to:

<UL><LI>Microsoft SQL Server, version 6.5
</UL> 
<P>
<P><h2>SUMMARY</h2>
 
<P>
The sample code in this article shows you how to:

<UL><LI>Create a connection point interface.

<LI>Display detailed error information.

<LI>Access Severity 0 to 10 error messages returned from SQL
   Server.
<P>
</UL>It also contains a workaround to the Microsoft Knowledge Base article
<B><A href="../sqlserver/q152621.htm">Q152621</A></B>, "BUG: SQL-DMO: GetMemUsage Method Returns Empty String."
<P>
Before proceeding, make sure you take note of the following:

<UL><LI>You must implement all methods exposed by the Sink object. These are
   documented in the "What's New in SQL Server 6.5" portion of Books
   Online.

<LI>You must appropriately handle the IUnknown interface methods. This
   sample uses the default implementations of the IUnknown interface where
   the last Release deletes the object.
<P>
</UL><h2>MORE INFORMATION</h2>
 
<P>
<P><h3>MAIN.CPP</h3>
 
<P>
<PRE>//
//   The following code is an example of how to implement the SQL-DMO
//   Server connection point to trap all error messages returned from the
//   SQL Server.
//

//
//   Includes:
//

#include "afx.h"
#include "afxole.h"        //    OLE

#include "stdio.h"         //    Standard I/O header

#include "initguid.h"         //    Only included once to define the GUID
</PRE>and UUID's properly
<P>
<PRE>#include "sqloleid.h"         //    SQL-DMO headers
#include "sqlole.h"

#include "ServerConnectionPoint.h"  //    Server connection point
</PRE>implementation
<P>
<P>
<P>
<PRE>//
//   Defines:
//
#define  _SERVER        ""
#define  _USER          "sa"
#define _PWD            ""
#define  _BAD_COOKIE 99999


//
//   Function declarations:
//
</PRE>BOOL  bInitialize(void);
<PRE>void  vUninitialize(void);
</PRE>HRESULT hrDisplayError(HRESULT hRes);
BOOL  bInstallConnectionPointHandler(void);
<PRE>void  vDoSomeStuff(void);


//
//   Local variables:
//
BOOL           bCoInit     =  FALSE;
LPSQLOLESERVER    iSQLServer  =  NULL;
LPCONNECTIONPOINT    iCP      =  NULL;
</PRE>CSQLServerSink *  pServerSink =  NULL;
<PRE>DWORD       dwCookie =  _BAD_COOKIE;


//
//   MAIN ROUTINE
//   ------------
void main(void)
</PRE>{
<PRE>   if(bInitialize())
   {
      if(bInstallConnectionPointHandler())
      {
         vDoSomeStuff();
      }
   }


   //
   //    Perform cleanup operations:
   //
   vUninitialize();
   printf("\n\nSample run completed...\n\n");
</PRE>}
<P>
<P>
<P>
<P>
<PRE>//
//   Initialize - perform all init operations:
//
</PRE>BOOL bInitialize(void)
{
<PRE>   BOOL  bRC   =  FALSE;

   printf("\n...Initializing OLE...");
   if(SUCCEEDED(CoInitialize(NULL)))
   {
      bCoInit = TRUE;


      //
      //    Create a Server object:
      //
      printf("\n...Creating SQL Server Object...");
      if(SUCCEEDED(hrDisplayError(CoCreateInstance(CLSID_SQLOLEServer,
                        NULL,
                        CLSCTX_INPROC_SERVER,
                        IID_ISQLOLEServer,
                        (LPVOID *)&amp;iSQLServer))))
      {
         bRC = TRUE;
      }

   }
   else
   {
      printf("\nCoInitialize failed.");
      bRC = bCoInit = FALSE;
   }

   return bRC;
 }



//
//    Uninitialize - perform all shutdown operations:
//
void vUninitialize(void)
</PRE>{
<PRE>   printf("\n...Performing the Unadvice...");
   if((dwCookie != _BAD_COOKIE) &amp;&amp; (iCP))
      iCP-&gt;Unadvise(dwCookie);


   printf("\n...Cleaning up object memory...");

   //
   //    Not part of above sequence in case Advise failed and dwCookie was
   //   (0)
   //
   if(iCP)
      iCP-&gt;Release();


   //
   //    Clean up the server object:
   //
   if(iSQLServer)
      iSQLServer-&gt;Release();


   //
   //    Shut down OLE:
   //
   if(bCoInit)
      CoUninitialize();

</PRE>}
<P>
<P>
<PRE>//
//    Install the connection point handler:
//
</PRE>BOOL bInstallConnectionPointHandler(void)
{
<PRE>   BOOL                 bRC      =  FALSE;
   LPCONNECTIONPOINTCONTAINER       iCPContainer   =  NULL;


   //
   //    Create an instance of the Server Sink object:
   //
   pServerSink = new CSQLServerSink;

   if(pServerSink)
   {

      printf("\n...Creating Connection Point Container...");
      if(SUCCEEDED(hrDisplayError(iSQLServer-
</PRE>&gt;QueryInterface(IID_IConnectionPointContainer,
<PRE>            (LPVOID *) &amp;iCPContainer))))
      {

         printf("\n...Finding the SQL Server Sink connection point...");
         if(SUCCEEDED(hrDisplayError(iCPContainer-
</PRE>&gt;FindConnectionPoint(IID_ISQLOLEServerSink, &amp;iCP))))
<PRE>         {
            printf("\n...Advising connection point that we are available to
</PRE>receive events...");
<PRE>            if(SUCCEEDED(hrDisplayError(iCP-&gt;Advise(pServerSink,
</PRE>&amp;dwCookie))))
<PRE>            {
               bRC = TRUE;
            }
            else
               dwCookie = _BAD_COOKIE;
         }

         iCPContainer-&gt;Release();
      }


   }
   else
   {
      printf("\nAttempt to create server sink object failed due to a memory
</PRE>error.");
<PRE>   }


   //
   //    Free memory if necessary:
   //
   if((pServerSink) &amp;&amp; (FALSE == bRC))
   {
      delete pServerSink;
      pServerSink = NULL;
   }

   return bRC;
</PRE>}
<P>
<P>
<PRE>//
//    Do some things to cause the Sink events to fire:
//
void vDoSomeStuff(void)
</PRE>{
<PRE>   printf("\n...Setting connection options...");
   if(SUCCEEDED(hrDisplayError(iSQLServer-&gt;SetLoginTimeout(5))))
   {
      if(SUCCEEDED(hrDisplayError(iSQLServer-&gt;SetApplicationName("Server
</PRE>Sink"))))
<PRE>      {
         if(SUCCEEDED(hrDisplayError(iSQLServer-&gt;SetHostName("SQL-DMO"))))
         {
            if(SUCCEEDED(hrDisplayError(iSQLServer-
</PRE>&gt;SetNetPacketSize(4096))))
<PRE>            {

               printf("\n...Attempting to connect...");
               if(SUCCEEDED(hrDisplayError(iSQLServer-&gt;Connect(_SERVER,
</PRE>_USER, _PWD))))
<PRE>               {

                  //
                  //    Cause a meesage to be fired from SQL Server.
                  //
                  //    This is one workaround for <B><A href="../sqlserver/q152621.htm">Q152621</A></B> (Bug #15500.)
                  //    You could also use ExecuteWithResultsAndMessages.
                  //
                  //    You may want to use Sink to capute information
                  //    output from any DBCC command because the standard
                  //    implementation of Database.CheckAllocations uses
                  //    'WITH NO_INFOMSGS'
                  //
                  hrDisplayError(iSQLServer-&gt;ExecuteImmediate("dbcc
</PRE>memusage"));
<P>
<PRE>                  //
                  //    This will fire the Sink event.
                  //
                  hrDisplayError(iSQLServer-
</PRE>&gt;ExecuteImmediate("raiserror(1204, 1, 1)"));
<P>
<PRE>                  //
                  //    This will NOT fire the Sink event due to Sev level.
                  //
                  hrDisplayError(iSQLServer-
</PRE>&gt;ExecuteImmediate("raiserror(1204, 11, 1)"));
<P>
<P>
<PRE>                  //
                  //    Close connection.
                  //
                  hrDisplayError(iSQLServer-&gt;DisConnect());
               }

            }
         }
      }
   }


</PRE>}
<P>
<P>
<P>
<PRE>//
//    Display Error Information as a result of an OLE call
//
</PRE>HRESULT hrDisplayError(HRESULT hRes)
{
<PRE>   LPERRORINFO    lpErrorInfo    =  NULL;
   BSTR        bstrDesc;
   BSTR        bstrSource;

   if(FAILED(hRes))
   {
      if(SUCCEEDED(GetErrorInfo(0, &amp;lpErrorInfo)))
      {
         lpErrorInfo-&gt;GetDescription(&amp;bstrDesc);
         lpErrorInfo-&gt;GetSource(&amp;bstrSource);

         printf("\n\nhrDisplayError: %S\n%S\n", bstrSource, bstrDesc);

         lpErrorInfo-&gt;Release();
         SysFreeString(bstrDesc);
         SysFreeString(bstrSource);
      }
      else
         printf("\n\nUnable to obtain detailed error information.");
   }

   return hRes;
</PRE>}
<P>
<P>
<P>
<P><h3>ServerConnectionPoint.h</h3>
 
<P>
<PRE>//
//    SQL-DMO Server Connection Point Interface Declaration and
//    Implementation
//


#include "windows.h"
#include "stdio.h"

#include "sqloleid.h"      //    SQL-DMO headers
#include "sqlole.h"



</PRE>class CSQLServerSink : public ISQLOLEServerSink
{
<P>
<PRE>   public:
      CSQLServerSink()
         {
            m_uiRefCount   =  0;
         }


      ~CSQLServerSink()
         {

         }


      //
      // IUnknown Interface
      //
      STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID *ppvObj)
         {
            if((riid == IID_IUnknown) || (riid == IID_IASQLOLEServerSink))
            {
               AddRef();
               *ppvObj = this;

               return NOERROR;
            }
            else
               return E_NOINTERFACE;
         }

      STDMETHOD_(ULONG,AddRef) (THIS)
         {
            return ++m_uiRefCount;

         }

      STDMETHOD_(ULONG,Release) (THIS)
         {
            --m_uiRefCount;

            if(0 == m_uiRefCount)
                  delete this;

            return m_uiRefCount;
         }


      //
      // Sink properties and methods:
      //
      STDMETHOD(QueryTimeout)(THIS_ SQLOLE_LPCSTR strMessage, LPBOOL
</PRE>pbContinue)
<PRE>         {
            printf("\nSINK QueryTimeout - %s", strMessage);
            *pbContinue = FALSE;

            return NOERROR;
         }


      //
      //    Only for designated error messages Sev 10 or less.
      //
      STDMETHOD(ServerMessage)(THIS_ long lMessageSeverity, long
</PRE>lMessageNumber,
<PRE>                  long lMessageState, SQLOLE_LPCSTR strMessage)
         {

            printf(  "\nSINK ServerMessage"
                  "\nError: %ld"
                  "\nSev:   %ld"
                  "\nState: %ld"
                  "\n%s\n",
                     lMessageNumber, lMessageSeverity, lMessageState,
</PRE>strMessage);
<P>
<PRE>            return NOERROR;
         }

      STDMETHOD(ConnectionBroken)(THIS_ SQLOLE_LPCSTR strMessage, LPBOOL
</PRE>pbRetry)
<PRE>         {
            printf("\nSINK ConnectionBroken - %s", strMessage);
            *pbRetry = TRUE;

            return NOERROR;
         }


      STDMETHOD(RemoteLoginFailed)(THIS_ long lMessageSeverity, long
</PRE>lMessageNumber,
<PRE>                     long lMessageState, SQLOLE_LPCSTR strMessage)
         {
            printf(  "\nSINK RemoteLoginFailed"
                  "\nError: %ld"
                  "\nSev:   %ld"
                  "\nState: %ld"
                  "\n%s\n",
                     lMessageNumber, lMessageSeverity, lMessageState,
</PRE>strMessage);
<P>
<PRE>            return NOERROR;
         }

      //
      //    Shows actual commands begin sent from SQL-DMO to SQL Server.
      //
      STDMETHOD(CommandSent)(THIS_ SQLOLE_LPCSTR strSQL)
         {
            printf("\nSINK CommandSent - %s", strSQL);

            return NOERROR;
         }


   private:
      UINT  m_uiRefCount;

</PRE>};
<P>
See also "How to use Connectable Objects in SQL-DMO."
<P>

	</FONT>
	</TD>
	</TR>
</TABLE>
<P>


<!--DOCBODY_END-->

<!--FOOTER_START-->
<table cellpadding=5 border=0 width="90%">
<tr>
<td>
	<HR WIDTH="90%">

<BLOCKQUOTE>
<FONT FACE="Verdana, Arial, Helvetica" SIZE="1">
<SPAN STYLE="font-family:verdana,arial,helvetica; font-size:8pt">
Additional query words:<BR>
Keywords            : kbnetwork SSrvDMO<BR>
Version             : 6.5<BR>
Platform            : WINDOWS<BR>

</SPAN>
</FONT>
<BR>
<BR>
THE INFORMATION PROVIDED IN THE MICROSOFT KNOWLEDGE BASE IS
PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND.  MICROSOFT DISCLAIMS
ALL WARRANTIES, EITHER EXPRESS OR IMPLIED, INCLUDING THE WARRANTIES
OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  IN NO
EVENT SHALL MICROSOFT CORPORATION OR ITS SUPPLIERS BE LIABLE FOR
ANY DAMAGES WHATSOEVER INCLUDING DIRECT, INDIRECT, INCIDENTAL,
CONSEQUENTIAL, LOSS OF BUSINESS PROFITS OR SPECIAL DAMAGES, EVEN IF
MICROSOFT CORPORATION OR ITS SUPPLIERS HAVE BEEN ADVISED OF THE
POSSIBILITY OF SUCH DAMAGES.  SOME STATES DO NOT ALLOW THE EXCLUSION
OR LIMITATION OF LIABILITY FOR CONSEQUENTIAL OR INCIDENTAL DAMAGES
SO THE FOREGOING LIMITATION MAY NOT APPLY.
</BLOCKQUOTE>
<P>
<center>
	<FONT FACE="Verdana,Arial,Helvetica" SIZE="1">
	Last reviewed:  April 9, 1997</FONT>
	<BR>
	<A href="../cpyright.htm" STYLE="font: bold 7pt Verdana,Arial,Helvetica">&copy; 1998 Microsoft Corporation. All rights reserved. Terms of Use.</A><BR>
	
</center>
</td>
</tr>
</table>

<!--FOOTER_END-->
</FONT>
</BODY>
</HTML>
