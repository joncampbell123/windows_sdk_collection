

<HTML>
<HEAD>
<TITLE>FIX: SQL Server 6.0 Service Pack 2 Fixlist </TITLE>

<!--STYLE_BEGIN-->
<style>@import url(../../msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="../../msdn_ie3.css">
<!--STYLE_END-->

<META HTTP-EQUIV="CONTENT-Type" CONTENT="text/html; charset=us-ascii">
<META NAME="ms.locale" CONTENT="EN-US">
<META NAME="Category" CONTENT="Support; KB Article">
<META NAME="KBID" CONTENT="Q138399">
<META NAME="KBModify" CONTENT="1997/05/01">
<META NAME="KBCreate" CONTENT="1995/10/19">
<META NAME="Keywords" CONTENT="kbfixlist kbfixlist6.00.sp2">
<META NAME="KBArea" CONTENT="Support; KB; sqlserver">
<META NAME="Description" CONTENT=" The following is a list of fixes and various other improvements that have been made in the Microsoft SQL Server version 6.0 Service Pack 2. Service Pack 2 is now available from your primary support provider. For more information, contact your primar...">
<META NAME="Product" CONTENT="SQL Server">
<META NAME="Platform" CONTENT="Windows">
<META NAME="Technology" CONTENT=" ">
<META NAME="Premium" CONTENT="support">

<META NAME="nyms" CONTENT="QAR4,QAM1,QAB4,QDIX,QAAP,QABM,QAXB,QAB9,QAKP,QBWS,QBVV,QACI,QA9N,QBWP,QAI5 V02180118">
</HEAD>

<BODY BGCOLOR="#FFFFFF" LEFTMARGIN="0" RIGHTMARGIN="0" TOPMARGIN="0">


<!--DOCBODY_START-->
<BR>
<CENTER>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" VALIGN="top" WIDTH="90%">
	<TR>
		<TD VALIGN="top">
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<H1>FIX: SQL Server 6.0 Service Pack 2 Fixlist</H1>
			</FONT>
			<FONT FACE="verdana,arial,helvetica" SIZE="1">
			Last reviewed:  May 1, 1997</FONT><BR>
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<B>Article ID: Q138399</B>
			</FONT>
		</TD>
	</TR>
	<TR>
	<TD>
	<FONT FACE="Verdana, Arial, Helvetica" SIZE=2>



 
 
The information in this article applies to:

<UL><LI>Microsoft SQL Server, version 6.0 Service Pack 2
</UL> 
<P>
The following is a list of fixes and various other improvements that have
been made in the Microsoft SQL Server version 6.0 Service Pack 2. Service
Pack 2 is now available from your primary support provider. For more
information, contact your primary support provider.
<P>
Service Pack 2 includes all fixes previously released in Service Pack 1 for
version 6.0. The list of fixes for Service Pack 1 is appended at the end of
this article.
<P>
Please note that workarounds described have been provided for your
information only. It is not necessary to implement these workarounds if
you have the updated software.
<P>
 
<P><h2>LIST OF PROBLEMS CORRECTED IN SERVICE PACK 2</h2>
 

<UL><LI>FIX: SELECT During UPDATE STATISTICS Can Terminate w/ Msg 814
<LI>FIX: DBCC NEWALLOC May Not Detect TEXT Extent Inconsistencies
<LI>FIX: INSERT Into w/ IDENTITY Col Inside Trigger Causes AV
<LI>FIX: SELECT INTO From Table w/ IDENTITY Col Causes Handled AV
<LI>FIX: Update of Primary Key Causes Repl Custom St. Proc to Fail
<LI>FIX: Multiple ORDER BY DESC May Cause 614 Errors
<LI>FIX: DBCC SQLPERF(THREADS) Fails w/ AV on 6.0 SP 1
<LI>FIX: SELECT w/ IN Clause Causes AV w/ Subquery SELECT NULL
<LI>FIX: Procedure for Repl. Can Fail When Referencing NCI
<LI>FIX: Repl w/ Ext Chars on Non-ANSI Char Sets May Fail
<LI>FIX: RPC w/ Text/Image Parameters May Cause Handled AV
<LI>FIX: Syntax Error Reporting Disabled w/ St Proc &gt;68 Pages
<LI>FIX: Drop Procedure Gives 3702 Error if Cursor Not Deallocated
<LI>FIX: Users Blocking With No Locks Displayed in sp_lock
<LI>FIX: Invalid Column in Subquery May Result in Handled AV
<LI>FIX: Milliseconds Are Not Replicated w/ DATETIME Fields
<LI>FIX: Cursor w/ Union May Cause Errors if Not First in Batch
<LI>FIX: Handled AV If Many Users Dropping/Creating Tables
<LI>FIX: BEGIN TRAN After OPEN CURSOR May Not Commit
<LI>FIX: Explicit Insert of Identity Value in SP Can Cause AV
<LI>FIX: Error 3307 Running Update Stats After 1105 Error
<LI>FIX: LogReader Can Fail On sp_repldone After Unsubscribing
<LI>FIX: LogReader Can Fail On sp_repldone Using Partitioning
<LI>FIX: Timestamp Col of Temp Table Set to 0 When Inserting Row in SP
<LI>FIX: AV or Error 632 on Update w/ Select Count(distinct) Subqu
<LI>FIX: Cursor Using Stored Proc After LOAD DB May Get 225 Error
<LI>FIX: Inserts on SMP Computer Can Cause Error Message 1203
<LI>FIX: Stored Procedures Can Corrupt Themselves in Small Caches
<LI>FIX: A Cursor in a St. Procedure Can Cause an Access Violation
<LI>FIX: A View With an Outer Join Can Cause An Access Violation
<LI>FIX: SELECT TEXT Columns with FOR BROWSE Holds sh_page Locks
<LI>FIX: dbopen Memory Leak of 32K On Failed Login Attempt
<LI>FIX: SELECT From View w/ Data Length &gt; 1962 Bytes May Hang Svr
<P>
</UL> 
<P><h3>FIX: SELECT During UPDATE STATISTICS Can Terminate w/ Msg 814</h3>
 
<P>
ARTICLE-ID:<B><A href="../sqlserver/q134629.htm">Q134629</A></B>
BUG# NT: 11144 (6.00)
<P>
<P><h2>SYMPTOMS</h2>
 
<P>
Queries that run during execution of UPDATE STATISTICS can terminate
with Msg 814, Level 20, State 1:
<P>
<PRE>   Keep count of buffer &lt;n&gt; holding logical page &lt;n&gt; in database &lt;db&gt;
   has become negative.

</PRE><h2>CAUSE</h2>
 
<P>
Though rare, you could encounter this problem if the following conditions
apply:
<P>
- The SELECT statement must include a subquery expression and execute
<PRE>  a query plan that uses an index referenced in the UPDATE STATISTICS
  command (or indirectly if the entire table is referenced).

</PRE>- Dedicated Multiprocessor Performance must be ON (Or SMPConcurrency
<PRE>  must be set to zero on SQL Server version 6.0).

</PRE>- The server must have three or more CPUs running.
<P>
If, after encountering the initial error, execution of other commands that
involve tables from the SELECT statement also fails with Msg 814, you may
have to restart SQL Server to avoid encountering the error in the future.
<P>
<P><h2>WORKAROUND</h2>
 
<P>
Run UPDATE STATISTICS prior to or after the query that fails.
<P>
-OR-
<P>
Drop and recreate affected indexes instead of running UPDATE STATISTICS.
<P>
 
<P><h3>FIX: DBCC NEWALLOC May Not Detect TEXT Extent Inconsistencies</h3>
 
<P>
ARTICLE-ID:<B><A href="../sqlserver/q135350.htm">Q135350</A></B>
BUG# NT: 11026 (4.20)
<P>
<P><h2>SYMPTOMS</h2>
 
<P>
The DBCC NEWALLOC commmand may not detect extent chain inconsistencies
if the problem is on TEXT or IMAGE chains.
<P>
<P><h2>CAUSE</h2>
 
<P>
The DBCC NEWALLOC command traverses extent chains for all indexes of a
table, but does not check the extent chains for indid = 255, which is the
number used for TEXT and IMAGE chains. Inconsistencies of this type are
also not detectable with the DBCC TEXT_AL or DBCC TEXT_ALLOC commands. DBCC
CHECKALLOC does correctly detect and report TEXT extent chain problems.
<P>
<P><h2>WORKAROUND</h2>
 
<P>
Use the DBCC CHECKALLOC command in addition to or in place of DBCC NEWALLOC
if you have TEXT or IMAGE columns.
<P>
 
<P><h3>FIX: INSERT Into w/ IDENTITY Col Inside Trigger Causes AV</h3>
 
<P>
ARTICLE-ID:<B><A href="../sqlserver/q136534.htm">Q136534</A></B>
BUG# NT: 10242 (6.00)
<P>
<P><h2>SYMPTOMS</h2>
 
<P>
An INSERT INTO a table with an IDENTITY column inside a trigger can cause a
handled access violation (AV).
<P>
<P><h2>CAUSE</h2>
 
<P>
The client AV occurs only if the table with an IDENTITY column has a
trigger. The trigger may be fired by either an INSERT, DELETE, or UPDATE
operation. The client does not cause an AV when a SELECT INTO operation is
performed on a table that is not using the IDENTITY property.
<P>
<P><h2>WORKAROUND</h2>
 
<P>
If your purpose in performing an INSERT operation inside a trigger is
to implement Unique Increasing key values without using the IDENTITY
property of SQL Server version 6.0, then please refer to the following
article in the Microsoft Knowledge Base:
<P>
<PRE>   ARTICLE-ID: <B><A href="../sqlserver/q75164.htm">Q75164</A></B>
   TITLE     : Implementing a Unique, Increasing Key Value

</PRE>If your objective is to implement Declarative Referential Integrity (DRI),
use the DRI feature of SQL Server version 6.0, or implement it by using
tables without IDENTITY columns. Refer to the SQL Server "Transact-SQL
Reference" manual for details on DRI implementation with triggers.
<P>
 
<P><h3>FIX: SELECT INTO From Table w/ IDENTITY Col Causes Handled AV</h3>
 
<P>
ARTICLE-ID:<B><A href="../sqlserver/q136536.htm">Q136536</A></B>
BUG# NT: 10340 (6.00)
<P>
<P><h2>SYMPTOMS</h2>
 
<P>
On Microsoft SQL Server version 6.0, a SELECT INTO from a table with an
identity column when the set IDENTITY_INSERT option is ON can cause a
handled access violation (AV).
<P>
The AV will not occur when the IDENTITY_INSERT option is switched OFF.
<P>
<P><h2>WORKAROUND</h2>
 

<UL><LI>Set the IDENTITY_INSERT option OFF before performing the SELECT-INTO.
<P>
</UL>OR

<UL><LI>Perform an INSERT by issuing a SELECT from the source to the destination
   table.
<P>
</UL> 
<P><h3>FIX: Update of Primary Key Causes Repl Custom St. Proc to Fail</h3>
 
<P>
ARTICLE-ID:<B><A href="../sqlserver/q136544.htm">Q136544</A></B>
BUG# NT: 11329 (6.00)
<P>
<P><h2>SYMPTOMS</h2>
 
<P>
On Microsoft SQL Server version 6.0, if you update the primary key of a
table, the original primary key parameters passed to a custom stored
procedure defined for replication will be replaced with the updated primary
key values.
<P>
 
<P><h3>FIX: Multiple ORDER BY DESC May Cause 614 Errors</h3>
 
<P>
ARTICLE-ID:<B><A href="../sqlserver/q137432.htm">Q137432</A></B>
BUG# NT: 11164 (6.00)
<P>
<P><h2>SYMPTOMS</h2>
 
<P>
A query with multiple ORDER BY &lt;col&gt; DESC clauses may get a 614 error:
<P>
<PRE>   A row on page X was accessed that has an illegal length of Y in database
   Z.

</PRE> 
<P><h3>FIX: DBCC SQLPERF(THREADS) Fails w/ AV on 6.0 SP 1</h3>
 
<P>
ARTICLE-ID:<B><A href="../sqlserver/q138013.htm">Q138013</A></B>
BUG# NT: 11497 (6.00)
<P>
<P><h2>SYMPTOMS</h2>
 
<P>
The command DBCC SQLPERF(THREADS) on SQL Server version 6.0 Service Pack 1
fails with the error:
<P>
<PRE>   DBCC function 'threads' in the library 'sqlper60' generated access
   violation; SQL Server is terminating process &lt;n&gt;

</PRE>The client connection that executed this command is terminated, but
other client connections are unaffected. The client may see the access
violation error listed above, or encounter DB-Library errors 10037,
"Unexpected EOF from SQL Server," or 10008, "Bad Token from SQL Server:
Datastream processing out of  synchronization."
<P>
This problem does not exist in SQL Server 6.0 without Service Pack 1
applied.
<P>
<P><h2>WORKAROUND</h2>
 
<P>
Most of the information from SQLPERF(THREADS) can be found using a
combination of other resources such as SQL Enterprise Manager
(Current Activity), sp_who, examining the sysprocesses table, and Windows
NT Performance Monitor.
<P>
 
<P><h3>FIX: SELECT w/ IN Clause Causes AV w/ Subquery SELECT NULL</h3>
 
<P>
ARTICLE-ID:<B><A href="../sqlserver/q138263.htm">Q138263</A></B>
BUG# NT: 11525 (6.00)
<P>
<P><h2>SYMPTOMS</h2>
 
<P>
A simple SELECT statement with an IN clause and a subquery of the form
SELECT NULL may cause a handled access violation in SQL Server version 6.0.
The problem also occurs with a NOT IN clause instead of an IN clause in the
query. However, if the subquery returns null results, the access violation
does not occur.
<P>
<P><h2>WORKAROUND</h2>
 
<P>
If the subquery is replaced with the NULL keyword, the access violation
does not occur.
<P>
 
<P><h3>FIX: Procedure for Repl. Can Fail When Referencing NCI</h3>
 
<P>
ARTICLE-ID:<B><A href="../sqlserver/q138290.htm">Q138290</A></B>
BUG# NT: 10981 (6.00)
<P>
<P><h2>SYMPTOMS</h2>
 
<P>
If a published article has a stored procedure created FOR REPLICATION
that references a column in a non-clustered index on the article's
base table, the filter procedure can prevent a transaction from being
replicated. Examining the MSjob_commands table in the distribution database
can help you detect this problem.
<P>
<P><h2>CAUSE</h2>
 
<P>
The SELECT statement in the replication filter procedure is being
incorrectly evaluated by SQL Server when applying the filter procedure
against the logged change in the published database.
<P>
The most common occurrence of this problem is when a "restriction clause"
for the article is created using SQL Enterprise Manager where the column
listed in the clause is part of a non-clustered index.
<P>
This problem can also occur if you develop your own filter procedure
using the CREATE PROCEDURE FOR REPLICATION command. This problem does
not affect the proper synchronization of data when first subscribing,
only changes made after synchronization.
<P>
<P><h2>WORKAROUND</h2>
 

<OL><P><LI>Drop the non-clustered index.

<P><LI>Remove the column referenced in the filter procedure from the non-
   clustered index.

<P><LI>Filter the replicated changes on the subscriber by using custom stored
   procedures.
<P>
</OL> 
<P><h3>FIX: Repl w/ Ext Chars on Non-ANSI Char Sets May Fail</h3>
 
<P>
ARTICLE-ID:<B><A href="../sqlserver/q138291.htm">Q138291</A></B>
BUG# NT: 11374 (6.00)
<P>
<P><h2>SYMPTOMS</h2>
 
<P>
Extended character values embedded in SQL statements, such as an
INSERT command, can be incorrectly distributed by the LogReader on
servers installed with non-ANSI character sets. In most situations,
the values will appear as unreadable characters. In other situations,
it could cause the command to fail with a syntax error when applied
to the subscriber.
<P>
CAUSE
 
<P>
The sp_replcmds procedure used by the LogReader is using an ANSItoOEM
conversion which can cause extended characters on non-ANSI servers to
become unreadable.
<P>
 
<P><h3>FIX: RPC w/ Text/Image Parameters May Cause Handled AV</h3>
 
<P>
ARTICLE-ID:<B><A href="../sqlserver/q138324.htm">Q138324</A></B>
BUG# NT: 11373 (6.00)
<P>
<P><h2>SYMPTOMS</h2>
 
<P>
A stored procedure created with a text/image parameter may cause a
handled access violation (AV) when executed through dbrpcexec or
Transact-SQL.
<P>
<P><h2>CAUSE</h2>
 
<P>
SQL Server fails to handle the text parameter properly when re-mapping
stored procedure variables after the stored procedure was bumped out of
procedure cache.
<P>
It is only reproducible if the stored procedure is executed with the length
of the text/image parameter greater than 2048 bytes immediately after it
is reloaded into procedure cache.
<P>
<P><h2>WORKAROUND</h2>
 
<P>
Because this would not happen the first time a stored procedure is loaded
into procedure cache, drop and recreate the stored procedure, which should
avoid the problem. Another way to avoid the problem would be to fake a call
to the stored procedure with the length of the text/image parameter that is
shorter than 2048 bytes, then call it with the real value. For example:
<P>
<PRE>   sp_recompile test_v
   go
   test_v_proc 1,'Fake one'
   go
   test_v_proc 1,'Real, longer then 2048 byte value'
   go

</PRE></OL> 
<P><h3>FIX: Syntax Error Reporting Disabled w/ St Proc &gt;68 Pages</h3>
 
<P>
ARTICLE-ID:<B><A href="../sqlserver/q138477.htm">Q138477</A></B>
BUG# NT: 11209 (6.00)
<P>
<P><h2>SYMPTOMS</h2>
 
<P>
Syntax error reporting is disabled when the query plan size of a
stored procedure exceeds 68 pages.
<P>
You can verify the query plan size by running DBCC MEMUSAGE after creating
a stored procedure without any syntax-errors.
<P>
The stored procedure has been created, but will not exist in the database,
thus it will not be displayed in the DBCC MEMUSAGE output.
<P>
<P><h2>WORKAROUND</h2>
 
<P>
Reduce the size of the stored procedure so that it is less than 68 pages.
<P>
 
<P><h3>FIX: Drop Procedure Gives 3702 Error if Cursor Not Deallocated</h3>
 
<P>
ARTICLE-ID:<B><A href="../sqlserver/q138538.htm">Q138538</A></B>
BUG# NT: 11556 (6.00)
<P>
<P><h2>SYMPTOMS</h2>
 
<P>
If you execute a stored procedure that declares a cursor not using exec(),
and then close the connection before the cursor is opened or deallocated,
and then try to drop the procedure from a new connection, a 3702 error
similar to the following will be generated:
<P>
<PRE>   Msg 3702, Level 16, State 3
   Cannot drop the procedure 'cursor3702' because it is currently in use.

</PRE><h2>WORKAROUND</h2>
 
<P>
Declare your cursor using exec(), or make sure that you always open
and/or deallocate the cursor before you close your connection. For
example:
<P>
<PRE>   use pubs
   go
   create procedure cursor3702 as
       exec("declare testcursor cursor for
       select * from authors")
   go
   cursor3702
   go

</PRE>If you now close this connection, you can drop the procedure from a
new connection.
<P>
If you receive the 3702 error, and the connection which executed the
stored procedure is already closed, you will need to restart SQL
Server before you can drop the procedure.
<P>
 
<P><h3>FIX: Users Blocking With No Locks Displayed in sp_lock</h3>
 
<P>
ARTICLE-ID:<B><A href="../sqlserver/q138603.htm">Q138603</A></B>
BUG# NT: 11660 (6.00)
<P>
<P><h2>SYMPTOMS</h2>
 
<P>
Many users performing queries against tables with non-clustered indexes on
symmetric multiprocessing (SMP) computers with more than two processors can
get processes blocking each other, but there are no related locks shown
by sp_lock. KILLing the blocker may or may not alleviate the problem. This
problem is very rare.
<P>
<P><h2>WORKAROUND</h2>
 
<P>
If KILL fails to alleviate the blocking, shut down and restart SQL Server.
The problem is caused by applications issuing many "cancels" and can be
alleviated by reducing the number of cancels sent to the server.
<P>
 
<P><h3>FIX: Invalid Column in Subquery May Result in Handled AV</h3>
 
<P>
ARTICLE-ID:<B><A href="../sqlserver/q138673.htm">Q138673</A></B>
BUG# NT: 11623 (6.00)
<P>
<P><h2>SYMPTOMS</h2>
 
<P>
A subquery that references an invalid column may cause a handled
access violation (AV). The expected output would be the 207 error message,
"Invalid column name &lt;table.column&gt;".
<P>
<P><h2>WORKAROUND</h2>
 
<P>
Make sure you are referencing valid column(s) within the subquery.
<P>
 
<P><h3>FIX: Milliseconds Are Not Replicated w/ DATETIME Fields</h3>
 
<P>
ARTICLE-ID:<B><A href="../sqlserver/q138718.htm">Q138718</A></B>
BUG# NT: 11767 (6.00)
<P>
<P><h2>SYMPTOMS</h2>
 
<P>
The milliseconds portion of the datetime field does not get replicated.
When sp_replcmds generates the inserted value for a datetime field,
the milliseconds portion is not included.
<P>
<P><h2>WORKAROUND</h2>
 
<P>
Do not include milliseconds for a datetime field in any table that is going
to be included in an article for replication.
<P>
 
<P><h3>FIX: Cursor w/ Union May Cause Errors if Not First in Batch</h3>
 
<P>
ARTICLE-ID:<B><A href="../sqlserver/q138746.htm">Q138746</A></B>
BUG# NT: 11237 (6.00)
<P>
<P><h2>SYMPTOMS</h2>
 
<P>
If a cursor is opened that contains a union between two queries, you may
receive errors such as:
<P>
<PRE>  DB-Library: Possible network error: Bad token from SQL Server:
  Datastream processing out of sync.
  Net-Library error 0:
  DB-Library: Possible network error: Bad token from SQL Server:
  Datastream processing out of sync.  Connection broken.
  &lt;above is repeated many times&gt;
  Net-Library error 6: ConnectionClose (CloseHandle()).
  Msg 533, Level 20, State 4
  Can't find a range table entry for range 5.
  DB-Library Process Dead - Connection Broken

</PRE>And in some cases, the following message may also occur:
<P>
<PRE>  Msg 16942, Level 16, State 2
  Asyncronous keyset generation failed, the cursor has been deallocated

</PRE><h2>WORKAROUND</h2>
 
<P>
This generally occurs when there are other Transact-SQL statements
preceding the declaration of the cursor. Moving the cursor to the beginning
of the batch may prevent the errors from occurring.
<P>
 
<P><h3>FIX: Handled AV If Many Users Dropping/Creating Tables</h3>
 
<P>
ARTICLE-ID:<B><A href="../sqlserver/q138748.htm">Q138748</A></B>
BUG# NT: 11417 (6.00)
<P>
<P><h2>SYMPTOMS</h2>
 
<P>
You may get a handled access violation (AV), 632 errors, or 614 errors on
symmetric multiprocessing (SMP) computers running SQL Server if there are
multiple users dropping and creating tables concurrently. This is true of
TEMPDB as well as user databases. The timing involved for this bug to occur
makes it very rare, and there are no side effects outside of the client
being terminated.
<P>
<P><h2>WORKAROUND</h2>
 
<P>
Set the sp_configure "SMP concurrency" option to "1".
<P>
 
<P><h3>FIX: BEGIN TRAN After OPEN CURSOR May Not Commit</h3>
 
<P>
ARTICLE-ID:<B><A href="../sqlserver/q138749.htm">Q138749</A></B>
BUG# NT: 11659 (6.00)
<P>
<P><h2>SYMPTOMS</h2>
 
<P>
When using Transact-SQL cursors, if BEGIN TRAN is issued after OPEN
CURSOR, and then the cursor is closed, there can be an open transaction
that cannot be removed with COMMIT TRAN or ROLLBACK TRAN.
<P>
<P><h2>WORKAROUND</h2>
 
<P>
Call BEGIN TRAN before you call OPEN CURSOR.
<P>
 
<P><h3>FIX: Explicit Insert of Identity Value in SP Can Cause AV</h3>
 
<P>
ARTICLE-ID:<B><A href="../sqlserver/q138750.htm">Q138750</A></B>
BUG# NT: 10308 (6.00)
<P>
<P><h2>SYMPTOMS</h2>
 
<P>
If you explicitly insert a value into an IDENTITY column inside a
stored procedure, it can cause an thread level access violation.
<P>
<P><h2>WORKAROUND</h2>
 
<P>
Use a batch file instead of a stored procedure if you need to insert
a value explicitly into an IDENTITY column.
<P>
 
<P><h3>FIX: Error 3307 Running Update Stats After 1105 Error</h3>
 
<P>
ARTICLE-ID:<B><A href="../sqlserver/q138787.htm">Q138787</A></B>
BUG# NT: 11167 (6.00)
<P>
<P><h2>SYMPTOMS</h2>
 
<P>
Error number 3307, "Process x was expected to hold logical lock on page y,"
can be generated if UPDATE STATISTICS is run when the database has run out
of space. This can also leave stranded locks that can only be cleared by
stopping/starting SQL Server.
<P>
<P><h2>WORKAROUND</h2>
 
<P>
Ensure there is adequate space in the database such that error 1105 "Can't
allocate space" is not encountered when you run UPDATE STATISTICS.
<P>
 
<P><h3>FIX: LogReader Can Fail On sp_repldone After Unsubscribing</h3>
 
<P>
ARTICLE-ID:<B><A href="../sqlserver/q138826.htm">Q138826</A></B>
BUG# NT: 11493 (6.00)
<P>
<P><h2>SYMPTOMS</h2>
 
<P>
If the last subscription to an article is removed while there are still
outstanding unreplicated transactions in the published database log, the
LogReader task for replication can fail with the following error:
<P>
<PRE>   The replicated transaction (xxx, yyy) no longer exists in the log.
   Unable to execute sp_repldone on '&lt;server&gt;'.

</PRE>Where xxx = the value of xactid_page and yyy = the value of xactid_row
in the MSjobs table in the distribution database.
<P>
The LogReader task will fail and be shutdown in this situation. No
replication transactions for the published database will be processed
until the error is corrected. Since the log cannot be truncated past
the oldest unreplicated transaction, the log may fill to a point where
Msg 1105 will be encountered.
<P>
<P><h2>WORKAROUND</h2>
 
<P>
Find the row in MSjobs in the distribution database whose xactid_page
and xactid_row match the values listed in the error message above. This
row should contain the maximum job_id value for the table.
<P>
After you do this, update the values for xactid_page and xactid_row for
this row to 0. It is recommended that you run the UPDATE statement with a
BEGIN TRAN command so that you can rollback changes if you make a mistake.
Make sure to execute COMMIT TRAN if the statement is successfully applied.
<P>
The simplest way to perform this update is:
<P>
<PRE>   UPDATE MSjobs SET xactid_page = 0, xactid_row = 0
   WHERE  xactid_page = &lt;xactid_page&gt; AND  xactid_row = &lt;xactid_row&gt;

   where
   &lt;xactid_page&gt; and &lt;xactid_row&gt; are the values that are displayed in the
   LogReader error message &lt;x,y&gt;

</PRE>If the LogReader is setup as "Autostart," restart SQLExecutive. Otherwise,
you may choose to execute the task "On Demand" to make sure it can run
successfully. If the problem is resolved, the LogReader task will show up
as a "Running Task" under SQL Enterprise Manager. However, it will not show
a successful status in the Task History if you restarted SQLExecutive.
<P>
 
<P><h3>FIX: LogReader Can Fail On sp_repldone Using Partitioning</h3>
 
<P>
ARTICLE-ID:<B><A href="../sqlserver/q138825.htm">Q138825</A></B>
BUG# NT: 11636 (6.00)
<P>
<P><h2>SYMPTOMS</h2>
 
<P>
Under certain conditions using horizontal or vertical partitioning, the
LogReader task for replication can fail with the following error:
<P>
<PRE>   The replicated transaction (xxx, yyy) no longer exists in the log.
   Unable to execute sp_repldone on &lt;server&gt;.

</PRE>where xxx = the value of xactid_page and yyy = the value of xactid_row
in the MSjobs table in the distribution database.
<P>
<P><h2>CAUSE</h2>
 
<P>
This problem can occur if a transaction is run against a published article
that does not meet the criteria of a horizontal or vertical partition. The
LogReader task will fail and be shutdown in this situation. No replication
transactions for the published database will be processed until the error
is corrected. Since the log cannot be truncated past the oldest
unreplicated transaction, the log may fill to a point where Msg 1105 will
be encountered.
<P>
<P><h2>WORKAROUND</h2>
 
<P>
Find the row in MSjobs in the distribution database whose xactid_page
and xactid_row match the values listed in the error message above. This row
should contain the maximum job_id value for the table. Then update the
values for xactid_page and xactid_row for this row to 0. It is recommended
that you run the UPDATE statement with a BEGIN TRAN command so that you can
rollback changes if you make a mistake.
<P>
Make sure to execute COMMIT TRAN if the statement is successfully applied.
If the LogReader is setup as "Autostart," restart SQLExecutive. Otherwise,
you may choose to execute the task "On Demand" to make sure it can run
successfully. If the problem is resolved, the LogReader task will show up
as a "Running Task" under SQL Enterprise Manager. However, it will not show
a successful status in the Task History if you restarted SQLExecutive.
<P>
 
<P><h3>FIX: Timestamp Col of Temp Table Set to 0 When Inserting Row in SP</h3>
 
<P>
ARTICLE-ID:<B><A href="../sqlserver/q138848.htm">Q138848</A></B>
BUG# NT: 11220 (6.00)
<P>
<P><h2>SYMPTOMS</h2>
 
<P>
When you insert a row inside a stored procedure (SP) into a temporary table
that contains a timestamp column in a situation where the temporary table
was created outside the SP and was deleted after the creation of the SP,
the timestamp column is set to 0 when the SP is called.
<P>
<P><h2>WORKAROUND</h2>
 
<P>
If the SP gets called once after its creation and before the original
table is dropped, the timestamp is set to a correct value in all subsequent
calls.
<P>
 
<P><h3>FIX: AV or Error 632 on Update w/ Select Count(distinct) Subqu</h3>
 
<P>
ARTICLE-ID:<B><A href="../sqlserver/q138846.htm">Q138846</A></B>
BUG# NT 11505 (6.00)
<P>
<P><h2>SYMPTOMS</h2>
 
<P>
A handled access violation (AV) or 632 error may be generated if an
UPDATE statement is issued that sets a column in the update table
equal to the "SELECT COUNT(DISTINCT column)" results of a subquery.
The subquery must contain a comparison expression against a column
which contains all null values.
<P>
The 632 error will generate the text:
<P>
<PRE>   Error : 632, Severity 20, State 1
   Memmove() was called with a length of n - maximum allowed length is m.

</PRE><h2>WORKAROUND</h2>
 
<P>
Rewrite the query to eliminate the use of the COUNT(distinct) expression
within the same statement as the comparison against the null column(s). A
possible option would be to select the distinct results into a temporary
table and perform futher manipulation on that data set.
<P>
 
<P><h3>FIX: Cursor Using Stored Proc After LOAD DB May Get 225 Error</h3>
 
<P>
ARTICLE-ID:<B><A href="../sqlserver/q140871.htm">Q140871</A></B>
BUG# NT: 12136 (6.00)
<P>
<P><h2>SYMPTOMS</h2>
 
<P>
Opening a server-side cursor where the SELECT statement is a stored
procedure may result in error 225:
<P>
<PRE>   Cannot run query--referenced object (name NAME NOT RECOVERABLE) dropped
   during query optimization

</PRE>after you load the database with LOAD DATABASE.
<P>
<P><h2>CAUSE</h2>
 
<P>
If the stored procedure has not already been executed by itself prior
to being used in the cursor, the re-resolution of the stored procedure
leads to this error.
<P>
<P><h2>WORKAROUND</h2>
 
<P>
Execute the stored procedure outside the cursor prior to using it with a
cursor after a LOAD DATABASE has taken place.
<P>
 
<P><h3>FIX: Inserts on SMP Computer Can Cause Error Message 1203</h3>
 
<P>
ARTICLE-ID:<B><A href="../sqlserver/q141539.htm">Q141539</A></B>
BUG# NT: 11223 (6.00)
<P>
<P><h2>SYMPTOMS</h2>
 
<P>
If a table has a non-unique clustered index and is running on a
multiprocessor computer with SMP support on, INSERTs can cause the
following 1203 error message to occur:
<P>
<PRE>   Msg  1203 Level 20 State 1
   Caller of lock manager is incorrectly trying to unlock an unlocked
   object. spid=%d locktype=%d dbid=%d lockid=%ld.

</PRE><h2>WORKAROUND</h2>
 
<P>
There are several options available to avoid this problem, including:

<OL><P><LI>Turn off dedicated multiprocessor support to allow the INSERT to
   complete.

<P><LI>Replace the clustered index on the problem table with a nonclustered
   index.

<P><LI>Make the non-unique clustered index into a unique clustered index.
<P>
</OL> 
<P><h3>FIX: Stored Procedures Can Corrupt Themselves in Small Caches</h3>
 
<P>
ARTICLE-ID:<B><A href="../urjump.htm">Q141540</A></B>
BUG# NT: 11322 (6.00)
<P>
<P><h2>SYMPTOMS</h2>
 
<P>
During the execution of a stored procedure, the following error
messages could occur:
<P>
<PRE>   Msg 2806, Level 18, State 0
   Stored procedure %s is corrupted.  Must re-create procedure.

</PRE></OL>In addition to the client receiving this message, message 707 will
appear in the errorlog.
<P>
<PRE>   Msg 707, Level 20, State 9
   System error detected during attempt to free memory at address
   0xdcdcdcdc.

</PRE>Until SQL Server is restarted, you will not be able to run the stored
procedure reported as corrupt by error message 2806.
<P>
<P><h2>CAUSE</h2>
 
<P>
If the SQL Server procedure cache gets full, this can result in corrupt
stored procedures. In addition to the cache being full, the stored
procedures running need to be above 64 pages in size. Also, they need to be
accessing temporary tables that were created outside the stored procedure.
<P>
<P><h2>WORKAROUND</h2>
 
<P>
You can avoid this problem by increasing the amount of memory available to
the SQL Server procedure cache. This can be done by either altering the
memory available to SQL Server or by increasing the percentage of SQL
Server's memory available to the procedure cache.
<P>
 
<P><h3>FIX: A Cursor in a St. Procedure Can Cause an Access Violation</h3>
 
<P>
ARTICLE-ID:<B><A href="../sqlserver/q141541.htm">Q141541</A></B>
BUG# NT: 11508 (6.00)
<P>
<P><h2>SYMPTOMS</h2>
 
<P>
A stored procedure that contains a cursor can cause an access violation if
the following conditions are met:

<OL><P><LI>The cursor needs to have an expression clause.
</OL>2. The cursor must have an ORDER BY clause.
3. The stored procedure must be executed, dropped, recreated, and
<PRE>   executed again for the AV to occur.

</PRE></OL><h2>WORKAROUND</h2>
 
<P>
Remove or change the expression clause to not be an expression clause.
Remove the ORDER BY and do the sort another way using temporary tables, or
sort the result set on your client. Do not drop the stored procedure and
immediately recreate and execute it. If the stored procedure must be
dropped, then drop the stored procedure and shut down and restart SQL
Server; this will allow it to execute upon re-creation.
<P>
 
<P><h3>FIX: A View With an Outer Join Can Cause An Access Violation</h3>
 
<P>
ARTICLE-ID:<B><A href="../sqlserver/q141542.htm">Q141542</A></B>
BUG# NT: 12004 (6.00)
<P>
<P><h2>SYMPTOMS</h2>
 
<P>
A SELECT against a view can result in the following error message:
<P>
<PRE>   Msg 530, level 18, State 0
   Attempt to insert NULL value into column %d in work table (table id);
   column does not allow NULLS, UPDATE fails.

</PRE>The connection will be terminated and the SQL Server error log will
show a language exec error and an access violation.
<P>
<P><h2>CAUSE</h2>
 
<P>
For this bug to occur, the view needs to meet the following conditions:

<OL><P><LI>The SELECT clause needs to have a DISTINCT in it.
</OL>2. The query being performed by the SELECT must use an outer join.
3. A column in one of the tables must be a bit field.
<P>
When SQL Server forms the outer join work table, it mistakenly puts
NULLS in the work table where the bit field is. By definition, a bit
field must be either 0 or 1, and in the case of a NULL it should
default to 0; however, in this case it does not.
<P>
<P><h2>WORKAROUND</h2>
 
<P>
You can circumvent the problem by avoiding any one of the three conditions
that must be present to cause it.
<P>
 
<P><h3>FIX: SELECT TEXT Columns with FOR BROWSE Holds sh_page Locks</h3>
 
<P>
ARTICLE-ID:<B><A href="../sqlserver/q141550.htm">Q141550</A></B>
BUG# NT: 11535 (6.00)
<P>
<P><h2>SYMPTOMS</h2>
 
<P>
Using FOR BROWSE in a SELECT statement in a user-defined transaction
holds shared page locks until the end of the transaction.
<P>
<P><h2>CAUSE</h2>
 
<P>
This problem occurs only when the TEXT datatype column is included in the
SELECT list. The locks are not held until the end of the transaction when
the TEXT datatype columns are not selected.
<P>
 
<P><h3>FIX: dbopen Memory Leak of 32K On Failed Login Attempt</h3>
 
<P>
ARTICLE-ID:<B><A href="../sqlserver/q139556.htm">Q139556</A></B>
BUG# NT: 11480 (6.00)
<P>
<P><h2>SYMPTOMS</h2>
 
<P>
A call to dbopen with an invalid password or an attempt to establish an
invalid trusted connection causes a 32K memory leak. The private bytes for
the process will climb by 32K each time the dbopen fails. You may also see
Process\Non-Paged Pool bytes increase. Continued leaks may cause Windows NT
to run to a low virtual memory state.
<P>
<P><h2>WORKAROUND</h2>
 
<P>
Ensure that all login attempts are valid.
<P>
MORE INFORMATION
 
<P>
Some specific troubleshooting areas:

<OL><P><LI>Check all passwords and password mappings.
   (Use the SQL Security Manager for mappings and the Control Panel Service
   application to verify startup information for the specific service.)

<P><LI>Enable failed and successful SQL Server logins.
   (Use the SQL Server Setup Security option.)

<P><LI>Logon as the secured user and use ISQL with the -E parameter to verify
   the user can establish a secured login.

<P><LI>Verify the net-library supports a trusted connection.
   (Use the SQL Server Client Configuration Utility to verify a named pipes
   or multi-protocol connection is being established.)

<P><LI>Verify the pipe name is correct. The pipe name must begin with
   \\.\pipe\...  Anything else will cause an error when SQL Server attempts
   to create the pipe. Thus, named pipe connections will fail.
<P>
   Verify the pipe is opend by looking in the SQL Server
   errorlog.

<P><LI>Run SQLExecutive in debug mode.
   (sqlexec -c -v)
<P>
   **Specifically, retries of the replication processes can indicate failed
<P><PRE>     logins.
</PRE><P>
</OL>By default, the first dbopen allocates 4K to track connections for the
application. This memory is not released until the application exits.
<P>
 
<P><h3>FIX: SELECT From View w/ Data Length &gt; 1962 Bytes May Hang Svr</h3>
 
<P>
BUG# NT: 12766 (6.00)
ARTICLE-ID:<B><A href="../urjump.htm">Q147179</A></B>
<P>
<P><h2>SYMPTOMS</h2>
 
<P>
A SELECT from a VIEW on a table that has a data length greater than 1962
bytes (a table created with VARCHAR datatype) may hang the server. The
server will crash with the following error message:
<P>
<PRE>   SQLSERVR.EXE   - Application error
   The exception Integer Division By Zero
   (0xc000094) at location 0x00513098

</PRE></OL> 
<P><h2>ADDENDUM: LIST OF PROBLEMS CORRECTED IN SERVICE PACK 1</h2>
 
<P>
For the complete description of these bugs, please see Knowledge Base
article <B><A href="../sqlserver/q136575.htm">Q136575</A></B>.

<UL><LI>FIX: Memory Leak in NTWDBLIB.DLL on Failed dbopen()
<LI>FIX: ODBC 6.0 Driver Sometimes Cannot Get Results w/ dbmsspx3
<LI>FIX: Updating a Text Column Results in a Table Scan
<LI>FIX: Cannot Insert BLOB Data Larger Than 128k w/ SQLSetParam
<LI>FIX: Repl Synch Fails with Table Names That Have Ext Chars
<LI>FIX: EXECUTE Command w/ a Local Variable Can Cause Thread AV
<LI>FIX: DUMP DATABASE w/ Variable Device Name in SP May Cause AV
<LI>FIX: IN Condition with More Than 15 Values May Fail
<LI>FIX: Unexpected Behavior During Object Resolution
<LI>FIX: DBCC NEWALLOC Enhanced to use RA for Performance
<LI>FIX: Query Plan Inconsistent If Search Value &gt; Last Step
<LI>FIX: Optimizer Hint for Index Name Fails in View
<LI>FIX: Open Cursor Statement in SP Sets Variables to NULL
<LI>FIX: Lvl 16 Error on Temp Tbl From SP w/ &gt; 64 Pgs May Cause AV
<LI>FIX: SELECT INTO w/ Correlated Subqueries May Cause AV
<LI>FIX: DUMPs May Halt Queries With Triggers
<LI>FIX: Create Worktable for Oversized Table Can Stop the Server
<LI>FIX: ALTER TABLE Allows Nulls in PRIMARY KEY
<LI>FIX: AV When Creating Reformat Plan of SP Containing Join
<LI>FIX: Updating a Record w/ NULL Text Field Can Cause 2574 Error
<LI>FIX: Add Constraint Causes Identity-Column Inserts to Fail
<LI>FIX: Cannot Create a Qualified Table With a Check Constraint
<LI>FIX: SET ARITHABORT ON Inadvertently Causes an Insert to Fail
<LI>FIX: Cursor Declaration In a Stored Procedure Causes Client AV
<P></UL>

	</FONT>
	</TD>
	</TR>
</TABLE>
<P>


<!--DOCBODY_END-->

<!--FOOTER_START-->
<table cellpadding=5 border=0 width="90%">
<tr>
<td>
	<HR WIDTH="90%">

<BLOCKQUOTE>
<FONT FACE="Verdana, Arial, Helvetica" SIZE="1">
<SPAN STYLE="font-family:verdana,arial,helvetica; font-size:8pt">
Additional query words:<BR>
Keywords            : kbfixlist kbfixlist6.00.sp2<BR>
Version             : 6.0<BR>
Platform            : WINDOWS<BR>
Issue type          : kbref<BR>

</SPAN>
</FONT>
<BR>
<BR>
THE INFORMATION PROVIDED IN THE MICROSOFT KNOWLEDGE BASE IS
PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND.  MICROSOFT DISCLAIMS
ALL WARRANTIES, EITHER EXPRESS OR IMPLIED, INCLUDING THE WARRANTIES
OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  IN NO
EVENT SHALL MICROSOFT CORPORATION OR ITS SUPPLIERS BE LIABLE FOR
ANY DAMAGES WHATSOEVER INCLUDING DIRECT, INDIRECT, INCIDENTAL,
CONSEQUENTIAL, LOSS OF BUSINESS PROFITS OR SPECIAL DAMAGES, EVEN IF
MICROSOFT CORPORATION OR ITS SUPPLIERS HAVE BEEN ADVISED OF THE
POSSIBILITY OF SUCH DAMAGES.  SOME STATES DO NOT ALLOW THE EXCLUSION
OR LIMITATION OF LIABILITY FOR CONSEQUENTIAL OR INCIDENTAL DAMAGES
SO THE FOREGOING LIMITATION MAY NOT APPLY.
</BLOCKQUOTE>
<P>
<center>
	<FONT FACE="Verdana,Arial,Helvetica" SIZE="1">
	Last reviewed:  May 1, 1997</FONT>
	<BR>
	<A href="../cpyright.htm" STYLE="font: bold 7pt Verdana,Arial,Helvetica">&copy; 1998 Microsoft Corporation. All rights reserved. Terms of Use.</A><BR>
	
</center>
</td>
</tr>
</table>

<!--FOOTER_END-->
</FONT>
</BODY>
</HTML>
