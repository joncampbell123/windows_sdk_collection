

<HTML>
<HEAD>
<TITLE>FIX: SQL Server 6.5 Service Pack 2 Fixlist (Part 3 of 3) </TITLE>

<!--STYLE_BEGIN-->
<style>@import url(../../msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="../../msdn_ie3.css">
<!--STYLE_END-->

<META HTTP-EQUIV="CONTENT-Type" CONTENT="text/html; charset=us-ascii">
<META NAME="ms.locale" CONTENT="EN-US">
<META NAME="Category" CONTENT="Support; KB Article">
<META NAME="KBID" CONTENT="Q164022">
<META NAME="KBModify" CONTENT="1997/11/07">
<META NAME="KBCreate" CONTENT="1997/02/21">
<META NAME="Keywords" CONTENT="SSrvGen kbfixlist6.50.sp2">
<META NAME="KBArea" CONTENT="Support; KB; sqlserver">
<META NAME="Description" CONTENT=" The following is a list (Part 3 of 3) of fixes and other various improvements that have been made in Microsoft SQL Server version 6.5 Service Pack 2, now available from your primary support provider. For more information, contact your primary suppor...">
<META NAME="Product" CONTENT="SQL Server">
<META NAME="Platform" CONTENT="Windows">
<META NAME="Technology" CONTENT=" ">
<META NAME="Premium" CONTENT="support">

<META NAME="nyms" CONTENT="QAR4,QAB4,QDKW,QAM1,QDIX,QAKP,QAAP,QAPN,QAB9,QBWS,QABM,QAXB,QA2Q,QAY2,QAG2 V02180118">
</HEAD>

<BODY BGCOLOR="#FFFFFF" LEFTMARGIN="0" RIGHTMARGIN="0" TOPMARGIN="0">


<!--DOCBODY_START-->
<BR>
<CENTER>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" VALIGN="top" WIDTH="90%">
	<TR>
		<TD VALIGN="top">
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<H1>FIX: SQL Server 6.5 Service Pack 2 Fixlist (Part 3 of 3)</H1>
			</FONT>
			<FONT FACE="verdana,arial,helvetica" SIZE="1">
			Last reviewed:  November 7, 1997</FONT><BR>
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<B>Article ID: Q164022</B>
			</FONT>
		</TD>
	</TR>
	<TR>
	<TD>
	<FONT FACE="Verdana, Arial, Helvetica" SIZE=2>



 
 
The information in this article applies to:

<UL><LI>Microsoft SQL Server, version 6.5 Service Pack 2
</UL> 
<P>
The following is a list (Part 3 of 3) of fixes and other various
improvements that have been made in Microsoft SQL Server version 6.5
Service Pack 2, now available from your primary support provider. For more
information, contact your primary support provider.
<P>
Please note that workarounds described in these articles have been provided
for your information only. It is not necessary to implement these
workarounds if you have the updated software.
<P>
 
<P><h2>LIST OF PROBLEMS CORRECTED IN SERVICE PACK 2 (Part 3 of 3)</h2>
 
<P>
<P><h3>SERVER COMPONENTS</h3>
 
<P>
<B><A href="../sqlserver/q158462.htm">Q158462</A></B>: FIX: Access Violation With Natural ANSI Join with View
<B><A href="../sqlserver/q158486.htm">Q158486</A></B>: FIX: Error 701/Server Unresponsive on Cursor Queries w/UPDATE
<B><A href="../sqlserver/q158584.htm">Q158584</A></B>: FIX: AV With Outer Join and Convert to Char Column
<B><A href="../sqlserver/q158685.htm">Q158685</A></B>: FIX: ANSI Join in Exists Clause Causes Parser Error 403
<B><A href="../sqlserver/q158791.htm">Q158791</A></B>: FIX: Using a Derived Table in the HAVING Clause May Cause AV
<B><A href="../sqlserver/q158792.htm">Q158792</A></B>: FIX: Problems Using the KILL Command with a Stored Procedure
<B><A href="../sqlserver/q158793.htm">Q158793</A></B>: FIX: Permission Denied Error Message 229 When Updating a Table
<B><A href="../sqlserver/q158806.htm">Q158806</A></B>: FIX: A Derived Table in the Group By Clause Causes Handled AV
<B><A href="../sqlserver/q158807.htm">Q158807</A></B>: FIX: Derived Table Generation May Cause Error 206
<B><A href="../sqlserver/q158808.htm">Q158808</A></B>: FIX: Permission Denied Error 229 Updating Table With DBID&gt;10
<B><A href="../sqlserver/q158856.htm">Q158856</A></B>: FIX: Err 107 Creating VIEW with a UNION &amp; Correlated Subquery
<B><A href="../sqlserver/q158892.htm">Q158892</A></B>: FIX: DBCC Shrinkdb Fails with Error 7991
<B><A href="../sqlserver/q158893.htm">Q158893</A></B>: FIX: Increasing the Size of Tempdb in RAM Fails
<B><A href="../sqlserver/q158998.htm">Q158998</A></B>: FIX: Dump to Tape Causes AV Using Adaptec 154x SCSI Adapter
<B><A href="../sqlserver/q159339.htm">Q159339</A></B>: FIX: Stack Overflow If a SELECT Statement Is Killed
<B><A href="../sqlserver/q159358.htm">Q159358</A></B>: FIX: Access Violation During the Load of a Read-Only Database
<B><A href="../sqlserver/q159372.htm">Q159372</A></B>: FIX: SET ANSI_WARNINGS ON Option Does Not Generate Warnings
<B><A href="../sqlserver/q159373.htm">Q159373</A></B>: FIX: Dynamic Cursor Fails to Delete a Record
<B><A href="../sqlserver/q159444.htm">Q159444</A></B>: FIX: A Join Returning a NULL in a Smallint Column May Cause AV
<B><A href="../sqlserver/q159445.htm">Q159445</A></B>: FIX: Optimizer May Incorrectly Choose Reformat Strategy
<B><A href="../sqlserver/q159598.htm">Q159598</A></B>: FIX: SQL Server Stops Responding After an INSERT/SELECT
<B><A href="../sqlserver/q159698.htm">Q159698</A></B>: FIX: Unexpected Results Using OBJECT_ID() &amp; Quoted Identifier
<B><A href="../sqlserver/q159699.htm">Q159699</A></B>: FIX: Sp_cursorfetch: No Error Reported With Incorrect Datatype
<B><A href="../sqlserver/q159701.htm">Q159701</A></B>: FIX: UNION in Views Maintains Duplicate Rows If Table Has Bit
<B><A href="../sqlserver/q159781.htm">Q159781</A></B>: FIX: Sp_cursorfetch May Cause Errors 614 and 605
<B><A href="../sqlserver/q159782.htm">Q159782</A></B>: FIX: Concurrent CREATE TABLE &amp; ALTER TABLE May Cause Deadlock
<B><A href="../sqlserver/q159783.htm">Q159783</A></B>: FIX: Stranded Tables After Deadlocks on System Tables
<B><A href="../sqlserver/q159816.htm">Q159816</A></B>: FIX: Error 15224 Renaming Column to 1 Character with Sp_rename
<B><A href="../sqlserver/q159847.htm">Q159847</A></B>: FIX: ANSI SQL JOIN May Fail With AV Joining VIEW With Table
<B><A href="../sqlserver/q159848.htm">Q159848</A></B>: FIX: ALTER TABLE ADD PK May Take a Long Time Even With No Data
<B><A href="../sqlserver/q159849.htm">Q159849</A></B>: FIX: Names May Collide with Creation of Temp Stored Procedures
<B><A href="../sqlserver/q159937.htm">Q159937</A></B>: FIX: AV Creating View With ANSI JOINS
<B><A href="../sqlserver/q160541.htm">Q160541</A></B>: FIX: Cross database insert fails with error 229 permission denied
<B><A href="../sqlserver/q161223.htm">Q161223</A></B>: FIX: Msg. 116 Doing Correlated Updates in a Stored Procedure
<B><A href="../sqlserver/q162033.htm">Q162033</A></B>: FIX: SQLTrace May Cause Error 17803 on a Server
<B><A href="../sqlserver/q162366.htm">Q162366</A></B>: FIX: Using a WHERE IN Clause on a Selected UNION May Fail
<B><A href="../sqlserver/q167606.htm">Q167606</A></B>: FIX: Err 511: Stored Proc w/ANSI_NULL_DFLT_ON Creates Temp Tbl
<B><A href="../sqlserver/q171879.htm">Q171879</A></B>: FIX: Switching Order of Tables in FROM Clause Changes Optimizer
<P>
Below are excerpts from each of the articles listed above. For the full
text of the articles, search for the article number in the Microsoft
Knowledge Base.
<P>
 
FIX: Access Violation With Natural ANSI Join with View
 
<P>
ARTICLE-ID: <B><A href="../sqlserver/q158462.htm">Q158462</A></B>
BUG #: 15823
<P>
<P><h2>SYMPTOMS</h2>
 
<P>
On a computer running Microsoft SQL Server 6.5 Service Pack 1, a natural
join between a table and a view using the ANSI INNER JOIN syntax results in
a handled access violation, if the view includes a Column1 = Column2
restriction clause.
<P>
<P>
 
FIX: Error 701/Server Unresponsive on Cursor Queries w/UPDATE
 
<P>
ARTICLE-ID: <B><A href="../sqlserver/q158486.htm">Q158486</A></B>
BUG #: Windows NT: 15624 (6.5)
<P>
<P><h2>SYMPTOMS</h2>
 
<P>
When you run cursor queries that do an UPDATE using the WHERE CURRENT OF
&lt;cursor&gt; clause, the server runs out of memory, even though the cursors are
closed properly. This leads to the following error message (701):
<P>
<PRE>   There is insufficient system memory to run this query.

</PRE>After that, the server becomes very slow for normal connections.
<P>
<P><h2>WORKAROUND</h2>
 
<P>
To work around this problem, do either of the following:

<UL><LI>Avoid using the UPDATE WHERE CURRENT OF &lt;cursor&gt; clause. Instead, you
   can use "positioned" updates (calling sp_cursor or using SQLSetPos in
   ODBC).
<P>
   -or-

<LI>Identify and close the connection that caused the error 701 message.
   Normally, the client connection that caused this problem runs into the
   error 701, and can be identified easily. When this connection is closed,
   everything returns to normal.
<P>
<P>
</UL> 
FIX: AV With Outer Join and Convert to Char Column
 
<P>
ARTICLE-ID: <B><A href="../sqlserver/q158584.htm">Q158584</A></B>
BUG #: 15789 (6.50, NT)
<P>
<P><h2>SYMPTOMS</h2>
 
<P>
A query performing an outer join (using either old or new ANSI-compatible
join syntax) and including a CHAR column in the select list (which comes
from doing a CONVERT) may generate a handled access violation (AV).
<P>
<P>
 
FIX: ANSI Join in Exists Clause Causes Parser Error 403
 
<P>
ARTICLE-ID: <B><A href="../sqlserver/q158685.htm">Q158685</A></B>
BUG #: 15735 (6.5)
<P>
<P><h2>SYMPTOMS</h2>
 
<P>
Using an ANSI JOIN together with a correlated subquery inside an EXISTS
clause returns the parser error 403:
<P>
<PRE>   Invalid operator for datatype op: UNKNOWN TOKEN type: varchar

</PRE><h2>WORKAROUND</h2>
 
<P>
Use a join expression in a WHERE clause instead.
<P>
 
FIX: Using a Derived Table in the HAVING Clause May Cause AV
 
<P>
ARTICLE-ID: <B><A href="../sqlserver/q158791.htm">Q158791</A></B>
BUG #: 16030 6.50
<P>
<P><h2>SYMPTOMS</h2>
 
<P>
A SELECT statement using a derived table in the HAVING clause may cause a
handled access violation (AV). In addition, the access violation's stack
dump may go into a state where it continuously writes the stack to the
errorlog. If this occurs, the errorlog will grow very quickly.
<P>
<P><h2>WORKAROUND</h2>
 
<P>
To work around this problem, do not use derived tables in the HAVING
clause.
<P>
 
FIX: Problems Using the KILL Command with a Stored Procedure
 
<P>
ARTICLE-ID: <B><A href="../sqlserver/q158792.htm">Q158792</A></B>
BUG #: 16064 (6.50)
<P>
<P><h2>SYMPTOMS</h2>
 
<P>
Using the KILL command to end a long-running stored procedure may cause the
computer running SQL Server to stop responding or go into a 100 percent CPU
spin. All existing connections cannot process, and any attempts to connect
will time-out. SQL Server cannot be shut down, and you must either kill it
or restart Windows NT. This problem should only occur if the stored
procedure is processing through a large cursor set.
<P>
<P><h2>WORKAROUND</h2>
 
<P>
Use the KILL command with discretion.
<P>
 
FIX: Permission Denied Error Message 229 When Updating a Table
 
<P>
ARTICLE-ID: <B><A href="../sqlserver/q158793.htm">Q158793</A></B>
BUG #: 16107 (6.50)
<P>
<P><h2>SYMPTOMS</h2>
 
<P>
A non-system administrator (SA) user will receive a Permission Denied error
message (number 229) when he or she tries to update a table through a
stored procedure, even if the user has permission to run the stored
procedure. If the SA or database owner (DBO) runs the stored procedure
first, the user will then be able to use the stored procedure. This problem
occurs when the following sequence of events occurs:

<OL><P><LI>Non-SA user runs stored procedure A.

<P><LI>Stored procedure A calls procedure B.

<P><LI>Procedure B updates a table through a cursor.
<P>
</OL><h2>WORKAROUND</h2>
 
<P>
To work around this problem, do one of the following:

<UL><LI>Do not use cursors to update tables when the cursor is in a stored
   procedure that is called by another procedure.

<LI>Give the user permissions to the underlying table.

<LI>Have the DBO run all stored procedures affected by this problem every
   time SQL Server is restarted. This allows normal users to run the stored
   procedures.
<P>
<P>
</UL> 
FIX: A Derived Table in the Group By Clause Causes Handled AV
 
<P>
ARTICLE-ID: <B><A href="../sqlserver/q158806.htm">Q158806</A></B>
BUG #: 15855 (6.50)
<P>
<P><h2>SYMPTOMS</h2>
 
<P>
A SELECT statement using a derived table in the Group By clause may cause a
handled access violation (AV). In addition, the access violation's stack
dump may go into a state where it continuously writes the stack to the
errorlog. If this occurs, the errorlog will grow very quickly.
<P>
<P><h2>WORKAROUND</h2>
 
<P>
To work around this problem, do not use derived tables in the Group By
clause.
<P>
 
FIX: Derived Table Generation May Cause Error 206
 
<P>
ARTICLE-ID: <B><A href="../sqlserver/q158807.htm">Q158807</A></B>
BUG #: 15800 (6.50)
<P>
<P><h2>SYMPTOMS</h2>
 
<P>
If a query used to create a derived table selects a user-defined datatype,
selecting from the derived table may cause the following error message:
<P>
<PRE>   206   16 Operand type clash: %s is incompatible with %s

</PRE></OL>The following example shows a query that may cause this problem. In the
example, au_id from the authors table is a user-defined datatype.
<P>
<PRE>   use pubs
   go
   select * from (select a.au_id from authors a
   inner join titleauthor ta on a.au_id = ta.au_id
   and a.au_fname = "Albert") as a
   go

</PRE><h2>WORKAROUND</h2>
 
<P>
To work around this problem, do not use derived tables to select data from
columns with user-defined data types.
<P>
<P>
 
FIX: Permission Denied Error 229 Updating Table With DBID&gt;10
 
<P>
ARTICLE-ID: <B><A href="../sqlserver/q158808.htm">Q158808</A></B>
BUG #: 16128 (6.50)
<P>
<P><h2>SYMPTOMS</h2>
 
<P>
A non-system administrator (SA) user will receive a Permission Denied error
message (number 229) when he or she tries to update a table through a
stored procedure, even if the user has permission to run the stored
procedure. If the SA or database owner (DBO) runs the stored procedure
first, the user will then be able to use the stored procedure. This problem
occurs when the following sequence of events occurs:

<OL><P><LI>Non-SA user runs stored procedure A.

<P><LI>Stored procedure A calls procedure B.

<P><LI>Procedure B updates a table through a cursor in which the table is
   located in another database.

<P><LI>The other database must have a DBID greater then 10.
<P>
</OL><h2>WORKAROUND</h2>
 
<P>
To work around this problem, do one of the following:

<UL><LI>Do not use cursors to update tables when the cursor is in a stored
   procedure that is called by another procedure.

<LI>Give the user permissions to the underlying table.

<LI>Have the DBO run all stored procedures affected by this problem every
   time SQL Server is restarted. This allows normal users to run the stored
   procedures.
<P>
<P>
</UL> 
FIX: Error Creating a VIEW with a UNION &amp; Correlated Subquery
 
<P>
ARTICLE-ID: <B><A href="../sqlserver/q158856.htm">Q158856</A></B>
BUG #: 16081 (sqlbug_65 sql 6.5)
<P>
<P><h2>SYMPTOMS</h2>
 
<P>
When you attempt to create a VIEW that contains a UNION clause and a
correlated subquery, the creation of the VIEW fails with error 107.
<P>
<P><h2>WORKAROUND</h2>
 
<P>
To work around this problem, change your VIEW definition, and avoid using
both a UNION and a correlated subquery.
<P>
<P>
 
FIX: DBCC Shrinkdb Fails with Error 7991
 
<P>
ARTICLE-ID: <B><A href="../sqlserver/q158892.htm">Q158892</A></B>
BUG #: 16024 (6.50)
<P>
<P><h2>SYMPTOMS</h2>
 
<P>
If the default database size in the SQL Server Configuration Values is set
to a value that is greater than the actual size of a database, you receive
the following error when trying to shrink the database:
<P>
<PRE>   Error 7991:
   Unable to shrink database '%.*s' as it contains %d pages. Minimum pages
   %d.

</PRE></OL>The database consistency checker (DBCC) command shrinkdb(&lt;dbname&gt;) works
correctly and shows the size to which the database can be shrunk, but you
will also receive error 7991, if the condition above is true. It makes no
difference whether you use the user interface or the DBCC shrinkdb Transact-
SQL command.
<P>
<P><h2>WORKAROUND</h2>
 
<P>
To work around this problem, set the Database Size configuration value to a
value that is less than the size of the database you want to shrink.
<P>
 
FIX: Increasing the Size of Tempdb in RAM Fails
 
<P>
ARTICLE-ID: <B><A href="../sqlserver/q158893.htm">Q158893</A></B>
BUG #: 16020 (6.50)
<P>
<P><h2>SYMPTOMS</h2>
 
<P>
If tempdb is located in RAM and you have no default disk specified, it is
not possible to alter the size of tempdb in RAM. No error message is
provided. Only the config_value for the SQL Server configuration value
"tempdb in RAM" is changed, but the run_value always remains the same
(previous) value after restarting SQL Server.
<P>
<P><h2>WORKAROUND</h2>
 
<P>
To work around this problem, specify a default device with sp_diskdefault.
You can then alter the size of tempdb without any problem.
<P>
<P>
 
FIX: Dump to Tape Causes AV Using Adaptec 154x SCSI Adapter
 
<P>
ARTICLE-ID: <B><A href="../sqlserver/q158998.htm">Q158998</A></B>
BUG #: 16157 (6.50)
<P>
<P><h2>SYMPTOMS</h2>
 
<P>
When you use the 154x series Adaptec SCSI adapter on Windows NT 4.0,
dumping any database to tape may cause a handled access violation (AV). The
access violation seems to occur more consistently on 4 mm DAT tape drives,
but has also been seen on 8 mm DAT tape drives.
<P>
<P><h2>WORKAROUND</h2>
 
<P>
To work around this problem, do not dump to a tape device. Instead, dump
and load to a different type of dump device, such as disk. If you dump to a
disk but you wish to store the data on tape, you can use another backup
package, such as Windows NT Backup, to archive the dump file to tape.
<P>
 
FIX: Stack Overflow If a SELECT Statement Is Killed
 
<P>
ARTICLE-ID: <B><A href="../sqlserver/q159339.htm">Q159339</A></B>
BUG #: 15658 (sqlbug_65)
<P>
<P><h2>SYMPTOMS</h2>
 
<P>
If a process is killed while running a SELECT statement in which an
aggregate function is used with a DISTINCT keyword, the following error
message is displayed in the errorlog:
<P>
<PRE>   spid10   ex_testhandle: stack overflow, top=0x10a0ac8, end=0x10a0ac8

</PRE>In addition, if the table from which the SELECT is run is a temporary
table, the following messages are displayed when the process is killed:
<P>
<PRE>   kernel   udread: Operating system error 6(The handle is invalid.) on
   device 'D:\MSSQL\DATA\MASTER.DAT' (virtpage 0x00000394).

   kernel   udwritem: Operating system error 6(The handle is invalid.) on
   device 'D:\MSSQL\DATA\MASTER.DAT' (virtpage 0x00000b80).

</PRE>If the SELECT is placed in a temporary stored procedure and it is selecting
from a temp table, then the following error is added to the errors above:
<P>
<PRE>   spid10   bufwait: timeout, BUF_IO, bp 0xca1420, pg 0x110, stat
   0x1004/0x6, obj 0, bpss 0x109f598

</PRE>This error message will continue to be entered in the errorlog until either
Windows NT or SQL Server is shut down. You will not be able to shut down
SQL Server using SQL Service Manager or by performing a "net stop
mssqlserver". At this point, the behavior of the server is somewhat
unpredictable. You may or may not be able to make new connections to the
server, but the existing connections appear to be stable.
<P>
However, if tempdb only has its original size of 2 MB on the master device,
when the process is killed, you will receive the following error instead:
<P>
<PRE>   Error: 1117, Severity: 21, State: 10
   Extent chain for object -321 is not correctly linked.

</PRE><h2>WORKAROUND</h2>
 
<P>
Avoid using the Kill command to terminate processes.
<P>
 
FIX: Access Violation During the Load of a Read-Only Database
 
<P>
ARTICLE-ID: <B><A href="../sqlserver/q159358.htm">Q159358</A></B>
BUG #: 15568 (6.5)
<P>
<P><h2>SYMPTOMS</h2>
 
<P>
An access violation (AV) may infrequently occur when issuing a LOAD
DATABASE or LOAD TRANSACTION command on a database that is read-only.
<P>
<P><h2>WORKAROUND</h2>
 
<P>
Re-create the database and reload it using the same database dump file. In
the case of an access violation during a LOAD TRANSACTION, reload the last
database dump and the succeeding transaction log dumps.
<P>
 
FIX: SET ANSI_WARNINGS ON Option Does Not Generate Warnings
 
<P>
ARTICLE-ID: <B><A href="../sqlserver/q159372.htm">Q159372</A></B>
BUG #: 15720 (Windows 6.50)
<P>
<P><h2>SYMPTOMS</h2>
 
<P>
The SET ANSI_WARNINGS ON option does not cause an error if an INSERT or
UPDATE statement violates the maximum specified field length of the column
it is inserted into. For references on the maximum lengths of each
datatype, refer to your documentation.
<P>
 
FIX: Dynamic Cursor Fails to Delete a Record
 
<P>
ARTICLE-ID: <B><A href="../sqlserver/q159373.htm">Q159373</A></B>
BUG #: 16127 (SQL 6.5)
<P>
<P><h2>SYMPTOMS</h2>
 
<P>
If a dynamic cursor is opened with optccval for the optimistic
concurrency control, and ROWSET_SIZE is equal to 1, it may
generate the following error message when you attempt to delete a record:
<P>
<PRE>   Msg 16934, Level 16, State 2, Optimistic concurrency check failed, the
   row was modified outside of this cursor

</PRE>An Open Database Connectivity (ODBC) application may receive this error
message using SQLSetPos to delete a record with the dynamic server side
cursor.
<P>
<P><h2>WORKAROUND</h2>
 
<P>
To work around this problem, use other types of cursors (for example, use
the SCROLL cursor type). Use the DECLARE &lt;cursor name&gt; SCROLL CURSOR FOR
&lt;statement&gt; syntax for cursors. This will change the cursor type from
DYNAMIC to SCROLLABLE (keyset-driven).
<P>
An ODBC application can use either ODBC cursors or keyset-driven server
side cursors.
<P>
<P>
 
FIX: A Join Returning a NULL in a Smallint Column May Cause AV
 
<P>
ARTICLE-ID: <B><A href="../sqlserver/q159444.htm">Q159444</A></B>
BUG #: 15183 (Windows: 6.50)
<P>
<P><h2>SYMPTOMS</h2>
 
<P>
A join that returns a NULL in a smallint column may result in a thread
level access violation (AV).
<P>
<P><h2>WORKAROUND</h2>
 
<P>
To work around this problem, use CONVERT to change the datatype from a
smallint value to an integer.
<P>
 
FIX: Optimizer May Incorrectly Choose Reformat Strategy
 
<P>
ARTICLE-ID: <B><A href="../sqlserver/q159445.htm">Q159445</A></B>
BUG #: 15601 (NT 6.5)
<P>
<P><h2>SYMPTOMS</h2>
 
<P>
As stated in the SQL Server documentation, when joining tables, SQL Server
may, use a reformatting strategy to join the tables and return the
qualifying rows. This strategy is considered only as a last resort, when
the tables are large and neither table in the join has a useful index.
<P>
However, this strategy, when chosen, may result in the query running slower
than it would if either the join order of the tables in the query has been
forced using the FORCEPLAN statement, or the underlying indexes on the
joined tables were used.
<P>
<P><h2>WORKAROUND</h2>
 
<P>
To work around this problem, try using the SET FORCEPLAN ON statement
before running the query.
<P>
<P>
 
FIX: SQL Server Stops Responding After an INSERT/SELECT
 
<P>
ARTICLE-ID:<B><A href="../sqlserver/q159598.htm">Q159598</A></B>
BUG #: 15780 (6.50)
<P>
<P><h2>SYMPTOMS</h2>
 
<P>
Running an INSERT-SELECT statement without a FROM clause (such as 'INSERT
INTO TABLE SELECT * WHERE 1=2') may cause SQL Server to stop responding. No
more connections can be made, existing connections time out, and no error
messages are presented in SQL Server the errorlog. SQL Server cannot be
shut down from either Service Manager or Control Panel.
<P>
WORKAROUND
 
<P>
To work around this problem, add a FROM clause to the query.
<P>
<P>
 
FIX: Unexpected Results Using OBJECT_ID() &amp; Quoted Identifier
 
<P>
ARTICLE-ID: <B><A href="../sqlserver/q159698.htm">Q159698</A></B>
BUG #: WINDOWS: 15669 (6.5)
<P>
<P><h2>SYMPTOMS</h2>
 
<P>
When you have SET QUOTED_IDENTIFIER ON, a table created with a period (.)
is not correctly identified using the OBJECT_ID() function.
<P>
For example, the query:
<P>
<PRE>   SELECT name, id, uid FROM SysObjects WHERE id = object_id('dbo.my
   table')

</PRE>returns information pertaining to the table called "my table" owned by
user "dbo" (if one exists).
<P>
<P><h2>WORKAROUND</h2>
 
<P>
Refer to the table using the name field of SysObjects and, if necessary,
the user id of the creator.
<P>
To continue the example above, you would use:
<P>
<PRE>   SELECT name, id, uid FROM SysObjects WHERE name = 'dbo.my table' and
   uid = user_id('dbo')

</PRE> 
FIX: Sp_cursorfetch: No Error Reported With Incorrect Datatype
 
<P>
ARTICLE-ID: <B><A href="../sqlserver/q159699.htm">Q159699</A></B>
BUG #: 15605 (WINDOWS: 6.5)
<P>
<P><h2>SYMPTOMS</h2>
 
<P>
If a non-integer variable is used as the fetch type parameter of
sp_cursorfetch, a fetch type of NEXT is assumed. An error message is not
returned.
<P>
<P><h2>WORKAROUND</h2>
 
<P>
Before running sp_cursorfetch, convert the fetch type to an integer
datatype, using the CONVERT() function. An error will be reported if the
conversion fails.
<P>
 
FIX: UNION in Views Maintains Duplicate Rows If Table Has Bit
 
<P>
ARTICLE-ID: <B><A href="../sqlserver/q159701.htm">Q159701</A></B>
BUG #: 16130 (WINDOWS: 6.5)
<P>
<P><h2>SYMPTOMS</h2>
 
<P>
Running a SELECT from a view that is defined as a UNION of select
statements does not eliminate duplicate rows, if the underlying table
contains a field of the bit type. However, duplicate rows are eliminated if
the UNION statement is not within a view.
<P>
<P><h2>WORKAROUND</h2>
 
<P>
If the bit datatype must be used, place the UNION statement outside a view,
or use the DISTINCT keyword when selecting from the view. Otherwise, use
tinyint, smallint, or int datatypes rather than the bit type.
<P>
 
FIX: Sp_cursorfetch May Cause Errors 614 and 605
 
<P>
ARTICLE-ID: <B><A href="../sqlserver/q159781.htm">Q159781</A></B>
BUG #: 14588 (WINDOWS: 6.50)
<P>
<P><h2>SYMPTOMS</h2>
 
<P>
If DYNAMIC CURSOR was opened through sp_cursoropen, and sp_cursor was used
to delete all rows from the table, subsequent calls to sp_cursorfetch with
any fetch type will fail, generating error 614. After the error occurs,
<PRE>'drop table' fails, and you will receive Msg 3702 until the server is
</PRE>restarted, even if the cursor has been closed. This problem may also cause
transient error 605 on the table if CURSOR is used repeatedly under this
condition. DBCC CHECKTABLE shows no corruption in the table. Regular
Transact SQL statements, such as SELECT, UPDATE, or DELETE still work fine
on the same table. The text of the error messages follows:
<P>
<PRE>   Error : 614, Severity: 21, State: 3
   A row on page %ld was accessed that has an illegal length of 0 in
   database '%s'.

   Getpage: bstat=0x1008/0, sstat=0x82000091, disk
   pageno is/should be: objid is/should be:
   0x342(834)     0x8(8)
   0x342(834)     0x7053b3f3(1884533747)
   ... extent objid 0x7053b3f3, mask 0x3/0, next/prev=0x340/0x340
   ... retry bufget after purging bp 0xf26d40

   Error : 605, Severity: 21, State: 1
   Attempt to fetch logical page %ld in database '%ld' belongs to object
   'syslogs', not to object '%s'.

   Msg 3702, Level 16, State 1
   Cannot drop the table '%s' because it is currently in use.

</PRE><h2>WORKAROUND</h2>
 
<P>
To work around this problem, use the Keyset cursor instead.
<P>
 
FIX: Concurrent CREATE TABLE &amp; ALTER TABLE May Cause Deadlock
 
<P>
ARTICLE-ID: <B><A href="../sqlserver/q159782.htm">Q159782</A></B>
BUG #: 16016 (WINDOWS: 6.50)
<P>
<P><h2>SYMPTOMS</h2>
 
<P>
If you perform a CREATE TABLE and an ALTER TABLE ADD CONSTRAINT
concurrently, you may receive deadlocks on system tables.
<P>
<P><h2>WORKAROUND</h2>
 
<P>
To work around this problem, place the ALTER TABLE in a user transaction
preceded by a SELECT (UPDLOCK) on syscolumns and sysindexes, as shown
below:
<P>
<PRE>   begin tran
   select count(*) from syscolumns(UPDLOCK) where id=object_id('TT1a')
   select count(*) from sysindexes(UPDLOCK) where id=object_id('TT1a')
   alter table TT1a add constraint TT1idx1a PRIMARY KEY (a, b, c, d, e, f,
      g, h)
   commit tran

</PRE> 
FIX: Stranded Tables After Deadlocks on System Tables
 
<P>
ARTICLE-ID: <B><A href="../sqlserver/q159783.htm">Q159783</A></B>
BUG #: 16012 (WINDOWS: 6.50)
<P>
<P><h2>SYMPTOMS</h2>
 
<P>
Concurrent CREATE TABLE and ALTER TABLE statements can cause deadlocks on
system tables. If the process running CREATE TABLE is chosen as the
deadlock victim, it is possible to see stranded tables with sysstat=195 in
sysobjects. If you try to drop the table, it will fail with the following
message:
<P>
<PRE>   Msg 3701, Level 11, State 1, Server bp71092, Line 1
   Cannot drop the table '%s', because it doesn't exist in the system
   catalogs.

</PRE>A 'create table' also fails, with the message:
<P>
<PRE>   Msg 2714, Level 16, State 1, Server bp71092, Line 1 There is already an
   object named '%' in the database.


</PRE> 
FIX: Error 15224 Renaming Column to 1 Character with Sp_rename
 
<P>
ARTICLE-ID: <B><A href="../sqlserver/q159816.htm">Q159816</A></B>
BUG #: 15750 (6.50: 0213)
<P>
<P><h2>SYMPTOMS</h2>
 
<P>
You receive the following parameter error when you attempt to use sp_rename
to rename a column to a single character:
<P>
<PRE>   Msg 15224, Level 11, State 15
   Error, the value for parameter NewName contains invalid characters or
</PRE>violates a basic restriction ().
<P>
 
FIX: ANSI SQL JOIN May Fail With AV Joining VIEW With Table
 
<P>
ARTICLE-ID:<B><A href="../sqlserver/q159847.htm">Q159847</A></B>
BUG #: 16066 (WINDOWS: 6.5)
<P>
<P><h2>SYMPTOMS</h2>
 
<P>
A SELECT statement may fail with an access violation (AV) if you use the
new ANSI style SQL JOIN when joining a VIEW and a table. This problem will
occur if either of the following are true:

<UL><LI>The VIEW contains expressions in its SELECT statement
<P>
   -or-

<LI>The VIEW contains the old style of JOIN operators.
<P>
</UL><h2>WORKAROUND</h2>
 
<P>
To work around this problem, avoid using the old style of join operators in
VIEWs if you are joining these VIEWs with new style ANSI SQL JOINs.
<P>
 
FIX: ALTER TABLE ADD PK May Take a Long Time Even With No Data
 
<P>
ARTICLE-ID: <B><A href="../sqlserver/q159848.htm">Q159848</A></B>
BUG #: 15900 (WINDOWS: 6.5)
<P>
<P><h2>SYMPTOMS</h2>
 
<P>
If there are thousands of tables with hundreds of columns each, the ALTER
TABLE ADD PK command may take a long time, even if there is no data in the
table.
<P>
<P><h2>MORE INFORMATION</h2>
 
<P>
ALTER TABLE ADD PK searches syscolumns several times and scans the tables.
With thousands of wide tables, it may take a full minute to add a PK to an
empty table.
<P>
 
FIX: Names May Collide with Creation of Temp Stored Procedures
 
<P>
ARTICLE-ID: <B><A href="../sqlserver/q159849.htm">Q159849</A></B>
BUG #: 15924 (WINDOWS: 6.5)
<P>
<P><h2>SYMPTOMS</h2>
 
<P>
If an Open Database Connectivity (ODBC) driver creates stored procedures
within a very short time of one another, the names of the stored procedures
may collide.
<P>
<P><h2>MORE INFORMATION</h2>
 
<P>
ODBC uses timestamp values in the naming convention of temporary stored
procedures. It is possible for a very quick thread (or multiple threads) to
use the same timestamp, and create additional stored procedures with the
same name. The server would then not be able to resolve which of the stored
procedures to run.
<P>
<P>
 
FIX: AV Creating View With ANSI JOINS
 
<P>
ARTICLE-ID: <B><A href="../sqlserver/q159937.htm">Q159937</A></B>
BUG #: 15781 (Windows: 6.50 SP1)
<P>
<P><h2>SYMPTOMS</h2>
 
<P>
When you create views containing ANSI standard joins, the DB-Library
process may fail, and break the connection. A handled access violation (AV)
is generated in the error log. This problem is most commonly seen with
nested ANSI joins, where the inner join is a CROSS JOIN.
<P>
<P><h2>WORKAROUND</h2>
 
<P>
To work around this problem, do not use ANSI-Standard joins.
<P>
<P>
 
FIX: Cross-Database INSERTS May Fail with Error 229
 
<P>
ARTICLE-ID: <B><A href="../sqlserver/q160541.htm">Q160541</A></B>
BUG #: 16276
<P>
<P><h2>SYMPTOMS</h2>
 
<P>
A stored procedure run by a user who has full execute permissions and who
is a valid user in two databases may fail with the following error on a
cross-database INSERT:
<P>
<PRE>   229 %s permission denied on object %.*s, database %.*s, owner %.*s

</PRE>This problem occurs even if the owner of the underlying table is also the
owner of the stored procedure. This problem occurs if the stored procedure
needs to be re-resolved, such as in the following cases: loading from
backup, dropping and recreating an underlying table, or shutting down and
restarting SQL Server (if the stored procedure references a temporary
table). If the stored procedure is dropped and re-created, it works
properly until one of the re-resolutions mentioned above occurs.
<P>
<P><h2>WORKAROUND</h2>
 
<P>
To work around this problem, do either of the following:

<UL><LI>Take the temporary table creation out of the stored procedure; create
   the temporary table before calling the stored procedure.
<P>
   -or-

<LI>Drop and re-create the affected stored procedure after a re-resolution
   event has occurred.
<P>
<P>
</UL> 
FIX: Msg. 116 Doing Correlated Updates in a Stored Procedure
 
<P>
ARTICLE-ID: <B><A href="../sqlserver/q161223.htm">Q161223</A></B>
BUG #: 15911
<P>
<P><h2>SYMPTOMS</h2>
 
<P>
Running a stored procedure that does a correlated UPDATE with trace flag
204 enabled may cause the following error:
<P>
<PRE>   Msg 116
   Only one expression can be specified in the select list when the
   subquery is not introduced with EXISTS.

</PRE>The error only seems to occur consistently when running the procedure with
trace flag 204 after the server is recycled (subsequent to creating the
procedure).
<P>
The correlated UPDATE could be similar to the following:
<P>
<PRE>   INSERT table1
   SELECT distinct x
   FROM table2
      UPDATE table1
      SET y = (SELECT SUM(z)
         FROM table2
         WHERE
   table1.x = table2.x
         )

</PRE><h2>WORKAROUND</h2>
 
<P>
To work around this problem, either disable the 204 trace flag, or drop and
re-create the stored procedure after each server restart.
<P>
<P>
 
FIX: SQLTrace May Cause Error 17803 on a Server
 
<P>
ARTICLE-ID: <B><A href="../sqlserver/q162033.htm">Q162033</A></B>
BUG #: 16226 (NT: 6.50)
<P>
<P><h2>SYMPTOMS</h2>
 
<P>
SQL Server may generate the following error if you use SQLTrace and the
application passes float parameters through Remote Procedure Calls (RPCs).
<P>
<PRE>    Msg 17803: Insufficient memory available.

</PRE>This error may also be accompanied by other problems, including a
previously active filter returning to a stopped state, or the inability to
start new filters. Once in this state, it may be impossible to terminate
the SQLTrace application.
<P>
<P><h2>WORKAROUND</h2>
 
<P>
To work around this problem, deselect the option of tracing RPC events in
the SQLTrace filter.
<P>
<P>
 
FIX: Using a WHERE IN Clause on a Selected UNION May Fail
 
<P>
ARTICLE-ID: <B><A href="../sqlserver/q162366.htm">Q162366</A></B>
BUG #: 16400 (SQL6.5)
<P>
<P><h2>SYMPTOMS</h2>
 
<P>
SELECT statements consisting of a UNION and a WHERE IN clause may fail.
<P>
For example, the following statement
<P>
<PRE>   SELECT type, name
      FROM (SELECT * FROM master..sysobjects
                UNION
                SELECT * FROM pubs..sysobjects) as O
      WHERE type IN ('S', 'U')

</PRE>Produces (in part) the following results:
<P>
<PRE>  type name
  ---- ------------------------------
  U    authors
  P    byroyalty
  C    CK__authors__au_id__02DC7882
  C    CK__authors__zip__04C4C0F4
  C    CK__jobs__max_lvl__2719D8F8
  C    CK__jobs__min_lvl__2625B4BF
  C    CK__publisher__pub_i__089551D8
  C    CK_emp_id

</PRE><h2>WORKAROUND</h2>
 
<P>
Embed SELECT statements into the WHERE IN clause, as shown by the
following:
<P>
<PRE>   SELECT type, name
      FROM (SELECT * FROM master..sysobjects
         UNION
         SELECT * FROM pubs..sysobjects) as O
      WHERE type IN (SELECT 'S' UNION SELECT 'U')


</PRE> 
FIX: Err 511: Stored Proc w/ANSI_NULL_DFLT_ON Creates Temp Tbl
 
<P>
ARTICLE-ID: <B><A href="../sqlserver/q167606.htm">Q167606</A></B>
BUG #: 16814 (NT: 6.5)
<P>
<P><h2>SYMPTOMS</h2>
 
<P>
A stored procedure that creates a temporary table without explicitly
specifying column nullability and INSERTS into that table will fail with
an error 511 if the procedure was created with ANSI_NULL_DFLT_ON set on,
and is run with ANSI_NULL_DFLT_ON set off. This problem occurs if you do
all of the following:

<OL><P><LI>Run the procedure.

<P><LI>Perform sp_recompile on an underlying permanent table referenced in the
   procedure.

<P><LI>Run the procedure again.
<P>
</OL>The error 511 occurs on the second execution after the recompile. All ODBC
connections set ANSI_DEFAULTS on, which in turn sets ANSI_NULL_DFLT_ON on.
Therefore, any procedure created over ODBC is susceptible to this problem.
<P>
<P><h2>WORKAROUND</h2>
 
<P>
To work around this problem, do either of the following:

<UL><LI>Explicitly specify columns as NULL, or NOT NULL during the table
   definition in the stored procedure.
<P>
   -or-

<LI>Specify the ANSI_NULL_DFLT_ON setting for clients before running the
   stored procedure.
<P>
<P>
</UL> 
FIX: Switching Order of Tables in FROM Clause Changes Optimizer
 
<P>
ARTICLE-ID: <B><A href="../sqlserver/q171879.htm">Q171879</A></B>
BUG #: 15522 (Windows: 6.5)
<P>
<P><h2>SYMPTOMS</h2>
 
<P>
Switching the order of tables in the FROM clause for some join queries may
result in a non-optimal execution of the query plan. In one scenario for a
two-table join, significant difference in the execution times was noted
between two identical queries that had the same WHERE clause, but had the
order of tables in the FROM clause switched.
<P>
<P><h2>WORKAROUND</h2>
 
<P>
For the Optimizer to use the optimal join order, compare the execution
times and plans for the query and place the tables that result in better
execution times in the FROM clause.
<P>

	</FONT>
	</TD>
	</TR>
</TABLE>
<P>


<!--DOCBODY_END-->

<!--FOOTER_START-->
<table cellpadding=5 border=0 width="90%">
<tr>
<td>
	<HR WIDTH="90%">

<BLOCKQUOTE>
<FONT FACE="Verdana, Arial, Helvetica" SIZE="1">
<SPAN STYLE="font-family:verdana,arial,helvetica; font-size:8pt">
Additional query words: SP2 database patch sp<BR>
Keywords          : SSrvGen kbfixlist6.50.sp2<BR>
Version           : 6.5 SP2<BR>
Platform          : WINDOWS<BR>
Issue type        : kbref<BR>

</SPAN>
</FONT>
<BR>
<BR>
THE INFORMATION PROVIDED IN THE MICROSOFT KNOWLEDGE BASE IS
PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND.  MICROSOFT DISCLAIMS
ALL WARRANTIES, EITHER EXPRESS OR IMPLIED, INCLUDING THE WARRANTIES
OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  IN NO
EVENT SHALL MICROSOFT CORPORATION OR ITS SUPPLIERS BE LIABLE FOR
ANY DAMAGES WHATSOEVER INCLUDING DIRECT, INDIRECT, INCIDENTAL,
CONSEQUENTIAL, LOSS OF BUSINESS PROFITS OR SPECIAL DAMAGES, EVEN IF
MICROSOFT CORPORATION OR ITS SUPPLIERS HAVE BEEN ADVISED OF THE
POSSIBILITY OF SUCH DAMAGES.  SOME STATES DO NOT ALLOW THE EXCLUSION
OR LIMITATION OF LIABILITY FOR CONSEQUENTIAL OR INCIDENTAL DAMAGES
SO THE FOREGOING LIMITATION MAY NOT APPLY.
</BLOCKQUOTE>
<P>
<center>
	<FONT FACE="Verdana,Arial,Helvetica" SIZE="1">
	Last reviewed:  November 7, 1997</FONT>
	<BR>
	<A href="../cpyright.htm" STYLE="font: bold 7pt Verdana,Arial,Helvetica">&copy; 1998 Microsoft Corporation. All rights reserved. Terms of Use.</A><BR>
	
</center>
</td>
</tr>
</table>

<!--FOOTER_END-->
</FONT>
</BODY>
</HTML>
