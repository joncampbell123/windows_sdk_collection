

<HTML>
<HEAD>
<TITLE>INF: Iterating Through a Results Set Using Transact-SQL </TITLE>

<!--STYLE_BEGIN-->
<style>@import url(../../msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="../../msdn_ie3.css">
<!--STYLE_END-->

<META HTTP-EQUIV="CONTENT-Type" CONTENT="text/html; charset=us-ascii">
<META NAME="ms.locale" CONTENT="EN-US">
<META NAME="Category" CONTENT="Support; KB Article">
<META NAME="KBID" CONTENT="Q111401">
<META NAME="KBModify" CONTENT="1997/04/29">
<META NAME="KBCreate" CONTENT="1994/02/10">
<META NAME="Keywords" CONTENT="kbtool SSrvTran_SQL SSrvWinNT">
<META NAME="KBArea" CONTENT="Support; KB; sqlserver">
<META NAME="Description" CONTENT="  It is often desirable to simulate a cursor-like FETCH-NEXT logic in a stored procedure, trigger, or Transact-SQL batch. For instance, it might be necessary to process all the rows in a table sequentially in order to avoid filling up the transaction...">
<META NAME="Product" CONTENT="SQL Server">
<META NAME="Platform" CONTENT="Windows">
<META NAME="Technology" CONTENT=" ">
<META NAME="Premium" CONTENT="support">

<META NAME="nyms" CONTENT="QBXS,QABM,QA2Q,QAN0,QAY2,QAG2,QAPN,QBWS,QA5V,QAPF,QAXB,QAI4,QBCF,QBSO,QANY V02180118">
</HEAD>

<BODY BGCOLOR="#FFFFFF" LEFTMARGIN="0" RIGHTMARGIN="0" TOPMARGIN="0">


<!--DOCBODY_START-->
<BR>
<CENTER>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" VALIGN="top" WIDTH="90%">
	<TR>
		<TD VALIGN="top">
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<H1>INF: Iterating Through a Results Set Using Transact-SQL</H1>
			</FONT>
			<FONT FACE="verdana,arial,helvetica" SIZE="1">
			Last reviewed:  April 29, 1997</FONT><BR>
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<B>Article ID: Q111401</B>
			</FONT>
		</TD>
	</TR>
	<TR>
	<TD>
	<FONT FACE="Verdana, Arial, Helvetica" SIZE=2>



<P><h3> </h3>
 
The information in this article applies to:
<P>
<PRE>  - Microsoft SQL Server version 4.2 for OS/2
  - Microsoft SQL Server version 4.2
</PRE> 
<P>
<P><h2>SUMMARY</h2>
 
<P>
It is often desirable to simulate a cursor-like FETCH-NEXT logic in a
stored procedure, trigger, or Transact-SQL batch. For instance, it might be
necessary to process all the rows in a table sequentially in order to avoid
filling up the transaction log. This article will discuss various methods
for accomplishing this task.
<P>
<P><h2>MORE INFORMATION</h2>
 
<P>
SQL Server 4.2x does not implement server side cursoring. However, it
is possible to iterate through a results set using Transact-SQL
statements.
<P>
One method is by using temp tables. This creates a "snapshot" of the
initial select and uses that as a basis for the "cursoring." The following
example illustrates how to do this:
<P>
<PRE>/********** example 1 **********/

</PRE>declare @au_id char( 11 )
<P>
set rowcount 0
select * into #mytemp from authors
<P>
set rowcount 1
<P>
select @au_id = au_id from #mytemp
<P>
while @@rowcount != 0
begin
<PRE>    set rowcount 0

    select * from #mytemp where au_id = @au_id
    delete #mytemp where au_id = @au_id

    set rowcount 1
    select @au_id = au_id from #mytemp
</PRE>end
set rowcount 0
<P>
A second method is by using the min() function to "walk" a table one row at
a time. This method would catch new rows that had been added after the
stored procedure began execution, provided that the new row had a unique
identifier greater than the current row being processed in the query.
<P>
<PRE>/********** example 2 **********/

</PRE>declare @au_id char( 11 )
<P>
select @au_id = min( au_id ) from authors
<P>
while @au_id is not null
begin
<PRE>    select * from authors where au_id = @au_id
    select @au_id = min( au_id ) from authors where au_id &gt; @au_id
</PRE>end
<P>
NOTE: Examples 1 and 2 both assume that a unique identifier exists for each
row in the source table. In some cases, no unique identifier may exist. If
this is the case, the temp table method may be modified to use a newly
created key column. Example 3 illustrates this method.
<P>
<PRE>/********** example 3 **********/

</PRE>set rowcount 0
select NULL mykey, * into #mytemp from authors
<P>
set rowcount 1
update #mytemp set mykey = 1
<P>
while @@rowcount &gt; 0
begin
<PRE>    set rowcount 0
    select * from #mytemp where mykey = 1
    delete #mytemp where mykey = 1
    set rowcount 1
    update #mytemp set mykey = 1
</PRE>end
set rowcount 0
<P>

	</FONT>
	</TD>
	</TR>
</TABLE>
<P>


<!--DOCBODY_END-->

<!--FOOTER_START-->
<table cellpadding=5 border=0 width="90%">
<tr>
<td>
	<HR WIDTH="90%">

<BLOCKQUOTE>
<FONT FACE="Verdana, Arial, Helvetica" SIZE="1">
<SPAN STYLE="font-family:verdana,arial,helvetica; font-size:8pt">
Additional query words: Windows NT<BR>
Keywords            : kbtool SSrvTran_SQL SSrvWinNT<BR>
Version             : 4.2 | 4.2<BR>
Platform            : OS/2 WINDOWS<BR>

</SPAN>
</FONT>
<BR>
<BR>
THE INFORMATION PROVIDED IN THE MICROSOFT KNOWLEDGE BASE IS
PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND.  MICROSOFT DISCLAIMS
ALL WARRANTIES, EITHER EXPRESS OR IMPLIED, INCLUDING THE WARRANTIES
OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  IN NO
EVENT SHALL MICROSOFT CORPORATION OR ITS SUPPLIERS BE LIABLE FOR
ANY DAMAGES WHATSOEVER INCLUDING DIRECT, INDIRECT, INCIDENTAL,
CONSEQUENTIAL, LOSS OF BUSINESS PROFITS OR SPECIAL DAMAGES, EVEN IF
MICROSOFT CORPORATION OR ITS SUPPLIERS HAVE BEEN ADVISED OF THE
POSSIBILITY OF SUCH DAMAGES.  SOME STATES DO NOT ALLOW THE EXCLUSION
OR LIMITATION OF LIABILITY FOR CONSEQUENTIAL OR INCIDENTAL DAMAGES
SO THE FOREGOING LIMITATION MAY NOT APPLY.
</BLOCKQUOTE>
<P>
<center>
	<FONT FACE="Verdana,Arial,Helvetica" SIZE="1">
	Last reviewed:  April 29, 1997</FONT>
	<BR>
	<A href="../cpyright.htm" STYLE="font: bold 7pt Verdana,Arial,Helvetica">&copy; 1998 Microsoft Corporation. All rights reserved. Terms of Use.</A><BR>
	
</center>
</td>
</tr>
</table>

<!--FOOTER_END-->
</FONT>
</BODY>
</HTML>
