

<HTML>
<HEAD>
<TITLE>FIX: SQL Server 6.5 Service Pack 1 Fixlist </TITLE>

<!--STYLE_BEGIN-->
<style>@import url(../../msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="../../msdn_ie3.css">
<!--STYLE_END-->

<META HTTP-EQUIV="CONTENT-Type" CONTENT="text/html; charset=us-ascii">
<META NAME="ms.locale" CONTENT="EN-US">
<META NAME="Category" CONTENT="Support; KB Article">
<META NAME="KBID" CONTENT="Q153096">
<META NAME="KBModify" CONTENT="1998/03/18">
<META NAME="KBCreate" CONTENT="1996/07/26">
<META NAME="Keywords" CONTENT="SSrvGen kbfixlist kbfixlist6.50.sp1">
<META NAME="KBArea" CONTENT="Support; KB; sqlserver">
<META NAME="Description" CONTENT=" The following is a list of fixes and other various improvements that have been made in the Microsoft SQL Server version 6.5 Service Pack 1. Service Pack 1 is now available from your primary support provider. For more information, contact your primar...">
<META NAME="Product" CONTENT="SQL Server">
<META NAME="Platform" CONTENT="Windows">
<META NAME="Technology" CONTENT=" ">
<META NAME="Security" CONTENT="PUBLIC ">
<META NAME="Premium" CONTENT="support">

<META NAME="nyms" CONTENT="QAR4,QAB4,QAAP,QABM,QAM1,QDIX,QAKP,QA2Q,QAPN,QAB9,QBVV,QBWS,QAY2,QAG2,QAXB V02180118">
</HEAD>

<BODY BGCOLOR="#FFFFFF" LEFTMARGIN="0" RIGHTMARGIN="0" TOPMARGIN="0">


<!--DOCBODY_START-->
<BR>
<CENTER>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" VALIGN="top" WIDTH="90%">
	<TR>
		<TD VALIGN="top">
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<H1>FIX: SQL Server 6.5 Service Pack 1 Fixlist</H1>
			</FONT>
			<FONT FACE="verdana,arial,helvetica" SIZE="1">
			Last reviewed:  March 18, 1998</FONT><BR>
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<B>Article ID: Q153096</B>
			</FONT>
		</TD>
	</TR>
	<TR>
	<TD>
	<FONT FACE="Verdana, Arial, Helvetica" SIZE=2>



 
 
The information in this article applies to:

<UL><LI>Microsoft SQL Server, version 6.5 Service Pack 1
</UL> 
<P>
The following is a list of fixes and other various improvements that have
been made in the Microsoft SQL Server version 6.5 Service Pack 1. Service
Pack 1 is now available from your primary support provider. For more
information, contact your primary support provider.
<P>
Please note that workarounds described have been provided for your
information only. It is not necessary to implement these workarounds if
you have the updated software.
<P>
 
<P><h2>LIST OF PROBLEMS CORRECTED IN SERVICE PACK 1</h2>
 
<P>
<P><h3>DB-LIBRARY COMPONENTS</h3>
 
<P>
<B><A href="../sqlserver/q151301.htm">Q151301</A></B>: FIX: dbcursorfetchex() Can Cause Blocking in DB-Library
<P>
<P><h3>ODBC COMPONENTS</h3>
 
<P>
<B><A href="../odbc/q153694.htm">Q153694</A></B>: FIX: SQLNumResultCols Fails with Incorrect Syntax Near 'SET'
<B><A href="../odbc/q153908.htm">Q153908</A></B>: FIX: 16-bit Driver Times Out on Async Calls to SQLTables
<P>
<P><h3>SERVER COMPONENTS</h3>
 
<P>
<B><A href="../sqlserver/q149938.htm">Q149938</A></B>: FIX: AV on INSERT of UNIONed SELECTs to Table With DEFAULTs
<B><A href="../sqlserver/q149939.htm">Q149939</A></B>: FIX: ROLLBACK of TRUNCATE TABLE May Cause Error 3301, AV
<B><A href="../sqlserver/q150775.htm">Q150775</A></B>: FIX: CREATE TABLE in Stored Procedure May Fail With Error 1750
<B><A href="../sqlserver/q150894.htm">Q150894</A></B>: FIX: LOAD TRAN May Fail With Handled AV
<B><A href="../sqlserver/q150896.htm">Q150896</A></B>: FIX: SH_PAGE Locks May Be Held on Inner Tables of JOINs
<B><A href="../sqlserver/q150897.htm">Q150897</A></B>: FIX: LOAD TRAN May Fail With Error 1511
<B><A href="../sqlserver/q150900.htm">Q150900</A></B>: FIX: UPDATE May Fail With Error 107
<B><A href="../sqlserver/q151111.htm">Q151111</A></B>: FIX: DECLARE CURSOR on Temp Table with FOR UPDATE Causes AV
<B><A href="../sqlserver/q151590.htm">Q151590</A></B>: FIX: Error 4409 Generated When Using Multiple Database Views
<B><A href="../sqlserver/q151591.htm">Q151591</A></B>: FIX: DBCC Checkident Always Reports the Seed Value as Current
<B><A href="../sqlserver/q151693.htm">Q151693</A></B>: FIX: Err Msg "Unknown Token Received from SQL Server"
<B><A href="../sqlserver/q151765.htm">Q151765</A></B>: FIX: SELECT INTO Inside a Temp Procedure Causes Client to Hang
<B><A href="../sqlserver/q151985.htm">Q151985</A></B>: FIX: SELECTs from SYSPROCESSES Result in Access Violation
<B><A href="../sqlserver/q151988.htm">Q151988</A></B>: FIX: 1108 Errors with Heavy Tempdb Activity
<B><A href="../sqlserver/q152353.htm">Q152353</A></B>: FIX: Select with CASE Statement Inside View Can Cause Client AV
<B><A href="../sqlserver/q152416.htm">Q152416</A></B>: FIX: sp_processmail Will Only Process One Query per Execution
<B><A href="../sqlserver/q152615.htm">Q152615</A></B>: FIX: Syntax Error in SELECT List May Cause Handled AV
<B><A href="../sqlserver/q152690.htm">Q152690</A></B>: FIX: Count(*) May Not Return Result Set
<B><A href="../sqlserver/q152709.htm">Q152709</A></B>: FIX: Update of BLOB Data w/SQL Server 2.65.0201 Driver Stops
<B><A href="../sqlserver/q152800.htm">Q152800</A></B>: FIX: GROUP BY Clause without Index Executes More Slowly
<B><A href="../sqlserver/q153006.htm">Q153006</A></B>: FIX: Dump or Load w/Tape Devices Results in Errors, AVs
<B><A href="../sqlserver/q153079.htm">Q153079</A></B>: FIX: SQL Server Stops w/ Temporary Procedure in a Transaction
<B><A href="../sqlserver/q153186.htm">Q153186</A></B>: FIX: Filtered Stored Procedures Cannot Reference Multiple Tables
<B><A href="../sqlserver/q153455.htm">Q153455</A></B>: FIX: Multiple "LEFT OUTER JOIN" in FROM Clause May Cause Error
<B><A href="../sqlserver/q153780.htm">Q153780</A></B>: FIX: sp_droppublisher Does Not Clear 'pub' Server Option
<B><A href="../sqlserver/q153802.htm">Q153802</A></B>: FIX: Deadlock During Cursor Update Causes CPU Spin and Spinloop
<B><A href="../sqlserver/q153803.htm">Q153803</A></B>: FIX: GRANT ALL Fails to Give Permissions on Stored Procedures
<B><A href="../sqlserver/q153836.htm">Q153836</A></B>: FIX: SQLGetData Fails on Multiple Active Statement Handles
<B><A href="../sqlserver/q153851.htm">Q153851</A></B>: FIX: AV if 4 or More Correlated Subqueries with Self-Join
<B><A href="../sqlserver/q153855.htm">Q153855</A></B>: FIX: IRL can cause 3307, OS error 6, unhandled server level AV
<B><A href="../sqlserver/q153954.htm">Q153954</A></B>: FIX: Checkpoint Process Deadlock Results in Errors 603, 3314
<B><A href="../sqlserver/q153961.htm">Q153961</A></B>: FIX: Full Memory and Cursors Cause AVs, 707, 706, and Spins
<B><A href="../sqlserver/q153987.htm">Q153987</A></B>: FIX: AV Error Using Temp Table and Cursor in Stored Procedure
<B><A href="../sqlserver/q153992.htm">Q153992</A></B>: FIX: Cannot Rename a Column with a Quoted Identifier
<B><A href="../sqlserver/q154018.htm">Q154018</A></B>: FIX: AV in Update Mode When Script Is Run Twice
<B><A href="../sqlserver/q154047.htm">Q154047</A></B>: FIX: SQL Terminates on Delete Table with 15 Self-References
<P>
 
<P><h3>FIX: dbcursorfetchex() Can Cause Blocking in DB-Library</h3>
 
<P>
ARTICLE-ID: <B><A href="../sqlserver/q151301.htm">Q151301</A></B>
BUG #: NT 15039 (6.50)
<P>
<P><h2>SYMPTOMS</h2>
 
<P>
If a DB-library application calls dbcursorfetch() or dbcursorfetchex()
successfully in one thread, subsequent calls to dbcursoropen() or dbclose()
from other threads using the same DBPROCESS would be blocked. Sp_who and
sp_lock show no blockage on the server side, and the DB-library application
would appear to hang.
<P>
<P><h2>WORKAROUND</h2>
 
<P>
Use a separate DBPROCESS for each thread.
<P>
<P>
 
<P><h3>FIX: SQLNumResultCols Fails with Incorrect Syntax Near 'SET'</h3>
 
<P>
ARTICLE-ID: <B><A href="../odbc/q153694.htm">Q153694</A></B>
BUG #: NT: 15314 (6.50)
<P>
<P><h2>SYMPTOMS</h2>
 
<P>
Calling SQLNumResultCols after SQLPrepare of a SELECT statement that
contains a subquery in the select list will fail with:
<P>
<PRE>   szSqlState = "37000", pfNativeError = 156
   szErrorMsg="[Microsoft][ODBC SQL Server Driver][SQL Server]
               Incorrect syntax near the keyword 'SET'."

</PRE>MORE INFORMATION
 
<P>
When the SQL Server ODBC driver constructs the T-SQL statement that will be
sent to the server to resolve the number of columns that will be returned
in the resultset, it incorrectly parses the initial query and excludes the
final table name. For example:
<P>
<PRE>   SQLPrepare(hstmt, "SELECT t1.c1, (SELECT t2.c1 FROM t2)
                      FROM t1", 44)
   SQLNumResultCols(hstmt, pcol1)

</PRE>This results in the following statement being sent to the server on the
call to SQLNumResultCols:
<P>
<PRE>   SET FMTONLY ON SELECT t1.c1, (SELECT t2.c1 FROM t2)
   FROM SET FMTONLY OFF

</PRE>Hence, causing SQL Server to report "Incorrect syntax near the Keyword
<PRE>'SET'."

</PRE><h2>WORKAROUND</h2>
 
<P>
Where possible convert the offending query to a SQL Server VIEW.
<P>
 
<P><h3>FIX: 16-bit Driver Times Out on Async Calls to SQLTables</h3>
 
<P>
ARTICLE-ID: <B><A href="../odbc/q153908.htm">Q153908</A></B>
BUG #: NT: 15563 (2.65.0201)
<P>
<P><h2>SYMPTOMS</h2>
 
<P>
When a 16-bit ODBC application calls SQLTables() using the Microsoft SQL
Server ODBC Driver version 2.65.0201 set in asynchronous mode, a "Timeout
expired" error message appears immediately after the second async retry.
<P>
This problem occurs with any network library configuration and Windows NT
local pipes. The Timeout error message also appears regardless of other
login or query timeouts you configure on the client computer.
<P>
<P><h2>WORKAROUND</h2>
 
<P>
To work around this problem, do not call the ODBC driver in asynchronous
mode. This can be done with different applications and they apply as
follows:

<UL><LI>For ODBC programs written directly to the ODBC API, call
   SQLSetStmtOption() with SQL_ASYNC_ENABLE (set to SQL_ASYNC_ENABLE_OFF).

<LI>For Visual Basic 3.0 and Access 2.0 applications, set DisableAsync to 1
   in the [ODBC] section of in the Vb.ini, App.ini or Msacc20.ini
   respectively.

<LI>For Visual Basic 4.0, set the INIPATH property of DBENGINE to point to
   Vb.ini or App.ini that has DisableAsync set to 1.
<P>
</UL>For MSACC20.INI entry settings applicable to Access 95, please see the
following article in the Microsoft Knowledge Base:
<P>
<PRE>   ARTICLE-ID: <B><A href="../access/q139044.htm">Q139044</A></B>
   TITLE     : INF: How to Add Former MSACC20.INI ODBC Section to Registry

</PRE>Jet 3.x (a base component of Access 95 and Visual Basic 4.0) registry
information is on Appendix C of the Microsoft Jet Database Engine
Programmer’s Guide. You can obtain Jet 2.x database engine information from
the Microsoft Developer Network Library Level 1 by querying the following:
<P>
<PRE>   jet database engine connectivity neil black

</PRE>You can also reference the Technical Backgrounder called "Jet Database
Engine ODBC Connectivity."
<P>
<P><h2>MORE INFORMATION</h2>
 
<P>
Microsoft client/server database applications, such as Access 2.0, Visual
Basic 3.0 and Visual Basic 4.0 (16-bit), are designed on top of the Jet
Database engine. Therefore, they attempt to make calls to SQLTables()
during several ODBC operations, which include attaching to a SQL Server 6.5
table. These applications utilize ODBC in asynchronous mode, by default.
Unless the default asynchronous behavior is turned off, the "Timeout
Expired" error message will occur with the driver version 2.65.0201.
<P>
NOTE: Microsoft Excel and Microsoft Query are not designed on top of the
Jet Database engine, thus the problem does not occur.
<P>
For more information about the Jet Database Engine, please refer to the
Microsoft Jet Database Engine Programmer's Guide published by Microsoft
Press. The ISBN number is 1-55615-877-7. You can order guide by
calling (800) MSP-RESS.
<P>
 
<P><h3>FIX: AV on INSERT of UNIONed SELECTs to Table With DEFAULTs</h3>
 
<P>
ARTICLE-ID: <B><A href="../sqlserver/q149938.htm">Q149938</A></B>
BUG #: NT: 14833 (6.00 and 6.50)
<P>
<P><h2>SYMPTOMS</h2>
 
<P>
INSERTing to a table from a UNION of two or more SELECT statements can
result in a handled Access Violation.
<P>
MORE INFORMATION
 
<P>
At a certain threshold of data, a work table needs to be created to resolve
the UNION correctly. If the target table has DEFAULTs, these are not
applied to intermediate work tables but other attributes of the target
table, such as NOT NULL, are applied, and this would cause the query to
fail with a different error if there was not the AV.
<P>
<P><h2>WORKAROUND</h2>
 
<P>
Implement the INSERT as distinct INSERT SELECTs for each table in the
UNION. If there is a UNIQUE INDEX on the target table, use the
IGNORE_DUP_KEY option on that INDEX to filter out duplicate rows that would
previously have been filtered out by the UNION. In many cases, this method
can be much faster anyway because it can eliminate one or more intermedate
work tables.
<P>
 
<P><h3>FIX: ROLLBACK of TRUNCATE TABLE May Cause Error 3301, AV</h3>
 
<P>
ARTICLE-ID: <B><A href="../sqlserver/q149939.htm">Q149939</A></B>
BUG #: NT: 14849 (6.50)
<P>
<P><h2>SYMPTOMS</h2>
 
<P>
A TRUNCATE TABLE command that is aborted or rolled back may get a 3301
error "Invalid log record found in Syslogs (logop 42)" and an access
violation.
<P>
If the truncated table has an IDENTITY column and the TRUNCATE aborts, or
is inside a user transaction which later does a ROLLBACK, this problem can
occur.
<P>
<P><h2>WORKAROUND</h2>
 
<P>
If the purpose of the TRUNCATE TABLE is just to remove all the rows, use
DELETE with no WHERE clause. If the purpose is also to reset the IDENTITY
value, use DELETE with no WHERE clause then TRUNCATE TABLE, and make sure
there is no user defined transaction at the time of the TRUNCATE TABLE via
logic such as
<P>
delete t1
while @@trancount &gt; 0
begin
<PRE>   commit tran
</PRE>end
truncate table t1
<P>
 
<P><h3>FIX: CREATE TABLE in Stored Procedure May Fail With Error 1750</h3>
 
<P>
ARTICLE-ID: <B><A href="../sqlserver/q150775.htm">Q150775</A></B>
BUG #: NT: 14884 (6.50)
<P>
<P><h2>SYMPTOMS</h2>
 
<P>
EXECuting a stored procedure that creates a temp or permanent table with
defaults may fail with the error:
<P>
<PRE>   [INTERNAL ERROR] unable to locate original param in voidptr list.
   Msg 1750, Level 16, State 0
   Unable to create constraint. See previous errors.

</PRE>MORE INFORMATION
 
<P>
If there is some activity in the stored procedure before the CREATE TABLE,
this error can occur. In the simplest case, executing the following stored
procedure will fail:
<P>
create proc sp_test1 as
begin
IF ( @@error &lt;&gt; 0 )
BEGIN
<PRE>   GOTO cleanup
</PRE>END
<PRE>CREATE TABLE   #t1 (c1         int NOT NULL DEFAULT -1)
</PRE>cleanup:
end
go
declare @rc int
EXEC @rc = sp_test1
SELECT @rc
go
<P>
<P><h2>WORKAROUND</h2>
 
<P>
Use some other method than a CONSTRAINT, such as ISNULL, to get the default
values you want into the table.
<P>
 
<P><h3>FIX: LOAD TRAN May Fail With Handled AV</h3>
 
<P>
ARTICLE-ID: <B><A href="../sqlserver/q150894.htm">Q150894</A></B>
BUG #: 14952 (6.50)
<P>
<P><h2>SYMPTOMS</h2>
 
<P>
LOAD TRANSACTION may fail with the errors:
<P>
<PRE>  udwritem: Operating system error 6(The handle is invalid.) on device ....
  ex_testhandle: stack overflow, top=0x17a7f10, end=0x17a7f10
  EXCEPTION_ACCESS_VIOLATION

</PRE>The actual stack of the AV in this case can be many different places. The
SQL Server may now become unresponsive and have to be restarted. The
database being loaded will have to be recreated.
<P>
<P><h2>WORKAROUND</h2>
 
<P>
DUMP the database and re-sync the transaction logs.
<P>
 
<P><h3>FIX: SH_PAGE Locks May Be Held on Inner Tables of JOINs</h3>
 
<P>
ARTICLE-ID: <B><A href="../sqlserver/q150896.htm">Q150896</A></B>
BUG #: NT: 15329 (6.50)
<P>
<P><h2>SYMPTOMS</h2>
 
<P>
A join of tables may hold the shared page locks on the inner tables of the
join(s) for the duration of the SELECT.
<P>
MORE INFORMATION
 
<P>
The page locks on the inner table(s) of joins where a unique index matches
the join on the inner table are not released until the end of the SELECT.
On earlier versions, SQL Server would obtain and release the locks one at a
time as the page chain is traversed. The outer table's page locks are not
held. If the tables are large, this can be a significant concurrency
impact. This did not happen in prior versions of SQL Server.
<P>
<P><h2>WORKAROUND</h2>
 
<P>
Use non-unique indexes instead of unique.
<P>
 
<P><h3>FIX: LOAD TRAN May Fail With Error 1511</h3>
 
<P>
ARTICLE-ID: <B><A href="../sqlserver/q150897.htm">Q150897</A></B>
BUG #: NT: 15114 (6.50)
<P>
<P><h2>SYMPTOMS</h2>
 
<P>
If the transaction log being LOADed contains the log records for a CREATE
CLUSTERED INDEX on a large table (&gt; 150 MB), then the transaction may fail
to load with the 1511 error.
<P>
Error : 1511, Severity: 20, State: 8
<PRE>   Sort cannot be reconciled with transaction log

</PRE><h2>WORKAROUND</h2>
 
<P>
DUMP the whole DATABASE after a CREATE CLUSTERED INDEX on a large table.
<P>
 
<P><h3>FIX: UPDATE May Fail With Error 107</h3>
 
<P>
ARTICLE-ID: <B><A href="../sqlserver/q150900.htm">Q150900</A></B>
BUG #: NT: 14984 (6.50)
<P>
<P><h2>SYMPTOMS</h2>
 
<P>
If using the 204 trace flag for backwards compatibility, UPDATEs using
JOINs may fail with an error 107.
<P>
Msg 107, Level 15, State 1
<PRE>   The column prefix 'so' does not match with a table name or alias name
   used in the query

</PRE><h2>WORKAROUND</h2>
 
<P>
Turn off the 204 trace flag or rewrite the JOIN as a subquery.
<P>
 
<P><h3>FIX:DECLARE CURSOR on Temp Table with FOR UPDATE Causes AV</h3>
 
<P>
ARTICLE-ID: <B><A href="../sqlserver/q151111.htm">Q151111</A></B>
BUG #: NT: 15086 (6.00)
<P>
<P><h2>SYMPTOMS</h2>
 
<P>
A DECLARE CURSOR statement that has a FOR UPDATE clause with multiple
columns in the column list can generate a handled access violation if the
table in the SELECT clause is a temporary table.
<P>
<P><h2>WORKAROUND</h2>
 
<P>
Do not use the FOR UPDATE clause for more than one column in case of a
temporary table. Use a permanent table if more than one column is
absolutely necessary in the FOR UPDATE clause.
<P>
 
<P><h3>FIX: Error 4409 Generated When Using Multiple Database Views</h3>
 
<P>
ARTICLE-ID: <B><A href="../sqlserver/q151590.htm">Q151590</A></B>
BUG #: NT: 14645 (6.00)
<P>
<P><h2>SYMPTOMS</h2>
 
<P>
Under certain conditions, you may receive 4409 errors. The problem arises
when the first view in
the chain of views can be executed but subsequent views are unavailable for
use. For example:
<P>
If you have viewA and viewC in the master database and viewB in the pubs
database, where viewA selects * from viewB and viewB selects * from viewC
and viewC selects * from sysdatabases. And, SQL Server has been stopped
while a client continues to try to execute a select * from viewA. When SQL
Server is restarted, the master database is always recovered first and then
the subsequent databases. As soon as master is recovered, the client
attempts to execute the select and receives the 4409 error because pubs has
not yet been recovered.
<P>
The same behavior can occur when you take a database on and offline, or you
try to drop and create viewC in the above scenario while someone is trying
to access it.
<P>
<P><h2>WORKAROUND</h2>
 
<P>
Drop and add the views when you are sure no one is accessing them.
<P>
 
<P><h3>FIX: DBCC Checkident Always Reports the Seed Value as Current</h3>
 
<P>
ARTICLE-ID: <B><A href="../sqlserver/q151591.htm">Q151591</A></B>
BUG #: 14759 (6.50)
<P>
<P><h2>SYMPTOMS</h2>
 
<P>
When running dbcc checkident, the current identity value will always be
reported as the original seed value.
<P>
<PRE>   Checking identity information: current identity value '1', maximum
   column value '14'. DBCC execution completed. If DBCC printed error
   messages, see your System Administrator.

</PRE>The rest of the dbcc completes successfully and if need be the next
identity value is corrected. However, the message will continue to report
the seed value as the current identity value.
<P>
 
<P><h3>FIX: Err Msg "Unknown Token Received from SQL Server"</h3>
 
<P>
ARTICLE-ID: <B><A href="../sqlserver/q151693.htm">Q151693</A></B>
BUG #: NT: 15056 (6.50)
<P>
<P><h2>SYMPTOMS</h2>
 
<P>
When you set the statement options to use a server-side cursor and prepare
a select statement on a SQL Server system table, the first execution of the
select creates the cursor successfully. After you close this cursor, if you
execute the prepared statement again, the following error message appears:
<P>
<PRE>   unknown token received from SQL Server.

</PRE><h2>WORKAROUND</h2>
 
<P>
Use a forward-only cursor instead of a static, keyset, or dynamic cursor on
the system tables. Note that the problem does not occur if a server-side
cursor is created on a user-defined table or view.
<P>
If a forward-only cursor is unacceptable, prepare the select statement
again on the system table and execute it to create a server-side cursor.
Note that the first execution works fine and applications typically do not
need to create a cursor on a system table repeatedly.
<P>
 
FIX: SELECT INTO Inside a Temp Proc Causes Client to Hang
 
<P>
ARTICLE-ID: <B><A href="../sqlserver/q151765.htm">Q151765</A></B>
BUG #: NT: 15113 (6.50)
<P>
<P><h2>SYMPTOMS</h2>
 
<P>
In SQL Server version 6.5, executing a temporary stored procedure
containing a SELECT INTO statement causes the client to stop responding.
The server never finishes the execution and the control is not returned to
the client. CPU utilization on the server computer goes above 95 percent
and persists, with the result that the server slows down drastically. This
does
not prevent other clients from connecting to SQL Server, but the queries
executed
from these clients will be slow.
<P>
<P><h2>WORKAROUND</h2>
 
<P>
Use permanent stored procedure in place of temporary stored procedure. For
ODBC clients, clear the Generate Stored Procedures for Prepared Statements
option check box in the ODBC SQL Server Driver Setup dialog box, or set the
SQL_USE_PROCEDURE_FOR_PREPARE option in the SQLSetConnectOption function to
SQL_UP_OFF.
<P>
<P><h2>MORE INFORMATION</h2>
 
<P>
This behavior is also seen in Microsoft SQL Server 6.0.
<P>
With ODBC clients the same behavior is seen if:

<OL><P><LI>Generate Stored Procedures for Prepared Statements option checkbox in
</OL>the ODBC SQL Server Driver Setup dialog box is checked.

<OL><P><LI>SQL_USE_PROCEDURE_FOR_PREPARE option in the SQLSetConnectOption function
</OL>is set to SQL_UP_ON.
<P>
and a SELECT INTO statement is prepared and executed.
<P>
 
<P><h3>FIX: SELECTs from SYSPROCESSES Result in Access Violation</h3>
 
<P>
ARTICLE-ID: <B><A href="../sqlserver/q151985.htm">Q151985</A></B>
BUG #: NT: 15280 (6.00 and 6.50)
<P>
<P><h2>SYMPTOMS</h2>
 
<P>
On busy symmetric multiprocessing (SMP) computers, queries against the
virtual table sysprocesses may infrequently get a handled access violation,
causing the client connection to be terminated. Other clients are
unaffected. The call stack of the access violation will look similar to the
following:
<P>
findwaitfor+0x2f
ins_sysproc+0x7fc
make_fake+0xe8
s_setuptables+0x2bc
s_execute+0x7d8
sequencer+0x23f
execproc+0xfb7
s_execute+0xb8c
sequencer+0x23f
language_exec+0x65e
<P>
 
<P><h3>FIX: 1108 Errors with Heavy Tempdb Activity</h3>
 
<P>
ARTICLE-ID: <B><A href="../sqlserver/q151988.htm">Q151988</A></B>
BUG #: NT: 15209 (6.50)
<P>
<P><h2>SYMPTOMS</h2>
 
<P>
SQL Servers with lots of tempdb activity, sorts, and deadlocks can get 1108
errors in the error log and at the client. The following error message
appears:
<P>
<PRE>   Error : 1108, Severity: 21, State: 1
   Cannot deallocate extent 944, database 2. Object id 0, index id 0,
   status 0 in extent does not match object id -49604, index id 0, status 0
   in object being deallocated.  Run DBCC CHECKALLOC


</PRE></OL>You can get 1108 errors in tempdb when there are sorts of small work tables
and some other event occurs such as a deadlock or cancel, causing a
backout. Normally, the client is already backing out for some other reason
so they don't even notice the error, but it does show up in the errorlog.
<P>
 
<P><h3>FIX: Select with CASE Statement Inside View Can Cause Client AV</h3>
 
<P>
ARTICLE-ID: <B><A href="../sqlserver/q152353.htm">Q152353</A></B>
BUG #: WINDOWS: 15383 (6.00 and 6.50)
<P>
<P><h2>SYMPTOMS</h2>
 
<P>
A View that has a Select statement with a CASE construct that does a sub-
select with an IN clause may cause the client to access violate (AV) during
a Select from the View.
<P>
The following sample is the problem View definition:
<P>
<PRE>   create view MyView as
   Select   Column1, Column2=
         Case
           When SomeColumn In
            (Select  SomeOtherColumn
              From   SomeOtherTable)
             Then SomeValue
           Else Null
         End
   From  MyTable

</PRE>A Select from MyView may cause the client to access violate.
<P>
<P><h2>WORKAROUND</h2>
 
<P>
Try to avoid the CASE construct inside a View Definition or perform some
pre-processing for the CASE logic before the View Definition by using the
IF-ELSE construct and Temporary Tables, and then define the View on the
Temporary Table.
<P>
 
<P><h3>FIX: sp_processmail Will Only Process One Query per Execution</h3>
 
<P>
ARTICLE-ID: <B><A href="../sqlserver/q152416.htm">Q152416</A></B>
BUG#: 15475
<P>
<P><h2>SYMPTOMS</h2>
 
<P>
The stored procedure sp_processmail will only process one query sent via e-
mail each time it is run if SQLMail is running with Microsoft Exchange
Client software.
<P>
<P><h2>WORKAROUND</h2>
 
<P>
If you are scheduling sp_processmail as a task, you have the following
options:

<OL><P><LI>Change the task to run every minute. Note that this will work as long as
   there is not more than one query per minute sent to SQL Server via
   e-mail.
</OL>2. Make multiple tasks to run sp_processmail that run every minute. This
<PRE>   provides a workaround for option 1 above.
</PRE></OL>3. Change the sp_processmail stored procedure not to delete the mail it
<PRE>   responds to by commenting the xp_deletemail call.
</PRE>4. Change the sp_processmail stored procedure to not run in a loop but to
<PRE>   instead do several iterations.

</PRE> 
<P><h3>FIX: Syntax Error in SELECT List May Cause Handled AV</h3>
 
<P>
ARTICLE-ID: <B><A href="../sqlserver/q152615.htm">Q152615</A></B>
BUG#: 15027 (6.0)
<P>
<P><h2>SYMPTOMS</h2>
 
<P>
The absence of a comma between columns in the SELECT list may cause a
handled AV under some narrow circumstances.
<P>
The parser incorrectly perceives that an alias is intended. A reference to
the object later in the SELECT query, usually in a GROUP BY or ORDER BY
clause triggers the parser confusion.
<P>
<P><h2>WORKAROUND</h2>
 
<P>
Add the comma to the SELECT clause.
<P>
 
FIX: Count(*) May Not Return Result Set
 
<P>
ARTICLE-ID: <B><A href="../sqlserver/q152690.htm">Q152690</A></B>
BUG#: 15418 (6.5)
<P>
<P><h2>SYMPTOMS</h2>
 
<P>
Count(*) may not return a result set. This problem occurs on tables with 34
or more columns. When a query is executed, it may return the following
message:
<P>
<PRE>   This command did not return data, and it did not return any rows

</PRE>This behavior has also been observed for SELECT-INTO from that table to
another table.
<P>
When you select from a view which has a definition like select * from
another view you may not return results. The base view definition would be
on a table with 34 columns or more.
<P>
<P><h2>WORKAROUND</h2>
 
<P>
You can use the following query instead of the Count(*) on the table
<P>
<PRE>   select rows from sysindexes where name like 'My_Table_name'

</PRE>To perform SELECT-INTO from the source table to the destination table,
create the destination table and perform the following query:
<P>
<PRE>   insert Destination_Table select * from Source_Table

</PRE> 
<P><h3>FIX: Update of BLOB Data w/SQL Server 2.65.0201 Driver Stops</h3>
 
<P>
ARTICLE-ID: <B><A href="../sqlserver/q152709.htm">Q152709</A></B>
<P><h2>SYMPTOMS</h2>
 
<P>
Update of a BLOB data causes SQL Server 2.65.0201 driver to stop with a
syntax error. When an update statement is sent to the driver, it generates
an invalid statement that results in the syntax error. This happens during
an update of a large BLOB data (larger than 64K).
<P>
<PRE>      The syntax error generated is
       Incorrect syntax near the keyword 'UPDATE'.
       State:37000, Native:156, Origin:[Microsoft][ODBC SQL Server
       Driver][SQL Server]

       Line 1"Incorrect syntax near '='
       State:37000, Native:170, Origin:[Microsoft][ODBC SQL Server
       Driver][SQL Server]

</PRE><h2>MORE INFORMATION</h2>
 
<P>
If the SQL Server 4030 trace is turned on , the 2.65.0201 SQL server driver
generates the following syntax when an update statement of BLOB data is
issued:
<P>
<PRE>   SELECT TEXTPTR(imagecol) FROM imagetest where intcol=update imagetest
   set imagecol=0x00

</PRE>This is an invalid syntax.
<P>
This does not happen in  2.50.0121 (6.0 drivers).They generate:
<P>
<PRE>   SELECT TEXTPTR(imagecol) FROM imagetest where imagecol LIKE
   0x000000

   WRITETEXT BULK imagetest.imagecol 0xa

</PRE> 
<P><h3>FIX: GROUP BY Clause without Index Executes More Slowly</h3>
 
<P>
ARTICLE-ID: <B><A href="../sqlserver/q152800.htm">Q152800</A></B>
BUG#: 14825
<P>
<P><h2>SYMPTOMS</h2>
 
<P>
If a Transact-SQL query contains a GROUP BY clause and an index is not
defined on the column involved in GROUP BY, the query requires many more
i/o’s
than expected, esulting in slower performance. This problem occurs only
only on the Alpha
platform.
<P>
<P><h2>WORKAROUND</h2>
 
<P>
Sort the columns in the GROUP BY clause. Alternately, define an index
encompassing the columns involved in the GROUP BY clause and make sure the
index is used when grouping the columns in the query.
<P>
 
<P><h3>FIX: Dump or Load w/Tape Devices Results in Errors, AVs</h3>
 
<P>
ARTICLE-ID: <B><A href="../sqlserver/q153006.htm">Q153006</A></B>
BUG #: NT: 15499 (6.50)
<P>
<P><h2>SYMPTOMS</h2>
 
<P>
Attempts to dump or load with tape devices may generate errors 3201,
tbswritecheck, or access violations (AVs).  Msg 3201 and the tbswritecheck
errors are seen when attempting to dump; the AV may occur during the load.
<P>
<P><h2>WORKAROUND</h2>
 
<P>
Do not dump to a tape device; dump and load using a different type of dump
device, such as disk.  If dumping to disk, use another backup package, such
as Windows NT Backup, to archive the dump file to tape.
<P>
MORE INFORMATION
 
<P>
The behavior and error messages may vary from computer to computer. Some
computers may report a Msg 3201 while the same tape drive and software may
work correctly on a different computer, or the load process may generate an
access violation (AV).
<P>
The 3201 and tbswritecheck errors may occur on any of the DUMP commands
(DATABASE, TRANSACTION), and the AV may occur on any of the LOAD commands
(DATABASE, TRANSACTION, TABLE).
<P>
For a robust backup and restore strategy, Microsoft recommends occasional
verification that dumps can be loaded, along with additional testing when a
device or software is changed.  Certain database errors may also prevent a
successful load, so it is important to run the recommended DBCC commands at
the time of each backup.
<P>
 
<P><h3>FIX: SQL Server Stops w/ Temporary Procedure in a Transaction</h3>
 
<P>
ARTICLE-ID: <B><A href="../sqlserver/q153079.htm">Q153079</A></B>
BUG# 15570 (6.50)
<P>
<P><h2>SYMPTOMS</h2>
 
<P>
When a temporary stored procedure is created and executed within a user-
defined transaction and the client (DBLIB or ODBC) disconnects without
either committing or rolling back the transaction, SQL Server stops
running. The SQL Service manager shows a red light.
<P>
An attempt to kill the process that initiated the transaction also causes
SQL Server to stop running.
<P>
<P><h2>WORKAROUND</h2>
 
<P>
Use a permanent stored procedure instead of a temporary stored procedure
within a transaction.
<P>
You can also commit or roll back the transaction before the client
disconnects.
<P>
<P><h2>MORE INFORMATION</h2>
 
<P>
The SQL Server errorlog (under SQL..\LOG directory on the server) would
look like:
<P>
Error : 631, Severity: 21, State: 1
<PRE>spid12   The length of 116 passed to delete row routine for the row at
</PRE>offset 32 is incorrect on the following page: Page pointer = 0xa8b000,
pageno = 104, status = 0x101, objectid = 6, indexid = 0
<PRE>kernel   WARNING: Process being freed while holding Dataserver semaphore
</PRE>Error : 631, Severity: 21, State: 1
The length of 116 passed to delete row routine for the row at offset 32 is
incorrect on the following page: Page pointer = 0xa8b000, pageno = 104,
status = 0x101, objectid = 6, indexid = 0
<PRE>kernel   udread: Operating system error 6(The handle is invalid.) on device
'C:\SQL60\DATA\MASTER.DAT' (virtpage 0x000002fb).
</PRE>Buffer 8d8700 from database 'master' has page number 0 in the page header
and page number 759 in the buffer header
Recursive error 822 in ex_print
<PRE>kernel   mirrorproc: i/o error on primary device 'C:\SQL60\DATA\MASTER.DAT'

</PRE> 
<P><h3>FIX: Filtered Stored Procedures Cannot Reference Multiple Tables</h3>
 
<P>
ARTICLE-ID: <B><A href="../sqlserver/q153186.htm">Q153186</A></B>
BUG #: NT: 15451 (6.50)
<P>
<P><h2>SYMPTOMS</h2>
 
<P>
The Filtered Stored procedures used to facilitate horizontal partitioning
in SQL Server 6.50 replication may cause the Logreader task to keep
retrying with the following message:
<P>
<PRE>   ConnectionTransact (GetOverLappedResult()).Possible network error:
   Write to SQL Server. Failed. Connection broken.

</PRE>This error prevents logreader from processing transactions, effectively
stopping replication. The problem occurs when rows that do not match the
restriction clause are inserted. This behavior is only exhibited in SQL
Server version 6.50.
<P>
<P><h2>WORKAROUND</h2>
 
<P>
To avoid encountering the bug you can:

<UL><LI>Publish the entire table instead of using horizontal partitioning.
<P>
</UL>-OR-

<UL><LI>Create a permanent table with the data from the original tables
   selectively siphoned out (using triggers  with the partition
   condition)  and then publish the new table.
<P>
<P>
</UL> 
<P><h3>FIX: Multiple "LEFT OUTER JOIN" in FROM Clause May Cause Error</h3>
 
<P>
ARTICLE-ID: <B><A href="../sqlserver/q153455.htm">Q153455</A></B>
BUG #: NT: 15565 (6.50)
<P>
<P><h2>SYMPTOMS</h2>
 
<P>
Multiple LEFT OUTER JOIN tables in the FROM clause of a SELECT query may
cause SQL Server error 803. For example, the following query:
<P>
<PRE>   select authors.au_id
   from
   (((( authors
   left outer join titleauthor on authors.au_id=titleauthor.au_id)
   left outer join titles on titleauthor.title_id=titles.title_id)
   left outer join authors a1 on a1.au_id=titleauthor.au_id)
   left outer join roysched on titles.title_id=roysched.title_id)
   where (roysched.royalty = 20)

</PRE>will cause the following SQL Server error:
<P>
<PRE>      Msg 803, Level 20, State 2
      Unable to place buffer 0x0 holding logical page 424 in sdes for
          object
      'titleauthor' - either there is no room in sdes or buffer already in
      requested slot.
      The SQL Server is terminating this process.


</PRE> 
<P><h3>FIX: sp_droppublisher Does Not Clear 'pub' Server Option</h3>
 
<P>
ARTICLE-ID: <B><A href="../sqlserver/q153780.htm">Q153780</A></B>
BUG #: NT: 15184 (6.50)
<P>
<P><h2>SYMPTOMS</h2>
 
<P>
The sp_droppublisher stored procedure, used to drop a publication server,
does not properly clear the 'pub' server option from sysservers. This will
prevent users from properly disabling a publication server on the screen
"Enable Subscribing from these Servers."
<P>
<P><h2>WORKAROUND</h2>
 
<P>
In the master database of any server participating in replication, please
replace the sp_droppublisher procedure by running the following script:
<P>
use master
go
if exists (select * from sysobjects where sysstat &amp; 0xf = 4 and name =
<PRE>'sp_droppublisher')
   drop procedure sp_droppublisher
</PRE>go
create procedure sp_droppublisher (
<PRE>   @publisher varchar (30),        /* publisher server name */
   @type varchar (5) = null     /* null or 'dist' */
        ) as

    declare @distaccount varchar(127)
    declare @proc varchar (255)
    declare @retcode int
    declare @privilege varchar (30)

    /*
    ** parameter check:  @publisher.
    ** check to make sure that the publisher exists, that the name isn't
    ** null, and that the name conforms to the rules for identifiers.
    */

    if @publisher is null
        begin
            raiserror (14043, 16, -1, 'the publisher')
            return (1)
        end

    execute @retcode = sp_validname @publisher

    if @retcode &lt;&gt; 0
   return (1)

    /*
    ** perform special logic if dropping a publisher for a distribution
    ** server.
    */
    if lower(@type) = 'dist'
      begin
       if not exists (select *
      from master..sysservers
                where srvname = @publisher
                and srvstatus &amp; 16 &lt;&gt; 0)

       begin
      raiserror (14080, 11, -1)
           return (1)
       end

       execute @retcode = sp_serveroption @publisher, 'dpub', false
       if @@error &lt;&gt; 0 or @retcode &lt;&gt; 0 return (1)

            if exists (select * from master..sysremotelogins
          where remoteserverid = (select srvid from master..sysservers
          where srvname = @publisher)
          and remoteusername = 'sa'
          and suid = 1)    /* 'sa' */
       begin
          execute @retcode = sp_dropremotelogin @publisher, sa, sa
          if @@error &lt;&gt; 0 or @retcode &lt;&gt; 0 return (1)
       end

            if exists (select * from master..sysremotelogins
          where remoteserverid = (select srvid from master..sysservers
          where srvname = @publisher)
          and remoteusername = 'probe'
          and suid = 10)   /* 'probe' */
       begin
          execute @retcode = sp_dropremotelogin @publisher, probe, probe
          if @@error &lt;&gt; 0 or @retcode &lt;&gt; 0 return (1)
       end

       return (0)
   end

    /*
    ** make sure the server is defined as a 'publisher'.
    */
    if not exists (select *
                     from master..sysservers
                    where srvname = @publisher
                      and srvstatus &amp; 2 &lt;&gt; 0)

        begin
            raiserror (14080, 11, -1)
            return (1)
        end

    /*
    ** turn off the server option to indicate that this is a publisher.
    */
    execute @retcode = sp_serveroption @publisher, 'pub', false
    if @@error &lt;&gt; 0 or @retcode &lt;&gt; 0 return (1)

    /*
    ** fetch the publisher's distributor account.
    */

    select @proc = rtrim(@publisher) + '.master..sp_helpdistributor '
    exec @retcode = @proc @account = @distaccount output
    if @@error &lt;&gt; 0 or @retcode &lt;&gt; 0
        begin
            raiserror (14071, 16, -1)
            return (1)
        end

    /*
    ** if @distaccount = 'localsystem' assume 'admin' privilege
    */
    if @distaccount = 'localsystem'
       return (0)

    /*
    ** if @distaccount has 'admin' privilege, do not revoke
    */
    execute @retcode = master.dbo.xp_logininfo @distaccount, 'all',
       @privilege = @privilege output
    if @@error &lt;&gt; 0 or @retcode &lt;&gt; 0 return (1)

    if @privilege = 'admin'
       return  (0)

    /*
    ** revoke replication privilege to the distributor nt account.
    */
    exec @retcode = master.dbo.xp_revokelogin @distaccount
    if @@error &lt;&gt; 0 or @retcode &lt;&gt; 0 return (1)
</PRE>go
<P>
To clear the problem before applying the procedure, you can manually
disable the 'pub' server option by executing the following statement on the
subscription server:
<P>
use master
go
sp_serveroption &lt;publication server&gt;,  'pub', false
go
<P>
Example:
<P>
use master
go
sp_serveroption AIKMAN, 'pub', false
go
<P>
<P>
 
FIX: Deadlock During Cursor Update Causes CPU Spin and Spinloop
 
<P>
ARTICLE-ID: <B><A href="../sqlserver/q153802.htm">Q153802</A></B>
BUG #: 15422 (6.50)
<P>
<P><h2>SYMPTOMS</h2>
 
<P>
A group of updates through cursors that result in the cursor being a
deadlock victim can cause the following error to appear in the error log:
<P>
<PRE>   closetable:table already closed for sdes %d

</PRE>After this error occurs, the process can become unkillable, and its status
in sysprocesses is marked as "spinloop." At this point SQL Server becomes
very unresponsive and will often stop responding entirely, allowing no one
to log on or shut it down. Processes that were accessing the tables become
blocked.
<P>
<P>
<P><h2>WORKAROUND</h2>
 
<P>
When using cursors for updates make sure they will not get into a deadlock
situation.
<P>
 
<P><h3>FIX: GRANT ALL Fails to Give Permissions on Stored Procedures</h3>
 
<P>
ARTICLE-ID: <B><A href="../sqlserver/q153803.htm">Q153803</A></B>
BUG #: 15102 (6.50)
<P>
<P><h2>SYMPTOMS</h2>
 
<P>
When a user attempts to GRANT ALL to a stored procedure, the permissions
can fail to be applied. No errors are reported; SQL Server simply does not
give permission to the stored procedure. Once this happens to a stored
procedure, it will always happen, and GRANT ALL will never work for that
stored procedure.
<P>
<P><h2>WORKAROUND</h2>
 
<P>
To grant permissions to a stored procedure, use GRANT EXEC instead of GRANT
ALL.
<P>
 
<P><h3>FIX: SQLGetData Fails on Multiple Active Statement Handles</h3>
 
<P>
ARTICLE-ID: <B><A href="../sqlserver/q153836.htm">Q153836</A></B>
BUG #: 15053 (6.50)
<P>
<P><h2>SYMPTOMS</h2>
 
<P>
When there are two active statement handles, SQLGetData fails to
fetch results from the two statement handles simultaneously.
The following error is generated:
<P>
<PRE>   szErrorMsg="[Microsoft][ODBC SQL Server Driver]Connection is busy
   with results for another hstmt"

</PRE><h2>WORKAROUND</h2>
 
<P>
Bind the result set columns using SQLBindCol before a fetch. This allows
multiple active statement handles.
<P>
<P><h2>MORE INFORMATION</h2>
 
<P>
When you are using server-based cursors, the connection between the client
and server does not remain busy between operations. This allows you to have
multiple cursors statements active at the same time. However, with the SQL
Server ODBC driver 2.65.0121v, an attempt to fetch data using SQLGetData
between multiple statement handles fails. If SQLFetch is being done on a
statement handle hstmt1 and if, before a result of SQL_NO_DATA_FOUND is
returned, another statement hstmt2 is allocated and another fetch operation
is done, and then a simultaneous SQLGetData is done on hstmt1, the result
will be a "Connection is busy with results" error.
<P>
 
<P><h3>FIX: AV if 4 or More Correlated Subqueries with Self-Join</h3>
 
<P>
ARTICLE-ID: <B><A href="../sqlserver/q153851.htm">Q153851</A></B>
BUG #: 14802 (6.50)
<P>
<P><h2>SYMPTOMS</h2>
 
<P>
If a complex query does a self-join and has four or more subqueries, all
referencing the same table, it may get a thread-level access violation (AV)
if the table has only a non-clustered index.
<P>
<P><h2>WORKAROUND</h2>
 
<P>
Convert the non-clustered index to a clustered index, or drop it.
<P>
 
<P><h3>FIX: IRL can cause 3307, OS error 6, unhandled server level AV</h3>
 
<P>
ARTICLE-ID: <B><A href="../sqlserver/q153855.htm">Q153855</A></B>
BUG #: NT: 15569 (6.50)
<P>
<P><h2>SYMPTOMS</h2>
 
<P>
If a table is set to enable Insert - Row Locking (IRL) with "sp_tableoption
<PRE>'table_name', 'Insert row lock', true"  within a transaction and the user
</PRE>fails to end the transaction with 'commit tran' or 'rollback tran' before
exiting, it could cause 3307 "Process %ld was expected to hold logical lock
on page %ld.", OS error 6, 602 "Could not find row in Sysindexes for dbid
<PRE>'%d', object '%Id',index '%d'." and an unhandled server level access
</PRE>violation (AV).
<P>
<P><h2>MORE INFORMATION</h2>
 
<P>
On a single processor computer, when the user exits without 'commit tran',
it can cause the following error in the errorlog:
<P>
Error : 3307, Severity: 21, State: 1
Process 10 was expected to hold logical lock on page 336.
WARNING: Process being freed while holding Dataserver semaphore
udread: Operating system error 6(The handle is invalid.) on device
<PRE>'C:\MSSQL\DATA\MASTER.DAT' (virtpage 0x000009a4).
</PRE>udread: Operating system error 6(The handle is invalid.) on device
<PRE>'C:\MSSQL\DATA\MASTER.DAT' (virtpage 0x00000394).
</PRE>udread: Operating system error 6(The handle is invalid.) on device
<PRE>'C:\MSSQL\DATA\MASTER.DAT' (virtpage 0x00000383).
</PRE>Buffer 8d3b20 from database 'master' has page number 0 in the page header
and page number 895 in the buffer header
Recursive error 822 in ex_print
mirrorproc: i/o error on primary device 'C:\MSSQL\DATA\MASTER.DAT'
<P>
SQL Server will terminate itself afterwards.  When SQL Server is restarted
and DBCC CHECKDB("pubs") is executed, the results sometimes report error
602: Could not find row in Sysindexes for dbid '%d', object '%Id',index
<PRE>'%d'.

</PRE>After a user exits on a multi-processor computer, sp_who shows the spid is
still valid and the status shows 'spinloop', which does not allow you to
kill the spid.  DBCC CHECKDB or other queries will either hang, or become
extremely slow. There will also be many bufwait() errors in the errorlog.
Stopping SQL Server would either cause an AV or cause SQl Server to stop
responding.
<P>
 
<P><h3>FIX: Checkpoint Process Deadlock Results in Errors 603, 3314</h3>
 
<P>
ARTICLE-ID: <B><A href="../sqlserver/q153954.htm">Q153954</A></B>
BUG #: NT: 15307 (6.50)
<P>
<P><h2>SYMPTOMS</h2>
 
<P>
A stored procedure that performs the following actions:

<OL><P><LI>creates a temporary table
</OL>2. inserts data into the table
3. creates a cursor for read-only access that is then used to update the
<PRE>   contents of the temporary table
</PRE></OL>4. drops the cursor
5. drops the temporary table
<P>
can, if executed by multiple users, result in the Checkpoint Process being
chosen as a deadlock victim (spid 3). In this case, the following message
will come up three times:
<P>
<PRE>   Your server command (process id 3) was deadlocked with another process
   and has been chosen as a deadlock victim. Re-run your command.

</PRE>The message will be followed by the following errors:
<P>
<PRE>   603: There are not enough system session descriptors available to run
   this query. The maximum number available to a process is %d. Split query
   and rerun.

   3314: Error while undoing log row in database '%.*s'. %S_RID.

</PRE>A thread-level Access Violation will also be displayed.
<P>
If you run sp_who prior to receiving 1105 errors in tempdb, the Checkpoint
Process is not present, and if the client processes continue to run, the
result is that tempdb eventually fills because the log is not being
truncated.
<P>
 
<P><h3>FIX: Full Memory and Cursors Cause AVs, 707, 706, and Spins</h3>
 
<P>
ARTICLE-ID: <B><A href="../sqlserver/q153961.htm">Q153961</A></B>
BUG #: NT: 14828 (6.50)
<P>
<P><h2>SYMPTOMS</h2>
 
<P>
A user application that uses engine side cursors in a stored procedure can
cause a myriad of problems when available SQL Server system memory becomes
full. Usually it starts with error 707:
<P>
<PRE>   System error detected during attempt to free memory at address 0x%1x.
   Please consult the SQL Server error log for more details.

</PRE>Or Error 706:
<P>
<PRE>   Process %d tried to remove PROC_HDR 0x%lx that it does not hold in Pss.

</PRE>These are then followed by handled access violations. The access violations
can also occur without the 707 or 706 errors. After the access violations,
SQL Server will often lock up and become unusable as it goes into a 100
percent CPU spin.
<P>
MORE INFORMATION
 
<P>
When the SQL Server procedure cache needs to swap out a stored procedure it
can incorrectly deallocate the procedure twice. This can cause a memory
leak as well as the access violations. This will only occur if the stored
procedure is using engine side cursors.
<P>
<P><h2>WORKAROUND</h2>
 
<P>
Increasing the amount of procedure cache available to SQL Server will
reduce the chance of the problem occurring. This can be accomplished by
giving SQL Server more memory to use, or by increasing the procedure cache
using sp_configure.
<P>
 
<P><h3>FIX: AV Error Using Temp Table and Cursor in Stored Procedure</h3>
 
<P>
ARTICLE-ID: <B><A href="../sqlserver/q153987.htm">Q153987</A></B>
BUG #: NT: 15510 (6.50)
<P>
<P><h2>SYMPTOMS</h2>
 
<P>
A stored procedure that performs selects against a cursor with a temporary
table in the cursor will fail with a handled access violation or with the
following error message:
<P>
<PRE>   Msg 208 "Invalidobject name #temptable"

</PRE>The problem will only occur after SQL Server has been shut down and
restarted after the initial creation of the stored procedure. If the stored
procedure is then dropped and re-created, it will work again until SQL
Server is shut down and restarted.
<P>
<P><h2>WORKAROUND</h2>
 
<P>
The problem only occurs if both the temporary table and the cursor are both
created inside a stored procedure. Creating the temporary table outside of
the stored procedure will allow the stored procedure to function correctly.
An alternative workaround would be to convert the temporary table to a
permanent table.
<P>
 
<P><h3>FIX: Cannot Rename a Column With a Quoted Identifier</h3>
 
<P>
ARTICLE-ID: <B><A href="../sqlserver/q153992.htm">Q153992</A></B>
BUG #: NT: 15100 (6.50)
<P>
<P><h2>SYMPTOMS</h2>
 
<P>
If you try to rename a table's column to use a quoted identifier column
name, sp_rename gives an error indicating that the column name is invalid.
The errors are as folows:
<P>
<PRE>   Msg 15006, Level 16, State 1
   '&lt;column name&gt;' is not a valid name since it contains invalid characters

   Msg 15224, Level 11, State 1
   Error, the value for parameter NewName contains invalid characters or
   violates a basic restriction

</PRE><h2>WORKAROUND</h2>
 
<P>
Export the data. Drop and re-create the table with quoted identifiers on
necessary columns. Import the data back in.
<P>
 
<P><h3>FIX: AV in Update Mode When Script Is Run Twice</h3>
 
<P>
ARTICLE-ID: <B><A href="../sqlserver/q154018.htm">Q154018</A></B>
BUG#: 14827 (6.50)
<P>
<P><h2>SYMPTOMS</h2>
 
<P>
This problem arises with simple scripts that use trace flag 323 to
determine if UPDATE IN PLACE is occurring. When you run such a script
twice, a handled access violation (AV) occurs.
<P>
<P><h2>WORKAROUND</h2>
 
<P>
To avoid this problem, do not use trace flag 323. Without the trace flag,
the script will run successfully.
<P>
 
<P><h3>FIX: SQL Terminates on Delete Table with 15 Self-References</h3>
 
<P>
ARTICLE-ID: <B><A href="../sqlserver/q154047.htm">Q154047</A></B>
BUG #: NT: 15629 (6.50)
<P>
<P><h2>SYMPTOMS</h2>
 
<P>
Trying to delete a table that contains 15 self-references can cause the
system to return the following errors and warnings:
<P>
<PRE>   Error : 1202, Severity: 20, State: 2
   Table_lock was called with illegal mode 0.

   WARNING: Process being freed while holding Dataserver semaphore

   udwritem: Operating system error 6(The handle is invalid.) on device
   'C:\MSSQL\DATA\MASTER.DAT' (virtpage 0x00002739).

   udread: Operating system error 6(The handle is invalid.) on device
   'C:\MSSQL\DATA\MASTER.DAT' (virtpage 0x00000394).

   Error: 5157, Severity: 20, State: 0
   Recursive error 1202 in ex_print

</PRE>This action also results in an unhandled exception, essentially terminating
the server.
<P>
<P><h2>WORKAROUND</h2>
 
<P>
The workaround for this problem is to avoid having more than 14 self-
references on a table. Establish another table that can contain the
additional required references.
<P>
<P><h2>MORE INFORMATION</h2>
 
<P>
This problem is specific to 15 self-references and hence is extremely
uncommon.
<P>
NOTE: If a default debugger is set up, it will generate a debug log (like
Dr. Watson log).
<P>
 
<P><h3>FIX: SELECT INTO Locking Behavior</h3>
 
<P>
ARTICLE-ID: <B><A href="../sqlserver/q153441.htm">Q153441</A></B>
BUG #: 14818 (DCR, 6.50)
<P>
<P><h2>SUMMARY</h2>
 
<P>
In SQL Server 6.5, SELECT INTO wraps within a transaction. Tables created
by using SELECT INTO hold to the ACID (atomicity, consistency, isolation,
durability) transaction properties. This also means that system resources,
such as pages, extents, and locks, are held for the duration of the SELECT
INTO statement. With larger system objects, this leads to the condition
where many internal tasks can be blocked by other users performing SELECT
INTO statements. For example, on high-activity servers, many users running
the SQL Enterprise Manager tool to monitor system processes can block on
each other, which leads to a condition where the SEM application appears to
hang.
<P>
<P><h2>MORE INFORMATION</h2>
 
<P>
When you upgrade to SQL Server 6.5 Service Pack 1, SELECT INTO locking
characteristics is a system settable feature. Wrapping the SELECT INTO with
a transaction remains the default behavior. For users wishing not to hold
system catalog locks on the activity, a trace flag has been added to allow
for such operations. To apply the trace flag, start the server with the
-T5302 command line parameter, or from within a query window, use the
following commands:
<P>
&gt; dbcc traceon (3604)
&gt; go
&gt; dbcc traceon (5302)
&gt; go
<P>
When the 5302 trace flag is applied and a SELECT INTO fails, the table is
still created. Note that the locking behavior you select is applied for all
databases within the server.
<P>

	</FONT>
	</TD>
	</TR>
</TABLE>
<P>


<!--DOCBODY_END-->

<!--FOOTER_START-->
<table cellpadding=5 border=0 width="90%">
<tr>
<td>
	<HR WIDTH="90%">

<BLOCKQUOTE>
<FONT FACE="Verdana, Arial, Helvetica" SIZE="1">
<SPAN STYLE="font-family:verdana,arial,helvetica; font-size:8pt">
Additional query words: sp1 database patch service pack<BR>
Keywords          : SSrvGen kbfixlist kbfixlist6.50.sp1<BR>
Version           : 6.5<BR>
Platform          : WINDOWS<BR>
Issue type        : kbref<BR>

</SPAN>
</FONT>
<BR>
<BR>
THE INFORMATION PROVIDED IN THE MICROSOFT KNOWLEDGE BASE IS
PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND.  MICROSOFT DISCLAIMS
ALL WARRANTIES, EITHER EXPRESS OR IMPLIED, INCLUDING THE WARRANTIES
OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  IN NO
EVENT SHALL MICROSOFT CORPORATION OR ITS SUPPLIERS BE LIABLE FOR
ANY DAMAGES WHATSOEVER INCLUDING DIRECT, INDIRECT, INCIDENTAL,
CONSEQUENTIAL, LOSS OF BUSINESS PROFITS OR SPECIAL DAMAGES, EVEN IF
MICROSOFT CORPORATION OR ITS SUPPLIERS HAVE BEEN ADVISED OF THE
POSSIBILITY OF SUCH DAMAGES.  SOME STATES DO NOT ALLOW THE EXCLUSION
OR LIMITATION OF LIABILITY FOR CONSEQUENTIAL OR INCIDENTAL DAMAGES
SO THE FOREGOING LIMITATION MAY NOT APPLY.
</BLOCKQUOTE>
<P>
<center>
	<FONT FACE="Verdana,Arial,Helvetica" SIZE="1">
	Last reviewed:  March 18, 1998</FONT>
	<BR>
	<A href="../cpyright.htm" STYLE="font: bold 7pt Verdana,Arial,Helvetica">&copy; 1998 Microsoft Corporation. All rights reserved. Terms of Use.</A><BR>
	
</center>
</td>
</tr>
</table>

<!--FOOTER_END-->
</FONT>
</BODY>
</HTML>
