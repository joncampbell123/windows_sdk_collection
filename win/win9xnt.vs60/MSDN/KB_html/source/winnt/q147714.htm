

<HTML>
<HEAD>
<TITLE>Windows Sockets 2 Service Provider Interface Limitations </TITLE>

<!--STYLE_BEGIN-->
<style>@import url(../../msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="../../msdn_ie3.css">
<!--STYLE_END-->

<META HTTP-EQUIV="CONTENT-Type" CONTENT="text/html; charset=us-ascii">
<META NAME="ms.locale" CONTENT="EN-US">
<META NAME="Category" CONTENT="Support; KB Article">
<META NAME="KBID" CONTENT="Q147714">
<META NAME="KBModify" CONTENT="1997/10/15">
<META NAME="KBCreate" CONTENT="1996/03/08">
<META NAME="Keywords" CONTENT="NTSrvWkst nttcp kbnetwork">
<META NAME="KBArea" CONTENT="Support; KB; winnt, crossnet, iis">
<META NAME="Description" CONTENT="  The Windows Sockets 2 Service Provider Interface (Revision 2.1.0) provides specifications for transport network programming under Windows. This interface is the most comprehensive open transport API designed to date. However, few limitations exist....">
<META NAME="Product" CONTENT="Windows NT">
<META NAME="Platform" CONTENT="Windows">
<META NAME="Technology" CONTENT=" ">
<META NAME="Premium" CONTENT="support">

<META NAME="nyms" CONTENT="QAGI,QDKW,QBVV,QAY5,QBWD,QAJH,QAIF,QAH6,QAB4,QAAP,QDKF,QAKD,QAUD,QAVZ,QATO V02180118">
</HEAD>

<BODY BGCOLOR="#FFFFFF" LEFTMARGIN="0" RIGHTMARGIN="0" TOPMARGIN="0">


<!--DOCBODY_START-->
<BR>
<CENTER>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" VALIGN="top" WIDTH="90%">
	<TR>
		<TD VALIGN="top">
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<H1>Windows Sockets 2 Service Provider Interface Limitations</H1>
			</FONT>
			<FONT FACE="verdana,arial,helvetica" SIZE="1">
			Last reviewed:  October 15, 1997</FONT><BR>
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<B>Article ID: Q147714</B>
			</FONT>
		</TD>
	</TR>
	<TR>
	<TD>
	<FONT FACE="Verdana, Arial, Helvetica" SIZE=2>



 
 
The information in this article applies to:

<UL><LI>Microsoft Windows NT Workstation versions 3.5, 3.51, and 4.0
<LI>Microsoft Windows NT Server versions 3.5, 3.51, and 4.0
</UL> 
<P>
<P><h2>SUMMARY</h2>
 
<P>
The Windows Sockets 2 Service Provider Interface (Revision 2.1.0) provides
specifications for transport network programming under Windows. This
interface is the most comprehensive open transport API designed to date.
However, few limitations exist. The purpose of this article is to list and
describe the limitation items of the specifications and provide alternative
solutions to work around the limitation items. The information below is
contributed by the Windows Sockets Vendor Community.
<P>
<P><h2>MORE INFORMATION</h2>
 

<OL><P><LI>Calling connect() on a non-blocking socket, getting WSAEWOULDBLOCK,
   then immediately calling recv() and expecting WSAEWOULDBLOCK before the
   connection has been established.
<P>
   Reason: This assumes that the connection will never be established
   by the time the application calls recv().
<P>
   Workaround: An application using a non-blocking socket must handle the
   WSAEWOULDBLOCK error value, but must not depend on occurance of the
   error.

<P><LI>Calling select() with three empty FD_SETs and a valid TIMEOUT structure
   as a delay function.
<P>
   Reason: The select() function is intended as a network function,
   not a general purpose timer.
<P>
   Workaround: Use a legitimate system timer service.

<P><LI>Polling with connect() on a non-blocking socket to determine when the
   connection has been established.
<P>
   Reason: The WinSock 1.1 specification does not define an error for
   connect() when a non-blocking connection is pending. Therefore, the
   error value returned varies.
<P>
   Workaround: Use asychronous notification of connection completion
   An application that prefers synchronous operation mode can use the
   select() function (please see item 21 below).

<P><LI>Assuming socket handles are always less than 16.
<P>
   Reason: The only invalid socket handle value is defined by the WinSock.H
   file as INVALID_SOCKET. Any other value the SOCKET type can handle is
   fair game, and an application must handle it. Socket handles are not
   transparent. Therefore, applications should not depend on specific
   values.
<P>
   Workaround: Expect a socket handle of any value, including 0. Do not
   expect socket handle values to change with each successive call to
   socket() or WSASocket(). Socket handles may be re-used by the WinSock
   implementation.

<P><LI>Polling with select() and a zero timeout in Win16's non-preemptive
   environment.
<P>
   Reason: With any non-zero timeout, select() calls the current blocking
   hook function, so that an application anticipating an event yields to
   other processes executing in a 16-bit Windows environment. However, with
   a zero time-out, an application does not yield to other processes, and
   may not allow network operations to occur (it will loop continuously).
<P>
   Workaround: Use a small non-zero timeout, or use asynchronous
   notification instead of using select().

<P><LI>Calling WSAAsyncSelect() with a zero Event mask in order to make
   the socket non-blocking.
<P>
   Reason: WSAAsyncSelect() is designed to allow an application to register
   for asynchronous notification of network events. The WinSock version 1.1
   specification does not specify an error for a zero event mask, but may
   interpret it as an invalid input argument (so it may fail with
   WSAEINVAL) or ignore the request.
<P>
   Workaround: To make a socket non-blocking without registering for
   asynchronous notification, use ioctlsocket() FIONBIO.

<P><LI>Telnet applications that neither enable OOBINLINE, nor read OOB data.
<P>
   Reason and Workaround not available.

<P><LI>Assuming zero (0) is an invalid socket handle value.
<P>
   Reason and Workaround: Please see item 4 above.

<P><LI>Applications that do not properly shut-down when the user closes the
   main window while a blocking API is running.
<P>
   Reason: WinSock applications that do not close sockets and call
   WSACleanup() does not allow a WinSock implementation to re-claim
   resources used by the application. Resource leakage can eventually
   result in resource shortage for all other WinSock applications (for
   example: network system failure).
<P>
   Workaround: While a blocking API is running, do the following to abort:
<P>
   a. Call WSACancelBlockingCall().
<P>
   b. Wait until the pending function returns. If it is cancelled before
<P><PRE>      the operation completes, the pending function fails with the WSAEINTR
      error. However, applications must also be prepared for success due to
      the race condition involved with cancellation.
</PRE><P>
   c. Close this socket and all other sockets.
<P>
<P><PRE>      NOTE: The proper closure of a connected stream socket involves the
      following:
</PRE><P>
<P><PRE>       - Call shutdown() how=1
</PRE><P>
<P><PRE>       - Loop on recv() until it returns 0 or fails with any error
</PRE><P>
<P><PRE>       - Call closesocket().
</PRE><P>
   d. Call WSACleanup().

<P><LI>Out of band data.
<P>
<P><PRE>    Reason: TCP does not do Out of Band (OOB) data reliably. In addition,
    there are incompatible differences in the implementation at the
    protocol level (in the urgent pointer offset). Berkeley Software
    Distribution's (BSD) implementation performs RFC 793. Many others
    implement the corrected RFC 1122 version. One version cannot point to
    the OOB data of the other version.
</PRE><P>
<P><PRE>    Workaround: Use a separate socket for urgent data. Some protocols
    require it (please see item 7 above).
</PRE>
<P><LI>Calling strlen() on a hostent structure's IP address, then truncating
<P><PRE>    it to four bytes, thereby overwriting part of the malloc() heap header.
</PRE><P>
<P><PRE>    Reason and Workaround not available.
</PRE>
<P><LI>Polling with recv(MSG_PEEK) to determine when a complete message
<P><PRE>    has arrived.
</PRE><P>
<P><PRE>    Reason and Workaround not available.
</PRE>
<P><LI>Bounding every set of operations with calls to WSAStartup() and
<P><PRE>    WSACleanup().
</PRE><P>
<P><PRE>    Reason: This is possible as long as each WSAStartup() has a matching
    call to WSACleanup(), but requires more work.
</PRE><P>
<P><PRE>    Workaround: In a DLL, custom control or class library, it is possible
    to register the calling client based on a unique task handle or process
    ID. This allows automatic registration without duplication. Automatic
    de-registration can occur when a process closes its last socket. You
    may also use the process notification mechanisms available in the 32-
    bit environment.
</PRE>
<P><LI>Ignoring API errors.
<P>
<P><PRE>    Reason: When a function fails, the error value returned by
    WSAGetLastError() (or included in an asynchronous message) informs you
    why it has failed. Based on the function that fails and the socket
    state, you can determine why the function fails and what you can do.
</PRE><P>
<P><PRE>    Workaround: Check for error values, and write your applications to
    anticipate them. When a fatal error occurs, display an error message
    that shows the following:
</PRE><P>
<P><PRE>     - The function that has failed
</PRE><P>
<P><PRE>     - The WinSock error number and macro
</PRE><P>
<P><PRE>     - A short description of the error definition
</PRE><P>
<P><PRE>     - Workarounds
</PRE>
<P><LI>Installing an empty blocking hook that returns FALSE.
<P>
<P><PRE>    Reason: One of the primary purposes of the blocking hook function is to
    provide a mechanism for an application with a pending blocking
    operation to yield. By returning FALSE from the blocking hook function,
    you defeat this purpose and your application prevents multitasking in
    the non-preemptive 16-bit Windows environment. This also prevents some
    WinSock implementations from completing the pending network operation.
</PRE><P>
<P><PRE>    Workaround: Sub-class the active window. This prevents re-entrant
    messages.
</PRE>
<P><LI>Client applications that bind to a specific port.
<P>
<P><PRE>    Reason: Client applications actively initiate a network communication.
    Server applications passively wait for communication. A server must
    bind() to a specific port which is known to clients that need to use
    the service. However, a client does not need to bind() its socket to a
    specific port to communicate with a server.
</PRE><P>
<P><PRE>    Workaround: Let the WinSock implementation assign the local port number
    implicitly when you call connect() (on stream or datagram sockets) or
    sendto() (on datagram sockets).
</PRE>
<P><LI>Nagle challenged applications.
<P>
<P><PRE>    Reason: The Nagle algorithm reduces trivial network traffic. The
    algorithm recommends that you do not send a TCP segment until:
</PRE><P>
<P><PRE>     - All outstanding TCP segments have been acknowledged
</PRE><P>
<P><PRE>     -or-
</PRE><P>
<P><PRE>     - There is a full TCP segment ready to send.
</PRE><P>
<P><PRE>    A "Nagle challenged application" is one that cannot wait until either
    of these conditions occurs. However, it has time-critical data that it
    must send continuously. This results in unwanted network traffic.
</PRE><P>
<P><PRE>    Workaround: Do not write applications that depend on the immediate data
    echo from the remote TCP host.
</PRE>
<P><LI>Assuming stream sockets maintain message frame boundaries.
<P>
<P><PRE>    Reason: Stream sockets (TCP) provide data streams. The largest message
    length an application can depend on is one-byte in length. This means
    that with any call to send() or recv(), the WinSock implementation may
    transfer any number of bytes less than the buffer length specified.
</PRE><P>
<P><PRE>    Workaround: Whether you use a blocking or non-blocking socket, compare
    the return from send() or recv() with the expected value. If the value
    is less than the expected value, adjust the buffer length and pointer
    for another function call (which may occur asynchronously, if you use
    asynchronous operation mode).
</PRE>
<P><LI>16-bit DLL's that call WSACleanup() from their WEP.
<P>
<P><PRE>    Reason: 16-bit Windows does not guarantee that WEP() is called and the
    Windows subsystem has been in frequent dis-array.
</PRE><P>
<P><PRE>    Workaround: Do not use WEP().
</PRE>
<P><LI>Single-byte send() and recv().
<P>
<P><PRE>    Reason: Couple one-byte sends with Nagle disabled.
</PRE><P>
<P><PRE>    Workaround: Send modest amounts and receive as much as possible.
</PRE>
<P><LI>Select().
<P>
<P><PRE>    Reason: Consider the steps involved in using select(). You must use the
    macros to clear the three fdsets, then set the appropriate fdsets for
    each socket, then set the timer, and then call select().
</PRE><P>
<P><PRE>    Workaround: Use asynchronous operation mode.
</PRE>
<P><LI>Applications that call gethostbyname() before calling inet_addr().
<P>
<P><PRE>    Reason: Some users prefer to use network addresses rather than
    host names. The WinSock version 1.1 specification does not specify what
    gethostbyname() should do with an IP address in standard ASCII dotted
    IP notation. As a result, the outcome is unpredictable. It may succeed
    and do a reverse-lookup, or it may fail.
</PRE><P>
<P><PRE>    Workaround: With any destination input by a user (which may be a host
    name or dotted IP address), call inet_addr() first to check for an IP
    address, and if that fails, call gethostbyname() to try to resolve it.
</PRE><P>
<P><PRE>    Furthermore, in some applications, you may want to explicitly check the
    input string for the broadcast address "255.255.255.255," because the
    return value from inet_addr() for this address is the same as
    SOCKET_ERROR.
</PRE>
<P><LI>Win32 applications that install blocking hooks.
<P>
<P><PRE>    Reason: Aside from yielding to other applications (please see item 15
    above), blocking hook functions are designed to allow concurrent
    processing within a task, while there is a blocking operation pending.
    In Win32, there are threads.
</PRE><P>
<P><PRE>    Workaround: Use threads.
</PRE>
<P><LI>Polling with ioctlsocket(FIONREAD) on a stream socket until a complete
<P><PRE>    "message" appears.
</PRE><P>
<P><PRE>    Reason: A stream socket (TCP) does not preserve message boundaries
    (please see item 18 above). An application that uses ioctlsocket()
    FIONREAD or recv(MSG_PEEK) to wait for a complete "message" to arrive
    may not succeed. One reason is due to the internal WinSock system
    buffering. If the bytes in a "message" straddle a system buffer
    boundary, the WinSock does not report bytes that exist in other
    buffers.
</PRE><P>
<P><PRE>    Workaround: Do not use peek reads. Read data into your application
    buffers and examine it there.
</PRE>
<P><LI>Assuming that a UDP datagram of any length may be sent.
<P>
<P><PRE>    Reason: Various networks all have their limitations on maximum
    transmission unit (MTU).
</PRE><P>
<P><PRE>    Workaround: Check for the maximum datagram size with the SO_MAX_MSGSIZE
    socket option.
</PRE>
<P><LI>Assuming the UDP transmissions (especially multicast transmissions) are
<P><PRE>    reliable.
</PRE><P>
<P><PRE>    Reason: UDP has no reliability mechanisms.
</PRE><P>
<P><PRE>    Workaround: Use TCP and keep track of your own message boundaries.
</PRE>
<P><LI>Applications that require vendor-specific extensions, and cannot run
<P><PRE>    (or load) without them.
</PRE><P>
<P><PRE>    Workaround: Have a fall-back position that uses only base capabilities
    for when the extension functions are not present.
<P></BLOCKQUOTE>
</OL>

	</FONT>
	</TD>
	</TR>
</TABLE>
<P>


<!--DOCBODY_END-->

<!--FOOTER_START-->
<table cellpadding=5 border=0 width="90%">
<tr>
<td>
	<HR WIDTH="90%">

<BLOCKQUOTE>
<FONT FACE="Verdana, Arial, Helvetica" SIZE="1">
<SPAN STYLE="font-family:verdana,arial,helvetica; font-size:8pt">
Additional query words: prodnt rfc<BR>
Keywords          : NTSrvWkst nttcp kbnetwork<BR>
Version           : WinNT:3.5,3.51,4.0<BR>
Platform          : winnt<BR>
Issue type        : kbref<BR>

</SPAN>
</FONT>
<BR>
<BR>
THE INFORMATION PROVIDED IN THE MICROSOFT KNOWLEDGE BASE IS
PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND.  MICROSOFT DISCLAIMS
ALL WARRANTIES, EITHER EXPRESS OR IMPLIED, INCLUDING THE WARRANTIES
OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  IN NO
EVENT SHALL MICROSOFT CORPORATION OR ITS SUPPLIERS BE LIABLE FOR
ANY DAMAGES WHATSOEVER INCLUDING DIRECT, INDIRECT, INCIDENTAL,
CONSEQUENTIAL, LOSS OF BUSINESS PROFITS OR SPECIAL DAMAGES, EVEN IF
MICROSOFT CORPORATION OR ITS SUPPLIERS HAVE BEEN ADVISED OF THE
POSSIBILITY OF SUCH DAMAGES.  SOME STATES DO NOT ALLOW THE EXCLUSION
OR LIMITATION OF LIABILITY FOR CONSEQUENTIAL OR INCIDENTAL DAMAGES
SO THE FOREGOING LIMITATION MAY NOT APPLY.
</BLOCKQUOTE>
<P>
<center>
	<FONT FACE="Verdana,Arial,Helvetica" SIZE="1">
	Last reviewed:  October 15, 1997</FONT>
	<BR>
	<A href="../cpyright.htm" STYLE="font: bold 7pt Verdana,Arial,Helvetica">&copy; 1998 Microsoft Corporation. All rights reserved. Terms of Use.</A><BR>
	
</center>
</td>
</tr>
</table>

<!--FOOTER_END-->
</FONT>
</BODY>
</HTML>
