

<HTML>
<HEAD>
<TITLE>Performance Enhancements for SQL Server Under Windows NT </TITLE>

<!--STYLE_BEGIN-->
<style>@import url(../../msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="../../msdn_ie3.css">
<!--STYLE_END-->

<META HTTP-EQUIV="CONTENT-Type" CONTENT="text/html; charset=us-ascii">
<META NAME="ms.locale" CONTENT="EN-US">
<META NAME="Category" CONTENT="Support; KB Article">
<META NAME="KBID" CONTENT="Q160606">
<META NAME="KBModify" CONTENT="1997/08/13">
<META NAME="KBCreate" CONTENT="1996/12/06">
<META NAME="Keywords" CONTENT="kbbug4.00 kbfix4.00.sp2 NTSrvWkst kbnetwork">
<META NAME="KBArea" CONTENT="Support; KB; winnt, crossnet, iis">
<META NAME="Description" CONTENT="  A new interface was added as a performance enhancement for SQL Server when running under Windows NT. This enhancement involves scatter/gather I/O functionality.  MORE INFORMATION  What is Scatter/Gather?  Scatter/gather is a standard technique used...">
<META NAME="Product" CONTENT="Windows NT">
<META NAME="Platform" CONTENT="Windows">
<META NAME="Technology" CONTENT=" ">
<META NAME="Premium" CONTENT="support">

<META NAME="nyms" CONTENT="QAUD,QAY5,QBWP,QBBI,QBQU,QA8T,QDIR,QAYY,QALW,QBFN,QBV8,QAB9,QAIC,QACI,QAO3 V02180118">
</HEAD>

<BODY BGCOLOR="#FFFFFF" LEFTMARGIN="0" RIGHTMARGIN="0" TOPMARGIN="0">


<!--DOCBODY_START-->
<BR>
<CENTER>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" VALIGN="top" WIDTH="90%">
	<TR>
		<TD VALIGN="top">
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<H1>Performance Enhancements for SQL Server Under Windows NT</H1>
			</FONT>
			<FONT FACE="verdana,arial,helvetica" SIZE="1">
			Last reviewed:  August 13, 1997</FONT><BR>
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<B>Article ID: Q160606</B>
			</FONT>
		</TD>
	</TR>
	<TR>
	<TD>
	<FONT FACE="Verdana, Arial, Helvetica" SIZE=2>



 
 
The information in this article applies to:

<UL><LI>Microsoft Windows NT Workstation version 4.0
<LI>Microsoft Windows NT Server version 4.0
</UL> 
<P>
<P><h2>SUMMARY</h2>
 
<P>
A new interface was added as a performance enhancement for SQL Server when
running under Windows NT. This enhancement involves scatter/gather I/O
functionality.
<P>
MORE INFORMATION
 
<P>
<P><h3>What is Scatter/Gather?</h3>
 
<P>
Scatter/gather is a standard technique used in some high-performance I/O
situations. It typically refers to Direct Memory Access (DMA) transfers. A
given block of data might exist in memory as several discrete buffers.
Without scatter/gather, when setting up a memory-to-disk transfer, the
operating system will often do a transfer for each buffer, or block move
them to a single larger buffer before initiating the transfer. Both of
these are inefficient. It is better if the operating system/driver/hardware
gathers up the data from the discrete locations in memory and transfers
them "in place" as a single operation. Likewise, on input from disk, if the
data block is scattered directly to the necessary locations in memory
without intermediate block moves, and so on, it is faster.
<P>
<P><h3>Interface Specification</h3>
 
<P>
ReadFileScatter
<P>
The ReadFileScatter function reads data from a file, starting at the
position indicated by the file offset in the OVERLAPPED structure, and
distributes the data into multiple user buffers.
<P>
BOOL ReadFileScatter(
<PRE>    HANDLE hFile,                         // handle of file to read
    FILE_SEGMENT_ELEMENT aSegmentArray[], // array of buffer segments that
</PRE>receives data
<PRE>    DWORD nNumberOfBytesToRead,           // number of bytes to read
    LPDWORD lpReserved,                   // reserved must be NULL
    LPOVERLAPPED lpOverlapped             // address of structure for data
   );

</PRE>Parameters
<P>
hFile
<P>
<PRE>   Identifies the file to be read. The file handle must have been created
   with GENERIC_READ access to the file.

   The file must be opened using FILE_FLAG_OVERLAPPED to specify
   asynchronous I/O, and FILE_FLAG_NO_BUFFERING to specify non-cached I/O.

</PRE>aSegmentArray
<P>
<PRE>   Points an array of pointers to segments. A segment is a memory buffer
   where part of the transferred data should be placed. Segments are system
   page sized and must be aligned on a page size boundary.

   The memory segment can be allocated using VirtualAllocVlm, or can be
   normal 32-Bit address memory but not both.

</PRE>NNumberOfBytesToRead
<P>
<PRE>   Specifies the number of bytes to be read from the file.

</PRE>lpReserved
<P>
<PRE>   Reserved must be NULL.

</PRE>lpOverlapped
<P>
<PRE>   Points to an OVERLAPPED structure. This structure is required and must
   point to a valid OVERLAPPED structure.

</PRE>The read operation starts at the offset specified in the OVERLAPPED
structure and ReadFileScatter may return before the read operation has been
completed. In this case, ReadFileScatter returns FALSE and the GetLastError
function returns ERROR_IO_PENDING. This allows the calling process to
continue while the read operation finishes. The application can use either
GetOverlappedResult/HasOverlappedIoCompleted to pick up I/O completion
notification, or GetQueuedCompletionStatus to pick up I/O completion.
<P>
Return Values
<P>
If the function succeeds, the return value is nonzero. If the function
fails, the return value is zero. To get extended error information, call
GetLastError. If ReadFileScatter attempts to read past the end of the file,
the function returns zero, and GetLastError returns ERROR_HANDLE_EOF
<P>
Remarks
<P>
Each FILE_SEGMENT_ELEMENT is 64 bits long. All 64 bits are used to
calculate the buffer pointer; therefore, applications must explicitly zero
the upper 32 bits of the element on systems which do not support 64-bit
pointers.
<P>
WriteFileGather
<P>
The WriteFileGather function gathers data from multiple buffers and writes
the data to a file.  The function is designed for  asynchronous operation.
The function starts writing data to the file at the position specified by
the OVERLAPPED structure.
<P>
BOOL WriteFileGather(
<PRE>    HANDLE hFile,                // handle to file to write to
    FILE_SEGMENT_ELEMENT aSegmentArray [], // array of buffer segments
</PRE>containing the data
<PRE>    DWORD nNumberOfBytesToWrite,    // number of bytes to write
    LPDWORD lpReserved,             // Reserved must be NULL
    LPOVERLAPPED lpOverlapped       // pointer to structure needed for
</PRE>overlapped I/O
<PRE>   );

</PRE>Parameters
<P>
hFile
<P>
<PRE>   Identifies the file to be written to. The file handle must have been
   created with GENERIC_WRITE access to the file. The file must be opened
   using FILE_FLAG_OVERLAPPED to specify asynchronous I/O, and
   FILE_FLAG_NO_BUFFERING to specify non-cached I/O.

</PRE>aSegmentArray
<P>
<PRE>   Points an array of pointers to segments. A segment is a memory buffer
   where part of the transferred data should be placed. Segments are system
   page sized and must be aligned on a page size boundary. The memory
   segment can be allocated using VirtualAllocVlm, or can be normal 32-bit
   address memory, but not both.

</PRE>NNumberOfBytesToWrite
<P>
<PRE>   Specifies the number of bytes to write to the file.

   Unlike the MS-DOS operating system, Windows NT interprets a value of
   zero as specifying a null write operation. A null write operation does
   not write any bytes but does cause the time stamp to change.

</PRE>lpReserved
<P>
<PRE>   Reserved must be NULL.

</PRE>LpOverlapped
<P>
<PRE>   Points to an OVERLAPPED structure. This structure is required and must
   point to a valid OVERLAPPED structure. The write operation starts at the
   offset specified in the OVERLAPPED structure and WriteFileGather may
   return before the write operation has been completed. In this case,
   WriteFileGather returns FALSE and the GetLastError function returns
   ERROR_IO_PENDING. This allows the calling process to continue processing
   while the write operation is being completed. The application can use
   either GetOverlappedResult/HasOverlappedIoCompleted to pick up I/O
   completion notification, or GetQueuedCompletionStatus to pick up I/O
   completion.

</PRE>Return Values
<P>
If the function succeeds, the return value is nonzero. If the function
fails, the return value is zero. To get extended error information, call
GetLastError.
<P>
Remarks
<P>
Each FILE_SEGMENT_ELEMENT is 64 bits long. All 64 bits are used to
calculate the buffer pointer; therefore, applications must explicitly zero
the upper 32 bits of the element on systems which do not support 64-bit
pointers.
<P>
If part of the file is locked by another process and the write operation
overlaps the locked portion, this function fails.
<P>
Unlike the MS-DOS operating system, Windows NT interprets zero bytes to
write as specifying a null write operation and WriteFileGather does not
truncate or extend the file. To truncate or extend a file, use the
SetEndOfFile function.
<P>
<P><h2>STATUS</h2>
 
<P>
Microsoft has confirmed this to be a problem in Windows NT version 4.0.
This problem was corrected in the latest US Service Pack for Windows NT.
For information on obtaining this update, query on the following word in
the Microsoft Knowledge Base (without the spaces):
<P>
<PRE>   S E R V P A C K
</PRE>

	</FONT>
	</TD>
	</TR>
</TABLE>
<P>


<!--DOCBODY_END-->

<!--FOOTER_START-->
<table cellpadding=5 border=0 width="90%">
<tr>
<td>
	<HR WIDTH="90%">

<BLOCKQUOTE>
<FONT FACE="Verdana, Arial, Helvetica" SIZE="1">
<SPAN STYLE="font-family:verdana,arial,helvetica; font-size:8pt">
Additional query words: prodnt SQL<BR>
Keywords          : kbbug4.00 kbfix4.00.sp2 NTSrvWkst kbnetwork<BR>
Version           : 4.0<BR>
Platform          : winnt<BR>

</SPAN>
</FONT>
<BR>
<BR>
THE INFORMATION PROVIDED IN THE MICROSOFT KNOWLEDGE BASE IS
PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND.  MICROSOFT DISCLAIMS
ALL WARRANTIES, EITHER EXPRESS OR IMPLIED, INCLUDING THE WARRANTIES
OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  IN NO
EVENT SHALL MICROSOFT CORPORATION OR ITS SUPPLIERS BE LIABLE FOR
ANY DAMAGES WHATSOEVER INCLUDING DIRECT, INDIRECT, INCIDENTAL,
CONSEQUENTIAL, LOSS OF BUSINESS PROFITS OR SPECIAL DAMAGES, EVEN IF
MICROSOFT CORPORATION OR ITS SUPPLIERS HAVE BEEN ADVISED OF THE
POSSIBILITY OF SUCH DAMAGES.  SOME STATES DO NOT ALLOW THE EXCLUSION
OR LIMITATION OF LIABILITY FOR CONSEQUENTIAL OR INCIDENTAL DAMAGES
SO THE FOREGOING LIMITATION MAY NOT APPLY.
</BLOCKQUOTE>
<P>
<center>
	<FONT FACE="Verdana,Arial,Helvetica" SIZE="1">
	Last reviewed:  August 13, 1997</FONT>
	<BR>
	<A href="../cpyright.htm" STYLE="font: bold 7pt Verdana,Arial,Helvetica">&copy; 1998 Microsoft Corporation. All rights reserved. Terms of Use.</A><BR>
	
</center>
</td>
</tr>
</table>

<!--FOOTER_END-->
</FONT>
</BODY>
</HTML>
