

<HTML>
<HEAD>
<TITLE>INFO: Using ActiveX Data Objects (ADO) via #import in VC++ </TITLE>

<!--STYLE_BEGIN-->
<style>@import url(../../msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="../../msdn_ie3.css">
<!--STYLE_END-->

<META HTTP-EQUIV="CONTENT-Type" CONTENT="text/html; charset=us-ascii">
<META NAME="ms.locale" CONTENT="EN-US">
<META NAME="Category" CONTENT="Support; KB Article">
<META NAME="KBID" CONTENT="Q169496">
<META NAME="KBModify" CONTENT="1998/02/12">
<META NAME="KBCreate" CONTENT="1997/06/03">
<META NAME="Keywords" CONTENT="kbcode kbusage adoall adovc">
<META NAME="KBArea" CONTENT="Support; KB; adobj">
<META NAME="Description" CONTENT="  The #import directive in Visual C++ offers a powerful new mechanism for manipulating OLE servers. When used with ActiveX Data Objects (ADO), #import can simplify getting at your data. This article discusses what is necessary to take advantage of #i...">
<META NAME="Product" CONTENT="adobj">
<META NAME="Platform" CONTENT="Windows">
<META NAME="Technology" CONTENT=" ">
<META NAME="Premium" CONTENT="support">

<META NAME="nyms" CONTENT="QAPN,QAAP,QAB4,QBBS,QAO3,QAH4,QAEQ,QARZ,QAO2,QAW6,QBG2,QAI5,QAH6,QAYY,QBFY V02180118">
</HEAD>

<BODY BGCOLOR="#FFFFFF" LEFTMARGIN="0" RIGHTMARGIN="0" TOPMARGIN="0">


<!--DOCBODY_START-->
<BR>
<CENTER>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" VALIGN="top" WIDTH="90%">
	<TR>
		<TD VALIGN="top">
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<H1>INFO: Using ActiveX Data Objects (ADO) via #import in VC++</H1>
			</FONT>
			<FONT FACE="verdana,arial,helvetica" SIZE="1">
			Last reviewed:  February 12, 1998</FONT><BR>
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<B>Article ID: Q169496</B>
			</FONT>
		</TD>
	</TR>
	<TR>
	<TD>
	<FONT FACE="Verdana, Arial, Helvetica" SIZE=2>



 
 
The information in this article applies to:

<UL><LI>ActiveX Data Objects (ADO) included with:
   - Microsoft Visual C++, 32-bit Editions, versions 4.2, 5.0
</UL> 
<P>
<P><h2>SUMMARY</h2>
 
<P>
The #import directive in Visual C++ offers a powerful new mechanism for
manipulating OLE servers. When used with ActiveX Data Objects (ADO),
#import can simplify getting at your data. This article discusses what is
necessary to take advantage of #import with ADO.
<P>
<P><h2>MORE INFORMATION</h2>
 
<P>
<P><h3>Before You Instantiate Any Classes Created by #import</h3>
 
<P>
It's important to initialize OLE before creating any instances of classes
created by #import. For example, the code below is safe, as it declares a
#import smart pointer, then initializes OLE, then instantiates the smart
pointer:
<P>
<PRE>   // Declare smart pointer of Recordset
    _RecordsetPtr     p;

   void main( void )
   {
      // Initialize OLE.
      ::CoInitialize(NULL);

      // Instantiate smart pointer.
      HRESULT hr = p.CreateInstance( __uuidof( Recordset ) );

      ...
   }

</PRE>The next code sample, however, is not safe and will generate an unhandled
exception. The global smart pointer p is both declared and instantiated (by
virtue of passing a specific uuid in the constructor):
<P>
<PRE>   // Declare &amp; instantiate smart pointer of Recordset
    _RecordsetPtr     p( __uuidof( _Recordset ) );

   void main( void )
   {
      // Initialize OLE
      ::CoInitialize(NULL);

      ...
   }

</PRE>Because p is a global variable, it is instantiated before CoInitialize is
ever called in main(). You can correct this with the code snippet below:
<P>
<PRE>   struct InitOle {
      InitOle()  { ::CoInitialize(NULL); }
      ~InitOle() { ::CoUninitialize();   }
    } _init_InitOle_;

   // Declare &amp; instantiate smart pointer of Recordset
    _RecordsetPtr     p( __uuidof( _Recordset ) );

   ...

</PRE>An instance of the struct InitOle is declared, and instantiated before p,
and, therefore, initializes OLE in it's constructor. Without this kind of
fail-safe, you will see the following error message:
<P>
<PRE>   Unhandled exception in [Program] (KERNEL32.DLL): 0xE06D7363
   Microsoft C++ Exception.

</PRE><h3>Correct Implementation of #import</h3>
 
<P>
It is important to invoke ADO correctly in your program, or you can have
compiler errors. Below shows the correct way to use #import with
Msado10.dll:
<P>
<PRE>   #import "C:\oledbsdk\redist\msado10.dll" \
           no_namespace                     \
           rename( "EOF", "adoEOF" )

</PRE>The actual path to Msado10.dll may vary depending on how you installed ADO;
however, the other two arguments are critical.
<P>
Passing the License Key to ADO and ADO Redistribution
 
<P>
ADO, while freely redistributable, does require a license key when run
on any system that had ADO installed in a mechanism other than a Microsoft
product. For more information on how to pass a license key to ADO using
#import and how to redistribute required ADO and OLE-DB DLLs, please see
the articles listed in the REFERENCES section below.
<P>
<P><h3>Error Handling</h3>
 
<P>
With ADO, you may get an error in the HRESULT returned from an ADO method,
you may get an exception raised by #import generated classes, and for
either condition the ADO Errors Collection may be populated. In order to
get at the Errors Collection you need a valid connection object.
<P>
For more information please see the following article:
<P>
<PRE>   ARTICLE-ID: <B><A href="../adobj/q169498.htm">Q169498</A></B>
   TITLE:      INFO: Extracting Error Information from ADO in VC++ with
               #import

</PRE><h3>ADO and Dbdaoint.h</h3>
 
<P>
If you attempt to mix ADO (via #import) and either MFC DAO or the DAO SDK
in the same implementation file, as shown below:
<P>
<PRE>   #include &lt;afxdao.h&gt;  // MFC DAO
   // -or-
   #include &lt;dbdao.h&gt;   // DAO SDK

   #import "...msado10.dll" no_namespace ...

</PRE>ADO will generate the following six errors:
<P>
<PRE>   error C2011: 'EditModeEnum' : 'enum' type redefinition
   error C2011: 'LockTypeEnum' : 'enum' type redefinition
   error C2011: 'FieldAttributeEnum' : 'enum' type redefinition
   error C2011: 'DataTypeEnum' : 'enum' type redefinition
   error C2011: 'ParameterDirectionEnum' : 'enum' type redefinition
   error C2011: 'RecordStatusEnum' : 'enum' type redefinition

</PRE>While very nearly identical in content, the actual values in each
enumerated type differ between what is required by ADO and what is required
by DAO. You have several options to work around this:

<UL><LI>Separate ADO and DAO code into separate .cpp files. Keep the use of
   #import or #include &lt;afxdao.h/dbdao.h&gt; in separate implementation
   files as well.

<LI>Modify the #import statement to create a namespace for anything
   generated for ADO. This means you will have to reference the
   namespace when referencing an ADO object as shown in the two functions
   below. The first shows how to use ADO exclusively within a function.
   The second shows how to mix-and-match ADO and DAO objects. This is
   possible only by explicitly referencing the ADO namespace for any ADO
   class or enumerated type:
<P>
<P><PRE>      #include &lt;afxdao.h&gt;
</PRE><P>
<P><PRE>      #import "C:\oledbsdk\redist\msado10.dll" \
<PRE></PRE>              rename_namespace("AdoNS") rename( "EOF", "adoEOF" )

      void ADOOnly( void )
      {
          using namespace AdoNS;

          _RecordsetPtr   prs;

          // Generates Compile Errors:
          CDaoRecordset   rs;
      }

      void MixAdoAndDao( void )
      {
          AdoNS::_RecordsetPtr  prs;

          // Compiles just fine
          CDaoRecordset   drs;
      }

</PRE></UL><h3>Dissecting and using Msado10.tlh/Msado10.tli</h3>
 
<P>
#import generates two files, Msado10.tlh and Msado10.tli off of the typelib
contained within Msado10.dll. The structure of the .tlh file can be broken
out as follows:

<UL><LI>Forward References and Typedefs
<LI>Smart Pointer Typedef and Declarations
<LI>Type Library Items
<P>
</UL>Each is described in detail below.
<P>
<P><h3>Forward References and Typedefs</h3>
 
<P>
Forward References and Typedefs are created through the use of struct
__declspec(uuid("...")) on the GUID for any Dual Interface, Interface, and
CoClass defined in the typelib.
<P>
<PRE>   ...
   struct __declspec(uuid("00000274-0000-0010-8000-00aa006d2ea4"))
   /* dual interface */ _Connection;
   ...
   struct __declspec(uuid("00000275-0000-0010-8000-00aa006d2ea4"))
   /* interface */ ICADOConnection;
   ...
   struct /* coclass */ Connection;
   ...

</PRE>Not all interfaces, such as Connection, have multiple implementations.
This depends on the typelib, but for ADO most interfaces are dual and not
implemented as interface or coclass.
<P>
<P><h3>Smart Pointer TypeDef Declarations</h3>
 
<P>
For Interfaces and Dual Interfaces, smart pointers are declared, which
greatly simplifies using the interface:
<P>
<PRE>   ...
   _COM_SMARTPTR_TYPEDEF(_Connection, __uuidof(_Connection));
   ...
   _COM_SMARTPTR_TYPEDEF(ICADOConnection, __uuidof(ICADOConnection));
   ...

</PRE>Note that no smart pointer was declared for the coclass Connection
interface.
<P>
<P><h3>Type Library Items</h3>
 
<P>
This includes any enumerated types defined in the typelib, as well
implementation of the smart pointers and typelib items:
<P>
<PRE>   enum CursorTypeEnum
   {
      adOpenUnspecified = -1,
      adOpenForwardOnly = 0,
      adOpenKeyset = 1,
      adOpenDynamic = 2,
      adOpenStatic = 3
   };

   ...

   struct __declspec(uuid("00000274-0000-0010-8000-00aa006d2ea4"))
   _Connection : _ADO
   {
      //
      // Property data
      //
      _declspec(property(get=GetConnectionString,
                         put=PutConnectionString))
      _bstr_t ConnectionString;
      ...

      //
      // Wrapper methods for error-handling
      //
      _bstr_t GetConnectionString ( );
      void PutConnectionString (
          _bstr_t pbstr );
      ...

      //
      // Raw methods provided by interface
      //
      virtual HRESULT __stdcall get_ConnectionString (
          BSTR * pbstr ) = 0;
      virtual HRESULT __stdcall put_ConnectionString (
          BSTR pbstr ) = 0;
      ...
   };

</PRE>In the code fragment above, the Property Data section uses declspec to
declare get and put methods for ConnectionString. The Wrapper methods
section provides methods created by #import, which wrap these methods, and
raise an _com_error exception if they are not successful. The Raw
Methods section declares the actual method that is invoked by the
interface.
<P>
While you could call GetConnectionString or PutConnectionString, it is
really unnecessary. Since ConnectionString is a property you would
reference it as shown below:
<P>
<PRE>   _ConnectionPtr   p;
   bstr             bstrConnect;
   ...
   bstrConnect = SysAllocString( L"DSN=AdoDemo;UID=admin;PWD=sa" );
   p-&gt;ConnectionString = bstrConnect;

</PRE>The actual implementation of GetConnectionString/PutConnectionString can be
found in the Msado10.tli file.
<P>
When it comes time to use the Connection object in your code, you would use
an instance of the smart pointer for the dual interface defined in
Msado10.tlh as shown below:
<P>
<PRE>   _ConnectionPtr p;
   bstrConnect
   HRESULT           hr = S_OK;
   _ConnectionPtr    pConn;

   hr = pConn.CreateInstance( __uuidof( Connection ) );

      if( !FAILED( hr ) )
          hr = pConn-&gt;Open( L"AdoDemo", L"admin", L"" );

</PRE>Where AdoDemo is an ODBC data source.
<P>
<P><h3>#import and Explicitly Calling Release()</h3>
 
<P>
The advantage of #import is that it takes care of AddRef, QueryInterface,
and Release for you automatically. However, if you decide to start calling
Release() explicitly, you can create problems for yourself.
<P>
Within _com_ptr_t is a member variable, m_pInterface. As #import is a very
thin wrapper, it makes no distinction with m_pInterface after the object is
actually released, versus just decrementing its reference count without
actually destroying the object.  By explicitly calling Release()--without
very explicitly calling AddRef() to balance it--#import will gladly try to
release an object that doesn't exist, creating interesting side effects and
crashing behavior.
<P>
Best advice, you didn't AddRef() it (or at least no need to), don't release
it either.
<P>
<P><h2>REFERENCES</h2>
 
<P>
- Inside Com by Dale Rogerson ISBN 1-57231-349-8

<UL><LI>The OLE-COM Object Viewer (Oleview.exe) that ships with Visual C++ for
   examining the contents of a typelib.

<LI>Visual C++ online documentation: search on #import
<P>
</UL>For more information, see the following articles in the Microsoft Knowledge
Base:
<P>
<PRE>   ARTICLE-ID:  <B><A href="../adobj/q166112.htm">Q166112</A></B>
   TITLE:       PRB: Conflict with EOF when using #import with ADO

   ARTICLE-ID:  <B><A href="../adobj/q170459.htm">Q170459</A></B>
   TITLE:       HOWTO: Passing a License Key to ADO in Visual C++ Using
                #import

   ARTICLE-ID:  <B><A href="../adobj/q168122.htm">Q168122</A></B>
   TITLE:       HOWTO: Redistribute ADO 1.0 or ADO/R 1.0 with OLE/DB 1.1

   ARTICLE-ID: <B><A href="../adobj/q168354.htm">Q168354</A></B>
   TITLE     : INFO: Underlying OLE and OLEDB Provider Errors Exposed via
               ADO
</PRE> 
<PRE>Keywords          : kbcode kbusage adoall adovc
Technology        : kbMfc
Platform          : WINDOWS
Issue type        : kbinfo</PRE>

	</FONT>
	</TD>
	</TR>
</TABLE>
<P>


<!--DOCBODY_END-->

<!--FOOTER_START-->
<table cellpadding=5 border=0 width="90%">
<tr>
<td>
	<HR WIDTH="90%">

<BLOCKQUOTE>
<FONT FACE="Verdana, Arial, Helvetica" SIZE="1">
<SPAN STYLE="font-family:verdana,arial,helvetica; font-size:8pt">
================================================================================<BR>

</SPAN>
</FONT>
<BR>
<BR>
THE INFORMATION PROVIDED IN THE MICROSOFT KNOWLEDGE BASE IS
PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND.  MICROSOFT DISCLAIMS
ALL WARRANTIES, EITHER EXPRESS OR IMPLIED, INCLUDING THE WARRANTIES
OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  IN NO
EVENT SHALL MICROSOFT CORPORATION OR ITS SUPPLIERS BE LIABLE FOR
ANY DAMAGES WHATSOEVER INCLUDING DIRECT, INDIRECT, INCIDENTAL,
CONSEQUENTIAL, LOSS OF BUSINESS PROFITS OR SPECIAL DAMAGES, EVEN IF
MICROSOFT CORPORATION OR ITS SUPPLIERS HAVE BEEN ADVISED OF THE
POSSIBILITY OF SUCH DAMAGES.  SOME STATES DO NOT ALLOW THE EXCLUSION
OR LIMITATION OF LIABILITY FOR CONSEQUENTIAL OR INCIDENTAL DAMAGES
SO THE FOREGOING LIMITATION MAY NOT APPLY.
</BLOCKQUOTE>
<P>
<center>
	<FONT FACE="Verdana,Arial,Helvetica" SIZE="1">
	Last reviewed:  February 12, 1998</FONT>
	<BR>
	<A href="../cpyright.htm" STYLE="font: bold 7pt Verdana,Arial,Helvetica">&copy; 1998 Microsoft Corporation. All rights reserved. Terms of Use.</A><BR>
	
</center>
</td>
</tr>
</table>

<!--FOOTER_END-->
</FONT>
</BODY>
</HTML>
