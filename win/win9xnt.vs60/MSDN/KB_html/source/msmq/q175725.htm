

<HTML>
<HEAD>
<TITLE>HOWTO: Using MSMQ C API Inside an MTS Component </TITLE>

<!--STYLE_BEGIN-->
<style>@import url(../../msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="../../msdn_ie3.css">
<!--STYLE_END-->

<META HTTP-EQUIV="CONTENT-Type" CONTENT="text/html; charset=us-ascii">
<META NAME="ms.locale" CONTENT="EN-US">
<META NAME="Category" CONTENT="Support; KB Article">
<META NAME="KBID" CONTENT="Q175725">
<META NAME="KBModify" CONTENT="1997/11/11">
<META NAME="KBCreate" CONTENT="1997/10/27">
<META NAME="Keywords" CONTENT="kbcode MQProg MQVC">
<META NAME="KBArea" CONTENT="Support; KB; msmq">
<META NAME="Description" CONTENT="  This article describes using the Microsoft Message Queue Server (MSMQ) C API from within Microsoft Transaction Server (MTS) components written with Visual C++. The two MSMQ transactional operations available are the message Send and Receive operati...">
<META NAME="Product" CONTENT="msmq">
<META NAME="Platform" CONTENT="Windows">
<META NAME="Technology" CONTENT=" ">
<META NAME="Premium" CONTENT="support">

<META NAME="nyms" CONTENT="QAPN,QAEV,QAUD,QAJG,QAH6,QBXJ,QAY5,QAYC,QASP,QAI4,QAW6,QAH4,QBVV,QAXC,QAGB V02180118">
</HEAD>

<BODY BGCOLOR="#FFFFFF" LEFTMARGIN="0" RIGHTMARGIN="0" TOPMARGIN="0">


<!--DOCBODY_START-->
<BR>
<CENTER>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" VALIGN="top" WIDTH="90%">
	<TR>
		<TD VALIGN="top">
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<H1>HOWTO: Using MSMQ C API Inside an MTS Component</H1>
			</FONT>
			<FONT FACE="verdana,arial,helvetica" SIZE="1">
			Last reviewed:  November 11, 1997</FONT><BR>
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<B>Article ID: Q175725</B>
			</FONT>
		</TD>
	</TR>
	<TR>
	<TD>
	<FONT FACE="Verdana, Arial, Helvetica" SIZE=2>



 
 
The information in this article applies to:

<UL><LI>Microsoft Message Queue Server version 1.0
<LI>Microsoft Transaction Server 1.0
<LI>Microsoft Visual Studio 97
</UL> 
<P>
<P><h2>SUMMARY</h2>
 
<P>
This article describes using the Microsoft Message Queue Server (MSMQ) C
API from within Microsoft Transaction Server (MTS) components written with
Visual C++. The two MSMQ transactional operations available are the message
Send and Receive operations.
<P>
You can include MSMQ Send operations in Microsoft Transaction Server (MTS)
transactions. This causes the send operation to be either committed or
rolled back along with the MTS transaction. As a result, the message is not
actually sent until the transaction commits. To include the send operation
in a transaction, use the MQ_MTS_TRANSACTION constant in the pTransaction
parameter of the MQSendMessage function from within a transactional MTS
component. MSMQ enlists the send operation in the MTS transaction. The
destination queue must be a transactional queue.
<P>
If the MTS component is not participating in a transaction, the send
operation described above fails with an MQ_ERROR_TRANSACTION_USAGE error.
This is because you cannot send a nontransactional message to a
transactional queue. You cannot always predict whether a component will
participate in a transaction. The component may be marked as "Does Not
Support Transactions" or "Supports Transactions" (in which case it may or
may not participate in a transaction). Therefore, it is important to verify
that the component is participating in the transaction and to use
MQ_MTS_TRANSACTION in the pTransaction parameter of MQSendMessage call to a
transactional queue only if it is participating. If it is not
participating, use the MQ_NO_TRANSACTION or MQ_SINGLE_MESSAGE constant with
the appropriate queue type.
<P>
For a local MSMQ transactional queue receive operation, specifying
MQ_MTS_TRANSACTION works regardless of whether or not the component is
transactional. The receive operation is included in a transaction only if
the component is transactional.
<P>
<P><h2>MORE INFORMATION</h2>
 
<P>
The following code demonstrates sending an MSMQ message containing a BSTR
from within an MTS component written using ActiveX Template Library (ATL).
The MTS context object is used to commit or abort the transaction. The
context object's IsInTransaction() method is used to determine whether or
not the component is transactional.
<P>
<PRE>   STDMETHODIMP CMsmqSample::MQSend(BSTR bstrSend)
   {
      IObjectContext *pContext = NULL ;  // The MTS context.
      HRESULT Hr  ;

      // The usual MSMQ structures.
      MQMSGPROPS MsgProps ;
      DWORD PropCnt = 0 ;
      MSGPROPID PropIDs[4] ;
      PROPVARIANT  PropVar[4] ;

      QUEUEHANDLE  hQueue = NULL ;
      ITransaction *pTransaction  ;

      try
   {
      // Get the MTS context object.
      Hr = GetObjectContext (&amp;pContext) ;
      if (FAILED (Hr)) throw Hr ;

      // Add code for database updates if needed.

      // Get the queue format name &amp; open the queue.
      WCHAR szwFormatName[256] ;
      DWORD dwFormatNameSize = 256 ;
      Hr = MQPathNameToFormatName (
             L"myMachine\\localx",
             szwFormatName,
             &amp;dwFormatNameSize) ;
      if (FAILED (Hr) ) throw Hr ;

      Hr = MQOpenQueue (
             szwFormatName,
             MQ_SEND_ACCESS,
             0,
             &amp;hQueue) ;
      if (FAILED (Hr) ) throw Hr ;

      // Assemble the message properties.
      PropIDs[PropCnt] = PROPID_M_BODY ;
      PropVar[PropCnt].vt = VT_VECTOR | VT_UI1 ;
      PropVar[PropCnt].caub.cElems = (SysStringLen (bstrSend) + 1) *
                                      sizeof (OLECHAR);
      PropVar[PropCnt].caub.pElems = (UCHAR *) bstrSend ;
      PropCnt++ ;

      PropIDs[PropCnt] = PROPID_M_LABEL ;
      PropVar[PropCnt].vt = VT_LPWSTR ;
      PropVar[PropCnt].pwszVal = L"C++ Transactional Message" ;
      PropCnt++ ;

      MsgProps.cProp = PropCnt;      //Number of properties.
      MsgProps.aPropID = PropIDs;    //Id of properties.
      MsgProps.aPropVar = PropVar;   //Value of properties.
      MsgProps.aStatus = NULL;       //Number of error reports.

      // Determine transaction type.
      // Since you are sending to a transactional queue, you must specify
      // MQ_SINGLE_MESSAGE if the object isn't in a transaction.
      pTransaction = MQ_MTS_TRANSACTION ;
      if ( ! pContext -&gt; IsInTransaction () )
         pTransaction = MQ_SINGLE_MESSAGE ;

      // Send the message.
      Hr = MQSendMessage(
              hQueue,            // Handle of queue.
              &amp;MsgProps,         // Message property structure.
              pTransaction) ;    // Transaction type.
      if (FAILED (Hr) ) throw Hr ;
  }
   catch (HRESULT hr)         // A failure occurred.
  {
      if (hQueue != NULL)
         MQCloseQueue (hQueue) ;

      if (pContext != NULL)
      {
         pContext -&gt; SetAbort () ;  // Abort the transaction.
         pContext -&gt; Release () ;
      }
      return hr ;
   }

   MQCloseQueue (hQueue) ;     // Close the queue.
   pContext -&gt; SetComplete () ;  // Commit the transaction.
   pContext -&gt; Release () ;    // Release the context object.

   return S_OK;
   }

</PRE>The following code demonstrates receiving an MSMQ message containing a BSTR
from within an MTS component written using ATL. The MTS context object is
used to commit or abort the transaction.
<P>
<PRE>   STDMETHODIMP CMsmqSample::MqReceive(BSTR * pbstrRcvMsg)
   {
      IObjectContext *pContext = NULL ;  // The MTS context.
      HRESULT Hr  ;

      // The usual MSMQ structures.
      MQMSGPROPS MsgProps ;
      DWORD PropCnt = 0 ;
      MSGPROPID PropIDs[4] ;
      PROPVARIANT  PropVar[4] ;

      QUEUEHANDLE  hQueue = NULL ;

      try
      {

      // Get the MTS context object.
      Hr = GetObjectContext (&amp;pContext) ;
      if (FAILED (Hr)) throw Hr ;

      // Add code for database updates if needed.

      // Get the queue format name &amp; open the queue.
      WCHAR szwFormatName[256] ;
      DWORD dwFormatNameSize = 256 ;
      Hr = MQPathNameToFormatName (
             L"myMachine\\localx",
             szwFormatName,
             &amp;dwFormatNameSize) ;
      if (FAILED (Hr) ) throw Hr ;

      Hr = MQOpenQueue (
             szwFormatName,
             MQ_RECEIVE_ACCESS,
             0,
             &amp;hQueue) ;
      if (FAILED (Hr) ) throw Hr ;

      // Assemble the message properties.
      #define MSG_BODY_LEN 500
      WCHAR wcBodyBuffer[MSG_BODY_LEN] = L"";

      PropIDs[PropCnt] = PROPID_M_BODY ;
      PropVar[PropCnt].vt = VT_VECTOR | VT_UI1 ;
      PropVar[PropCnt].caub.cElems = sizeof (wcBodyBuffer);
      PropVar[PropCnt].caub.pElems = (UCHAR *)wcBodyBuffer ;
      PropCnt++ ;

      MsgProps.cProp = PropCnt;      //No. of properties.
      MsgProps.aPropID = PropIDs;    //Id of properties.
      MsgProps.aPropVar = PropVar;   //Value of properties.
      MsgProps.aStatus = NULL;       //No. error reports.

      // Receive the message.
      Hr = MQReceiveMessage(
              hQueue,                // Handle of queue.
              0,                     // Timeout.
              MQ_ACTION_RECEIVE,     // Action.
              &amp;MsgProps,             // Message property structure.
              NULL,                  // OVERLAPPED structure.
              NULL,                  // Receive callback.
              NULL,                  // Cursor.
              MQ_MTS_TRANSACTION) ;  // Part of MTS Transaction.

      // For this application, return a blank string if there was no
      // message in the queue.
      if (Hr == MQ_ERROR_IO_TIMEOUT)
         *pbstrRcvMsg = SysAllocString (L"") ; // Return empty string.
      else if (FAILED (Hr) )
         throw Hr ;                       // Throw error.
      else
      {
         wcBodyBuffer[MSG_BODY_LEN - 1] = 0 ;
         *pbstrRcvMsg = SysAllocString (wcBodyBuffer) ; // Return message
                                                        // body to caller.
      }
   }
   catch (HRESULT hr)         // A failure occurred.
   {
      if (hQueue != NULL)
         MQCloseQueue (hQueue) ;

      if (pContext != NULL)
      {
         pContext -&gt; SetAbort () ;  // Abort the transaction.
         pContext -&gt; Release () ;
      }
      return hr ;
   }

   MQCloseQueue (hQueue) ;
   pContext -&gt; SetComplete () ;  // Commit the transaction.
   pContext -&gt; Release () ;     //  Release the context object.
   return S_OK;
   }

</PRE><h2>REFERENCES</h2>
 
<P>
For more details on using a single queue for send/receive and to avoid
queue and component type mismatch, see the following Knowledge Base
article:
<P>
<PRE>   ARTICLE-ID: <B><A href="../msmq/q174387.htm">Q174387</A></B>
   TITLE     : "INFO: Using a Single MSMQ Queue for an MTS Component"
</PRE>

	</FONT>
	</TD>
	</TR>
</TABLE>
<P>


<!--DOCBODY_END-->

<!--FOOTER_START-->
<table cellpadding=5 border=0 width="90%">
<tr>
<td>
	<HR WIDTH="90%">

<BLOCKQUOTE>
<FONT FACE="Verdana, Arial, Helvetica" SIZE="1">
<SPAN STYLE="font-family:verdana,arial,helvetica; font-size:8pt">
Additional query words: viper falcon<BR>
Keywords          : kbcode MQProg MQVC<BR>
Version           : WINNT:1.0,97<BR>
Platform          : winnt<BR>
Issue type        : kbhowto<BR>

</SPAN>
</FONT>
<BR>
<BR>
THE INFORMATION PROVIDED IN THE MICROSOFT KNOWLEDGE BASE IS
PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND.  MICROSOFT DISCLAIMS
ALL WARRANTIES, EITHER EXPRESS OR IMPLIED, INCLUDING THE WARRANTIES
OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  IN NO
EVENT SHALL MICROSOFT CORPORATION OR ITS SUPPLIERS BE LIABLE FOR
ANY DAMAGES WHATSOEVER INCLUDING DIRECT, INDIRECT, INCIDENTAL,
CONSEQUENTIAL, LOSS OF BUSINESS PROFITS OR SPECIAL DAMAGES, EVEN IF
MICROSOFT CORPORATION OR ITS SUPPLIERS HAVE BEEN ADVISED OF THE
POSSIBILITY OF SUCH DAMAGES.  SOME STATES DO NOT ALLOW THE EXCLUSION
OR LIMITATION OF LIABILITY FOR CONSEQUENTIAL OR INCIDENTAL DAMAGES
SO THE FOREGOING LIMITATION MAY NOT APPLY.
</BLOCKQUOTE>
<P>
<center>
	<FONT FACE="Verdana,Arial,Helvetica" SIZE="1">
	Last reviewed:  November 11, 1997</FONT>
	<BR>
	<A href="../cpyright.htm" STYLE="font: bold 7pt Verdana,Arial,Helvetica">&copy; 1998 Microsoft Corporation. All rights reserved. Terms of Use.</A><BR>
	
</center>
</td>
</tr>
</table>

<!--FOOTER_END-->
</FONT>
</BODY>
</HTML>
