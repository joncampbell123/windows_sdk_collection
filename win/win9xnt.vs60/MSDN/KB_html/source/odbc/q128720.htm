

<HTML>
<HEAD>
<TITLE>INF: Use of SQLPutData() in Visual Basic </TITLE>

<!--STYLE_BEGIN-->
<style>@import url(../../msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="../../msdn_ie3.css">
<!--STYLE_END-->

<META HTTP-EQUIV="CONTENT-Type" CONTENT="text/html; charset=us-ascii">
<META NAME="ms.locale" CONTENT="EN-US">
<META NAME="Category" CONTENT="Support; KB Article">
<META NAME="KBID" CONTENT="Q128720">
<META NAME="KBModify" CONTENT="1996/09/09">
<META NAME="KBCreate" CONTENT="1995/04/06">
<META NAME="Keywords" CONTENT="kbother kbcode">
<META NAME="KBArea" CONTENT="Support; KB; odbc">
<META NAME="Description" CONTENT="  When sending long data values for binary large objects (BLOBs), you should use SQLPutData() and send the data in chunks. This is primarily due to the limitation(s) imposed by the ODBC drivers in sending BLOBs.  For more information on calling SQLPu...">
<META NAME="Product" CONTENT="ODBC">
<META NAME="Platform" CONTENT="Windows">
<META NAME="Technology" CONTENT="ODBC ">
<META NAME="Premium" CONTENT="support">

<META NAME="nyms" CONTENT="QAY5,QA4Q,QA9E,QAGI,QAB9,QBV8,QACJ,QAHE,QAH4,QDNN,QBS0,QAIF,QAH6,QA7H,QANG V02180118">
</HEAD>

<BODY BGCOLOR="#FFFFFF" LEFTMARGIN="0" RIGHTMARGIN="0" TOPMARGIN="0">


<!--DOCBODY_START-->
<BR>
<CENTER>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" VALIGN="top" WIDTH="90%">
	<TR>
		<TD VALIGN="top">
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<H1>INF: Use of SQLPutData() in Visual Basic</H1>
			</FONT>
			<FONT FACE="verdana,arial,helvetica" SIZE="1">
			Last reviewed:  September 9, 1996</FONT><BR>
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<B>Article ID: Q128720</B>
			</FONT>
		</TD>
	</TR>
	<TR>
	<TD>
	<FONT FACE="Verdana, Arial, Helvetica" SIZE=2>



 
 
The information in this article applies to:

<UL><LI>Microsoft Open Database Connectivity, version 2.0
</UL> 
 
<P>
<P><h2>SUMMARY</h2>
 
<P>
When sending long data values for binary large objects
(BLOBs), you should use SQLPutData() and send the data in
chunks. This is primarily due to the limitation(s) imposed
by the ODBC drivers in sending BLOBs.
<P>
For more information on calling SQLPutData(), refer to the
"Microsoft ODBC 2.0 Programmer's Reference and SDK Guide."
<P>
The following is a small code sample written in Visual Basic
that illustrates the calling of the ODBC API SQLPutData() to
add data to a column.
<P>
<P><h2>MORE INFORMATION</h2>
 
<P>
<PRE>' Items found in (general) (declarations) in module
'
'Declarations required to call ODBC API from VB 4.0 and 3.0:
'
'If the application is 16-bit, include the following
'function declaration
</PRE>#If Win16 Then
<PRE>Declare Function GetFocus Lib "User" () As Integer
Declare Function GetParent Lib "User" (ByVal hWnd%) As
</PRE>Integer
<P>
<PRE>Declare Function SQLAllocConnect Lib "odbc.dll" (ByVal
</PRE>henv&amp;, phdbc&amp;) As Integer
<PRE>Declare Function SQLAllocEnv Lib "odbc.dll" (phenv&amp;) As
</PRE>Integer
<PRE>Declare Function SQLAllocStmt Lib "odbc.dll" (ByVal hdbc&amp;,
</PRE>phstmt&amp;) As Integer
<PRE>Declare Function SQLDisconnect Lib "odbc.dll" (ByVal hdbc&amp;)
</PRE>As Integer
<PRE>Declare Function SQLError Lib "odbc.dll" (ByVal henv&amp;, ByVal
</PRE>hdbc&amp;, ByVal hstmt&amp;, ByVal szSqlState$, pfNativeError&amp;,
ByVal szErrorMsg$, ByVal cbErrorMsgMax%, pcbErrorMsg%) As
Integer
<PRE>Declare Function SQLExecDirect Lib "odbc.dll" (ByVal hstmt&amp;,
</PRE>ByVal szSqlStr$, ByVal cbSqlStr&amp;) As Integer
<PRE>Declare Function SQLFreeConnect Lib "odbc.dll" (ByVal hdbc&amp;)
</PRE>As Integer
<PRE>Declare Function SQLFreeEnv Lib "odbc.dll" (ByVal henv&amp;) As
</PRE>Integer
<PRE>Declare Function SQLFreeStmt Lib "odbc.dll" (ByVal hstmt&amp;,
</PRE>ByVal fOption%) As Integer
<PRE>Declare Function SQLBindParameter Lib "odbc.dll" (ByVal
</PRE>hstmt&amp;, ByVal ipar%, ByVal fParamType%, ByVal fCType%, ByVal
fSqlType%, ByVal cbColDef&amp;, ByVal ibScale%, rgbValue As Any,
ByVal cbValueMax&amp;, pcbValue As Long) As Integer
<PRE>Declare Function SQLDriverConnect Lib "odbc.dll" (ByVal
</PRE>hdbc&amp;, ByVal hWnd%, ByVal szCSIn$, ByVal cbCSIn%, ByVal
szCSOut$, ByVal cbCSMax%, cbCSOut%, ByVal fDrvrComp%) As
Integer
<PRE>Declare Function SQLParamData Lib "odbc.dll" (ByVal hstmt&amp;,
</PRE>prgbValue As Any) As Integer
<PRE>Declare Function SQLPutData Lib "odbc.dll" (ByVal hstmt&amp;,
</PRE>ByVal rgbValue$, ByVal cbValue&amp;) As Integer
<P>
<PRE>'If the application is 32-bit, include the following
'function declaration
</PRE>#Else
<PRE>Declare Function GetFocus Lib "User32" () As Integer
Declare Function GetParent Lib "User32" (ByVal hWnd%) As
</PRE>Integer
<P>
<PRE>Declare Function SQLAllocConnect Lib "odbc32.dll" (ByVal
</PRE>henv&amp;, phdbc&amp;) As Integer
<PRE>Declare Function SQLAllocEnv Lib "odbc32.dll" (phenv&amp;) As
</PRE>Integer
<PRE>Declare Function SQLAllocStmt Lib "odbc32.dll" (ByVal hdbc&amp;,
</PRE>phstmt&amp;) As Integer
<PRE>Declare Function SQLDisconnect Lib "odbc32.dll" (ByVal
</PRE>hdbc&amp;) As Integer
<PRE>Declare Function SQLError Lib "odbc32.dll" (ByVal henv&amp;,
</PRE>ByVal hdbc&amp;, ByVal hstmt&amp;, ByVal szSqlState$,
pfNativeError&amp;, ByVal szErrorMsg$, ByVal cbErrorMsgMax%,
pcbErrorMsg%) As Integer
<PRE>Declare Function SQLExecDirect Lib "odbc32.dll" (ByVal
</PRE>hstmt&amp;, ByVal szSqlStr$, ByVal cbSqlStr&amp;) As Integer
<PRE>Declare Function SQLFreeConnect Lib "odbc32.dll" (ByVal
</PRE>hdbc&amp;) As Integer
<PRE>Declare Function SQLFreeEnv Lib "odbc32.dll" (ByVal henv&amp;)
</PRE>As Integer
<PRE>Declare Function SQLFreeStmt Lib "odbc32.dll" (ByVal hstmt&amp;,
</PRE>ByVal fOption%) As Integer
<PRE>Declare Function SQLBindParameter Lib "odbc32.dll" (ByVal
</PRE>hstmt&amp;, ByVal ipar%, ByVal fParamType%, ByVal fCType%, ByVal
fSqlType%, ByVal cbColDef&amp;, ByVal ibScale%, rgbValue As Any,
ByVal cbValueMax&amp;, pcbValue As Long) As Integer
<PRE>Declare Function SQLDriverConnect Lib "odbc32.dll" (ByVal
</PRE>hdbc&amp;, ByVal hWnd%, ByVal szCSIn$, ByVal cbCSIn%, ByVal
szCSOut$, ByVal cbCSMax%, cbCSOut%, ByVal fDrvrComp%) As
Integer
<PRE>Declare Function SQLParamData Lib "odbc32.dll" (ByVal
</PRE>hstmt&amp;, prgbValue As Any) As Integer
<PRE>Declare Function SQLPutData Lib "odbc32.dll" (ByVal hstmt&amp;,
</PRE>ByVal rgbValue$, ByVal cbValue&amp;) As Integer
#End If
<P>
<PRE>'Since this is in module, the variables need to be global
</PRE>Global Const SQL_ERROR = -1
Global Const SQL_CHAR = 1
Global Const SQL_C_CHAR = 1
Global Const SQL_NEED_DATA = 99
Global Const SQL_DRIVER_PROMPT = 2
Global Const SQL_LEN_DATA_AT_EXEC_OFFSET = -100
<P>
<P>
<P>
<PRE>Sub Command3D1_Click ()
'
' This sample VB code illustrates the use of the ODBC API
' call  SQLPutData()
'
' It has been kept as simple as possible with a minimal
' amount of code and declarations.

    Dim henv As Long
    Dim hdbc2 As Long
    Dim hstmt2 As Long
    Dim nstatus%
    Dim ptoken As Integer

    nstatus = SQLAllocEnv(henv)

    nstatus = SQLAllocConnect(henv, hdbc2)
    If (nstatus = SQL_ERROR) Then
        MsgBox "Couldn't allocate memory for connection"
    End If

' The parameters passed to SQLDriverConnect() after the
' second one are not really used for anything. The call
' expects the variables as output variables so we pass them
' to the call to avoid problems.
'
    nstatus = SQLDriverConnect(hdbc2, GetParent(GetFocus()),
</PRE>S$, Len(S$), Server, Len(Server), cbOut%, SQL_DRIVER_PROMPT)
<PRE>    If (nstatus = SQL_ERROR) Then
        MsgBox "Couldn't connect"
    End If

' In this sample, I am connecting to a SQL Server database
' and this table is defined:
' CREATE TABLE model01 (col1 char(30),col2 char(30))
' INSERT INTO model01 VALUES('Kate Moss', 'Kate Moss')

    sSQLString = "update model01 set col2 = ? where col1 =
'Kate Moss'"

    leng = Len(sSQLString)

    nstatus = SQLAllocStmt(hdbc2, hstmt2)
    If (nstatus = SQL_ERROR) Then
        MsgBox "Couldn't allocate memory for statement"
    End If

'
' In this particular call to SQLBindParmeter, we are binding
' a VB string variable to a column on the SQL Server
' database server that we know to be a char(30). The '1' in
' the third parameter of this call indicates that this
' parameter is of type SQL_PARAM_INPUT. Please refer to the
' definition of fParamType in the description of
' SQLBIndParameter() in the ODBC SDK Programmer's Reference
' for more information. The sixth parameter, cbColDef , is
' indicating that we will be inserting 22 characters into
' this column via the parameter marker. 22 will be the most
' that we can insert into this column now, because of how we
' have defined cbColDef. The 7th parameter (ibScale) is 0
' because we know from Appendix D of the ODBC 2.0
' Programmer's Reference that this is the case for char
' datatypes. If you've read this far into the comment and
' still don't have the Prog. Ref., please call 1-800-MSP-
' RESS or visit your local computer book store to order it.
' ISBN number = 1-55615-658-8. The 8th parameter is a 1
' instead of a pointer to a memory area because we know that
' we are going to be using SQLParamData()/SQLPutData() to
' load the parameter. The 1 is just meant as a placeholder
' in this case. For the same reason, the 9th parameter is 0.
' The 10th parameter needs to be the result of the
' computation (-100 - (number of bytes being passed)). In
' this case cbColDef is 22, which is why the 10th parameter,
' pcbValue, is -122. The -100 in the computation represents
' the #define in SQLEXT.H called
' SQL_LEN_DATA_AT_EXEC_OFFSET. The bind is done this way so
' that later on, when the sql statement is executed, the
' ODBC driver manager knows more information will need to be
' prompted for via the parameter marker.
'

    nstatus = SQLBindParameter(hstmt2, 1, 1, SQL_C_CHAR,
</PRE>SQL_CHAR, 22, 0, 1, 0, -122)
<PRE>    If (nstatus = SQL_ERROR) Then
        MsgBox "error on Bind"
    End If


    nstatus = SQLExecDirect(hstmt2, sSQLString, leng)
    If (nstatus = SQL_ERROR) Then
        MsgBox "Error on execdirect"
    End If

    Dim lenhy As Integer
    lenhy = 0

'
' The use of SQLParamData() is simplified here to only
' account for use of one parameter marked in the SQL
' statement being executed. If there had been more than one
' parameter marker, we would have needed to call
' SQLParamData() more. In general, if there
' are n parameter markers (?) contained in the SQL statement
' being processed, then SQLParamData() must be called n + 1
' times to successfully move through the parameters.
'
     nstatus = SQLParamData(hstmt2, ptoken)
     If (nstatus = SQL_NEED_DATA) Then
        ' An assumption is made here that we know that the
        ' length of the data that we are inserting in this
        ' particular parameter marker is 22.
        While (lenhy &lt; 22)
          buffer = "Some String"
          '
          ' It is quite inefficient in this particular case
          ' to initialize the buffer in this part of the
          'code. In most regular situations though, the
          ' value of the buffer inserted into the column
          ' with SQLPutData() will change
          ' before each call to SQLPutData(), so I left the
          'code this way.
          nstatus = SQLPutData(hstmt2, buffer, Len(buffer))
          If (nstatus = SQL_ERROR) Then
            MsgBox "Error calling putdata"
          End If
          lenhy = lenhy + Len(buffer)
        Wend
     End If
    '
    ' As mentioned before, the last call to SQLParamData()
    'is required to properly
    ' finish processing parameters.

    nstatus = SQLParamData(hstmt2, ptoken)

    nstatus = SQLDisconnect(hdbc2)
    nstatus = SQLFreeConnect(hdbc2)
    nstatus = SQLFreeEnv(henv)

    MsgBox "Finished"

End Sub
</PRE>

	</FONT>
	</TD>
	</TR>
</TABLE>
<P>


<!--DOCBODY_END-->

<!--FOOTER_START-->
<table cellpadding=5 border=0 width="90%">
<tr>
<td>
	<HR WIDTH="90%">

<BLOCKQUOTE>
<FONT FACE="Verdana, Arial, Helvetica" SIZE="1">
<SPAN STYLE="font-family:verdana,arial,helvetica; font-size:8pt">
Additional reference words: 2.10 3.00 odbc vb<BR>
KBCategory: kbinterop kbcode<BR>
KBSubcategory:
<P>


</SPAN>
</FONT>
<BR>
<BR>
THE INFORMATION PROVIDED IN THE MICROSOFT KNOWLEDGE BASE IS
PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND.  MICROSOFT DISCLAIMS
ALL WARRANTIES, EITHER EXPRESS OR IMPLIED, INCLUDING THE WARRANTIES
OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  IN NO
EVENT SHALL MICROSOFT CORPORATION OR ITS SUPPLIERS BE LIABLE FOR
ANY DAMAGES WHATSOEVER INCLUDING DIRECT, INDIRECT, INCIDENTAL,
CONSEQUENTIAL, LOSS OF BUSINESS PROFITS OR SPECIAL DAMAGES, EVEN IF
MICROSOFT CORPORATION OR ITS SUPPLIERS HAVE BEEN ADVISED OF THE
POSSIBILITY OF SUCH DAMAGES.  SOME STATES DO NOT ALLOW THE EXCLUSION
OR LIMITATION OF LIABILITY FOR CONSEQUENTIAL OR INCIDENTAL DAMAGES
SO THE FOREGOING LIMITATION MAY NOT APPLY.
</BLOCKQUOTE>
<P>
<center>
	<FONT FACE="Verdana,Arial,Helvetica" SIZE="1">
	Last reviewed:  September 9, 1996</FONT>
	<BR>
	<A href="../cpyright.htm" STYLE="font: bold 7pt Verdana,Arial,Helvetica">&copy; 1998 Microsoft Corporation. All rights reserved. Terms of Use.</A><BR>
	
</center>
</td>
</tr>
</table>

<!--FOOTER_END-->
</FONT>
</BODY>
</HTML>
