

<HTML>
<HEAD>
<TITLE>BUG: Int 21 Read/Write Track on Logical Drive Fails on OSR2 </TITLE>

<!--STYLE_BEGIN-->
<style>@import url(../../msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="../../msdn_ie3.css">
<!--STYLE_END-->

<META HTTP-EQUIV="CONTENT-Type" CONTENT="text/html; charset=us-ascii">
<META NAME="ms.locale" CONTENT="EN-US">
<META NAME="Category" CONTENT="Support; KB Article">
<META NAME="KBID" CONTENT="Q174569">
<META NAME="KBModify" CONTENT="1997/10/02">
<META NAME="KBCreate" CONTENT="1997/10/01">
<META NAME="Keywords" CONTENT="BseFileio">
<META NAME="KBArea" CONTENT="Support; KB; win32sdk">
<META NAME="Description" CONTENT="  On Windows 95 OEM Service Release2 (OSR2), Read Track on Logical Drive (Int 21h function 440Dh minor code 61h) and Write Track on Logical Drive (Int 21h function 440Dh minor code 41h), do not work when called through the DeviceIoControl API. When t...">
<META NAME="Product" CONTENT="Win32 SDK">
<META NAME="Platform" CONTENT="Windows">
<META NAME="Technology" CONTENT=" ">
<META NAME="Premium" CONTENT="support">

<META NAME="nyms" CONTENT="QAY5,QA4Q,QAUD,QAKC,QDL9,QBWO,QBWN,QAGI,QBC6,QBV8,QAB9,QBFN,QBWQ,QAMV,QA8T V02180118">
</HEAD>

<BODY BGCOLOR="#FFFFFF" LEFTMARGIN="0" RIGHTMARGIN="0" TOPMARGIN="0">


<!--DOCBODY_START-->
<BR>
<CENTER>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" VALIGN="top" WIDTH="90%">
	<TR>
		<TD VALIGN="top">
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<H1>BUG: Int 21 Read/Write Track on Logical Drive Fails on OSR2</H1>
			</FONT>
			<FONT FACE="verdana,arial,helvetica" SIZE="1">
			Last reviewed:  October 2, 1997</FONT><BR>
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<B>Article ID: Q174569</B>
			</FONT>
		</TD>
	</TR>
	<TR>
	<TD>
	<FONT FACE="Verdana, Arial, Helvetica" SIZE=2>



 
 
The information in this article applies to:

<UL><LI>Microsoft Win32 Application Programming Interface (API) included with:
   - Microsoft Windows 95
</UL> 
<P>
<P><h2>SYMPTOMS</h2>
 
<P>
On Windows 95 OEM Service Release2 (OSR2), Read Track on Logical Drive (Int
21h function 440Dh minor code 61h) and Write Track on Logical Drive (Int
21h function 440Dh minor code 41h), do not work when called through the
DeviceIoControl API. When these functions are called, both DeviceIoControl
and the Int 21h functions succeed, but the data is not read or written.
However, both functions work correctly when called from Win16-based and MS-
DOS based applications.
<P>
On the retail version of Windows 95, both functions work when called
through DeviceIOControl as well as Win16-based and MS-DOS based
applications.
<P>
<P><h2>CAUSE</h2>
 
<P>
Windows 95 OEM Service Release 2 has a bug that affects Int 21h function
440Dh minor codes 61h and 41h only when called through DeviceIoControl.
<P>
<P><h2>RESOLUTION</h2>
 
<P>
There are two ways to work around this bug:

<OL><P><LI>Use DeviceIoControl with VWIN32_DIOC_DOS_INT25 and
   VWIN32_DIOC_DOS_INT26 to issue Absolute Disk Read (Int 25h) and
   Absolute Disk Write (Int 26h) respectively. This method works
   for FAT12 and FAT16 volumes. This method is compatible with the
   retail release version of Windows 95, but will not work on
   FAT32 volumes.

<P><LI>Use DeviceIoControl with VWIN32_DIOC_DOS_DRIVEINFO to issue
   Ext Absolute Disk Read &amp; Write (Int 21h function 7305h). This
   method works for FAT12, FAT16, and FAT32 volumes, but is not
   backward compatible with the retail release version of
   Windows 95.
<P>
</OL><h2>STATUS</h2>
 
<P>
Microsoft has confirmed this to be a bug in the Microsoft products listed
at the beginning of this article. We are researching this bug and will post
new information here in the Microsoft Knowledge Base as it becomes
available.
<P>
<P><h2>MORE INFORMATION</h2>
 
<P>
Win32 and console applications running on Windows 95 and its successors use
the DeviceIoControl() API to issue MS-DOS Interrupt 21h functions to
perform low-level disk I/O. Such applications usually are disk utilities
that must bypass the file system in order to perform activities such as
formatting and defragmenting disks.
<P>
Windows 95 and its successors provides several functions to access sectors
on a logical drive. These functions correspond to those available to MS-DOS
and Win16-based applications, including Int 21h function 440Dh functions,
Int 25h, and Int 26h. In addition, Windows 95 OEM Service Release 2 (OSR2)
includes a new function, Int 21h function 7305h.
<P>
If your application must be compatible with the retail release version of
Windows 95, but still support FAT32, then it should check the operating
system version. If Windows 95 OSR2 is running, your application can call
Int 21h function 7305h. If it is running on the retail release of Windows
95, it should use Int 25h and Int 26h. The following code demonstrates how
to call these functions.
<P>
<P><h3>Sample Code</h3>
 
<P>
<PRE>   #include &lt;windows.h&gt;

   #define VWIN32_DIOC_DOS_INT25     2
   #define VWIN32_DIOC_DOS_INT26     3
   #define VWIN32_DIOC_DOS_DRIVEINFO 6

   typedef struct _DIOC_REGISTERS {
       DWORD reg_EBX;
       DWORD reg_EDX;
       DWORD reg_ECX;
       DWORD reg_EAX;
       DWORD reg_EDI;
       DWORD reg_ESI;
       DWORD reg_Flags;
   } DIOC_REGISTERS, *PDIOC_REGISTERS;

   #define CARRY_FLAG 1

   #pragma pack(1)
   typedef struct _DISKIO {
      DWORD  dwStartSector;   // starting logical sector number
      WORD   wSectors;        // number of sectors
      DWORD  dwBuffer;        // address of read/write buffer
   } DISKIO, * PDISKIO;
   #pragma pack()

   /*------------------------------------------------------------------
   ReadLogicalSectors (hDev, bDrive, dwStartSector, wSectors, lpSectBuff)

   Purpose:
      Reads sectors from a logical drive.  Uses Int 25h.

   Parameters:
      hDev
         Handle of VWIN32

      bDrive
         The MS-DOS logical drive number. 1 = A, 2 = B, 3 = C, etc.

      dwStartSector
         The first logical sector to read

      wSectors
         The number of sectors to read

      lpSectBuff
         The caller-supplied buffer that will contain the sector data

   Return Value:
      Returns TRUE if successful, or FALSE if failure.

   Comments:
      This function does not validate its parameters.
   ------------------------------------------------------------------*/
   BOOL ReadLogicalSectors (HANDLE hDev,
                            BYTE   bDrive,
                            DWORD  dwStartSector,
                            WORD   wSectors,
                            LPBYTE lpSectBuff)
   {
      BOOL           fResult;
      DWORD          cb;
      DIOC_REGISTERS reg = {0};
      DISKIO         dio = {0};

      dio.dwStartSector = dwStartSector;
      dio.wSectors      = wSectors;
      dio.dwBuffer      = (DWORD)lpSectBuff;

      reg.reg_EAX = bDrive - 1;    // Int 25h drive numbers are 0-based.
      reg.reg_EBX = (DWORD)&amp;dio;
      reg.reg_ECX = 0xFFFF;        // use DISKIO struct

      fResult = DeviceIoControl(hDev, VWIN32_DIOC_DOS_INT25,
                                &amp;reg, sizeof(reg),
                                &amp;reg, sizeof(reg), &amp;cb, 0);

      // Determine if the DeviceIoControl call and the read succeeded.
      fResult = fResult &amp;&amp; !(reg.reg_Flags &amp; CARRY_FLAG);

      return fResult;
   }


   /*------------------------------------------------------------------
   WriteLogicalSectors (hDev, bDrive, dwStartSector, wSectors, lpSectBuff)

   Purpose:
      Writes sectors to a logical drive. Uses Int 26h

   Parameters:
      hDev
         Handle of VWIN32

      bDrive
         The MS-DOS logical drive number. 1 = A, 2 = B, 3 = C, etc.

      dwStartSector
         The first logical sector to write

      wSectors
         The number of sectors to write

      lpSectBuff
         The caller-supplied buffer that contains the sector data

   Return Value:
      Returns TRUE if successful, or FALSE if failure.

   Comments:
      This function does not validate its parameters.
   ------------------------------------------------------------------*/
   BOOL WriteLogicalSectors (HANDLE hDev,
                             BYTE   bDrive,
                             DWORD  dwStartSector,
                             WORD   wSectors,
                             LPBYTE lpSectBuff)
   {
      BOOL           fResult;
      DWORD          cb;
      DIOC_REGISTERS reg = {0};
      DISKIO         dio = {0};

      dio.dwStartSector = dwStartSector;
      dio.wSectors      = wSectors;
      dio.dwBuffer      = (DWORD)lpSectBuff;

      reg.reg_EAX = bDrive - 1;    // Int 26h drive numbers are 0-based.
      reg.reg_EBX = (DWORD)&amp;dio;
      reg.reg_ECX = 0xFFFF;        // use DISKIO struct

      fResult = DeviceIoControl(hDev, VWIN32_DIOC_DOS_INT26,
                                &amp;reg, sizeof(reg),
                                &amp;reg, sizeof(reg), &amp;cb, 0);

      // Determine if the DeviceIoControl call and the write succeeded.
      fResult = fResult &amp;&amp; !(reg.reg_Flags &amp; CARRY_FLAG);

      return fResult;
   }


   /*------------------------------------------------------------------
   NewReadSectors(hDev, bDrive, dwStartSector, wSectors, lpSectBuff)

   Purpose:
     Reads the specified number of sectors into a caller-supplied
     buffer. Uses Int 21h function 7305h

   Parameters:
     hDev
        Handle of VWIN32

     bDrive
        The MS-DOS logical drive number. 0 = default, 1 = A, 2 = B,
        3 = C, etc.

     dwStartSector
        The first sector to read.

     wSectors
        The number of sectors to read.

     lpSectBuff
        The caller-supplied buffer to read into.

   Return Value:
     Returns TRUE if successful, or FALSE if failure.

   Comments:
     This function does not validate its parameters.  It assumes that
     lpSectBuff is allocated by the caller and is large enough to
     hold all of the data from all of the sectors being read.
   ------------------------------------------------------------------*/
   BOOL NewReadSectors (HANDLE hDev,
                        BYTE   bDrive,
                        DWORD  dwStartSector,
                        WORD   wSectors,
                        LPBYTE lpSectBuff)
   {
     BOOL           fResult;
     DWORD          cb;
     DIOC_REGISTERS reg = {0};
     DISKIO         dio;

     dio.dwStartSector = dwStartSector;
     dio.wSectors      = wSectors;
     dio.lpBuffer      = (DWORD)lpSectBuff;

     reg.reg_EAX = 0x7305;   // Ext_ABSDiskReadWrite
     reg.reg_EBX = (DWORD)&amp;dio;
     reg.reg_ECX = -1;
     reg.reg_EDX = bDrive;   // Int 21h, fn 7305h drive numbers are 1-based

     fResult = DeviceIoControl(hDev, VWIN32_DIOC_DOS_DRIVEINFO,
                               &amp;reg, sizeof(reg),
                               &amp;reg, sizeof(reg), &amp;cb, 0);

     // Determine if the DeviceIoControl call and the read succeeded.
     fResult = fResult &amp;&amp; !(reg.reg_Flags &amp; CARRY_FLAG);

     return fResult;
   }


   /*------------------------------------------------------------------
   NewWriteSectors(hDev, bDrive, dwStartSector, wSectors, lpSectBuff)

   Purpose:
     Writes the specified number of sectors from a caller-supplied
     buffer. Uses Int 21h function 7305h

   Parameters:
     hDev
        Handle of VWIN32

     bDrive
        The MS-DOS logical drive number. 0 = default, 1 = A, 2 = B,
        3 = C, etc.

     dwStartSector
        The first sector to write.

     wSectors
        The number of sectors to write.

     lpSectBuff
        The caller-supplied buffer from which to write.

   Return Value:
     Returns TRUE if successful, or FALSE if failure.

   Comments:
     This function does not validate its parameters.  It assumes that
     lpSectBuff is allocated by the caller and is large enough to
     hold all of the data to be written.
   ------------------------------------------------------------------*/
   BOOL NewWriteSectors (HANDLE hDev,
                        BYTE   bDrive,
                        DWORD  dwStartSector,
                        WORD   wSectors,
                        LPBYTE lpSectBuff)
   {
     BOOL           fResult;
     DWORD          cb;
     DIOC_REGISTERS reg = {0};
     DISKIO         dio;

     dio.dwStartSector = dwStartSector;
     dio.wSectors      = wSectors;
     dio.lpBuffer      = (DWORD)lpSectBuff;

     reg.reg_EAX = 0x7305;   // Ext_ABSDiskReadWrite
     reg.reg_EBX = (DWORD)&amp;dio;
     reg.reg_ECX = -1;
     reg.reg_EDX = bDrive;   // Int 21h, fn 7305h drive numbers are 1-based

     reg.reg_ESI = 0x6001;   // Normal file data (See function
                             // documentation for other values)


     fResult = DeviceIoControl(hDev, VWIN32_DIOC_DOS_DRIVEINFO,
                               &amp;reg, sizeof(reg),
                               &amp;reg, sizeof(reg), &amp;cb, 0);

     // Determine if the DeviceIoControl call and the write succeeded.
     fResult = fResult &amp;&amp; !(reg.reg_Flags &amp; CARRY_FLAG);

     return fResult;
   }

</PRE></OL><h2>REFERENCES</h2>
 
<P>
"Microsoft MS-DOS Programmer's Reference", Version 6.0, pages 140-144, 313-
314, 321-322.
<P>
Online Documentation:
<P>
Microsoft Win32 SDK, Programming Tools and Guides; Programmer's Guide to
Windows 95; Windows 95 Reference; FAT32 API Reference; Functions; Int 21h
Function 7305h Ext_AbsDiskReadWrite (FAT32)
<P>

	</FONT>
	</TD>
	</TR>
</TABLE>
<P>


<!--DOCBODY_END-->

<!--FOOTER_START-->
<table cellpadding=5 border=0 width="90%">
<tr>
<td>
	<HR WIDTH="90%">

<BLOCKQUOTE>
<FONT FACE="Verdana, Arial, Helvetica" SIZE="1">
<SPAN STYLE="font-family:verdana,arial,helvetica; font-size:8pt">
Additional query words: format logical drive low level ioctl bios<BR>
Keywords          : BseFileio<BR>
Platform          : Win95<BR>
Issue type        : kbbug<BR>

</SPAN>
</FONT>
<BR>
<BR>
THE INFORMATION PROVIDED IN THE MICROSOFT KNOWLEDGE BASE IS
PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND.  MICROSOFT DISCLAIMS
ALL WARRANTIES, EITHER EXPRESS OR IMPLIED, INCLUDING THE WARRANTIES
OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  IN NO
EVENT SHALL MICROSOFT CORPORATION OR ITS SUPPLIERS BE LIABLE FOR
ANY DAMAGES WHATSOEVER INCLUDING DIRECT, INDIRECT, INCIDENTAL,
CONSEQUENTIAL, LOSS OF BUSINESS PROFITS OR SPECIAL DAMAGES, EVEN IF
MICROSOFT CORPORATION OR ITS SUPPLIERS HAVE BEEN ADVISED OF THE
POSSIBILITY OF SUCH DAMAGES.  SOME STATES DO NOT ALLOW THE EXCLUSION
OR LIMITATION OF LIABILITY FOR CONSEQUENTIAL OR INCIDENTAL DAMAGES
SO THE FOREGOING LIMITATION MAY NOT APPLY.
</BLOCKQUOTE>
<P>
<center>
	<FONT FACE="Verdana,Arial,Helvetica" SIZE="1">
	Last reviewed:  October 2, 1997</FONT>
	<BR>
	<A href="../cpyright.htm" STYLE="font: bold 7pt Verdana,Arial,Helvetica">&copy; 1998 Microsoft Corporation. All rights reserved. Terms of Use.</A><BR>
	
</center>
</td>
</tr>
</table>

<!--FOOTER_END-->
</FONT>
</BODY>
</HTML>
