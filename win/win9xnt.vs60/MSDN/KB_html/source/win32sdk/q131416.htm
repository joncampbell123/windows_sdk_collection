

<HTML>
<HEAD>
<TITLE>BUG: WNetGetUniversalName Fails Under Windows 95 </TITLE>

<!--STYLE_BEGIN-->
<style>@import url(../../msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="../../msdn_ie3.css">
<!--STYLE_END-->

<META HTTP-EQUIV="CONTENT-Type" CONTENT="text/html; charset=us-ascii">
<META NAME="ms.locale" CONTENT="EN-US">
<META NAME="Category" CONTENT="Support; KB Article">
<META NAME="KBID" CONTENT="Q131416">
<META NAME="KBModify" CONTENT="1997/11/07">
<META NAME="KBCreate" CONTENT="1995/06/11">
<META NAME="Keywords" CONTENT="NtwkWinnet kbcode kbnetwork">
<META NAME="KBArea" CONTENT="Support; KB; win32sdk">
<META NAME="Description" CONTENT="  The WNetGetUniversalName function takes a drive-based path for a network resource and obtains a data structure that contains a more universal form of the name. This function always fails with error 1200 when called from a 32-bit application running...">
<META NAME="Product" CONTENT="Win32 SDK">
<META NAME="Platform" CONTENT="Windows">
<META NAME="Technology" CONTENT=" ">
<META NAME="Premium" CONTENT="support">

<META NAME="nyms" CONTENT="QAUD,QAY5,QAC9,QDL9,QBWQ,QBWO,QBWN,QA5J,QA5I,QAUJ,QAJQ,QBV8,QALW,QAB9,QBQU V02180118">
</HEAD>

<BODY BGCOLOR="#FFFFFF" LEFTMARGIN="0" RIGHTMARGIN="0" TOPMARGIN="0">


<!--DOCBODY_START-->
<BR>
<CENTER>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" VALIGN="top" WIDTH="90%">
	<TR>
		<TD VALIGN="top">
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<H1>BUG: WNetGetUniversalName Fails Under Windows 95</H1>
			</FONT>
			<FONT FACE="verdana,arial,helvetica" SIZE="1">
			Last reviewed:  November 7, 1997</FONT><BR>
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<B>Article ID: Q131416</B>
			</FONT>
		</TD>
	</TR>
	<TR>
	<TD>
	<FONT FACE="Verdana, Arial, Helvetica" SIZE=2>



 
 
The information in this article applies to:

<UL><LI>Microsoft Win32 Software Development Kit (SDK), version 4.0
</UL> 
<P>
<P><h2>SYMPTOMS</h2>
 
<P>
The WNetGetUniversalName function takes a drive-based path for a network
resource and obtains a data structure that contains a more universal form
of the name. This function always fails with error 1200 when called from a
32-bit application running under Windows 95.
<P>
<P><h2>RESOLUTION</h2>
 
<P>
The functionality provided by WNetGetUniversalName can be implemented using
the Win32 network enumeration functions WNetOpenEnum and WNetEnumResource.
Here is an example of how to use these functions to implement similar
functionality:
<P>
<PRE>   #include &lt;windows.h&gt;
   #include &lt;stdio.h&gt;

   // Function Name:  GetUniversalName
   //
   // Parameters:     szUniv  - contains the UNC equivalent of szDrive
   //                           upon completion
   //
   //                 szDrive - contains a drive based path
   //
   // Return value:   TRUE if successful, otherwise FALSE
   //
   // Comments:       This function assumes that szDrive contains a
   //                 valid drive based path.
   //
   //                 For simplicity, this code assumes szUniv points
   //                 to a buffer large enough to accommodate the UNC
   //                 equivalent of szDrive.

   BOOL GetUniversalName( char szUniv[], char szDrive[] )
   {
      // get the local drive letter
      char chLocal = toupper( szDrive[0] );

      // cursory validation
      if ( chLocal &lt; 'A' || chLocal &gt; 'Z' )
         return FALSE;

      if ( szDrive[1] != ':' || szDrive[2] != '\\' )
         return FALSE;

      HANDLE hEnum;
      DWORD dwResult = WNetOpenEnum( RESOURCE_CONNECTED, RESOURCETYPE_DISK,
                                     0, NULL, &amp;hEnum );

      if ( dwResult != NO_ERROR )
         return FALSE;

      // request all available entries
      const int    c_cEntries   = 0xFFFFFFFF;
      // start with a reasonable buffer size
      DWORD        cbBuffer     = 50 * sizeof( NETRESOURCE );
      NETRESOURCE *pNetResource = (NETRESOURCE*) malloc( cbBuffer );

      BOOL fResult = FALSE;

      while ( TRUE )
      {
         DWORD dwSize   = cbBuffer,
               cEntries = c_cEntries;

         dwResult = WNetEnumResource( hEnum, &amp;cEntries, pNetResource,
                                      &amp;dwSize );

         if ( dwResult == ERROR_MORE_DATA )
         {
            // the buffer was too small, enlarge
            cbBuffer = dwSize;
            pNetResource = (NETRESOURCE*) realloc(pNetResource, cbBuffer);
            continue;
         }

         if ( dwResult != NO_ERROR )
            goto done;

         // search for the specified drive letter
         for ( int i = 0; i &lt; (int) cEntries; i++ )
            if ( pNetResource[i].lpLocalName &amp;&amp;
                 chLocal == toupper(pNetResource[i].lpLocalName[0]) )
            {
               // match
               fResult = TRUE;

               // build a UNC name
               strcpy( szUniv, pNetResource[i].lpRemoteName );
               strcat( szUniv, szDrive + 2 );
               _strupr( szUniv );
               goto done;
            }
      }

   done:
      // cleanup
      WNetCloseEnum( hEnum );
      free( pNetResource );

      return fResult;

   }

</PRE>An alternative workaround to using WNetOpenEnum and WNetEnumResource is to
use WnetGetConnection, which, when provided the drive letter of a shared
drive, will return the UNC name that is mapped to that drive.
<P>
<P><h2>STATUS</h2>
 
<P>
Microsoft has confirmed this to be a bug in the Microsoft products listed
at the beginning of this article. We are researching this problem and will
post new information here in the Microsoft Knowledge Base as it becomes
available.
<P>

	</FONT>
	</TD>
	</TR>
</TABLE>
<P>


<!--DOCBODY_END-->

<!--FOOTER_START-->
<table cellpadding=5 border=0 width="90%">
<tr>
<td>
	<HR WIDTH="90%">

<BLOCKQUOTE>
<FONT FACE="Verdana, Arial, Helvetica" SIZE="1">
<SPAN STYLE="font-family:verdana,arial,helvetica; font-size:8pt">
Additional query words: Win95<BR>
Keywords          : NtwkWinnet kbcode kbnetwork<BR>
Platform          : Win95<BR>
Issue type        : kbbug<BR>

</SPAN>
</FONT>
<BR>
<BR>
THE INFORMATION PROVIDED IN THE MICROSOFT KNOWLEDGE BASE IS
PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND.  MICROSOFT DISCLAIMS
ALL WARRANTIES, EITHER EXPRESS OR IMPLIED, INCLUDING THE WARRANTIES
OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  IN NO
EVENT SHALL MICROSOFT CORPORATION OR ITS SUPPLIERS BE LIABLE FOR
ANY DAMAGES WHATSOEVER INCLUDING DIRECT, INDIRECT, INCIDENTAL,
CONSEQUENTIAL, LOSS OF BUSINESS PROFITS OR SPECIAL DAMAGES, EVEN IF
MICROSOFT CORPORATION OR ITS SUPPLIERS HAVE BEEN ADVISED OF THE
POSSIBILITY OF SUCH DAMAGES.  SOME STATES DO NOT ALLOW THE EXCLUSION
OR LIMITATION OF LIABILITY FOR CONSEQUENTIAL OR INCIDENTAL DAMAGES
SO THE FOREGOING LIMITATION MAY NOT APPLY.
</BLOCKQUOTE>
<P>
<center>
	<FONT FACE="Verdana,Arial,Helvetica" SIZE="1">
	Last reviewed:  November 7, 1997</FONT>
	<BR>
	<A href="../cpyright.htm" STYLE="font: bold 7pt Verdana,Arial,Helvetica">&copy; 1998 Microsoft Corporation. All rights reserved. Terms of Use.</A><BR>
	
</center>
</td>
</tr>
</table>

<!--FOOTER_END-->
</FONT>
</BODY>
</HTML>
