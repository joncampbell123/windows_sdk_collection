

<HTML>
<HEAD>
<TITLE>Alternative to PtInRegion() for Hit-Testing </TITLE>

<!--STYLE_BEGIN-->
<style>@import url(../../msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="../../msdn_ie3.css">
<!--STYLE_END-->

<META HTTP-EQUIV="CONTENT-Type" CONTENT="text/html; charset=us-ascii">
<META NAME="ms.locale" CONTENT="EN-US">
<META NAME="Category" CONTENT="Support; KB Article">
<META NAME="KBID" CONTENT="Q121960">
<META NAME="KBModify" CONTENT="1995/09/29">
<META NAME="KBCreate" CONTENT="1994/10/24">
<META NAME="Keywords" CONTENT="kbgraphic kbcode">
<META NAME="KBArea" CONTENT="Support; KB; win32sdk">
<META NAME="Description" CONTENT="  It may be useful to perform hit-testing on an object that is defined by a polygon. To accomplish this, you could call CreatePolygonRgn() to create a region from the polygon, and then call PtInRegion() to determine if the point falls within the regi...">
<META NAME="Product" CONTENT="Win32 SDK">
<META NAME="Platform" CONTENT="Windows">
<META NAME="Technology" CONTENT=" ">
<META NAME="Premium" CONTENT="support">

<META NAME="nyms" CONTENT="QANO,QBC9,QBC8,QAII,QAUD,QAK4,QAH4,QBVV,QDL9,QBWO,QBWN,QBE7,QBE6,QAOB,QAG2 V02180118">
</HEAD>

<BODY BGCOLOR="#FFFFFF" LEFTMARGIN="0" RIGHTMARGIN="0" TOPMARGIN="0">


<!--DOCBODY_START-->
<BR>
<CENTER>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" VALIGN="top" WIDTH="90%">
	<TR>
		<TD VALIGN="top">
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<H1>Alternative to PtInRegion() for Hit-Testing</H1>
			</FONT>
			<FONT FACE="verdana,arial,helvetica" SIZE="1">
			Last reviewed:  September 29, 1995</FONT><BR>
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<B>Article ID: Q121960</B>
			</FONT>
		</TD>
	</TR>
	<TR>
	<TD>
	<FONT FACE="Verdana, Arial, Helvetica" SIZE=2>



 
The information in this article applies to:

<UL><LI>Microsoft Windows Software Development Kit (SDK) for Windows
   versions 3.1 and 3.0

<LI>Microsoft Win32 Application Programming Interface (API) included with:
<P>
<P><PRE>    - Microsoft Windows NT versions 3.1, 3.5, and 3.51
    - Microsoft Windows 95 version 4.0
</UL></PRE> 
<P>
<P><h2>SUMMARY</h2>
 
<P>
It may be useful to perform hit-testing on an object that is defined by a
polygon. To accomplish this, you could call CreatePolygonRgn() to create a
region from the polygon, and then call PtInRegion() to determine if the
point falls within the region. However, this method can be expensive both
in terms of GDI resources, and in terms of speed. If a polygon is complex,
CreatePolygonRgn() will often fail due to lack of memory in Windows because
regions are in GDI's heap.
<P>
The code below provides a better method. Use it to determine if a point
lies within a polygon. It is fast and does not use regions. The trick lies
in determining the number of times an imaginary line drawn from the point
you want to test crosses edges of your polygon. If the line crosses edges
an even number of times, the point is outside the polygon. If it crosses an
odd number of times it is inside. The line is drawn horizontally from the
point to the right.
<P>
<P><h2>MORE INFORMATION</h2>
 
<P>
WARNING: ANY USE BY YOU OF THE CODE PROVIDED IN THIS ARTICLE IS AT YOUR OWN
RISK. Microsoft provides this code "as is" without warranty of any kind,
either express or implied, including but not limited to the implied
warranties of merchantability and/or fitness for a particular purpose. The
references below do not constitute a recommendation. You are encouraged to
examine any resource to determine whether or not it meets your needs. These
books are not recommended over any others.
<P>
The following code is based on an algorithm presented in "Algorithms" by
Robert Sedgewick, Addison-Wesley, 1988, 2nd ed. ISBN 0201066734. The
algorithm is on p.354, in the section "Inclusion in a Polygon" in the
chapter "Elementary Geometric Methods." It is also discussed in "Computer
Graphics" by Foley, van Dam, Feiner and Hughes, Addison-Wesley, 1990, 2nd
ed. ISBN 0201121107, chapter 2, section 1, p.34.
<P>
<P><h3>Sample Code</h3>
 
<P>
<PRE>#include "windows.h"
#include "limits.h"
</PRE>BOOL G_PtInPolygon(POINT *rgpts, WORD wnumpts, POINT ptTest,
<PRE>                   RECT *prbound) ;
</PRE>BOOL G_PtInPolyRect(POINT *rgpts, WORD wnumpts, POINT ptTest,
<PRE>                    RECT *prbound) ;
</PRE>BOOL Intersect(POINT p1, POINT p2, POINT p3, POINT p4) ;
<PRE>int  CCW(POINT p0, POINT p1, POINT p2) ;

/*************************************************************************

 * FUNCTION:   G_PtInPolygon
 *
 * PURPOSE
 * This routine determines if the point passed is in the polygon. It uses

 * the classical polygon hit-testing algorithm: a horizontal ray starting

 * at the point is extended infinitely rightwards and the number of
 * polygon edges that intersect the ray are counted. If the number is odd,

 * the point is inside the polygon.
 *
 * RETURN VALUE
 * (BOOL) TRUE if the point is inside the polygon, FALSE if not.
 *************************************************************************/

</PRE>BOOL G_PtInPolygon(POINT *rgpts, WORD wnumpts, POINT ptTest,
<PRE>                   RECT *prbound)
{
   RECT   r ;
   POINT  *ppt ;
   WORD   i ;
   POINT  pt1, pt2 ;
   WORD   wnumintsct = 0 ;

   if (!G_PtInPolyRect(rgpts,wnumpts,ptTest,prbound))
      return FALSE ;

   pt1 = pt2 = ptTest ;
   pt2.x = r.right + 50 ;

   // Now go through each of the lines in the polygon and see if it
   // intersects
   for (i = 0, ppt = rgpts ; i &lt; wnumpts-1 ; i++, ppt++)
   {
      if (Intersect(ptTest, pt2, *ppt, *(ppt+1)))
         wnumintsct++ ;
   }

   // And the last line
   if (Intersect(ptTest, pt2, *ppt, *rgpts))
      wnumintsct++ ;

   return (wnumintsct&amp;1) ;
</PRE>}
<P>
<PRE>/*************************************************************************

 * FUNCTION:   G_PtInPolyRect
 *
 * PURPOSE
 * This routine determines if a point is within the smallest rectangle
 * that encloses a polygon.
 *
 * RETURN VALUE
 * (BOOL) TRUE or FALSE depending on whether the point is in the rect or

 * not.
 *************************************************************************/

</PRE>BOOL  G_PtInPolyRect(POINT *rgpts, WORD wnumpts, POINT ptTest,
<PRE>                     RECT *prbound)
{
   RECT r ;
   // If a bounding rect has not been passed in, calculate it
   if (prbound)
      r = *prbound ;
   else
   {
      int   xmin, xmax, ymin, ymax ;
      POINT *ppt ;
      WORD  i ;

      xmin = ymin = INT_MAX ;
      xmax = ymax = -INT_MAX ;

      for (i=0, ppt = rgpts ; i &lt; wnumpts ; i++, ppt++)
      {
         if (ppt-&gt;x &lt; xmin)
            xmin = ppt-&gt;x ;
         if (ppt-&gt;x &gt; xmax)
            xmax = ppt-&gt;x ;
         if (ppt-&gt;y &lt; ymin)
            ymin = ppt-&gt;y ;
         if (ppt-&gt;y &gt; ymax)
            ymax = ppt-&gt;y ;
      }
      SetRect(&amp;r, xmin, ymin, xmax, ymax) ;
   }
   return (PtInRect(&amp;r,ptTest)) ;
</PRE>}
<P>
<PRE>/*************************************************************************

 * FUNCTION:   Intersect
 *
 * PURPOSE
 * Given two line segments, determine if they intersect.
 *
 * RETURN VALUE
 * TRUE if they intersect, FALSE if not.
 *************************************************************************/

</PRE>BOOL Intersect(POINT p1, POINT p2, POINT p3, POINT p4)
{
<PRE>   return ((( CCW(p1, p2, p3) * CCW(p1, p2, p4)) &lt;= 0)
        &amp;&amp; (( CCW(p3, p4, p1) * CCW(p3, p4, p2)  &lt;= 0) )) ;
}

/*************************************************************************

 * FUNCTION:   CCW (CounterClockWise)
 *
 * PURPOSE
 * Determines, given three points, if when travelling from the first to
 * the second to the third, we travel in a counterclockwise direction.
 *
 * RETURN VALUE
 * (int) 1 if the movement is in a counterclockwise direction, -1 if
 * not.
 *************************************************************************/

int CCW(POINT p0, POINT p1, POINT p2)
</PRE>{
<PRE>   LONG dx1, dx2 ;
   LONG dy1, dy2 ;

   dx1 = p1.x - p0.x ; dx2 = p2.x - p0.x ;
   dy1 = p1.y - p0.y ; dy2 = p2.y - p0.y ;

   /* This is basically a slope comparison: we don't do divisions because

    * of divide by zero possibilities with pure horizontal and pure
    * vertical lines.
    */
   return ((dx1 * dy2 &gt; dy1 * dx2) ? 1 : -1) ;
</PRE>}
<P>
<PRE>/*************************************************
 * The above code might be tested as follows:
 *************************************************/
void PASCAL TestProc( HWND hWnd )
</PRE>{
<PRE>    POINT rgpts[] = {0,0, 10,0, 10,10, 5,15, 0,10};
    WORD wnumpts = 5;
    POINT ptTest = {3,10};
    RECT prbound = {0, 0, 20, 20};
    BOOL bInside;

    bInside = G_PtInPolygon(rgpts, wnumpts, ptTest, &amp;prbound);

    if (bInside)
       MessageBox(hWnd, "Point is inside!", "Test", MB_OK );
    else
       MessageBox(hWnd, "Point is outside!", "Test", MB_OK );
</PRE>}
<PRE>/* code ends */
</PRE>

	</FONT>
	</TD>
	</TR>
</TABLE>
<P>


<!--DOCBODY_END-->

<!--FOOTER_START-->
<table cellpadding=5 border=0 width="90%">
<tr>
<td>
	<HR WIDTH="90%">

<BLOCKQUOTE>
<FONT FACE="Verdana, Arial, Helvetica" SIZE="1">
<SPAN STYLE="font-family:verdana,arial,helvetica; font-size:8pt">
Additional reference words: 3.00 3.10 3.50 4.00 95  hittest hit-test fails<BR>
KBCategory: kbgraphic kbcode<BR>
KBSubcategory: GdiMisc<BR>

</SPAN>
</FONT>
<BR>
<BR>
THE INFORMATION PROVIDED IN THE MICROSOFT KNOWLEDGE BASE IS
PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND.  MICROSOFT DISCLAIMS
ALL WARRANTIES, EITHER EXPRESS OR IMPLIED, INCLUDING THE WARRANTIES
OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  IN NO
EVENT SHALL MICROSOFT CORPORATION OR ITS SUPPLIERS BE LIABLE FOR
ANY DAMAGES WHATSOEVER INCLUDING DIRECT, INDIRECT, INCIDENTAL,
CONSEQUENTIAL, LOSS OF BUSINESS PROFITS OR SPECIAL DAMAGES, EVEN IF
MICROSOFT CORPORATION OR ITS SUPPLIERS HAVE BEEN ADVISED OF THE
POSSIBILITY OF SUCH DAMAGES.  SOME STATES DO NOT ALLOW THE EXCLUSION
OR LIMITATION OF LIABILITY FOR CONSEQUENTIAL OR INCIDENTAL DAMAGES
SO THE FOREGOING LIMITATION MAY NOT APPLY.
</BLOCKQUOTE>
<P>
<center>
	<FONT FACE="Verdana,Arial,Helvetica" SIZE="1">
	Last reviewed:  September 29, 1995</FONT>
	<BR>
	<A href="../cpyright.htm" STYLE="font: bold 7pt Verdana,Arial,Helvetica">&copy; 1998 Microsoft Corporation. All rights reserved. Terms of Use.</A><BR>
	
</center>
</td>
</tr>
</table>

<!--FOOTER_END-->
</FONT>
</BODY>
</HTML>
