

<HTML>
<HEAD>
<TITLE>HOWTO: Manage Computer Accounts Programmatically in Windows NT </TITLE>

<!--STYLE_BEGIN-->
<style>@import url(../../msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="../../msdn_ie3.css">
<!--STYLE_END-->

<META HTTP-EQUIV="CONTENT-Type" CONTENT="text/html; charset=us-ascii">
<META NAME="ms.locale" CONTENT="EN-US">
<META NAME="Category" CONTENT="Support; KB Article">
<META NAME="KBID" CONTENT="Q136867">
<META NAME="KBModify" CONTENT="1997/06/25">
<META NAME="KBCreate" CONTENT="1995/09/19">
<META NAME="Keywords" CONTENT="BseSecurity codesam kbcode kbnetwork NtwkLmapi">
<META NAME="KBArea" CONTENT="Support; KB; win32sdk">
<META NAME="Description" CONTENT="  The ability to manage Windows NT computer accounts can be accomplished by using the Windows NT server manager utility. The server manager (srvmgr) can be used to create and delete various computer accounts, including the following account types:   ...">
<META NAME="Product" CONTENT="Win32 SDK">
<META NAME="Platform" CONTENT="Windows">
<META NAME="Technology" CONTENT=" ">
<META NAME="Premium" CONTENT="support">

<META NAME="nyms" CONTENT="QBG2,QBWP,QAUD,QAI5,QAUJ,QDIO,QA9A,QAOZ,QAH6,QBBI,QBWG,QAWK,QAJG,QBW3,QBXS V02180118">
</HEAD>

<BODY BGCOLOR="#FFFFFF" LEFTMARGIN="0" RIGHTMARGIN="0" TOPMARGIN="0">


<!--DOCBODY_START-->
<BR>
<CENTER>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" VALIGN="top" WIDTH="90%">
	<TR>
		<TD VALIGN="top">
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<H1>HOWTO: Manage Computer Accounts Programmatically in Windows NT</H1>
			</FONT>
			<FONT FACE="verdana,arial,helvetica" SIZE="1">
			Last reviewed:  June 25, 1997</FONT><BR>
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<B>Article ID: Q136867</B>
			</FONT>
		</TD>
	</TR>
	<TR>
	<TD>
	<FONT FACE="Verdana, Arial, Helvetica" SIZE=2>



 
 
The information in this article applies to:

<UL><LI>Microsoft Win32 Software Development Kit (SDK) version 3.51, 4.0
</UL> 
<P>
<P><h2>SUMMARY</h2>
 
<P>
The ability to manage Windows NT computer accounts can be accomplished by
using the Windows NT server manager utility. The server manager (srvmgr)
can be used to create and delete various computer accounts, including the
following account types:

<UL><LI>Windows NT Workstation
<LI>Windows NT Server (non domain controller)
<LI>Windows NT Backup domain controller
<P>
</UL>Furthermore, Windows NT user manager for domains (usrmgr) provides the
ability to manage trust relationships with domains. The management of
interdomain trust accounts "permitted to trust this domain" will be
addressed by this article.
<P>
The list of trusted domains can be managed programmatically with the
Windows NT LSA (local security authority) API. This procedure will not be
discussed in this article.
<P>
This article describes how to manage Windows NT computer accounts
programmatically by using Win32 API calls from Windows NT. It is assumed
that you already have an understanding of the various computer account
types in Windows NT.
<P>
<P><h2>MORE INFORMATION</h2>
 
<P>
<P><h3>Considerations for Managing Computer Accounts</h3>
 

<UL><LI>Computer account management should take place on the primary domain
   controller for the target domain.

<LI>The computer account name should be all uppercase for consistency with
   Windows NT account management utilities.

<LI>A computer account name always has a trailing dollar sign ($). Any APIs
   used to manage computer accounts must build the computer name such that
   the last character of the computer account name is a dollar sign ($).
   For interdomain trust, the account name is TrustingDomainName$.

<LI>The maximum computer name length is MAX_COMPUTERNAME_LENGTH (15). This
   length does not include the trailing dollar sign ($).

<LI>The password for a new computer account should be the lowercase
   representation of the computer account name, without the trailing dollar
   sign ($). For interdomain trust, the password can be an arbitrary value
   that matches the value specified on the trust side of the relationship.

<LI>The maximum password length is LM20_PWLEN (14). The password should be
   truncated to this length if the computer account name exceeds this
   length.

<LI>The password provided at computer-account-creation time is valid only
   until the computer account becomes active on the domain. A new password
   is established during trust relationship activation.

<LI>The user that calls the account management functions must have
   Administrator privilege on the target computer. In the case of existing
   computer accounts, the creator of the account can manage the account,
   regardless of administrative membership.

<LI>The SeMachineAccountPrivilege can be granted on the target computer to
   give specified users the ability to create computer accounts. This gives
   non-administrators the ability to create computer accounts. The caller
   needs to enable this privilege prior to adding the computer account.

<LI>The Net function calls are currently implemented as Unicode only.
   The caller must insure that strings passed to these functions are
   in Unicode form.
<P>
</UL>Machine account types are defined by the following flags:
<P>
<PRE>   UF_SERVER_TRUST_ACCOUNT (Backup domain controller)
   UF_WORKSTATION_TRUST_ACCOUNT (Workstation and server)
   UF_INTERDOMAIN_TRUST_ACCOUNT (Interdomain trust account)

</PRE>The following list of APIs can be used to manage computer accounts in
the target domain:

<UL><LI>NetGetDCName can be used to obtain the computer name of the primary
   domain controller.

<LI>NetUserAdd can be used for creating a new computer account.

<LI>NetUserDel can be used to delete an existing computer account.

<LI>NetUserSetInfo can be used to modify the password of an existing
   computer account. This is useful for resetting a computer account to a
   known state.

<LI>NetUserEnum can be used to enumerate existing computer accounts. This
   API can return a list of accounts based on account type through the use
   of the filter parameter.
<P>
</UL><h3>Sample Code</h3>
 
<P>
<PRE>   // works compiled ansi or unicode
   #define UNICODE
   #define _UNICODE

   #define RTN_OK 0
   #define RTN_USAGE 1
   #define RTN_ERROR 13

   /*++

</PRE>The following sample code adds the specified workstation computer account
to the specified domain. If no domain is specified, the computer account is
created on the local computer.
<P>
If the computer account creation fails with GetLastError ==
ERROR_ACCESS_DENIED, the sample attempts to enable the
SeMachineAccountPrivilege for the caller. If the privilege is enabled
successfully, the computer account add operation is re-tried.
<P>
The following import libraries are required:
<P>
<PRE>   netapi32.lib
   advapi32.lib

</PRE>--*/
<P>
<PRE>   #include &lt;windows.h&gt;
   #include &lt;stdio.h&gt;
   #include &lt;lm.h&gt;

   BOOL
   AddMachineAccount(
       LPWSTR wTargetComputer,
       LPWSTR MachineAccount,
       DWORD AccountType
       );

   BOOL SetCurrentPrivilege(
       LPWSTR TargetComputer,  // target of privilege operation
       LPCWSTR Privilege,      // Privilege to enable/disable
       BOOL bEnablePrivilege   // to enable or disable privilege
       );

   int wmain(int argc, wchar_t *argv[])
   {
       LPWSTR wMachineAccount;
       LPWSTR wPrimaryDC;
       LPWSTR wMachineAccountPrivilege = L"SeMachineAccountPrivilege";
       DWORD dwError;
       BOOL bSuccess;

       if (argc &lt; 2)
       {
           fprintf(stderr, "Usage: %ls &lt;machineaccountname&gt; [domain]\n",
               argv[0]);
           return RTN_USAGE;
       }

       wMachineAccount = argv[1];

       //
       // default will operate on local machine.  Non-NULL wPrimaryDC will
       // cause buffer to be freed
       //
       wPrimaryDC = NULL;

       //
       // if a domain name was specified, fetch the computer name of the
       // primary domain controller
       //
       if (argc == 3) {

           dwError = NetGetDCName(NULL, argv[2], (LPBYTE *)&amp;wPrimaryDC);

           if(dwError != NO_ERROR) {
               fprintf(stderr,"NetGetDCName error! (rc=%lu)\n", dwError);
               return RTN_ERROR;
           }
       }

       bSuccess=AddMachineAccount(
           wPrimaryDC,                  // primary DC computer name
           wMachineAccount,             // computer account name
           UF_WORKSTATION_TRUST_ACCOUNT // computer account type
           );

       if(!bSuccess &amp;&amp; GetLastError() == ERROR_ACCESS_DENIED ) {

           //
           // try to enable the SeMachineAccountPrivilege
           //
           if(SetCurrentPrivilege(
               wPrimaryDC, wMachineAccountPrivilege, TRUE )) {

               //
               // enabled the privilege.  retry the add operation
               //
               bSuccess=AddMachineAccount(
                   wPrimaryDC,
                   wMachineAccount,
                   UF_WORKSTATION_TRUST_ACCOUNT
                   );

               //
               // disable the privilege
               //
               SetCurrentPrivilege(
                   wPrimaryDC, wMachineAccountPrivilege, FALSE);
           }
       }

       //
       // free the buffer allocated for the PDC computer name
       //
       if(wPrimaryDC) NetApiBufferFree(wPrimaryDC);

       if(!bSuccess)
       {
           fprintf(stderr,"AddMachineAccount error! (rc=%lu)\n",
               GetLastError());
           return RTN_ERROR;
       }

       return RTN_OK;
   }

   BOOL
   AddMachineAccount(
       LPWSTR wTargetComputer,
       LPWSTR MachineAccount,
       DWORD AccountType
       )
   {
       LPWSTR wAccount;
       LPWSTR wPassword;
       USER_INFO_1 ui;
       DWORD cbAccount;
       DWORD cbLength;
       DWORD dwError;

       //
       // ensure a valid computer account type was passed
       // TODO SetLastError
       //
       if (AccountType != UF_WORKSTATION_TRUST_ACCOUNT &amp;&amp;
           AccountType != UF_SERVER_TRUST_ACCOUNT &amp;&amp;
           AccountType != UF_INTERDOMAIN_TRUST_ACCOUNT
           ) {
           SetLastError(ERROR_INVALID_PARAMETER);
           return FALSE;
       }

       //
       // obtain number of chars in computer account name
       //
       cbLength = cbAccount = lstrlenW(MachineAccount);

       //
       // ensure computer name doesn't exceed maximum length
       //
       if(cbLength &gt; MAX_COMPUTERNAME_LENGTH) {
           SetLastError(ERROR_INVALID_ACCOUNT_NAME);
           return FALSE;
       }

       //
       // allocate storage to contain Unicode representation of
       // computer account name + trailing $ + NULL
       //
       wAccount=(LPWSTR)HeapAlloc(GetProcessHeap(), 0,
           (cbAccount + 1 + 1) * sizeof(WCHAR)  // Account + '$' + NULL
           );

       if(wAccount == NULL) return FALSE;

       //
       // password is the computer account name converted to lowercase
       // you will convert the passed MachineAccount in place
       //
       wPassword = MachineAccount;

       //
       // copy MachineAccount to the wAccount buffer allocated while
       // converting computer account name to uppercase.
       // convert password (inplace) to lowercase
       //
       while(cbAccount--) {
           wAccount[cbAccount] = towupper( MachineAccount[cbAccount] );
           wPassword[cbAccount] = towlower( wPassword[cbAccount] );
       }

       //
       // computer account names have a trailing Unicode '$'
       //
       wAccount[cbLength] = L'$';
       wAccount[cbLength + 1] = L'\0'; // terminate the string

       //
       // if the password is greater than the max allowed, truncate
       //
       if(cbLength &gt; LM20_PWLEN) wPassword[LM20_PWLEN] = L'\0';

       //
       // initialize USER_INFO_x structure
       //
       ZeroMemory(&amp;ui, sizeof(ui));

       ui.usri1_name = wAccount;
       ui.usri1_password = wPassword;

       ui.usri1_flags = AccountType | UF_SCRIPT;
       ui.usri1_priv = USER_PRIV_USER;

       dwError=NetUserAdd(
                   wTargetComputer,    // target computer name
                   1,                  // info level
                   (LPBYTE) &amp;ui,       // buffer
                   NULL
                   );

       //
       // free allocated memory
       //
       if(wAccount) HeapFree(GetProcessHeap(), 0, wAccount);

       //
       // indicate whether it was successful
       //
       if(dwError == NO_ERROR)
           return TRUE;
       else {
           SetLastError(dwError);
           return FALSE;
       }
   }

   BOOL SetCurrentPrivilege(
       LPWSTR TargetComputer,  // target of privilege operation
       LPCWSTR Privilege,      // Privilege to enable/disable
       BOOL bEnablePrivilege   // to enable or disable privilege
       )
   {
       HANDLE hToken;
       TOKEN_PRIVILEGES tp;
       LUID luid;
       TOKEN_PRIVILEGES tpPrevious;
       DWORD cbPrevious=sizeof(TOKEN_PRIVILEGES);
       BOOL bSuccess=FALSE;

       if(!LookupPrivilegeValueW(TargetComputer, Privilege, &amp;luid))
               return FALSE;

       if(!OpenProcessToken(
               GetCurrentProcess(),
               TOKEN_QUERY | TOKEN_ADJUST_PRIVILEGES,
               &amp;hToken
               )) return FALSE;

       //
       // first pass.  get current privilege setting
       //
       tp.PrivilegeCount           = 1;
       tp.Privileges[0].Luid       = luid;
       tp.Privileges[0].Attributes = 0;

       AdjustTokenPrivileges(
               hToken,
               FALSE,
               &amp;tp,
               sizeof(TOKEN_PRIVILEGES),
               &amp;tpPrevious,
               &amp;cbPrevious
               );

       if(GetLastError() == ERROR_SUCCESS) {
           //
           // second pass.  set privilege based on previous setting
           //
           tpPrevious.PrivilegeCount     = 1;
           tpPrevious.Privileges[0].Luid = luid;

           if(bEnablePrivilege) {
               tpPrevious.Privileges[0].Attributes |=
                   (SE_PRIVILEGE_ENABLED);
           }
           else {
               tpPrevious.Privileges[0].Attributes ^=
                   (SE_PRIVILEGE_ENABLED &amp;
                   tpPrevious.Privileges[0].Attributes);
           }

           AdjustTokenPrivileges(
                   hToken,
                   FALSE,
                   &amp;tpPrevious,
                   cbPrevious,
                   NULL,
                   NULL
                   );

           if (GetLastError() == ERROR_SUCCESS) bSuccess=TRUE;
       }

       CloseHandle(hToken);

       return bSuccess;
   }
</PRE>

	</FONT>
	</TD>
	</TR>
</TABLE>
<P>


<!--DOCBODY_END-->

<!--FOOTER_START-->
<table cellpadding=5 border=0 width="90%">
<tr>
<td>
	<HR WIDTH="90%">

<BLOCKQUOTE>
<FONT FACE="Verdana, Arial, Helvetica" SIZE="1">
<SPAN STYLE="font-family:verdana,arial,helvetica; font-size:8pt">
Additional query words: computer account server workstation trust<BR>
Keywords            : BseSecurity codesam kbcode kbnetwork NtwkLmapi<BR>
Version             : 3.51 4.0<BR>
Platform            : NT WINDOWS<BR>
Issue type          : kbhowto<BR>

</SPAN>
</FONT>
<BR>
<BR>
THE INFORMATION PROVIDED IN THE MICROSOFT KNOWLEDGE BASE IS
PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND.  MICROSOFT DISCLAIMS
ALL WARRANTIES, EITHER EXPRESS OR IMPLIED, INCLUDING THE WARRANTIES
OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  IN NO
EVENT SHALL MICROSOFT CORPORATION OR ITS SUPPLIERS BE LIABLE FOR
ANY DAMAGES WHATSOEVER INCLUDING DIRECT, INDIRECT, INCIDENTAL,
CONSEQUENTIAL, LOSS OF BUSINESS PROFITS OR SPECIAL DAMAGES, EVEN IF
MICROSOFT CORPORATION OR ITS SUPPLIERS HAVE BEEN ADVISED OF THE
POSSIBILITY OF SUCH DAMAGES.  SOME STATES DO NOT ALLOW THE EXCLUSION
OR LIMITATION OF LIABILITY FOR CONSEQUENTIAL OR INCIDENTAL DAMAGES
SO THE FOREGOING LIMITATION MAY NOT APPLY.
</BLOCKQUOTE>
<P>
<center>
	<FONT FACE="Verdana,Arial,Helvetica" SIZE="1">
	Last reviewed:  June 25, 1997</FONT>
	<BR>
	<A href="../cpyright.htm" STYLE="font: bold 7pt Verdana,Arial,Helvetica">&copy; 1998 Microsoft Corporation. All rights reserved. Terms of Use.</A><BR>
	
</center>
</td>
</tr>
</table>

<!--FOOTER_END-->
</FONT>
</BODY>
</HTML>
