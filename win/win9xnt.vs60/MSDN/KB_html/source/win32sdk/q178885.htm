

<HTML>
<HEAD>
<TITLE>BUG: NetStatisticsGet2 Not Implemented </TITLE>

<!--STYLE_BEGIN-->
<style>@import url(../../msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="../../msdn_ie3.css">
<!--STYLE_END-->

<META HTTP-EQUIV="CONTENT-Type" CONTENT="text/html; charset=us-ascii">
<META NAME="ms.locale" CONTENT="EN-US">
<META NAME="Category" CONTENT="Support; KB Article">
<META NAME="KBID" CONTENT="Q178885">
<META NAME="KBModify" CONTENT="1998/03/04">
<META NAME="KBCreate" CONTENT="1998/01/06">
<META NAME="Keywords" CONTENT="BseMisc NtwkLmapi">
<META NAME="KBArea" CONTENT="Support; KB; win32sdk">
<META NAME="Description" CONTENT="  A Visual C++ compiler and linker fails to build an application using the NetStatisticsGet2 function. The compiler reports  function not defined.  If the function prototype is explicitly declared in the application, the linker reports an  unresolved...">
<META NAME="Product" CONTENT="Win32 SDK">
<META NAME="Platform" CONTENT="Windows">
<META NAME="Technology" CONTENT=" ">
<META NAME="Security" CONTENT="PUBLIC ">
<META NAME="Premium" CONTENT="support">

<META NAME="nyms" CONTENT="QALX,QAM9,QA28,QATJ,QAUD,QBWP,QAY5,QAI4 V02180118">
</HEAD>

<BODY BGCOLOR="#FFFFFF" LEFTMARGIN="0" RIGHTMARGIN="0" TOPMARGIN="0">


<!--DOCBODY_START-->
<BR>
<CENTER>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" VALIGN="top" WIDTH="90%">
	<TR>
		<TD VALIGN="top">
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<H1>BUG: NetStatisticsGet2 Not Implemented</H1>
			</FONT>
			<FONT FACE="verdana,arial,helvetica" SIZE="1">
			Last reviewed:  March 4, 1998</FONT><BR>
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<B>Article ID: Q178885</B>
			</FONT>
		</TD>
	</TR>
	<TR>
	<TD>
	<FONT FACE="Verdana, Arial, Helvetica" SIZE=2>



 
 
The information in this article applies to:

<UL><LI>Microsoft Win32 Application Programming Interface (API) included with:
<P>
   - Microsoft Windows NT 4.0
</UL> 
<P>
<P><h2>SYMPTOMS</h2>
 
<P>
A Visual C++ compiler and linker fails to build an application using the
NetStatisticsGet2 function. The compiler reports "function not defined." If
the function prototype is explicitly declared in the application, the
linker reports an "unresolved external" for this function.
<P>
<P><h2>CAUSE</h2>
 
<P>
The NetStatisticsGet2 function is not included in the lmstats.h Win32 SDK
header file, and this function is not defined in the NETAPI32 library.
<P>
<P><h2>RESOLUTION</h2>
 
<P>
This function provides various statistics for the Windows NT Workstation or
Server components. There is no alternative to get Windows NT Workstation
information, but some statistics for server information can be found within
the performance registry of Windows NT. An application can get the counter
data for the server object.
<P>
<P><h2>STATUS</h2>
 
<P>
Microsoft has confirmed this to be a bug in the Microsoft products listed
at the beginning of this article. We are researching this bug and will post
new information here in the Microsoft Knowledge Base as it becomes
available.
<P>
<P><h2>MORE INFORMATION</h2>
 
<P>
You can include the following function definition in an application for
Windows NT to gather server statistics for a Windows NT Server or Windows
NT Workstation. You can use this function to determine how busy Windows NT
is performing as a network server.
<P>
The function defined here is named GetServerStats. There are some other
supporting subroutines that need to be included with any code to implement
the GetServerStats function.
<P>
<PRE>   ================== netperf.h ================================
   #define TYPE_MASK         0x00000300
   #define TYPE_NOT_SUPPORTED   -1
   #define TYPE_DWORD         0
   #define TYPE_LARGE         1
   #define MAX_INDEX         3000


   typedef struct
   {
      DWORDLONG dwlPerf_Time;
      DWORDLONG dwlPerf_Frequency;
      DWORDLONG dwlBytes_Total;
      DWORDLONG dwlBytes_Received;
      DWORDLONG dwlBytes_Transmitted;
      DWORD dwSessions_Timed_Out;
      DWORD dwSessions_Errored_Out;
      DWORD dwSessions_Logged_Off;
      DWORD dwSessions_Forced_Off;
      DWORD dwErrors_Logon;
      DWORD dwErrors_Access_Permissions;
      DWORD dwErrors_Granted_Access;
      DWORD dwErrors_System;
      DWORD dwBlocking_Requests_Rejected;
      DWORD dwWork_Item_Shortages;
      DWORD dwFiles_Opened_Total;
      DWORD dwFiles_Open;
      DWORD dwServer_Sessions;
      DWORD dwContext_Blocks_Queued;
      DWORD dwLogon_Total;
   }SERVER_STATS, *PSERVER_STATS;

   typedef struct
   {
      TCHAR *szName;
      int  nType;

      union
      {
      DWORD  dwCounter;
      DWORDLONG dwlCounter;
      };
   }COUNTER;

   // Function to return server statistics.
   LONG GetServerStats(TCHAR *szMachine, PSERVER_STATS pServerStats);

   LONG GetCounterNames(TCHAR *szMachine, LPVOID *lplpCounterNames);
   void GetCounterIndices(DWORD Index[], LPVOID lpCounterNames,
                       COUNTER Counter[], DWORD dwNumCounters);
   LONG GetObjectData(TCHAR *szMachine, int nIndex, LPVOID *lplpObj);
   void InitServerStats(PSERVER_STATS pServerStats, COUNTER Counter[]);
   LONG GetCounters(LPVOID lpObj, COUNTER Counter[],
                 DWORD dwNumCounters, DWORD Index[]);

   ================== netperf.c ================================
   #include "netperf.h"

   LONG GetServerStats(TCHAR *szMachine, PSERVER_STATS pServerStats)
   {
      LPVOID lpServerObj, lpCounterNames;
      DWORD dwNumCounters;
      LONG lErr;
      DWORD Index[MAX_INDEX + 1];

      COUNTER Counter[] = {{_T("Server"), -1, 0},
                           {_T("Bytes Total/sec"), -1, 0},
                           {_T("Bytes Received/sec"), -1, 0},
                           {_T("Bytes Transmitted/sec"), -1, 0},
                           {_T("Sessions Timed Out"), -1, 0},
                           {_T("Sessions Errored Out"), -1, 0},
                           {_T("Sessions Logged Off"), -1, 0},
                           {_T("Sessions Forced Off"), -1, 0},
                           {_T("Errors Logon"), -1, 0},
                           {_T("Errors Access Permissions"), -1, 0},
                           {_T("Errors Granted Access"), -1, 0},
                           {_T("Errors System"), -1, 0},
                           {_T("Blocking Requests Rejected"), -1, 0},
                           {_T("Work Item Shortages"), -1, 0},
                           {_T("Files Opened Total"), -1, 0},
                           {_T("Files Open"), -1, 0},
                           {_T("Server Sessions"), -1, 0},
                           {_T("Context Blocks Queued/sec"), -1, 0},
                           {_T("Logon Total"), -1, 0}};

      // Get the list of counter names and indices.
      lErr = GetCounterNames(szMachine, &amp;lpCounterNames);

      if(lErr != ERROR_SUCCESS)
      {
         return lErr;
      }

      dwNumCounters = sizeof(Counter) / sizeof(COUNTER);

      // Retrieve and save the indices for counters of interest.
      GetCounterIndices(Index, lpCounterNames, Counter, dwNumCounters);

      // Get the performance data for the "Server" object.
      lErr = GetObjectData(szMachine, Index[0], &amp;lpServerObj);

      if(lErr != ERROR_SUCCESS)
      {
         GlobalFreePtr(lpCounterNames);
         return lErr;
      }

      // Retrieve selected counter data from the "Server" object.
      lErr = GetCounters(lpServerObj, Counter, dwNumCounters, Index);

      if(lErr != ERROR_SUCCESS)
      {
         GlobalFreePtr(lpServerObj);
         GlobalFreePtr(lpCounterNames);
         return lErr;
      }

      // Initialize the SERVER_STATS data structure with our results.
      InitServerStats(pServerStats, Counter);

      // Save PerfTime and PerfFreq as well.
      pServerStats-&gt;dwlPerf_Time =
         ((PPERF_DATA_BLOCK)lpServerObj)-&gt;PerfTime.HighPart &lt;&lt; 32 |
         ((PPERF_DATA_BLOCK)lpServerObj)-&gt;PerfTime.LowPart;
      pServerStats-&gt;dwlPerf_Frequency =
         ((PPERF_DATA_BLOCK)lpServerObj)-&gt;PerfFreq.HighPart &lt;&lt; 32 |
         ((PPERF_DATA_BLOCK)lpServerObj)-&gt;PerfFreq.LowPart;

      GlobalFreePtr(lpServerObj);
      GlobalFreePtr(lpCounterNames);

      return lErr;
   }

   LONG GetCounterNames(TCHAR *szMachine, LPVOID *lplpCounterNames)
   {
      DWORD dwType, dwCount = 10000, dwCountRet;
      LONG lErr;
      HKEY hKey1, hKey2;

      if(szMachine &amp;&amp; *szMachine)
      {
         lErr = RegConnectRegistry(szMachine, HKEY_LOCAL_MACHINE, &amp;hKey1);

         if(lErr != ERROR_SUCCESS)
         {
            return lErr;   // Unable to connect
         }
      }
      else
      {
         hKey1 = HKEY_LOCAL_MACHINE;
      }

      lErr = RegOpenKeyEx(hKey1,
        (LPCTSTR)_T(
        "SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Perflib\\009"
         ),
         0, KEY_READ, &amp;hKey2);
      RegCloseKey(hKey1);

      if(lErr != ERROR_SUCCESS)
      {
         return lErr; // Not running NT
      }

      *lplpCounterNames = NULL;

      // Keep trying until the buffer is large enough.
      do
      {
         if(*lplpCounterNames) GlobalFreePtr(*lplpCounterNames);

         *lplpCounterNames = (LPVOID *)GlobalAllocPtr(GHND, dwCount);
         dwCountRet = dwCount;

         // Get the counters data.
         lErr = RegQueryValueEx(hKey2, (LPCTSTR)_T("Counters"), NULL,
                &amp;dwType, (LPBYTE)*lplpCounterNames, &amp;dwCountRet);
         dwCount += 1000;
      }while(lErr != ERROR_SUCCESS);

      RegCloseKey(hKey2);

      return ERROR_SUCCESS;
   }



   void GetCounterIndices(DWORD Index[], LPVOID lpCounterNames,
                          COUNTER Counter[], DWORD dwNumCounters)
   {
      DWORD i;
      TCHAR *szCur = (TCHAR *)lpCounterNames;

      // While not at end of list.
      while(*szCur)
      {
         for(i = 0; i &lt; dwNumCounters; i++)
         {
            if(!lstrcmp(szCur, Counter[i].szName))
            {
               TCHAR *szIndex;

               // We have a match, so back up to index.
               szIndex = szCur;
               szIndex -= 2;

               while(*szIndex) szIndex--;

               szIndex++;

               if(i == 0)
               {  // Store "Server" index as Index[0].
                  Index[i] = _ttoi((const TCHAR *)szIndex);
               }
               else
               {  // Otherwise, store index into Counter array.
                  Index[_ttoi((const TCHAR *)szIndex)] = i;
               }

               break;
            }
         }

      // Next string.
      szCur = _tcschr(szCur, 0);
      szCur++;
      }
   }


   LONG GetObjectData(TCHAR *szMachine, int nIndex, LPVOID *lplpObj)
   {
      HKEY hKey;
      DWORD dwType, dwCount = 1000, dwCountRet;
      LONG lErr;
      TCHAR szIndex[17];

      if(szMachine &amp;&amp; *szMachine)
      {
         // Connect to remote machine.
         lErr = RegConnectRegistry(szMachine, HKEY_PERFORMANCE_DATA,
                                   &amp;hKey);

         if(lErr != ERROR_SUCCESS)
         {
            return lErr;   // Unable to connect.
         }
      }
      else
      {
         hKey = HKEY_PERFORMANCE_DATA;
      }

      *lplpObj = NULL;
      _itot(nIndex, szIndex, 10);

      // Keep trying until the buffer is large enough.
      do
      {
         if(*lplpObj) GlobalFreePtr(*lplpObj);

         *lplpObj = (LPVOID)GlobalAllocPtr(GHND, dwCount);
         dwCountRet = dwCount;

         // Get the server object data.
         lErr = RegQueryValueEx(hKey, szIndex, NULL, &amp;dwType,
                (LPBYTE)*lplpObj, &amp;dwCountRet);
         dwCount += 1000;
      }while(lErr != ERROR_SUCCESS);

      RegCloseKey(HKEY_PERFORMANCE_DATA);

      return ERROR_SUCCESS;
   }



   void InitServerStats(PSERVER_STATS pServerStats, COUNTER Counter[])
   {
      pServerStats-&gt;dwlBytes_Total = Counter[1].dwlCounter;
      pServerStats-&gt;dwlBytes_Received = Counter[2].dwlCounter;
      pServerStats-&gt;dwlBytes_Transmitted = Counter[3].dwlCounter;
      pServerStats-&gt;dwSessions_Timed_Out = Counter[4].dwCounter;
      pServerStats-&gt;dwSessions_Errored_Out = Counter[5].dwCounter;
      pServerStats-&gt;dwSessions_Logged_Off = Counter[6].dwCounter;
      pServerStats-&gt;dwSessions_Forced_Off = Counter[7].dwCounter;
      pServerStats-&gt;dwErrors_Logon = Counter[8].dwCounter;
      pServerStats-&gt;dwErrors_Access_Permissions = Counter[9].dwCounter;
      pServerStats-&gt;dwErrors_Granted_Access = Counter[10].dwCounter;
      pServerStats-&gt;dwErrors_System = Counter[11].dwCounter;
      pServerStats-&gt;dwBlocking_Requests_Rejected = Counter[12].dwCounter;
      pServerStats-&gt;dwWork_Item_Shortages = Counter[13].dwCounter;
      pServerStats-&gt;dwFiles_Opened_Total = Counter[14].dwCounter;
      pServerStats-&gt;dwFiles_Open = Counter[15].dwCounter;
      pServerStats-&gt;dwServer_Sessions = Counter[16].dwCounter;
      pServerStats-&gt;dwContext_Blocks_Queued = Counter[17].dwCounter;
      pServerStats-&gt;dwLogon_Total = Counter[18].dwCounter;
   }


   LONG GetCounters(LPVOID lpObj, COUNTER Counter[],
                 DWORD dwNumCounters, DWORD Index[])
   {
      PPERF_DATA_BLOCK pDataBlock;
      PPERF_OBJECT_TYPE pObject;
      PPERF_COUNTER_DEFINITION pCounterDef;
      DWORD i;

      pDataBlock = (PPERF_DATA_BLOCK)lpObj;

      if(!pDataBlock-&gt;LittleEndian)
      {
         return ERROR_NOT_SUPPORTED;   // Big-endian format not handled.
      }

      pObject = (PPERF_OBJECT_TYPE)((BYTE *)pDataBlock +
         pDataBlock-&gt;HeaderLength);

      // Multiple objects may be returned.
      while(pObject-&gt;ObjectNameTitleIndex != Index[0])
      {
         pObject = (PPERF_OBJECT_TYPE)((BYTE *)pObject +
            pObject-&gt;TotalByteLength);
      }

      // Find the first counter definition.
      pCounterDef = (PPERF_COUNTER_DEFINITION)((BYTE *)pObject +
         pObject-&gt;HeaderLength);

      for(i = 0; i &lt; pObject-&gt;NumCounters; i++)
      {
        DWORD dwIndex;
        // Ignore any data that you do not explicitly seek.
         if(Index[pCounterDef-&gt;CounterNameTitleIndex] &gt; 0)
         {
            switch(pCounterDef-&gt;CounterType &amp; TYPE_MASK)
            {
               case PERF_SIZE_DWORD:

                  dwIndex = pCounterDef-&gt;CounterNameTitleIndex;
                  Counter[Index[dwIndex]].nType = TYPE_DWORD;

                  // Save the offsets first, and update with data later.
                  dwIndex = pCounterDef-&gt;CounterNameTitleIndex;
                  Counter[Index[dwIndex]].dwCounter =
                      pCounterDef-&gt;CounterOffset;
               break;

               case PERF_SIZE_LARGE:
                  dwIndex = pCounterDef-&gt;CounterNameTitleIndex;
                  Counter[Index[dwIndex]].nType = TYPE_LARGE;

                  // Save the offsets first, and update with data later.
                  dwIndex = pCounterDef-&gt;CounterNameTitleIndex;
                  Counter[Index[dwIndex]].dwCounter =
                     pCounterDef-&gt;CounterOffset;
               break;

               default:
                  dwIndex = pCounterDef-&gt;CounterNameTitleIndex;
                  Counter[Index[dwIndex]].nType = TYPE_NOT_SUPPORTED;
               break;
            }
         }

         // Next counter.
         pCounterDef = (PPERF_COUNTER_DEFINITION)((BYTE *)pCounterDef +
            pCounterDef-&gt;ByteLength);
      }

      // No instances, so pCounterDef is now pointing
      // at the PERF_COUNTER_BLOCK.
      // Update data.
      for(i = 1; i &lt; dwNumCounters; i++)
      {
         if(Counter[i].dwlCounter != (DWORDLONG)-1)
         {
            switch(Counter[i].nType)
            {
               case TYPE_DWORD:
                  Counter[i].dwCounter = *(DWORD *)((BYTE *)pCounterDef +
                     Counter[i].dwCounter);
               break;
               case TYPE_LARGE:
                  Counter[i].dwlCounter =
                     *(DWORDLONG *)((BYTE *)pCounterDef +
                         Counter[i].dwCounter);
               break;
            }
         }
      }

      return ERROR_SUCCESS;
   }
</PRE> 
<PRE>Keywords          : BseMisc NtwkLmapi
Version           : WINNT:4.0
Platform          : winnt
Issue type        : kbbug</PRE>

	</FONT>
	</TD>
	</TR>
</TABLE>
<P>


<!--DOCBODY_END-->

<!--FOOTER_START-->
<table cellpadding=5 border=0 width="90%">
<tr>
<td>
	<HR WIDTH="90%">

<BLOCKQUOTE>
<FONT FACE="Verdana, Arial, Helvetica" SIZE="1">
<SPAN STYLE="font-family:verdana,arial,helvetica; font-size:8pt">
================================================================================<BR>

</SPAN>
</FONT>
<BR>
<BR>
THE INFORMATION PROVIDED IN THE MICROSOFT KNOWLEDGE BASE IS
PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND.  MICROSOFT DISCLAIMS
ALL WARRANTIES, EITHER EXPRESS OR IMPLIED, INCLUDING THE WARRANTIES
OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  IN NO
EVENT SHALL MICROSOFT CORPORATION OR ITS SUPPLIERS BE LIABLE FOR
ANY DAMAGES WHATSOEVER INCLUDING DIRECT, INDIRECT, INCIDENTAL,
CONSEQUENTIAL, LOSS OF BUSINESS PROFITS OR SPECIAL DAMAGES, EVEN IF
MICROSOFT CORPORATION OR ITS SUPPLIERS HAVE BEEN ADVISED OF THE
POSSIBILITY OF SUCH DAMAGES.  SOME STATES DO NOT ALLOW THE EXCLUSION
OR LIMITATION OF LIABILITY FOR CONSEQUENTIAL OR INCIDENTAL DAMAGES
SO THE FOREGOING LIMITATION MAY NOT APPLY.
</BLOCKQUOTE>
<P>
<center>
	<FONT FACE="Verdana,Arial,Helvetica" SIZE="1">
	Last reviewed:  March 4, 1998</FONT>
	<BR>
	<A href="../cpyright.htm" STYLE="font: bold 7pt Verdana,Arial,Helvetica">&copy; 1998 Microsoft Corporation. All rights reserved. Terms of Use.</A><BR>
	
</center>
</td>
</tr>
</table>

<!--FOOTER_END-->
</FONT>
</BODY>
</HTML>
