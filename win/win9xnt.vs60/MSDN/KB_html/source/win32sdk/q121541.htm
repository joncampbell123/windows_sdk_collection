

<HTML>
<HEAD>
<TITLE>HOWTO: Override Full Drag </TITLE>

<!--STYLE_BEGIN-->
<style>@import url(../../msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="../../msdn_ie3.css">
<!--STYLE_END-->

<META HTTP-EQUIV="CONTENT-Type" CONTENT="text/html; charset=us-ascii">
<META NAME="ms.locale" CONTENT="EN-US">
<META NAME="Category" CONTENT="Support; KB Article">
<META NAME="KBID" CONTENT="Q121541">
<META NAME="KBModify" CONTENT="1998/02/03">
<META NAME="KBCreate" CONTENT="1994/10/09">
<META NAME="Keywords" CONTENT="UsrWndw">
<META NAME="KBArea" CONTENT="Support; KB; win32sdk">
<META NAME="Description" CONTENT="  Windows NT version 3.5 introduces full drag, which allows you to see the entire window moving or resizing instead of seeing just an outline of the window moving or resizing. The sample application below demonstrates how to enable full drag by runni...">
<META NAME="Product" CONTENT="Win32 SDK">
<META NAME="Platform" CONTENT="Windows">
<META NAME="Technology" CONTENT=" ">
<META NAME="Premium" CONTENT="support">

<META NAME="nyms" CONTENT="QA9N,QANJ,QACI,QAEF,QAEV,QAI4,QA4Q,QASC,QBE7,QBE6,QAY5,QAYC,QAJP,QADP,QBWP V02180118">
</HEAD>

<BODY BGCOLOR="#FFFFFF" LEFTMARGIN="0" RIGHTMARGIN="0" TOPMARGIN="0">


<!--DOCBODY_START-->
<BR>
<CENTER>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" VALIGN="top" WIDTH="90%">
	<TR>
		<TD VALIGN="top">
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<H1>HOWTO: Override Full Drag</H1>
			</FONT>
			<FONT FACE="verdana,arial,helvetica" SIZE="1">
			Last reviewed:  February 3, 1998</FONT><BR>
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<B>Article ID: Q121541</B>
			</FONT>
		</TD>
	</TR>
	<TR>
	<TD>
	<FONT FACE="Verdana, Arial, Helvetica" SIZE=2>



 
 
The information in this article applies to:

<UL><LI>Microsoft Win32 Application Programming Interface (API) included with:
<P><PRE>    - Microsoft Windows NT versions 3.5, 3.51
    - Microsoft Windows 95
</UL></PRE> 
<P>
<P><h2>SUMMARY</h2>
 
<P>
Windows NT version 3.5 introduces full drag, which allows you to see the
entire window moving or resizing instead of seeing just an outline of the
window moving or resizing. The sample application below demonstrates how to
enable full drag by running the Desktop Control Panel applet and selecting
the Full Drag check box.
<P>
<P><h2>MORE INFORMATION</h2>
 
<P>
When you resize a window with full drag enabled, the application will
receive numerous messages indicating that the window is resizing. (You can
verify this with Spy.) If this has undesirable effects on your application,
you will need to override the full drag feature in your application.
<P>
When the moving or resizing starts, the application receives this message:
<P>
<PRE>   WM_ENTERSIZEMOVE (0231)

</PRE>When the moving or resizing finishes, the application receives this
message:
<P>
<PRE>   WM_EXITSIZEMOVE (0232)

</PRE>The above messages act as a notification that the window is entering and
exiting a sizing or moving operation. If you want, you can use these
notifications to set a flag to prevent the program from handling a WM_PAINT
message during the move or size operation to override full drag.
<P>
<P><h3>Sample Code</h3>
 
<P>
<PRE>   
   /***********************************************************************
    *
     Fulldrag.c
     *
     Copyright (c) 1997 Microsoft Corporation.
     *
     Abstract:
     *
     Sample program that demonstrates how a program can override
     Full Drag.
     *
   
   ***********************************************************************/
   
    #define STRICT
    #include &lt;windows.h&gt;
   
   
   /***********************************************************************
     *
     Globals
     *
     g_fMoveSize
     *
     Set while you are in a move/size loop. The WM_ENTERSIZEMOVE
     and WM_EXITSIZEMOVE messages tell you when these things happen.
     *
     g_fPaintDeferred
     *
     Set if you deferred a paint that occurred while you were
     busy doing a Move/Size. When the Move/Size completes
     and you discover that a paint was deferred, you force
     a full repaint to complete the deferred paint.
     *
     *
     Note:
     *
     In a real (that is, non-sample) program, these would not be global
     variables. They would be per-window variables.
     *
   
   ***********************************************************************/
   
    BOOL g_fDragging;
    BOOL g_fPaintDeferred;
   
   
   /***********************************************************************
     *
     Hilbert
     *
     Draws a segment of the hilbert curve.
     *
     The math is not important. What is important is that drawing
     a hilbert curve takes a long time.
     *
   
   ***********************************************************************/
   
    #define MAXDEPTH 8      /* Bigger depth takes longer to draw. */
    void
    Hilbert(HDC hdc, int x, int y, int vx, int vy, int wx, int wy, int n)
    {
    if (n &gt;= MAXDEPTH) {
    LineTo(hdc, x + (vx+wx)/2, y + (vy+wy)/2);
    } else {
    n++;
    Hilbert(hdc, x, y, wx/2, wy/2, vx/2, vy/2, n);
    Hilbert(hdc, x+vx/2, y+vy/2, vx/2, vy/2, wx/2, wy/2, n);
    Hilbert(hdc, x+vx/2+wx/2, y+vy/2+wy/2, vx/2, vy/2, wx/2, wy/2, n);
    Hilbert(hdc, x+vx/2+wx, y+vy/2+wy, -wx/2, -wy/2, -vx/2, -vy/2, n);
        }
    }
   
   
   /***********************************************************************
     *
     Hilbert_OnPaint
     *
     Handle the WM_PAINT message.
     *
     If the user is dragging the window, then don't do painting,
     because that would make the dragging very jerky. Instead, just
     remember that there was a paint message that you ignored. After
     the size/move is complete, you will perform one big paint to do
     the things that you ignored.
     *
   
   ***********************************************************************/
   
    void
    Hilbert_OnPaint(HWND hwnd)
    {
    PAINTSTRUCT ps;
    RECT rc;
    HDC hdc;
   
    hdc = BeginPaint(hwnd, &amp;ps);
    if (hdc) {
    if (g_fDragging) {
    g_fPaintDeferred = TRUE;
    } else {
    HBRUSH hbrOld;
    HPEN hpenOld;
    HCURSOR hcurOld;
   
    hcurOld = SetCursor(LoadCursor(0, IDC_WAIT));
    hbrOld = SelectObject(hdc, GetStockObject(BLACK_BRUSH)); hpenOld =
    SelectObject(hdc, GetStockObject(BLACK_PEN));
    MoveToEx(hdc, 0, 0, 0);
    Hilbert(hdc, 0, 0, GetSystemMetrics(SM_CXFULLSCREEN), 0,
    0, GetSystemMetrics(SM_CYFULLSCREEN), 0);
    SelectObject(hdc, hpenOld);
    SelectObject(hdc, hbrOld);
    SetCursor(hcurOld);
            }
    EndPaint(hwnd, &amp;ps);
        }
    }
   
   
   /***********************************************************************
     *
     Hilbert_WndProc
     *
     Window procedure.
     *
   
   ***********************************************************************/
   
    LRESULT CALLBACK
    Hilbert_WndProc(HWND hwnd, UINT wm, WPARAM wp, LPARAM lp)
    {
    switch (wm) {
    case WM_PAINT:
    Hilbert_OnPaint(hwnd);
    break;
   
    case WM_DESTROY:
    PostQuitMessage(0); break;
   
        /*
     When you begin a Size/Move operation, remember that you are
     performing a Size/Move operation so you don't paint during the
    . Size/Move.
         */
    case WM_ENTERSIZEMOVE:
    g_fDragging = TRUE; break;
   
        /*
     When you finish a Size/Move operation, remember that you are
     performing a Size/Move operation so you will resume painting,
    . and if there were any deferred paint messages, re-invalidate
    . yourself they will be regenerated.
         */
    case WM_EXITSIZEMOVE:
    g_fDragging = FALSE;
    if (g_fPaintDeferred) {
    g_fPaintDeferred = FALSE;
    InvalidateRect(hwnd, 0, TRUE);
            }
    break;
   
        }
   
    return DefWindowProc(hwnd, wm, wp, lp);
    }
   
   
   /***********************************************************************
     *
     WinMain
     *
     Program entry point.
     *
     Register the class, create the window, and go into a message loop.
     *
   
   ***********************************************************************/
   
    int WINAPI
    WinMain(HINSTANCE hinst, HINSTANCE hinstPrev, LPSTR pszCmdLine, int
    nCmdShow)
    {
    HWND hwnd;
    MSG msg;
    WNDCLASS wc = {
    0,
    Hilbert_WndProc,
    0,
    0,
    hinst,
    LoadIcon(0, IDI_APPLICATION),
    LoadCursor(0, IDC_ARROW),
    (HBRUSH)(COLOR_WINDOW+1),
    0,
    "Hilbert"
        };
   
    RegisterClass(&amp;wc);
    hwnd = CreateWindow("Hilbert", "Hilbert", WS_OVERLAPPEDWINDOW,
    CW_USEDEFAULT, CW_USEDEFAULT,
    CW_USEDEFAULT, CW_USEDEFAULT, 0, 0, hinst, 0);
    ShowWindow(hwnd, nCmdShow);
    while (GetMessage(&amp;msg, 0, 0, 0)) {
    TranslateMessage(&amp;msg);
    DispatchMessage(&amp;msg);
        }
   
    return 0;
    }

</PRE> 
<PRE>Keywords          : UsrWndw
Version           : WIN95;WINNT:3.5,3.5
Platform          : Win95 winnt
Issue type        : kbhowto</PRE>

	</FONT>
	</TD>
	</TR>
</TABLE>
<P>


<!--DOCBODY_END-->

<!--FOOTER_START-->
<table cellpadding=5 border=0 width="90%">
<tr>
<td>
	<HR WIDTH="90%">

<BLOCKQUOTE>
<FONT FACE="Verdana, Arial, Helvetica" SIZE="1">
<SPAN STYLE="font-family:verdana,arial,helvetica; font-size:8pt">
================================================================================<BR>

</SPAN>
</FONT>
<BR>
<BR>
THE INFORMATION PROVIDED IN THE MICROSOFT KNOWLEDGE BASE IS
PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND.  MICROSOFT DISCLAIMS
ALL WARRANTIES, EITHER EXPRESS OR IMPLIED, INCLUDING THE WARRANTIES
OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  IN NO
EVENT SHALL MICROSOFT CORPORATION OR ITS SUPPLIERS BE LIABLE FOR
ANY DAMAGES WHATSOEVER INCLUDING DIRECT, INDIRECT, INCIDENTAL,
CONSEQUENTIAL, LOSS OF BUSINESS PROFITS OR SPECIAL DAMAGES, EVEN IF
MICROSOFT CORPORATION OR ITS SUPPLIERS HAVE BEEN ADVISED OF THE
POSSIBILITY OF SUCH DAMAGES.  SOME STATES DO NOT ALLOW THE EXCLUSION
OR LIMITATION OF LIABILITY FOR CONSEQUENTIAL OR INCIDENTAL DAMAGES
SO THE FOREGOING LIMITATION MAY NOT APPLY.
</BLOCKQUOTE>
<P>
<center>
	<FONT FACE="Verdana,Arial,Helvetica" SIZE="1">
	Last reviewed:  February 3, 1998</FONT>
	<BR>
	<A href="../cpyright.htm" STYLE="font: bold 7pt Verdana,Arial,Helvetica">&copy; 1998 Microsoft Corporation. All rights reserved. Terms of Use.</A><BR>
	
</center>
</td>
</tr>
</table>

<!--FOOTER_END-->
</FONT>
</BODY>
</HTML>
