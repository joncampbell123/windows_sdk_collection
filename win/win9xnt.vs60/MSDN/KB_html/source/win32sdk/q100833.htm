

<HTML>
<HEAD>
<TITLE>INFO: Win32s Translated Pointers Guaranteed for 32K </TITLE>

<!--STYLE_BEGIN-->
<style>@import url(../../msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="../../msdn_ie3.css">
<!--STYLE_END-->

<META HTTP-EQUIV="CONTENT-Type" CONTENT="text/html; charset=us-ascii">
<META NAME="ms.locale" CONTENT="EN-US">
<META NAME="Category" CONTENT="Support; KB Article">
<META NAME="KBID" CONTENT="Q100833">
<META NAME="KBModify" CONTENT="1997/06/10">
<META NAME="KBCreate" CONTENT="1993/06/29">
<META NAME="Keywords" CONTENT="kbprg W32s W32sThunk kbprg">
<META NAME="KBArea" CONTENT="Support; KB; win32sdk">
<META NAME="Description" CONTENT="  Translated pointers are guaranteed to be valid only for 32K, rather than 64K, which selectors are usually limited to. This limitation is for performance reasons.  Selectors are tiled every 32K. A 0:32 pointer can be quickly translated into a 16:16 ...">
<META NAME="Product" CONTENT="Win32 SDK">
<META NAME="Platform" CONTENT="Windows">
<META NAME="Technology" CONTENT=" ">
<META NAME="Premium" CONTENT="support">

<META NAME="nyms" CONTENT="QAO2,QAO3,QAH6,QAH7,QAD7,QBJQ,QAJQ,QABN,QA7H,QAYY,QANG,QBQU,QANY,QABI,QBFM V02180118">
</HEAD>

<BODY BGCOLOR="#FFFFFF" LEFTMARGIN="0" RIGHTMARGIN="0" TOPMARGIN="0">


<!--DOCBODY_START-->
<BR>
<CENTER>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" VALIGN="top" WIDTH="90%">
	<TR>
		<TD VALIGN="top">
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<H1>INFO: Win32s Translated Pointers Guaranteed for 32K</H1>
			</FONT>
			<FONT FACE="verdana,arial,helvetica" SIZE="1">
			Last reviewed:  June 10, 1997</FONT><BR>
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<B>Article ID: Q100833</B>
			</FONT>
		</TD>
	</TR>
	<TR>
	<TD>
	<FONT FACE="Verdana, Arial, Helvetica" SIZE=2>



<P><h3> </h3>
 
The information in this article applies to:

<UL><LI>Microsoft Win32s versions 1.0, 1.1, 1.2, 1.30, 1.30a, 1.30c
</UL> 
<P>
<P><h2>SUMMARY</h2>
 
<P>
Translated pointers are guaranteed to be valid only for 32K, rather than
64K, which selectors are usually limited to. This limitation is for
performance reasons.
<P>
Selectors are tiled every 32K. A 0:32 pointer can be quickly translated
into a 16:16 pointer, which will be valid for a minimum of 32K. In other
words, the offset portion of the 16:16 pointer is not guaranteed to be 0
(zero) when translated. As a result, even though the translated selectors
have a limit of 64K, the offset passed to the 16-bit side may be as large
as 32K-1.
<P>
Selectors are created on a 32K alignment so that if you pass several
pointers to the same range, the Universal Thunk (UT) uses the same
selector. Selectors are freed when application terminates.
<P>
The alternative is to create a selector for each and every translation,
which is very slow.
<P>
<P><h2>MORE INFORMATION</h2>
 
<P>
For any given address, there are two selectors that point to it, but only
one has a limit less than 32K:
<P>
<PRE>           +-------+-------+-------+-------+-------+-------+
           |Selector 2(64K)|Selector 4(64K)|Selector 6(64K)|
   +-------+-------+-------+-------+-------+-------+-------+
   |Selector 1(64K)|Selector 3(64K)|Selector 5(64K)|       |
   +-------+-------+-------+-------+-------+-------+-------+
   |  32K  |  32K  |  32K  |  32K  |  32K  |  32K  |  32K  |
   +-------+-------+-------+-------+-------+-------+-------+

</PRE>Under Win32s, 16-bit and 32-bit applications share the same global data
space; therefore, it is possible to share a buffer of up to 64K in size
with a far pointer or more than 64K with a huge pointer by doing the
following:

<OL><P><LI>Do a GlobalAlloc() on the 32-bit side. Be sure to use GMEM_MOVEABLE.
</OL>2. Copy the data.
3. Send the handle to the 16-bit side.
4. Get a pointer to the data on the 16-bit side by using GlobalLock().
<PRE>   If the buffer in more than 64K in size, make sure to type cast the
   return value from GlobalLock() to a huge pointer.


</PRE></OL>When you pass a pointer to a block that was allocated via GlobalAlloc()
from the 32-bit side, it costs no selectors. The translated pointer is
valid until the memory is freed.
<P>
For more information on how to share large amounts of data between the
16-bit and 32-bit side of an Universal Thunk under Win32s, please refer
to the following Knowledge Base article:
<P>
<PRE>  ARTICLE ID: <B><A href="../win32sdk/q126708.htm">Q126708</A></B>
  TITLE     : HOWTO: Pass Large Memory Block Through Win32s Universal Thunk
 

	</FONT>
	</TD>
	</TR>
</TABLE>
<P>


<!--DOCBODY_END-->

<!--FOOTER_START-->
<table cellpadding=5 border=0 width="90%">
<tr>
<td>
	<HR WIDTH="90%">

<BLOCKQUOTE>
<FONT FACE="Verdana, Arial, Helvetica" SIZE="1">
<SPAN STYLE="font-family:verdana,arial,helvetica; font-size:8pt">
Keywords            : kbprg W32s W32sThunk kbprg<BR>
Version             : 1.0 1.1 1.2 1.3 1.3a 1.3c<BR>
Platform            : WINDOWS<BR>
Issue type          : kbinfo<BR>

</SPAN>
</FONT>
<BR>
<BR>
THE INFORMATION PROVIDED IN THE MICROSOFT KNOWLEDGE BASE IS
PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND.  MICROSOFT DISCLAIMS
ALL WARRANTIES, EITHER EXPRESS OR IMPLIED, INCLUDING THE WARRANTIES
OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  IN NO
EVENT SHALL MICROSOFT CORPORATION OR ITS SUPPLIERS BE LIABLE FOR
ANY DAMAGES WHATSOEVER INCLUDING DIRECT, INDIRECT, INCIDENTAL,
CONSEQUENTIAL, LOSS OF BUSINESS PROFITS OR SPECIAL DAMAGES, EVEN IF
MICROSOFT CORPORATION OR ITS SUPPLIERS HAVE BEEN ADVISED OF THE
POSSIBILITY OF SUCH DAMAGES.  SOME STATES DO NOT ALLOW THE EXCLUSION
OR LIMITATION OF LIABILITY FOR CONSEQUENTIAL OR INCIDENTAL DAMAGES
SO THE FOREGOING LIMITATION MAY NOT APPLY.
</BLOCKQUOTE>
<P>
<center>
	<FONT FACE="Verdana,Arial,Helvetica" SIZE="1">
	Last reviewed:  June 10, 1997</FONT>
	<BR>
	<A href="../cpyright.htm" STYLE="font: bold 7pt Verdana,Arial,Helvetica">&copy; 1998 Microsoft Corporation. All rights reserved. Terms of Use.</A><BR>
	
</center>
</td>
</tr>
</table>

<!--FOOTER_END-->
</FONT>
</BODY>
</HTML>
