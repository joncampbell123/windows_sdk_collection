

<HTML>
<HEAD>
<TITLE>Mapping Modes and Round-Off Errors </TITLE>

<!--STYLE_BEGIN-->
<style>@import url(../../msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="../../msdn_ie3.css">
<!--STYLE_END-->

<META HTTP-EQUIV="CONTENT-Type" CONTENT="text/html; charset=us-ascii">
<META NAME="ms.locale" CONTENT="EN-US">
<META NAME="Category" CONTENT="Support; KB Article">
<META NAME="KBID" CONTENT="Q89215 ">
<META NAME="KBModify" CONTENT="1995/11/02">
<META NAME="KBCreate" CONTENT="1992/09/14">
<META NAME="Keywords" CONTENT="kbgraphic">
<META NAME="KBArea" CONTENT="Support; KB; win32sdk">
<META NAME="Description" CONTENT="  Mapping modes, window extents/origins, and viewport extents/origins allow for very powerful coordinate manipulation, such as  scaling or moving objects. However, you should be aware that there are cases when using mapping modes other than MM_TEXT r...">
<META NAME="Product" CONTENT="Win32 SDK">
<META NAME="Platform" CONTENT="Windows">
<META NAME="Technology" CONTENT=" ">
<META NAME="Premium" CONTENT="support">

<META NAME="nyms" CONTENT="QAPN,QAAP,QAB4,QA5W,QAJH,QAK6,QAH4,QAMV,QAW6,QDL9,QBWO,QBWN,QANJ,QADX,QAKP V02180118">
</HEAD>

<BODY BGCOLOR="#FFFFFF" LEFTMARGIN="0" RIGHTMARGIN="0" TOPMARGIN="0">


<!--DOCBODY_START-->
<BR>
<CENTER>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" VALIGN="top" WIDTH="90%">
	<TR>
		<TD VALIGN="top">
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<H1>Mapping Modes and Round-Off Errors</H1>
			</FONT>
			<FONT FACE="verdana,arial,helvetica" SIZE="1">
			Last reviewed:  November 2, 1995</FONT><BR>
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<B>Article ID: Q89215 </B>
			</FONT>
		</TD>
	</TR>
	<TR>
	<TD>
	<FONT FACE="Verdana, Arial, Helvetica" SIZE=2>



 
The information in this article applies to:

<UL><LI>Microsoft Windows Software Development Kit (SDK) for Windows
   versions 3.1 and 3.0

<LI>Microsoft Win32 Application Programming Interface (API) included with:
<P>
<P><PRE>    - Microsoft Windows NT versions 3.5 and 3.51
    - Microsoft Windows 95 version 4.0
</UL></PRE> 
<P>
<P><h2>SUMMARY</h2>
 
<P>
Mapping modes, window extents/origins, and viewport extents/origins
allow for very powerful coordinate manipulation, such as  scaling or
moving objects. However, you should be aware that there are cases when
using mapping modes other than MM_TEXT results in improper painting
due to round-off errors.
<P>
Round-off errors occur when one logical unit does not equal one device
unit, and an application requests the graphics device interface (GDI)
to perform an action that would result in a nonintegral number of
pixels needing to be drawn, scrolled, blt'd, and so on.
<P>
Round-off errors can manifest themselves in many ways, including
unpainted portions of a client area when scrolling, gaps between
objects that shouldn't have gaps (or vice versa), objects that shrink
or grow one pixel depending on where they are on the screen, objects
of unexpected sizes, and so on.
<P>
<P><h2>MORE INFORMATION</h2>
 
<P>
To better understand round-off errors, consider the following code:
<P>
<PRE>  SetMapMode (hDC, MM_ANISOTROPIC);
  SetWindowExt (hDC, 2, 2);
  SetViewportExt (hDC, 3, 3);
  PatBlt (hDC, 0, 0, 5, 2, BLACKNESS);

</PRE>This code tells the GDI to treat two logical units (the coordinates
used by most GDI functions), in both the vertical and horizontal
direction, as being equal to three device units (pixels). It then asks
the GDI to draw what amounts to a black rectangle five logical units
wide by three logical units tall starting at the logical point (0,0).
<P>
The GDI would translate this request into a request to draw a
rectangle 7.5 (5 * 3/2 = 7.5) pixels wide by 3 (2 * 3/2 = 3) pixels
tall. However, display cards cannot draw half a pixel, so the GDI
would either have to round the width up to 8 or truncate it to 7. If
an application relied on one behavior or the other, improper painting
could occur.
<P>
Note that using mapping modes, window origins/extents, and viewport
origins/extents does not mean that an application will have round-off
errors. The occurrence of round-off errors depends on what these
features are used for, the structure of the application, and other
factors. Many applications take advantage of mapping modes, window
origins/extents, and viewport origins/extents without ever
encountering adverse round-off errors.
<P>
If an application exhibits round-off errors, there are a number of ways
to prevent them, some which are described below.
<P>
<P><h3>Method 1</h3>
 
<P>
Only use MM_TEXT mapping mode, where one logical unit always equals
one device unit. However, the application must do all its own scaling
and moving of objects. The benefit of this approach is that the
application has strict control over how objects are scaled and moved;
you can look at your code to see the algebra that leads to round-off
errors, and counter these errors appropriately. The drawback to this
approach is that it makes the code more complicated and harder to read
than it might be if the SetMapMode, SetWindowOrg, SetWindowExt,
SetViewportOrg, and SetViewportExt functions were used.
<P>
<P><h3>Method 2</h3>
 
<P>
Mix MM_TEXT mapping mode with the mapping mode required. Sometimes
applications only have round-off problems with certain types of
objects. For example, in a graphing program, the application might
want to set a certain mapping mode to draw a bar graph; this mapping
mode might cause the fonts that the application draws to be of the
wrong size.
<P>
To work around problems like this, mix MM_TEXT mapping mode with your
mapping mode of choice. You could use MM_TEXT when dealing with
objects that need exact sizes or placement and the other mapping mode
for other drawing.
<P>
The benefits and drawbacks of this method are almost the same as those
for method 1. However, with method 2, applications can take advantage
of mapping modes for some of the scaling and moving of objects.
<P>
<P><h3>Method 3</h3>
 
<P>
If window/viewport origins/extents are set at compile time, be sure to
only do operations that would result in no round-off errors. For
example, take the fraction WindowExt over ViewportExt, and reduce this
fraction. Then only do operations that involve multiples of the
reduced WindowExt values. For example, given the following
<P>
<PRE>    WindowExt   = ( 6, 27)
    ViewportExt = (50, 39)

</PRE>turn this into a fraction and reduce it. It yields:
<P>
<PRE>    in x direction:   6/50 = (2 * 3) / (2 * 5 * 5)  = 3/25
    in y direction:  27/39 = (3 * 3 * 3) / (3 * 13) = 9/13

</PRE>Therefore, anything done in the x direction could be done using a
multiple of three logical units; anything done in the y direction
could be done using a multiple of nine logical units. For example, if
the application wanted to scroll the window horizontally, it could
scroll 3, 6, 9, 12, and so on logical units without having to deal
with rounding errors. By using these values, the application will
never have round-off errors.
<P>
One benefit of this method is that an application can take advantage
of window origins/extents and viewport origins/extents. A disadvantage
is that the application is limited to a certain set of origins/extents
(that is, those built into the application at compile time).
<P>
<P><h3>Method 4</h3>
 
<P>
Applications can perform method 3 on-the-fly. This allows the
application to deal with arbitrary window origins/extents and viewport
origins/extents. To determine the minimum number of logical units an
application could use given arbitrary extent values, the following
code might prove useful (the code shown is for determining the value
to use in the horizontal direction):
<P>
<PRE>int GetMinWinXFactor (HDC hDC)
</PRE>{
<PRE>   int nMinX, xWinExt, xViewExt, nGCD;

   xWinExt  = LOWORD (GetWindowExt (hDC));
   xViewExt = LOWORD (GetViewportExt (hDC));
   while ((nGCD = GreatestCommonDivisor (xWinExt, xViewExt)) != 1)
      {
      xWinExt  /= nGCD;
      xViewExt /= nGCD;
      }
   return xWinExt;
</PRE>}
<P>
<PRE>int GreatestCommonDivisor (int i, int j)
</PRE>{
<PRE>   while (i != j)
      if (i &gt; j)
         i -= j;
      else
         j -= i;
   return i;
</PRE>}
<P>
The return value from the GetMinWinXFactor function above can then be
used just like in method 3 (that is, the application can do all output
based on multiples of this value).
<P>
<P><h3>Final Notes</h3>
 
<P>
The discussion above did not take into account the window origin,
which can contribute to round-off errors. How origins and extents
affect the coordinates that GDI uses is summed up in "Programmer's
Reference.
<P>
Developers using mapping modes are encouraged to study the equations
presented in the programmer's reference. The GDI uses these equations when
converting between logical and device units. When round-off errors occur in
an application, it is always a good idea to run the numbers through these
equations to try to determine the cause of the errors.
<P>

	</FONT>
	</TD>
	</TR>
</TABLE>
<P>


<!--DOCBODY_END-->

<!--FOOTER_START-->
<table cellpadding=5 border=0 width="90%">
<tr>
<td>
	<HR WIDTH="90%">

<BLOCKQUOTE>
<FONT FACE="Verdana, Arial, Helvetica" SIZE="1">
<SPAN STYLE="font-family:verdana,arial,helvetica; font-size:8pt">
Additional reference words: 3.00 3.10 3.50 4.00 95  rounding<BR>
KBCategory: kbgraphic<BR>
KBSubcategory: GdiDc<BR>

</SPAN>
</FONT>
<BR>
<BR>
THE INFORMATION PROVIDED IN THE MICROSOFT KNOWLEDGE BASE IS
PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND.  MICROSOFT DISCLAIMS
ALL WARRANTIES, EITHER EXPRESS OR IMPLIED, INCLUDING THE WARRANTIES
OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  IN NO
EVENT SHALL MICROSOFT CORPORATION OR ITS SUPPLIERS BE LIABLE FOR
ANY DAMAGES WHATSOEVER INCLUDING DIRECT, INDIRECT, INCIDENTAL,
CONSEQUENTIAL, LOSS OF BUSINESS PROFITS OR SPECIAL DAMAGES, EVEN IF
MICROSOFT CORPORATION OR ITS SUPPLIERS HAVE BEEN ADVISED OF THE
POSSIBILITY OF SUCH DAMAGES.  SOME STATES DO NOT ALLOW THE EXCLUSION
OR LIMITATION OF LIABILITY FOR CONSEQUENTIAL OR INCIDENTAL DAMAGES
SO THE FOREGOING LIMITATION MAY NOT APPLY.
</BLOCKQUOTE>
<P>
<center>
	<FONT FACE="Verdana,Arial,Helvetica" SIZE="1">
	Last reviewed:  November 2, 1995</FONT>
	<BR>
	<A href="../cpyright.htm" STYLE="font: bold 7pt Verdana,Arial,Helvetica">&copy; 1998 Microsoft Corporation. All rights reserved. Terms of Use.</A><BR>
	
</center>
</td>
</tr>
</table>

<!--FOOTER_END-->
</FONT>
</BODY>
</HTML>
