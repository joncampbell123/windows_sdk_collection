

<HTML>
<HEAD>
<TITLE>Retrieving Palette Information from a Bitmap Resource </TITLE>

<!--STYLE_BEGIN-->
<style>@import url(../../msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="../../msdn_ie3.css">
<!--STYLE_END-->

<META HTTP-EQUIV="CONTENT-Type" CONTENT="text/html; charset=us-ascii">
<META NAME="ms.locale" CONTENT="EN-US">
<META NAME="Category" CONTENT="Support; KB Article">
<META NAME="KBID" CONTENT="Q124947">
<META NAME="KBModify" CONTENT="1996/11/20">
<META NAME="KBCreate" CONTENT="1995/01/17">
<META NAME="Keywords" CONTENT="kbgraphic">
<META NAME="KBArea" CONTENT="Support; KB; win32sdk">
<META NAME="Description" CONTENT="  You may sometime need to create a logical palette from a bitmap resource in order to display the bitmap with the maximum number of available colors. For example, on an 8 bit-per-pixel display, a logical palette is necessary to draw a 256-color bitm...">
<META NAME="Product" CONTENT="Win32 SDK">
<META NAME="Platform" CONTENT="Windows">
<META NAME="Technology" CONTENT=" ">
<META NAME="Premium" CONTENT="support">

<META NAME="nyms" CONTENT="QAPG,QDL9,QBWO,QBWN,QAY5,QAUD,QAG9,QAIM,QAY2,QAH2,QAMV,QBV8,QAB9,QAI4,QALW V02180118">
</HEAD>

<BODY BGCOLOR="#FFFFFF" LEFTMARGIN="0" RIGHTMARGIN="0" TOPMARGIN="0">


<!--DOCBODY_START-->
<BR>
<CENTER>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" VALIGN="top" WIDTH="90%">
	<TR>
		<TD VALIGN="top">
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<H1>Retrieving Palette Information from a Bitmap Resource</H1>
			</FONT>
			<FONT FACE="verdana,arial,helvetica" SIZE="1">
			Last reviewed:  November 20, 1996</FONT><BR>
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<B>Article ID: Q124947</B>
			</FONT>
		</TD>
	</TR>
	<TR>
	<TD>
	<FONT FACE="Verdana, Arial, Helvetica" SIZE=2>



 
The information in this article applies to:

<UL><LI>Microsoft Windows Software Development Kit (SDK) for Windows
   version 3.1

<LI>Microsoft Win32 Application Programming Interface (API) included with:
<P>
<P><PRE>    - Microsoft Windows NT versions 3.5 and 3.51
    - Microsoft Windows 95 version 4.0
    - Microsoft Win32s versions 1.2, 1.25a, and 1.3
</UL></PRE> 
<P>
<P><h2>SUMMARY</h2>
 
<P>
You may sometime need to create a logical palette from a bitmap resource in
order to display the bitmap with the maximum number of available colors.
For example, on an 8 bit-per-pixel display, a logical palette is necessary
to draw a 256-color bitmap on a device context for that display. The
LoadBitmap function does not return or take a palette as one of its
parameters; thus, for example, there is no way to incorporate a palette
with a 256-color bitmap loaded with LoadBitmap. Therefore, an application
must load the resource as a device-independent bitmap (DIB), rather than a
device-dependent bitmap (DDB), in order to retrieve the bitmap's color
information. An application can use the FindResource, LoadResource, and
LockResource functions to do this.
<P>
The solution differs slightly for Win32s.
<P>
<P>
<P><h2>MORE INFORMATION</h2>
 
<P>
<P><h3>Windows and Windows NT</h3>
 
<P>
A bitmap (.BMP file) is stored in an application's resources as a (DIB),
along with a color table if one exists. When a DIB is loaded from an
application's resources with the LoadBitmap function, a DDB is returned.
This DDB is a bitmap compatible with the screen. Routines such as
CreateDIBitmap and SetDIBits that convert DIBs to DDBs take a handle to a
device context as their first parameter. This tells the routine what kind
of DDB to create. If this device context currently has a palette selected
into it, then CreateDIBitmap or SetDIBits can use this palette to create
the DDB. Without a palette, the routines are restricted to system colors
when matching the DIB's colors to the DDB's colors. For example, on an 8
bit-per-pixel display, the resulting DDB can have only up to 20 different
colors. With a logical palette, the resulting bitmap could have had up to
256 different colors.
<P>
If the bitmap is loaded as a DIB from the resource, then an application can
query the DIB's color table and create a logical palette for the DIB. Then,
it can call either CreateDIBitmap or SetDIBits, along with a device context
with that palette selected, to obtain a DDB compatible with that palette.
To load a bitmap from a resource as a DIB, you can use the FindResource
function with the RT_BITMAP flag set and then use the LoadResource function
to load it. You can lock the resource with the LockResource function.
<P>
The following code demonstrates how to use the above technique to load a
DIB from an application's resources, create a palette for it, and then
create a DDB out of it. The LoadResourceBitmap function below can be used
in place of the LoadBitmap function. The only additional parameter needed
is the address of a logical palette handle. The palette handle referenced
will contain a handle to a logical palette after the function is called.
<P>
HBITMAP LoadResourceBitmap(HINSTANCE hInstance, LPSTR lpString,
<PRE>                           HPALETTE FAR* lphPalette)
{
    HRSRC  hRsrc;
    HGLOBAL hGlobal;
    HBITMAP hBitmapFinal = NULL;
    LPBITMAPINFOHEADER  lpbi;
    HDC hdc;
    int iNumColors;

    if (hRsrc = findresource(hinstance, lpString, RT_BITMAP))
       {
       hGlobal = LoadResource(hInstance, hRsrc);
       lpbi = (LPBITMAPINFOHEADER)LockResource(hGlobal);

       hdc = GetDC(NULL);
       *lphPalette =  CreateDIBPalette ((LPBITMAPINFO)lpbi, &amp;iNumColors);
       if (*lphPalette)
          {
          SelectPalette(hdc,*lphPalette,FALSE);
          RealizePalette(hdc);
          }

       hBitmapFinal = CreateDIBitmap(hdc,
                   (LPBITMAPINFOHEADER)lpbi,
                   (LONG)CBM_INIT,
                   (LPSTR)lpbi + lpbi-&gt;biSize + iNumColors *
</PRE>sizeof(RGBQUAD),
<P>
<PRE>                   (LPBITMAPINFO)lpbi,
                   DIB_RGB_COLORS );

       ReleaseDC(NULL,hdc);
       UnlockResource(hGlobal);
       FreeResource(hGlobal);
       }
    return (hBitmapFinal);
</PRE>}
<P>
HPALETTE CreateDIBPalette (LPBITMAPINFO lpbmi, LPINT lpiNumColors)
{
<PRE>   LPBITMAPINFOHEADER  lpbi;
   LPLOGPALETTE     lpPal;
   HANDLE           hLogPal;
   HPALETTE         hPal = NULL;
   int              i;

   lpbi = (LPBITMAPINFOHEADER)lpbmi;
   if (lpbi-&gt;biBitCount &lt;= 8)
       *lpiNumColors = (1 &lt;&lt; lpbi-&gt;biBitCount);
   else
       *lpiNumColors = 0;  // No palette needed for 24 BPP DIB

   if (lpbi-&gt;biClrUsed &gt; 0)
       *lpiNumColors = lpbi-&gt;biClrUsed;  // Use biClrUsed

   if (*lpiNumColors)
      {
      hLogPal = GlobalAlloc (GHND, sizeof (LOGPALETTE) +
                             sizeof (PALETTEENTRY) * (*lpiNumColors));
      lpPal = (LPLOGPALETTE) GlobalLock (hLogPal);
      lpPal-&gt;palVersion    = 0x300;
      lpPal-&gt;palNumEntries = *lpiNumColors;

      for (i = 0;  i &lt; *lpiNumColors;  i++)
         {
         lpPal-&gt;palPalEntry[i].peRed   = lpbmi-&gt;bmiColors[i].rgbRed;
         lpPal-&gt;palPalEntry[i].peGreen = lpbmi-&gt;bmiColors[i].rgbGreen;
         lpPal-&gt;palPalEntry[i].peBlue  = lpbmi-&gt;bmiColors[i].rgbBlue;
         lpPal-&gt;palPalEntry[i].peFlags = 0;
         }
      hPal = CreatePalette (lpPal);
      GlobalUnlock (hLogPal);
      GlobalFree   (hLogPal);
   }
   return hPal;
</PRE>}
<P>
Here is an example of how you might use the above function to load a bitmap
from a resource and display it using a logical palette:
<P>
<PRE>   {
   HBITMAP hBitmap,hOldBitmap;
   HPALETTE hPalette;
   HDC hMemDC, hdc;
   BITMAP bm;

   hBitmap = LoadResourceBitmap(hInst,"test", &amp;hPalette);
   GetObject(hBitmap, sizeof(BITMAP), (LPSTR)&amp;bm);
   hdc = GetDC(hWnd);
   hMemDC = CreateCompatibleDC(hdc);
   SelectPalette(hdc,hPalette,FALSE);
   RealizePalette(hdc);
   SelectPalette(hMemDC,hPalette,FALSE);
   RealizePalette(hMemDC);
   hOldBitmap = SelectObject(hMemDC,hBitmap);
   BitBlt(hdc,0,0,bm.bmWidth,bm.bmHeight,hMemDC,0,0,SRCCOPY);
   DeleteObject(SelectObject(hMemDC,hOldBitmap));
   DeleteDC(hMemDC);
   ReleaseDC(hWnd,hdc);
   DeleteObject(hPalette);
   }

</PRE><h3>Win32s</h3>
 
<P>
On Win32s, LoadResource does not return a true global memory handle. This
causes CreateDIBitmap to fail. To work around this problem, use GlobalAlloc
to create a global memory handle.
<P>
Here is what LoadResourceBitmap should be on Win32s:
<P>
HBITMAP LoadResourceBitmap(HINSTANCE hInstance, LPSTR lpString,
<PRE>                           HPALETTE FAR* lphPalette)
{
    HRSRC  hRsrc;
    HGLOBAL hGlobal, hTemp;
    DWORD dwSize;
    HBITMAP hBitmapFinal = NULL;
    LPBITMAPINFOHEADER  lpbi;
    LPSTR lpRes, lpNew;
    HDC hdc;
    int iNumColors;

    if (hRsrc = findresource(hinstance, lpString, RT_BITMAP))
    {
       hTemp = LoadResource(hInstance, hRsrc);
       dwSize = SizeofResource(hInstance, hRsrc);
       lpRes = LockResource(hTemp);

       hGlobal = GlobalAlloc(GHND, dwSize);
       lpNew = GlobalLock(hGlobal);
       memcpy(lpNew, lpRes, dwSize);
       UnlockResource(hTemp);
       FreeResource(hTemp);

       lpbi = (LPBITMAPINFOHEADER)lpNew;

       hdc = GetDC(NULL);
       *lphPalette =  CreateDIBPalette ((LPBITMAPINFO)lpbi, &amp;iNumColors);
       if (*lphPalette)
       {
          SelectPalette(hdc,*lphPalette,FALSE);
          RealizePalette(hdc);
       }

       hBitmapFinal = CreateDIBitmap(hdc,
                 (LPBITMAPINFOHEADER)lpbi,
                 (LONG)CBM_INIT,
                 (LPSTR)lpbi + lpbi-&gt;biSize + iNumColors * sizeof(RGBQUAD),
                 (LPBITMAPINFO)lpbi,
                 DIB_RGB_COLORS );

       ReleaseDC(NULL,hdc);
       GlobalUnlock(hGlobal);
       GlobalFree(hGlobal);
    }
    return (hBitmapFinal);
</PRE>}
<P>
<P><h2>REFERENCES</h2>
 
<P>
For more information on DIB-related functions, please review the Microsoft
Windows SDK sample DIBVIEW.
<P>

	</FONT>
	</TD>
	</TR>
</TABLE>
<P>


<!--DOCBODY_END-->

<!--FOOTER_START-->
<table cellpadding=5 border=0 width="90%">
<tr>
<td>
	<HR WIDTH="90%">

<BLOCKQUOTE>
<FONT FACE="Verdana, Arial, Helvetica" SIZE="1">
<SPAN STYLE="font-family:verdana,arial,helvetica; font-size:8pt">
Additional reference words: 1.20 1.25a 1.30 3.10 3.50 4.00 95<BR>
KBCategory: kbgraphic<BR>
KBSubcategory: GdiBmp<BR>

</SPAN>
</FONT>
<BR>
<BR>
THE INFORMATION PROVIDED IN THE MICROSOFT KNOWLEDGE BASE IS
PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND.  MICROSOFT DISCLAIMS
ALL WARRANTIES, EITHER EXPRESS OR IMPLIED, INCLUDING THE WARRANTIES
OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  IN NO
EVENT SHALL MICROSOFT CORPORATION OR ITS SUPPLIERS BE LIABLE FOR
ANY DAMAGES WHATSOEVER INCLUDING DIRECT, INDIRECT, INCIDENTAL,
CONSEQUENTIAL, LOSS OF BUSINESS PROFITS OR SPECIAL DAMAGES, EVEN IF
MICROSOFT CORPORATION OR ITS SUPPLIERS HAVE BEEN ADVISED OF THE
POSSIBILITY OF SUCH DAMAGES.  SOME STATES DO NOT ALLOW THE EXCLUSION
OR LIMITATION OF LIABILITY FOR CONSEQUENTIAL OR INCIDENTAL DAMAGES
SO THE FOREGOING LIMITATION MAY NOT APPLY.
</BLOCKQUOTE>
<P>
<center>
	<FONT FACE="Verdana,Arial,Helvetica" SIZE="1">
	Last reviewed:  November 20, 1996</FONT>
	<BR>
	<A href="../cpyright.htm" STYLE="font: bold 7pt Verdana,Arial,Helvetica">&copy; 1998 Microsoft Corporation. All rights reserved. Terms of Use.</A><BR>
	
</center>
</td>
</tr>
</table>

<!--FOOTER_END-->
</FONT>
</BODY>
</HTML>
