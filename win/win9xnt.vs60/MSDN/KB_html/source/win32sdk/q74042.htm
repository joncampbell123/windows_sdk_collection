

<HTML>
<HEAD>
<TITLE>How to Use PeekMessage() Correctly in Windows </TITLE>

<!--STYLE_BEGIN-->
<style>@import url(../../msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="../../msdn_ie3.css">
<!--STYLE_END-->

<META HTTP-EQUIV="CONTENT-Type" CONTENT="text/html; charset=us-ascii">
<META NAME="ms.locale" CONTENT="EN-US">
<META NAME="Category" CONTENT="Support; KB Article">
<META NAME="KBID" CONTENT="Q74042 ">
<META NAME="KBModify" CONTENT="1997/07/22">
<META NAME="KBCreate" CONTENT="1991/07/11">
<META NAME="Keywords" CONTENT="kb16bitonly">
<META NAME="KBArea" CONTENT="Support; KB; win32sdk">
<META NAME="Description" CONTENT="  In the Windows environment, many applications use a PeekMessage() loop to perform background processing. Such applications must allow the Windows system to enter an idle state when their background processing is complete. Otherwise, system performa...">
<META NAME="Product" CONTENT="Win32 SDK">
<META NAME="Platform" CONTENT="Windows">
<META NAME="Technology" CONTENT=" ">
<META NAME="Premium" CONTENT="support">

<META NAME="nyms" CONTENT="QBSO,QDL9,QBWO,QBWN,QAA7,QAGI,QBWQ,QAJH,QAY5,QAUD,QBVV,QAU3,QAMR,QAYV,QAPW V02180118">
</HEAD>

<BODY BGCOLOR="#FFFFFF" LEFTMARGIN="0" RIGHTMARGIN="0" TOPMARGIN="0">


<!--DOCBODY_START-->
<BR>
<CENTER>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" VALIGN="top" WIDTH="90%">
	<TR>
		<TD VALIGN="top">
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<H1>How to Use PeekMessage() Correctly in Windows</H1>
			</FONT>
			<FONT FACE="verdana,arial,helvetica" SIZE="1">
			Last reviewed:  July 22, 1997</FONT><BR>
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<B>Article ID: Q74042 </B>
			</FONT>
		</TD>
	</TR>
	<TR>
	<TD>
	<FONT FACE="Verdana, Arial, Helvetica" SIZE=2>



 
3.00 3.10 4.00 | 3.10 3.50 3.51
<PRE>WINDOWS        | WINDOWS NT
kbui

</PRE> 
The information in this article applies to:

<UL><LI>Microsoft Windows Software Development Kit (SDK) versions 3.0 and 3.1

<LI>Microsoft Win32 Application Programming Interface (API) included with:
<P>
<P><PRE>    - Microsoft Windows NT versions 3.5 and 3.51
    - Microsoft Windows 95 version 4.0
</UL></PRE> 
<P>
<P><h2>SUMMARY</h2>
 
<P>
In the Windows environment, many applications use a PeekMessage() loop to
perform background processing. Such applications must allow the Windows
system to enter an idle state when their background processing is complete.
Otherwise, system performance, "idle-time" system processes such as paging
optimizations, and power management on battery-powered systems will be
adversely affected.
<P>
While an application is in a PeekMessage() loop, the Windows system cannot
go idle. Therefore, an application should not remain in a PeekMessage()
loop after its background processing has completed.
<P>
NOTE: The PeekMessage method described in this article is only needed if
your application is a 32-bit application for Windows and is, for some
reason, unable to create threads and perform background processing.
<P>
<P><h2>MORE INFORMATION</h2>
 
<P>
Many Windows-based applications use PeekMessage() to retrieve messages
while they are in the middle of a long process, such as printing,
repaginating, or recalculating, that must be done "in the background."
PeekMessage() is used in these situations because, unlike GetMessage(), it
does not wait for a message to be placed in the queue before it returns.
<P>
An application should not call PeekMessage() unless it has background
processing to do between the calls to PeekMessage(). When an application is
waiting for an input event, it should call GetMessage() or WaitMessage().
<P>
Remaining in a PeekMessage() loop when there is no background work
causes system performance problems. A program in a PeekMessage() loop
continues to be rescheduled by the Windows scheduler, consuming CPU
time and taking time away from other processes.
<P>
In enhanced mode, the virtual machine (VM) in which Windows is running
will not appear to be idle as long as an application is calling the
PeekMessage function. Therefore, the Windows VM will continue to
receive a considerable fraction of CPU time.
<P>
Many power management methods employed on laptop and notebook computers are
based on the system going idle when there is no processing to do. An
application that remains in a PeekMessage() loop will make the system
appear busy to power management software, resulting in excessive power
consumption and shortening the time that the user can run the system.
<P>
In the future, the Windows system will make more and more use of idle
time to do background processing, which is designed to optimize system
performance. Applications that do not allow the system to go idle will
adversely affect the performance of these techniques.
<P>
All these problems can be avoided by calling the PeekMessage() function
only when there is background work to do, and calling GetMessage() or
WaitMessage() when there is no background work to do.
<P>
For example, consider the following PeekMessage() loop. If there is no
background processing to do, this loop will continue to run without
waiting for messages, preventing the system from going idle and
causing the negative effects described above.
<P>
<PRE>   // This PeekMessage loop will NOT let the system go idle.

   for( ;; )
   {
      while (PeekMessage(&amp;msg, NULL, 0, 0, PM_REMOVE))
      {
         if (msg.message == WM_QUIT)
            return TRUE;

         TranslateMessage(&amp;msg);
         DispatchMessage(&amp;msg);
      }

      BackgroundProcessing();
    }

</PRE>This loop can be rewritten in two ways, as shown below. Both of the
following PeekMessage() loops have two desirable properties:

<UL><LI>They process all input messages before performing background
   processing, providing good response to user input.

<LI>The application "idles" (waits for an input message) when no
   background processing needs to be done.
<P>
</UL><h3>Improved PeekMessage Loop 1</h3>
 
<P>
<PRE>   // Improved PeekMessage() loop

   for(;;)
   {
      while (PeekMessage(&amp;msg, NULL, 0, 0, PM_REMOVE))
      {
         if (msg.message == WM_QUIT)
            return TRUE;

         TranslateMessage(&amp;msg);
         DispatchMessage(&amp;msg);
      }

      if (IfBackgroundProcessingRequired())
         BackgroundProcessing();
      else
         WaitMessage(); // Will not return until a message is posted.
   }

</PRE><h3>Improved PeekMessage Loop 2</h3>
 
<P>
<PRE>   // Another improved PeekMessage() loop

   for (;;)
   {
      for (;;)
      {
         if (IfBackgroundProcessingRequired())
         {
            if (!PeekMessage(&amp;msg, NULL, 0, 0, PM_REMOVE))
               break;
         }
         else
            GetMessage(&amp;msg, NULL, 0, 0, 0);

         if (msg.message == WM_QUIT)
            return TRUE;

         TranslateMessage(&amp;msg);
         DispatchMessage(&amp;msg);
      }
      BackgroundProcessing();
   }

</PRE>Note that calls to functions such as IsDialogMessage() and
TranslateAccelerator() can be added to these loops as appropriate.
<P>
There is one case in which the loops above need additional support: if
the application waits for input from a device (for example, a fax
board) that does not send standard Windows messages. For the reasons
outlined above, a Windows-based application should not use a PeekMessage()
loop to continuously poll the device. Rather, implement an interrupt
service routine (ISR) in a dynamic-link library (DLL). When the ISR is
called, the DLL can use the PostMessage function to inform the
application that the device requires service. DLL functions can safely
call the PostMessage() function because the PostMessage() function
is reentrant.
<P>

	</FONT>
	</TD>
	</TR>
</TABLE>
<P>


<!--DOCBODY_END-->

<!--FOOTER_START-->
<table cellpadding=5 border=0 width="90%">
<tr>
<td>
	<HR WIDTH="90%">

<BLOCKQUOTE>
<FONT FACE="Verdana, Arial, Helvetica" SIZE="1">
<SPAN STYLE="font-family:verdana,arial,helvetica; font-size:8pt">
Additional reference words: 3.00 3.10 3.50 4.00 95<BR>
KBCategory: kbui<BR>
KBSubcategory: UsrMsg<BR>
Keywords            : kb16bitonly<BR>

</SPAN>
</FONT>
<BR>
<BR>
THE INFORMATION PROVIDED IN THE MICROSOFT KNOWLEDGE BASE IS
PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND.  MICROSOFT DISCLAIMS
ALL WARRANTIES, EITHER EXPRESS OR IMPLIED, INCLUDING THE WARRANTIES
OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  IN NO
EVENT SHALL MICROSOFT CORPORATION OR ITS SUPPLIERS BE LIABLE FOR
ANY DAMAGES WHATSOEVER INCLUDING DIRECT, INDIRECT, INCIDENTAL,
CONSEQUENTIAL, LOSS OF BUSINESS PROFITS OR SPECIAL DAMAGES, EVEN IF
MICROSOFT CORPORATION OR ITS SUPPLIERS HAVE BEEN ADVISED OF THE
POSSIBILITY OF SUCH DAMAGES.  SOME STATES DO NOT ALLOW THE EXCLUSION
OR LIMITATION OF LIABILITY FOR CONSEQUENTIAL OR INCIDENTAL DAMAGES
SO THE FOREGOING LIMITATION MAY NOT APPLY.
</BLOCKQUOTE>
<P>
<center>
	<FONT FACE="Verdana,Arial,Helvetica" SIZE="1">
	Last reviewed:  July 22, 1997</FONT>
	<BR>
	<A href="../cpyright.htm" STYLE="font: bold 7pt Verdana,Arial,Helvetica">&copy; 1998 Microsoft Corporation. All rights reserved. Terms of Use.</A><BR>
	
</center>
</td>
</tr>
</table>

<!--FOOTER_END-->
</FONT>
</BODY>
</HTML>
