

<HTML>
<HEAD>
<TITLE>HOWTO: Detect All Program Terminations </TITLE>

<!--STYLE_BEGIN-->
<style>@import url(../../msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="../../msdn_ie3.css">
<!--STYLE_END-->

<META HTTP-EQUIV="CONTENT-Type" CONTENT="text/html; charset=us-ascii">
<META NAME="ms.locale" CONTENT="EN-US">
<META NAME="Category" CONTENT="Support; KB Article">
<META NAME="KBID" CONTENT="Q125689">
<META NAME="KBModify" CONTENT="1997/05/27">
<META NAME="KBCreate" CONTENT="1995/02/01">
<META NAME="Keywords" CONTENT="BseProcThrd kbcode kbprg">
<META NAME="KBArea" CONTENT="Support; KB; win32sdk">
<META NAME="Description" CONTENT="  The processes for detecting program terminations fall into two categories:   - Win32 processes use one of the Wait Functions, WaitForSingleObject(),    MsgWaitForMultipleObjects(), etc., to wait for other Win32 processes,    Windows 16-bit processe...">
<META NAME="Product" CONTENT="Win32 SDK">
<META NAME="Platform" CONTENT="Windows">
<META NAME="Technology" CONTENT=" ">
<META NAME="Premium" CONTENT="support">

<META NAME="nyms" CONTENT="QAH4,QAY5,QAGB,QABH,QABI,QBV8,QAB9,QAJH,QAUD,QDL9,QBWO,QBWN,QBVV,QAPN,QAHT V02180118">
</HEAD>

<BODY BGCOLOR="#FFFFFF" LEFTMARGIN="0" RIGHTMARGIN="0" TOPMARGIN="0">


<!--DOCBODY_START-->
<BR>
<CENTER>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" VALIGN="top" WIDTH="90%">
	<TR>
		<TD VALIGN="top">
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<H1>HOWTO: Detect All Program Terminations</H1>
			</FONT>
			<FONT FACE="verdana,arial,helvetica" SIZE="1">
			Last reviewed:  May 27, 1997</FONT><BR>
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<B>Article ID: Q125689</B>
			</FONT>
		</TD>
	</TR>
	<TR>
	<TD>
	<FONT FACE="Verdana, Arial, Helvetica" SIZE=2>



 
 
The information in this article applies to:

<UL><LI>Microsoft Win32 Application Programming Interface (API) included with:
   - Microsoft Windows 95
</UL> 
<P>
<P><h2>SUMMARY</h2>
 
<P>
The processes for detecting program terminations fall into two categories:

<UL><LI>Win32 processes use one of the Wait Functions, WaitForSingleObject(),
   MsgWaitForMultipleObjects(), etc., to wait for other Win32 processes,
   Windows 16-bit processes, and MS-DOS-based applications to terminate.

<LI>Windows 16-bit processes, on the other hand, must use the TOOLHELP
   NotifyRegister() function. The 16-bit processes can be notified when
   other 16-bit processes and MS-DOS-based applications exit, but have the
   limitation of not being notified of Win32 process activity.
<P>
</UL><h2>MORE INFORMATION</h2>
 
<P>
Win32 processes can use one of the Wait functions to wait for a spawned
process. By using CreateProcess() to launch a Win32 process, 16-bit
process, or MS-DOS-based application, you can fill in a PROCESS_INFORMATION
structure. The hProcess field of this structure can be used to wait until
the spawned process terminates. For example, the following code spawns a
process and waits for its termination:
<P>
<PRE>  PROCESS_INFORMATION ProcessInfo;
  STARTUPINFO StartupInfo = {0};
  StartupInfo.cb = sizeof(STARTUPINFO);
  if (CreateProcess(NULL, szCommandLine, NULL, NULL, FALSE,
        0, NULL, NULL, &amp;StartupInfo, &amp;ProcessInfo))
   {
       WaitForSingleObject(ProcessInfo.hProcess, INFINITE);
       /* Process has terminated */
       ...
   }
   else
   {
       /* Process could not be started */
       ...
   }

</PRE>If necessary, you can put this code into a separate thread to allow the
initial thread to continue to execute.
<P>
NOTE: For a discussion of how the NTVDM WOW architecture may influence
waiting on 16-bit applications, please see the following article in the
Microsoft Knowledge Base:
<P>
<PRE>   ARTICLE-ID: <B><A href="../win32sdk/q105676.htm">Q105676</A></B>
   TITLE     : Starting and Terminating Windows-based Application

</PRE>This synchronization method is not available to 16-bit processes. Instead,
they must use the TOOLHELP NotifyRegister function to register a callback
function to be called when a program terminates. This method will detect
the termination of 16-bit processes and MS-DOS-based applications, but not
Win32 processes.
<P>
The following code shows how to register a callback function with
NotifyRegister():
<P>
<PRE>   FARPROC lpfnCallback;

   lpfnCallback = MakeProcInstance(NotifyRegisterCallback, ghInst);
   if (!NotifyRegister(NULL, (LPFNNOTIFYCALLBACK)lpfnCallback,
                       NF_NORMAL))
   {
      MessageBox(NULL, "NotifyRegister Failed", "Error", MB_OK);
      FreeProcInstance(lpfnCallback);
   }

</PRE>The next section of code demonstrates the implementation of the callback
function:
<P>
<PRE>   BOOL FAR PASCAL __export NotifyRegisterCallback (WORD wID,
                                                    DWORD dwData)
   {
      HTASK hTask;  // task that called the notification callback
      TASKENTRY te;

      // Check for task exiting
      switch (wID)
      {
         case NFY_EXITTASK:
            // Obtain info about the task that is terminating
            hTask = GetCurrentTask();
            te.dwSize = sizeof(TASKENTRY);
            TaskFindHandle(&amp;te, hTask);

            // Check if the task that is terminating is our child task.
            // Also check if the hInstance of the task that is
            // terminating is the same as the hInstance of the task
            // that was WinExec'd by us earlier in the program.

            if (te.hTaskParent == ghtaskParent &amp;&amp;
                te.hInst == ghInstChild)
                PostMessage(ghwnd, WM_USER+509, (WORD)te.hInst, dwData);
            break;

         default:
            break;
      }
      // Pass notification to other callback functions
      return FALSE;
   }

</PRE>The NotifyRegisterCallback() API is called by the 16-bit TOOLHELP DLL in
the context of the process that is causing the event. Problems arising
because of reentrancy and notification chaining makes the callback function
subject to certain restrictions. For example, operations that cause
TOOLHELP events cannot be done in the callback function. (See the TOOLHELP
NotifyRegister function documentation in your Software Development Kit for
events that cause TOOLHELP callbacks.)
<P>
There is no way a 16-bit process can be notified when a Win32 process
exits. However, a 16-bit process can use TaskFirst() and TaskNext() to
periodically walk the task list to determine if a Win32 process is still
executing. This technique also works for 16-bit processes and MS-DOS-based
applications. For example, the following code shows how to check for the
existence of a process:
<P>
<PRE>   BOOL StillExecuting(HINSTANCE hAppInstance)
   {
      TASKENTRY  te = {0};

      te.dwSize = sizeof(te);
      if (TaskFirst(&amp;te))
          do
          {
             if (te.hInstance == hAppInstance)
                return TRUE;      // process found
          } while (TaskNext(&amp;te));

      // process not found
      return FALSE;
   }

</PRE>Refer to the TermWait sample for complete details on how to use
NotifyRegister and implement a callback function. For additional
information, please search in the Microsoft Knowledge Base using this word:
<P>
<PRE>   TERMWAIT
</PRE>

	</FONT>
	</TD>
	</TR>
</TABLE>
<P>


<!--DOCBODY_END-->

<!--FOOTER_START-->
<table cellpadding=5 border=0 width="90%">
<tr>
<td>
	<HR WIDTH="90%">

<BLOCKQUOTE>
<FONT FACE="Verdana, Arial, Helvetica" SIZE="1">
<SPAN STYLE="font-family:verdana,arial,helvetica; font-size:8pt">
Additional query words: end exit notification notify spawn terminate<BR>
termination<BR>
Keywords            : BseProcThrd kbcode kbprg<BR>
Version             : 95<BR>
Platform            : Win95<BR>
Issue type          : kbhowto<BR>

</SPAN>
</FONT>
<BR>
<BR>
THE INFORMATION PROVIDED IN THE MICROSOFT KNOWLEDGE BASE IS
PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND.  MICROSOFT DISCLAIMS
ALL WARRANTIES, EITHER EXPRESS OR IMPLIED, INCLUDING THE WARRANTIES
OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  IN NO
EVENT SHALL MICROSOFT CORPORATION OR ITS SUPPLIERS BE LIABLE FOR
ANY DAMAGES WHATSOEVER INCLUDING DIRECT, INDIRECT, INCIDENTAL,
CONSEQUENTIAL, LOSS OF BUSINESS PROFITS OR SPECIAL DAMAGES, EVEN IF
MICROSOFT CORPORATION OR ITS SUPPLIERS HAVE BEEN ADVISED OF THE
POSSIBILITY OF SUCH DAMAGES.  SOME STATES DO NOT ALLOW THE EXCLUSION
OR LIMITATION OF LIABILITY FOR CONSEQUENTIAL OR INCIDENTAL DAMAGES
SO THE FOREGOING LIMITATION MAY NOT APPLY.
</BLOCKQUOTE>
<P>
<center>
	<FONT FACE="Verdana,Arial,Helvetica" SIZE="1">
	Last reviewed:  May 27, 1997</FONT>
	<BR>
	<A href="../cpyright.htm" STYLE="font: bold 7pt Verdana,Arial,Helvetica">&copy; 1998 Microsoft Corporation. All rights reserved. Terms of Use.</A><BR>
	
</center>
</td>
</tr>
</table>

<!--FOOTER_END-->
</FONT>
</BODY>
</HTML>
