

<HTML>
<HEAD>
<TITLE>HOWTO: Eject Removable Media on Windows 95 </TITLE>

<!--STYLE_BEGIN-->
<style>@import url(../../msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="../../msdn_ie3.css">
<!--STYLE_END-->

<META HTTP-EQUIV="CONTENT-Type" CONTENT="text/html; charset=us-ascii">
<META NAME="ms.locale" CONTENT="EN-US">
<META NAME="Category" CONTENT="Support; KB Article">
<META NAME="KBID" CONTENT="Q168180">
<META NAME="KBModify" CONTENT="1997/05/12">
<META NAME="KBCreate" CONTENT="1997/05/07">
<META NAME="Keywords" CONTENT="BseFileio kbcode kbhowto">
<META NAME="KBArea" CONTENT="Support; KB; win32sdk">
<META NAME="Description" CONTENT="  Some Win32 applications need to have the ability to eject removable media from a drive on Windows 95. To do so safely, an application should first make sure that no other applications are currently using the media. Ejecting the media while another ...">
<META NAME="Product" CONTENT="Win32 SDK">
<META NAME="Platform" CONTENT="Windows">
<META NAME="Technology" CONTENT=" ">
<META NAME="Premium" CONTENT="support">

<META NAME="nyms" CONTENT="QAUD,QAYS,QABT,QAI4,QAGI,QAHE,QALW,QALG,QAJ6,QABI,QDL9,QBWO,QBWN,QAK7,QAH4 V02180118">
</HEAD>

<BODY BGCOLOR="#FFFFFF" LEFTMARGIN="0" RIGHTMARGIN="0" TOPMARGIN="0">


<!--DOCBODY_START-->
<BR>
<CENTER>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" VALIGN="top" WIDTH="90%">
	<TR>
		<TD VALIGN="top">
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<H1>HOWTO: Eject Removable Media on Windows 95</H1>
			</FONT>
			<FONT FACE="verdana,arial,helvetica" SIZE="1">
			Last reviewed:  May 12, 1997</FONT><BR>
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<B>Article ID: Q168180</B>
			</FONT>
		</TD>
	</TR>
	<TR>
	<TD>
	<FONT FACE="Verdana, Arial, Helvetica" SIZE=2>



 
 
The information in this article applies to:

<UL><LI>Microsoft Win32 Application Programming Interface (API) included with:
   - Microsoft Windows 95
</UL> 
<P>
<P><h2>SUMMARY</h2>
 
<P>
Some Win32 applications need to have the ability to eject removable media
from a drive on Windows 95. To do so safely, an application should first
make sure that no other applications are currently using the media.
Ejecting the media while another application has files open on the media
could lead to those files becoming corrupt or, at the very least, the user
could lose data. This article explains how to safely eject removable media
on Windows 95, and presents example code that demonstrates this.
<P>
For information on how to eject removable media on Windows NT, please
search this database for the keywords:
<P>
<PRE>   eject removable media NT

</PRE><h2>MORE INFORMATION</h2>
 
<P>
An application can safely eject removable media by first making sure that
no files on the media are being used. Once this is done, the application
can eject the media. On Windows 95, there are no special "dismount volume"
functions that need to be called before removing the media.
<P>
Because removable media are used in drives that have an associated drive
letter, all operations will be targeted to the drive rather than the
specific media in the drive. For example, to eject the media in drive E:,
an application sends the media removal request to drive E:.
<P>
The steps to ejecting the media safely are:

<OL><P><LI>Lock the volume for exclusive access with Int 21h function 440Dh
   minor code 4Ah.

<P><LI>Unlock the media so that it can be removed with Int 21h function
   440Dh minor code 48h.

<P><LI>Eject the media with Int 21h function 440Dh minor code 49h.

<P><LI>Remove the exclusive volume lock taken in step 1 with Int 21h
   function 440Dh minor code 6Ah.
<P>
</OL>Win32 applications may issue the requests in all of these steps by
using DeviceIoControl to send the Int 21h IOCTL requests to VWIN32. The
following sample code demonstrates how this is done.
<P>
<P><h3>Sample Code</h3>
 
<P>
<PRE>/*
   Program to programmatically eject removable media from a drive on
   Windows 95.
*/

#include &lt;windows.h&gt;
#include &lt;stdio.h&gt;
#include &lt;ctype.h&gt;

//-----------------------------------------------------------------------
// DeviceIoControl infrastructure

</PRE></OL>#if !defined (VWIN32_DIOC_DOS_IOCTL)
<PRE>#define VWIN32_DIOC_DOS_IOCTL      1

</PRE>typedef struct _DIOC_REGISTERS {
<PRE>    DWORD reg_EBX;
    DWORD reg_EDX;
    DWORD reg_ECX;
    DWORD reg_EAX;
    DWORD reg_EDI;
    DWORD reg_ESI;
    DWORD reg_Flags;
</PRE>} DIOC_REGISTERS, *PDIOC_REGISTERS;
#endif
<P>
<PRE>// Intel x86 processor status flags
#define CARRY_FLAG             0x0001

//-----------------------------------------------------------------------
// DOS IOCTL function support

</PRE>#pragma pack(1)
<P>
<PRE>// Parameters for locking/unlocking removable media
</PRE>typedef struct _PARAMBLOCK {
<PRE>   BYTE bOperation;
   BYTE bNumLocks;
</PRE>} PARAMBLOCK, *PPARAMBLOCK;
<P>
#pragma pack()
<P>
<PRE>//-----------------------------------------------------------------------
// Win95 low-level media unlocking/removal support

</PRE>HANDLE WINAPI OpenVWin32 (void);
BOOL WINAPI CloseVWin32 (HANDLE hVWin32);
BOOL WINAPI UnlockLogicalVolume (HANDLE hVWin32, BYTE bDriveNum);
BOOL WINAPI LockLogicalVolume (HANDLE hVWin32,
<PRE>                               BYTE   bDriveNum,
                               BYTE   bLockLevel,
                               WORD   wPermissions);
</PRE>BOOL UnlockMedia (HANDLE hVWin32, BYTE bDrive);
BOOL EjectMedia (HANDLE hVWin32, BYTE bDrive);
<P>
<PRE>/*-----------------------------------------------------------------------
</PRE>main ()
<P>
This program ejects media from the specified drive, if the media is
removable and the device supports software-controlled media removal.
<P>
The command line arguments are:
<P>
<PRE>   eject drive

</PRE>For example:
<PRE>   eject E:

</PRE>This code works on Windows 95 only, but does not check for Windows 95.
-----------------------------------------------------------------------*/
<PRE>void main (int argc, char **argv)
</PRE>{
<PRE>   HANDLE hVWin32      = INVALID_HANDLE_VALUE;
   BYTE   bDrive;
   BOOL   fDriveLocked = FALSE;

   if (argc !=2)
   {
      printf("usage: eject drive\n");
      return;
   }

   // convert command line arg 1 from a drive letter to a DOS drive
   // number
   bDrive = (toupper (argv[1][0]) - 'A') + 1;

   hVWin32 = OpenVWin32 ();

   // Make sure no other applications are using the drive.
   fDriveLocked = LockLogicalVolume (hVWin32, bDrive, 0, 0);
   if (!fDriveLocked)
   {
      printf("volume %c is in use by another application; therefore, it "
             "cannot be ejected\n", 'A' + bDrive - 1);
      goto CLEANUP_AND_EXIT_APP;
   }

   // Make sure there is no software lock keeping the media in the drive.
   if (!UnlockMedia (hVWin32, bDrive))
   {
      printf("could not unlock media from drive %c:\n", 'A' + bDrive - 1);
      goto CLEANUP_AND_EXIT_APP;
   }

   // Eject the media
   if (!EjectMedia (hVWin32, bDrive))
   {
      printf("could not eject media from drive %c:\n", 'A' + bDrive - 1);
   }

</PRE>CLEANUP_AND_EXIT_APP:
<PRE>   if (fDriveLocked)
      UnlockLogicalVolume (hVWin32, bDrive);

   if (hVWin32 != INVALID_HANDLE_VALUE)
      CloseVWin32 (hVWin32);
</PRE>}
<P>
<PRE>/*-----------------------------------------------------------------------
</PRE>UnlockMedia (hVWin32, bDrive)
<P>
Purpose:
<PRE>   Unlocks removable media from the specified drive so that it can be
   ejected.

</PRE>Parameters:
<PRE>   hVWin32
      A handle to VWIN32. Used to issue request to unlock the media.

   bDrive
      The logical drive number to unlock. 0 = default, 1 = A, 2 = B,
      etc.

</PRE>Return Value:
<PRE>   If successful, returns TRUE; if unsuccessful, returns FALSE.
</PRE>-----------------------------------------------------------------------*/
BOOL UnlockMedia (HANDLE hVWin32, BYTE bDrive)
{
<PRE>   DIOC_REGISTERS regs = {0};
   PARAMBLOCK     unlockParams = {0};
   int   i;
   BOOL  fResult;
   DWORD cb;

   // First, check the lock status. This way, you'll know the number of
   // pending locks you must unlock.

   unlockParams.bOperation = 2;   // return lock/unlock status

   regs.reg_EAX = 0x440D;
   regs.reg_EBX = bDrive;
   regs.reg_ECX = MAKEWORD(0x48, 0x08);
   regs.reg_EDX = (DWORD)&amp;unlockParams;

   fResult = DeviceIoControl (hVWin32, VWIN32_DIOC_DOS_IOCTL,
                              &amp;regs, sizeof(regs), &amp;regs, sizeof(regs),
                              &amp;cb, 0);

   // See if DeviceIoControl and the unlock succeeded.
   if (fResult)
   {
      /*
         DeviceIoControl succeeded. Now see if the unlock succeeded. It
         succeeded if the carry flag is not set, or if the carry flag is
         set but EAX is 0x01 or 0xB0.

         It failed if the carry flag is set and EAX is not 0x01 or 0xB0.

         If the carry flag is clear, then unlock succeeded. However, you
         don't need to set fResult because it is already TRUE when you get
         in here.

      */
      if (regs.reg_Flags &amp; CARRY_FLAG)
         fResult = (regs.reg_EAX == 0xB0) || (regs.reg_EAX == 0x01);
   }

   if (!fResult)
      return (FALSE);

   // Now, let's unlock the media for every time it has been locked;
   // this will totally unlock the media.

   for (i = 0; i &lt; unlockParams.bNumLocks; ++i)
   {
      unlockParams.bOperation = 1;   // unlock the media

      regs.reg_EAX = 0x440D;
      regs.reg_EBX = bDrive;
      regs.reg_ECX = MAKEWORD(0x48, 0x08);
      regs.reg_EDX = (DWORD)&amp;unlockParams;

      fResult = DeviceIoControl (hVWin32, VWIN32_DIOC_DOS_IOCTL,
                                 &amp;regs, sizeof(regs), &amp;regs, sizeof(regs),
                                 &amp;cb, 0);

      // See if DeviceIoControl and the lock succeeded
      fResult = fResult &amp;&amp; !(regs.reg_Flags &amp; CARRY_FLAG);
      if (!fResult)
         break;
   }
   return fResult;
</PRE>}
<P>
<PRE>/*-----------------------------------------------------------------------
</PRE>EjectMedia (hVWin32, bDrive)
<P>
Purpose:
<PRE>   Ejects removable media from the specified drive.

</PRE>Parameters:
<PRE>   hVWin32
      A handle to VWIN32. Used to issue request to unlock the media.

   bDrive
      The logical drive number to unlock. 0 = default, 1 = A, 2 = B,
      etc.

</PRE>Return Value:
<PRE>   If successful, returns TRUE; if unsuccessful, returns FALSE.
</PRE>-----------------------------------------------------------------------*/
BOOL EjectMedia (HANDLE hVWin32, BYTE bDrive)
{
<PRE>   DIOC_REGISTERS regs = {0};
   BOOL  fResult;
   DWORD cb;

   regs.reg_EAX = 0x440D;
   regs.reg_EBX = bDrive;
   regs.reg_ECX = MAKEWORD(0x49, 0x08);

   fResult = DeviceIoControl (hVWin32, VWIN32_DIOC_DOS_IOCTL,
                              &amp;regs, sizeof(regs), &amp;regs, sizeof(regs),
                              &amp;cb, 0);

   // See if DeviceIoControl and the lock succeeded
   fResult = fResult &amp;&amp; !(regs.reg_Flags &amp; CARRY_FLAG);

   return fResult;
</PRE>}
<P>
<PRE>/*-----------------------------------------------------------------------
</PRE>OpenVWin32 ()
<P>
Purpose:
<PRE>   Opens a handle to VWIN32 that can be used to issue low-level disk I/O
   commands.

</PRE>Parameters:
<PRE>   None.

</PRE>Return Value:
<PRE>   If successful, returns a handle to VWIN32.

   If unsuccessful, return INVALID_HANDLE_VALUE. Call GetLastError() to
   determine the cause of failure.
</PRE>-----------------------------------------------------------------------*/
HANDLE WINAPI OpenVWin32 (void)
{
<PRE>   return CreateFile ("\\\\.\\vwin32", 0, 0, NULL, 0,
                      FILE_FLAG_DELETE_ON_CLOSE, NULL);
}

/*-----------------------------------------------------------------------
</PRE>CloseVWin32 (hVWin32)
<P>
Purpose:
<PRE>   Closes the handle opened by OpenVWin32.

</PRE>Parameters:
<PRE>   hVWin32
      An open handle to VWIN32.

</PRE>Return Value:
<PRE>   If successful, returns TRUE. If unsuccessful, returns FALSE. Call
   GetLastError() to determine the cause of failure.
</PRE>-----------------------------------------------------------------------*/
BOOL WINAPI CloseVWin32 (HANDLE hVWin32)
{
<PRE>   return CloseHandle (hVWin32);
</PRE>}
<P>
<PRE>/*-----------------------------------------------------------------------
</PRE>LockLogicalVolume (hVWin32, bDriveNum, bLockLevel, wPermissions)
<P>
Purpose:
<PRE>   Takes a logical volume lock on a logical volume.

</PRE>Parameters:
<PRE>   hVWin32
      An open handle to VWIN32.

   bDriveNum
      The logical drive number to lock. 0 = default, 1 = A:, 2 = B:,
      3 = C:, etc.

   bLockLevel
      Can be 0, 1, 2, or 3. Level 0 is an exclusive lock that can only
      be taken when there are no open files on the specified drive.
      Levels 1 through 3 form a hierarchy where 1 must be taken before
      2, which must be taken before 3.

   wPermissions
      Specifies how the lock will affect file operations when lock levels
      1 through 3 are taken. Also specifies whether a formatting lock
      should be taken after a level 0 lock.

      Zero is a valid permission.

</PRE>Return Value:
<PRE>   If successful, returns TRUE.  If unsuccessful, returns FALSE.
</PRE>-----------------------------------------------------------------------*/
BOOL WINAPI LockLogicalVolume (HANDLE hVWin32,
<PRE>                               BYTE   bDriveNum,
                               BYTE   bLockLevel,
                               WORD   wPermissions)
{
   BOOL           fResult;
   DIOC_REGISTERS regs = {0};
   BYTE           bDeviceCat;  // can be either 0x48 or 0x08
   DWORD          cb;

   /*
      Try first with device category 0x48 for FAT32 volumes. If it
      doesn't work, try again with device category 0x08. If that
      doesn't work, then the lock failed.
   */

   bDeviceCat = 0x48;

</PRE>ATTEMPT_AGAIN:
<PRE>   // Set up the parameters for the call.
   regs.reg_EAX = 0x440D;
   regs.reg_EBX = MAKEWORD(bDriveNum, bLockLevel);
   regs.reg_ECX = MAKEWORD(0x4A, bDeviceCat);
   regs.reg_EDX = wPermissions;

   fResult = DeviceIoControl (hVWin32, VWIN32_DIOC_DOS_IOCTL,
                              &amp;regs, sizeof(regs), &amp;regs, sizeof(regs),
                              &amp;cb, 0);

   // See if DeviceIoControl and the lock succeeded
   fResult = fResult &amp;&amp; !(regs.reg_Flags &amp; CARRY_FLAG);

   // If DeviceIoControl or the lock failed, and device category 0x08
   // hasn't been tried, retry the operation with device category 0x08.
   if (!fResult &amp;&amp; (bDeviceCat != 0x08))
   {
      bDeviceCat = 0x08;
      goto ATTEMPT_AGAIN;
   }

   return fResult;
</PRE>}
<P>
<PRE>/*-----------------------------------------------------------------------
</PRE>UnlockLogicalVolume (hVWin32, bDriveNum)
<P>
Purpose:
<PRE>   Unlocks a logical volume that was locked with LockLogicalVolume().

</PRE>Parameters:
<PRE>   hVWin32
      An open handle to VWIN32.

   bDriveNum
      The logical drive number to unlock. 0 = default, 1 = A:, 2 = B:,
      3 = C:, etc.

</PRE>Return Value:
<PRE>   If successful, returns TRUE. If unsuccessful, returns FALSE.

</PRE>Comments:
<PRE>   Must be called the same number of times as LockLogicalVolume() to
   completely unlock a volume.

   Only the lock owner can unlock a volume.
</PRE>-----------------------------------------------------------------------*/
BOOL WINAPI UnlockLogicalVolume (HANDLE hVWin32, BYTE bDriveNum)
{
<PRE>   BOOL           fResult;
   DIOC_REGISTERS regs = {0};
   BYTE           bDeviceCat;  // can be either 0x48 or 0x08
   DWORD          cb;

   /* Try first with device category 0x48 for FAT32 volumes. If it
      doesn't work, try again with device category 0x08. If that
      doesn't work, then the unlock failed.
   */

   bDeviceCat = 0x48;

</PRE>ATTEMPT_AGAIN:
<PRE>   // Set up the parameters for the call.
   regs.reg_EAX = 0x440D;
   regs.reg_EBX = bDriveNum;
   regs.reg_ECX = MAKEWORD(0x6A, bDeviceCat);

   fResult = DeviceIoControl (hVWin32, VWIN32_DIOC_DOS_IOCTL,
                              &amp;regs, sizeof(regs), &amp;regs, sizeof(regs),
                              &amp;cb, 0);

   // See if DeviceIoControl and the unlock succeeded
   fResult = fResult &amp;&amp; !(regs.reg_Flags &amp; CARRY_FLAG);

   // If DeviceIoControl or the unlock failed, and device category 0x08
   // hasn't been tried, retry the operation with device category 0x08.
   if (!fResult &amp;&amp; (bDeviceCat != 0x08))
   {
      bDeviceCat = 0x08;
      goto ATTEMPT_AGAIN;
   }
   return fResult;
</PRE>}
<P>
<P><h2>REFERENCES</h2>
 
<P>
For more information about the Int 21h IOCTL calls used in this article
and the Windows 95 DeviceIoControl mechanism, please see the Programmer's
Guide to Windows 95 in the Win32 SDK documentation.
<P>

	</FONT>
	</TD>
	</TR>
</TABLE>
<P>


<!--DOCBODY_END-->

<!--FOOTER_START-->
<table cellpadding=5 border=0 width="90%">
<tr>
<td>
	<HR WIDTH="90%">

<BLOCKQUOTE>
<FONT FACE="Verdana, Arial, Helvetica" SIZE="1">
<SPAN STYLE="font-family:verdana,arial,helvetica; font-size:8pt">
Additional query words: eject removable media disk disc remove<BR>
Keywords            : BseFileio kbcode kbhowto<BR>
Version             : 95<BR>
Platform            : NT WINDOWS<BR>

</SPAN>
</FONT>
<BR>
<BR>
THE INFORMATION PROVIDED IN THE MICROSOFT KNOWLEDGE BASE IS
PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND.  MICROSOFT DISCLAIMS
ALL WARRANTIES, EITHER EXPRESS OR IMPLIED, INCLUDING THE WARRANTIES
OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  IN NO
EVENT SHALL MICROSOFT CORPORATION OR ITS SUPPLIERS BE LIABLE FOR
ANY DAMAGES WHATSOEVER INCLUDING DIRECT, INDIRECT, INCIDENTAL,
CONSEQUENTIAL, LOSS OF BUSINESS PROFITS OR SPECIAL DAMAGES, EVEN IF
MICROSOFT CORPORATION OR ITS SUPPLIERS HAVE BEEN ADVISED OF THE
POSSIBILITY OF SUCH DAMAGES.  SOME STATES DO NOT ALLOW THE EXCLUSION
OR LIMITATION OF LIABILITY FOR CONSEQUENTIAL OR INCIDENTAL DAMAGES
SO THE FOREGOING LIMITATION MAY NOT APPLY.
</BLOCKQUOTE>
<P>
<center>
	<FONT FACE="Verdana,Arial,Helvetica" SIZE="1">
	Last reviewed:  May 12, 1997</FONT>
	<BR>
	<A href="../cpyright.htm" STYLE="font: bold 7pt Verdana,Arial,Helvetica">&copy; 1998 Microsoft Corporation. All rights reserved. Terms of Use.</A><BR>
	
</center>
</td>
</tr>
</table>

<!--FOOTER_END-->
</FONT>
</BODY>
</HTML>
