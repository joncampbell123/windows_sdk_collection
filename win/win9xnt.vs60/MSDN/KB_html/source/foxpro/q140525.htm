

<HTML>
<HEAD>
<TITLE>How To Receive from the Serial Port by Using MScomm32.ocx </TITLE>

<!--STYLE_BEGIN-->
<style>@import url(../../msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="../../msdn_ie3.css">
<!--STYLE_END-->

<META HTTP-EQUIV="CONTENT-Type" CONTENT="text/html; charset=us-ascii">
<META NAME="ms.locale" CONTENT="EN-US">
<META NAME="Category" CONTENT="Support; KB Article">
<META NAME="KBID" CONTENT="Q140525">
<META NAME="KBModify" CONTENT="1996/10/17">
<META NAME="KBCreate" CONTENT="1995/12/03">
<META NAME="Keywords" CONTENT="kbprg kbhowto kbcode">
<META NAME="KBArea" CONTENT="Support; KB; foxpro, crossnet, odbc">
<META NAME="Description" CONTENT="  This article gives you two techniques you can use to receive data from the serial port using the Mscomm32.ocx control. The first uses an event-driven method and does not require you to poll the serial port to check for the presence of received char...">
<META NAME="Product" CONTENT="Visual FoxPro">
<META NAME="Platform" CONTENT="Windows">
<META NAME="Technology" CONTENT=" ">
<META NAME="Premium" CONTENT="support">

<META NAME="nyms" CONTENT="QDJ9,QAPN,QABH,QABI,QBXS,QAH4,QAYY,QBWC,QDJP,QAO4,QALM,QAKG,QAKD,QACJ,QAXC V02180118">
</HEAD>

<BODY BGCOLOR="#FFFFFF" LEFTMARGIN="0" RIGHTMARGIN="0" TOPMARGIN="0">


<!--DOCBODY_START-->
<BR>
<CENTER>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" VALIGN="top" WIDTH="90%">
	<TR>
		<TD VALIGN="top">
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<H1>How To Receive from the Serial Port by Using MScomm32.ocx</H1>
			</FONT>
			<FONT FACE="verdana,arial,helvetica" SIZE="1">
			Last reviewed:  October 17, 1996</FONT><BR>
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<B>Article ID: Q140525</B>
			</FONT>
		</TD>
	</TR>
	<TR>
	<TD>
	<FONT FACE="Verdana, Arial, Helvetica" SIZE=2>



 
The information in this article applies to:

<UL><LI>Microsoft Visual FoxPro for Windows, versions 3.0, 5.0
</UL> 
<P>
<P><h2>SUMMARY</h2>
 
<P>
This article gives you two techniques you can use to receive data from the
serial port using the Mscomm32.ocx control. The first uses an event-driven
method and does not require you to poll the serial port to check for the
presence of received characters. This technique allows the most flexibility
and does not require extensive coding to prevent buffer over-runs. The
second technique requires you to poll the input buffer periodically to
check for the presence of received characters. This article describes these
two techniques and provides examples for each.
<P>
<P><h2>MORE INFORMATION</h2>
 
<P>
You need to set the following properties regardless of which technique
you use:

<UL><LI>CommPort property: Set this numeric property to the desired
   communications port. Valid values are 1, 2, 3, or 4 depending on the
   serial ports available and the configuration of the individual computer.
   These values correspond to Com1, Com2, Com3, and Com4 respectively.

<LI>Settings property: Set this character property to the baud rate, Parity,
   Data Bits, and Stop Bits required by the device connected to the serial
   port. This property is a character, comma-delimited list. For example,
   to set the serial port to 14,400 baud, Even Parity, 7 Data Bits, and
   1 Stop Bit, set the string to:
<P>
   14400,E,7,1

<LI>PortOpen property: Set this logical property to true to open
   communications to the serial port. You can also check this property
   to determine if the port opened correctly.
<P>
</UL><h3>Technique One: Event-Driven Receive</h3>
 
<P>
The event Driven technique generates an OnComm event when there are
characters waiting in the input buffer. Also, the CommEvent property will
contain a numeric 2. For the OnComm event to be triggered, you must set the
Rthreshold property to a value other than zero (its default). The most
common setting for the rthreshold property is 1, meaning that the OnComm
event is triggered if a minimum of one character is waiting in the input
buffer.
<P>
For example, the following code may be placed in the OnComm event to append
received data to a property of a form called mybuffer.
<P>
Procedure MyCom.OnComm
<PRE>  IF This.CommEvent = 2
    ThisForm.mybuffer = ThisForm.mybuffer + This.Input
  ENDIF
</PRE>ENDPROC
<P>
<P><h3>Technique Two: Polling the Input Buffer</h3>
 
<P>
Polling the input buffer requires that the program periodically stop what
it is doing and check to see if there are characters waiting in the input
buffer. When using this technique, leave the Rthreshold property at 0 (its
default value), and check the InBufferCount property to see if it is
greater than zero, which indicates that there are characters waiting in the
buffer.
<P>
NOTE: Using a technique such as checking the length of the Input property
results in lost characters because as soon as the Input property is
accessed, the Input buffer is emptied. Use the InBufferCount property
instead.
<P>
Assuming the Mscomm control is on the form and has the name MyCom and that
there is a form property named mybuffer, the following code illustrates how
to poll for waiting characters:
<P>
Procedure myform.myproc
<PRE>  IF Thisform.MyCom.InBufferCount &gt; 0
    Thisform.mybuffer = Thisform.mybuffer + Thisform.MyCom.Input
  ENDIF
</PRE>ENDPROC
<P>
The procedure code could be called in a timer method to facilitate checking
for characters at semi-regular intervals. However, if large amounts of data
are expected to be received from the serial port, Technique One will reduce
the chance of over-running the input buffer.
<P>

	</FONT>
	</TD>
	</TR>
</TABLE>
<P>


<!--DOCBODY_END-->

<!--FOOTER_START-->
<table cellpadding=5 border=0 width="90%">
<tr>
<td>
	<HR WIDTH="90%">

<BLOCKQUOTE>
<FONT FACE="Verdana, Arial, Helvetica" SIZE="1">
<SPAN STYLE="font-family:verdana,arial,helvetica; font-size:8pt">
Additional reference words: 5.00 3.00 VFoxWin<BR>
KBCategory: kbprg kbhowto kbcode<BR>
KBSubcategory: FxprgGeneral<BR>

</SPAN>
</FONT>
<BR>
<BR>
THE INFORMATION PROVIDED IN THE MICROSOFT KNOWLEDGE BASE IS
PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND.  MICROSOFT DISCLAIMS
ALL WARRANTIES, EITHER EXPRESS OR IMPLIED, INCLUDING THE WARRANTIES
OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  IN NO
EVENT SHALL MICROSOFT CORPORATION OR ITS SUPPLIERS BE LIABLE FOR
ANY DAMAGES WHATSOEVER INCLUDING DIRECT, INDIRECT, INCIDENTAL,
CONSEQUENTIAL, LOSS OF BUSINESS PROFITS OR SPECIAL DAMAGES, EVEN IF
MICROSOFT CORPORATION OR ITS SUPPLIERS HAVE BEEN ADVISED OF THE
POSSIBILITY OF SUCH DAMAGES.  SOME STATES DO NOT ALLOW THE EXCLUSION
OR LIMITATION OF LIABILITY FOR CONSEQUENTIAL OR INCIDENTAL DAMAGES
SO THE FOREGOING LIMITATION MAY NOT APPLY.
</BLOCKQUOTE>
<P>
<center>
	<FONT FACE="Verdana,Arial,Helvetica" SIZE="1">
	Last reviewed:  October 17, 1996</FONT>
	<BR>
	<A href="../cpyright.htm" STYLE="font: bold 7pt Verdana,Arial,Helvetica">&copy; 1998 Microsoft Corporation. All rights reserved. Terms of Use.</A><BR>
	
</center>
</td>
</tr>
</table>

<!--FOOTER_END-->
</FONT>
</BODY>
</HTML>
