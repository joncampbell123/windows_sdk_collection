

<HTML>
<HEAD>
<TITLE>OLE Data Structures and Structure Allocation </TITLE>

<!--STYLE_BEGIN-->
<style>@import url(../../msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="../../msdn_ie3.css">
<!--STYLE_END-->

<META HTTP-EQUIV="CONTENT-Type" CONTENT="text/html; charset=us-ascii">
<META NAME="ms.locale" CONTENT="EN-US">
<META NAME="Category" CONTENT="Support; KB Article">
<META NAME="KBID" CONTENT="Q83457 ">
<META NAME="KBModify" CONTENT="1995/02/17">
<META NAME="KBCreate" CONTENT="1992/04/13">
<META NAME="Keywords" CONTENT="kbole kbprg">
<META NAME="KBArea" CONTENT="Support; KB; oleprog">
<META NAME="Description" CONTENT="  In general, OLE client and server applications deal with the data structures defined in the OLE.H header file. However, these data structures contain only a single pointer to a table of function pointers (a VTBL structure).  To associate additional...">
<META NAME="Product" CONTENT="OLE (Programming)">
<META NAME="Platform" CONTENT="Windows">
<META NAME="Technology" CONTENT="OLE ">
<META NAME="Premium" CONTENT="support">

<META NAME="nyms" CONTENT="QAIC,QAO3,QAO2,QA9Q,QAYY,QAJH,QAPN,QBW6,QAY5,QAD7,QAH6,QAGI,QAP2,QABB,QARL V02180118">
</HEAD>

<BODY BGCOLOR="#FFFFFF" LEFTMARGIN="0" RIGHTMARGIN="0" TOPMARGIN="0">


<!--DOCBODY_START-->
<BR>
<CENTER>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" VALIGN="top" WIDTH="90%">
	<TR>
		<TD VALIGN="top">
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<H1>OLE Data Structures and Structure Allocation</H1>
			</FONT>
			<FONT FACE="verdana,arial,helvetica" SIZE="1">
			Last reviewed:  February 17, 1995</FONT><BR>
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<B>Article ID: Q83457 </B>
			</FONT>
		</TD>
	</TR>
	<TR>
	<TD>
	<FONT FACE="Verdana, Arial, Helvetica" SIZE=2>



 
The information in this article applies to:

<UL><LI>Microsoft OLE version 1.0
</UL> 
<P>
<P><h2>SUMMARY</h2>
 
<P>
In general, OLE client and server
applications deal with the data structures defined in the OLE.H header
file. However, these data structures contain only a single pointer to
a table of function pointers (a VTBL structure).
<P>
To associate additional data with the item represented by the VTBL
data structure, an application must create a superset of the
appropriate structures in OLE.H. The new structure must contain all
fields of the original structure and any additional application-
specific data desired.
<P>
This article describes the OLE data structures and provides examples
of application-specific structures. This article also discusses how
the OLE libraries use pointers to structures and details the most
efficient way to allocate memory for OLE data structures.
<P>
<P><h2>MORE INFORMATION</h2>
 
<P>
<P><h3>OLE Data Structures and Parameter Types</h3>
 
<P>
The OLE.H header file defines five main data structures and a VTBL
structure for each. The following table lists these structures and
their contents:
<P>
<PRE>   Data Structure      Contents
   --------------      --------

   OLECLIENT           One LPOLECLIENTVTBL
   OLECLIENTVTBL       One far pointer to the client application's
                       notification procedure: CallBack.

   OLESTREAM           One LPOLESTREAMVTBL
   OLESTREAMVTBL       Far pointers to the stream methods, Get and Put.

   OLEOBJECT           One LPOLEOBJECTVTBL
   OLEOBJECTVTBL       Far pointers to object methods. For example:
                       DoVerb, GetData, Release, and Show.

   OLESERVER           One LPOLESERVERVTBL
   OLESERVERVTBL       Far pointers to server methods. For example:
                       Create, Edit, and Release.

   OLESERVERDOC        One LPOLESERVERDOCVTBL
   OLESERVERDOCVTBL    Far pointers to document methods. For example:
                       GetObject, Release, and SetHostNames.

</PRE>OLE client applications use only the OLECLIENT and OLESTREAM data
structures and their associated VTBL structures. OLE server
applications use all the structures above except for the OLESTREAM
data structure.
<P>
Each of the five data structures above contains only a single pointer
to its associated VTBL data type. An application can achieve the
greatest use of these structures by defining its own data types. Make
sure that the VTBL pointer is the first member of each application-
specific data structure.
<P>
For example, the following code defines MYOLESERVER as a replacement
for the OLESERVER data structure:
<P>
<PRE>   typedef struct
   {
      LPOLESERVERVTBL  pvtbl;    // Standard
      LHSERVER         lh;       // Required by OleRegisterServer
      BOOL             fRelease; // TRUE if waiting required
      BOOL             fEmbed;   // TRUE if only embedding
      BOOL             fLink;    // TRUE if only linking
      WORD             wCmdShow; // OLE-specific window show command
      HWND             hWnd;     // Main application window
      HANDLE           hMem;     // Memory handle to this structure
      LPDOCUMENT       pDoc;     // Last document allocated
   } MYOLESERVER;

</PRE>An LPOLESERVERVTBL must be the first member of the MYOLESERVER data
structure. The MYOLESERVER structure also contains other information
that is useful in OLESERVTBL methods, such as a pointer to the default
document.
<P>
An application can pass a pointer to a variable of the MYOLESERVER
data type to any OLE function that requires a pointer to an OLESERVER.
OLE will typecast the pointer to an LPOLESERVER to access the VTBL
member, leaving the remainder of the structure untouched.
<P>
Any time that an OLE library calls any callback function (method) in
the application, it uses the pointer the application passed in, which
continues to point to the application-specific data.
<P>
This technique applies to both client and server applications for all
five data structures. Specifically,

<UL><LI>A pointer to an OLECLIENT structure is provided by the client
   application's CallBack function.

<LI>Pointers to OLESTREAM structures are provided by the client
   application's Get and Put methods (in OLESTREAMVTBL).

<LI>Pointers to OLEOBJECT, OLESERVER and OLESERVERDOC structures are
   provided by the methods defined and referenced in the appropriate
   VTBL structures.
<P>
</UL>During the process of creating an application's methods and callback
functions (to fill in VTBL structures), the application can replace
any standard OLE structure pointer with a pointer to an application-
defined data type. For example, all OLESERVERVTBL methods are defined
to accept an LPOLESERVER type. However, the OLESERVTBL method accepts
the same pointer that the application passed to a function such as
OleRegisterServer, the application can replace the LPOLESERVER type in
the function with an application-defined far pointer data type.
<P>
Replacing standard OLE data types with application-defined data types
eliminates local variables in which the application stores a typecast
copy of a parameter with a standard data type. This technique applies
to all five OLE data structures; the client application's CallBack can
change the LPOLECLIENT data type, and other methods can perform
similar changes.
<P>
<P><h3>How OLE Uses Pointers, Allocating Structures</h3>
 
<P>
OLE uses pointers to structures to allow an application to define its
own data structures as outlined above. However, doing so precludes the
application from running in real mode Windows 3.0. An OLE application
will run only in protected mode.
<P>
After an application allocates a data structure, it must lock the
allocated memory to obtain a pointer to the memory. It is important to
plan how the application will use memory to ensure that leaving the
block of memory locked is of little consequence.
<P>
If the application allocates local memory with the LocalAlloc
function, specify LMEM_FIXED as the value for the wFlags parameter. Do
not use the alternative method to allocate fixed local memory (calling
LocalAlloc with wFlags set to LMEM_MOVEABLE, followed by a call to
LocalLock) because this creates a "sand bar" in the local heap.
LMEM_FIXED local memory is the better choice for local memory that
will remain locked.
<P>
If the application allocates global memory with the GlobalAlloc
function, specify GMEM_MOVEABLE as the wFlags parameter. Then call
GlobalLock to lock the memory. If GMEM_FIXED is specified in the
GlobalAlloc call, the data structure is allocated from the scarce
memory with an address below 1 megabyte (MB). Allocating the object as
GMEM_MOVEABLE and keeping the memory locked enables the application to
retain a pointer to the memory block without creating any "sand bars"
that interfere with memory management.
<P>

	</FONT>
	</TD>
	</TR>
</TABLE>
<P>


<!--DOCBODY_END-->

<!--FOOTER_START-->
<table cellpadding=5 border=0 width="90%">
<tr>
<td>
	<HR WIDTH="90%">

<BLOCKQUOTE>
<FONT FACE="Verdana, Arial, Helvetica" SIZE="1">
<SPAN STYLE="font-family:verdana,arial,helvetica; font-size:8pt">
Additional reference words: 1.00<BR>
KBCategory: kbole kbprg<BR>
KBSubcategory: LeOneCli LeOneSvr<BR>

</SPAN>
</FONT>
<BR>
<BR>
THE INFORMATION PROVIDED IN THE MICROSOFT KNOWLEDGE BASE IS
PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND.  MICROSOFT DISCLAIMS
ALL WARRANTIES, EITHER EXPRESS OR IMPLIED, INCLUDING THE WARRANTIES
OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  IN NO
EVENT SHALL MICROSOFT CORPORATION OR ITS SUPPLIERS BE LIABLE FOR
ANY DAMAGES WHATSOEVER INCLUDING DIRECT, INDIRECT, INCIDENTAL,
CONSEQUENTIAL, LOSS OF BUSINESS PROFITS OR SPECIAL DAMAGES, EVEN IF
MICROSOFT CORPORATION OR ITS SUPPLIERS HAVE BEEN ADVISED OF THE
POSSIBILITY OF SUCH DAMAGES.  SOME STATES DO NOT ALLOW THE EXCLUSION
OR LIMITATION OF LIABILITY FOR CONSEQUENTIAL OR INCIDENTAL DAMAGES
SO THE FOREGOING LIMITATION MAY NOT APPLY.
</BLOCKQUOTE>
<P>
<center>
	<FONT FACE="Verdana,Arial,Helvetica" SIZE="1">
	Last reviewed:  February 17, 1995</FONT>
	<BR>
	<A href="../cpyright.htm" STYLE="font: bold 7pt Verdana,Arial,Helvetica">&copy; 1998 Microsoft Corporation. All rights reserved. Terms of Use.</A><BR>
	
</center>
</td>
</tr>
</table>

<!--FOOTER_END-->
</FONT>
</BODY>
</HTML>
