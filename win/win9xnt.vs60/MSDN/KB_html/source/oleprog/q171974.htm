

<HTML>
<HEAD>
<TITLE>FILE: Bind to an Object on a Remote Machine Using ROT </TITLE>

<!--STYLE_BEGIN-->
<style>@import url(../../msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="../../msdn_ie3.css">
<!--STYLE_END-->

<META HTTP-EQUIV="CONTENT-Type" CONTENT="text/html; charset=us-ascii">
<META NAME="ms.locale" CONTENT="EN-US">
<META NAME="Category" CONTENT="Support; KB Article">
<META NAME="KBID" CONTENT="Q171974">
<META NAME="KBModify" CONTENT="1998/03/03">
<META NAME="KBCreate" CONTENT="1997/07/25">
<META NAME="Keywords" CONTENT="LeTwoDCom kbfile">
<META NAME="KBArea" CONTENT="Support; KB; oleprog">
<META NAME="Description" CONTENT="  DCOM supports connecting to an object on a remote machine ROT (Running object table) using file monikers. ROTMONK is a COM server/client sample that demonstrates how to achieve this functionality.  The following file is available for download from ...">
<META NAME="Product" CONTENT="OLE (Programming)">
<META NAME="Platform" CONTENT="Windows">
<META NAME="Technology" CONTENT="OLE ">
<META NAME="Security" CONTENT="PUBLIC ">
<META NAME="Premium" CONTENT="support">

<META NAME="nyms" CONTENT="QAPN,QAW6,QARL,QBWS,QAFI,QAJQ,QAUJ,QABI,QA2Q,QAI5,QAG2,QAPF,QAGU,QAY2,QAH4 V02180118">
</HEAD>

<BODY BGCOLOR="#FFFFFF" LEFTMARGIN="0" RIGHTMARGIN="0" TOPMARGIN="0">


<!--DOCBODY_START-->
<BR>
<CENTER>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" VALIGN="top" WIDTH="90%">
	<TR>
		<TD VALIGN="top">
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<H1>FILE: Bind to an Object on a Remote Machine Using ROT</H1>
			</FONT>
			<FONT FACE="verdana,arial,helvetica" SIZE="1">
			Last reviewed:  March 3, 1998</FONT><BR>
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<B>Article ID: Q171974</B>
			</FONT>
		</TD>
	</TR>
	<TR>
	<TD>
	<FONT FACE="Verdana, Arial, Helvetica" SIZE=2>



 
 
The information in this article applies to:

<UL><LI>Microsoft OLE Libraries 4.0 included with:
   - Microsoft Win32 Software Development Kit (SDK)
</UL> 
<P>
<P><h2>SUMMARY</h2>
 
<P>
DCOM supports connecting to an object on a remote machine ROT (Running
object table) using file monikers. ROTMONK is a COM server/client sample
that demonstrates how to achieve this functionality.
<P>
The following file is available for download from the Microsoft Software
Library:
<P>
<PRE> ~ <A href="http://support.microsoft.com/download/support/mslfiles/rotmonk.exe">Rotmonk.exe</A> <I>(size: 127108 bytes)</I> 

</PRE>For more information about downloading files from the Microsoft Software
Library, please see the following article in the Microsoft Knowledge Base:
<P>
<PRE>   ARTICLE-ID: <B><A href="../zmiscellaneous/q119591.htm">Q119591</A></B>
   TITLE     : How to Obtain Microsoft Support Files from Online Services

</PRE><h2>MORE INFORMATION</h2>
 
<P>
There are a few things that you need to know so that you can make this
feature work properly:

<OL><P><LI>If the server supports multiple clients to connect to it, the server
   must register its class object to be multiple use. Even though the
   clients connect via the ROT, the server must still register the class as
   multiple-use so that COM can marshal the interface for each client.

<P><LI>The server has to register the object in the ROT with
   ROTFLAGS_ALLOWANYCLIENT flag. Otherwise, the moniker is registered with
   a security descriptor that allows only clients from the same security
   context to access it. When the server specifies ROTFLAGS_ALLOWANYCLIENT,
   any clients can access it. Also, refer to the ROTFLAGS_ALLOWANYCLIENT
   documentation in Win32 SDK. This flag is only available for servers that
   run as a service, the interactive user, or a specific user.
<P>
   In order for a ROT registration with ROTFLAGS_ALLOWANYCLIENT to succeed,
   the following regsitry entries must be present:
<P>
<P><PRE>      [HKEY_CLASSES_ROOT\AppID\app.exe]
      "AppID"="{APPIDGUID}"
</PRE><P>
   where app.exe is the module name of the registering process (just the
   name of the process is sufficient, paths must not be specified).
   APPIDGUID is a placeholder for a real GUID of the AppID of this process:
<P>
<P><PRE>      [HKEY_CLASSES_ROOT\AppID\{APPIDGUID}]
      "RunAs"="Interactive User"
</PRE><P>
<P><PRE>    The RunAs named value can specify either "Interactive User" or a
    specific user. A RunAs entry must be present because the system
    prohibits "activate as activator" processes from registering in the ROT
    with ROTFLAGS_ALLOWANYCLIENT. This is done for security reasons.
</PRE>
<P><LI>The client and the server have to use the same physical file to
   create the moniker, and the file has to be shared out so the client
   can access this file. As an example a client would do:
<P>
<P><PRE>      CreateFileMoniker("\\machinename\sharename\path to file...")
</PRE><P>
   while the server might do something like:
<P>
<P><PRE>      CreateFileMoniker("path to drive based file....");
</PRE><P>
   Due to a bug in the OLE libraries, if the server shares out the root
   directory (for example, c:\) and if the client creates a file moniker on
   the same physical file the two file monikers are not considered the
   same. The reason for this is that when the system is recreating the
   local file name from the UNC name, there is an extra "\" added in the
   file name which causes the two file monikers to be different. If you
   share out any directory besides root directory, then this problem does
   not occur.
<P>
</OL><h3>File Moniker Specific</h3>
 

<OL><P><LI>The server needs to implement IPersistFile to support bind to objects
   through file moniker.

<P><LI>At the bare minimum, the file should be a structured storage file with
   the class id of the object written with WriteClassStg.
<P>
</OL>The sample contains the server code in the root directory, and client code
in the client subdirectory.
<P>
<P><h3>Server File</h3>
 
<P>
<PRE>rotmonk.cpp   WinMain, and main windows procedure, and registering an
              object in ROT.
oleinit.cpp   OLE initialization and class factory registration.
persist.cpp   Bare-bone implementation of IPersistFile Interface.
debug.cpp     Helper trace function for debugging.
rotmonk.reg   Server registration file.
rotmonk.rmp   The dummy file on which the File Moniker is created, if this
              file does not exist, the server program can recreate it.

</PRE></OL><h3>Client File</h3>
 
<P>
<PRE>Client.cpp    WinMain, and Main Windows Procedure, and binding to an object
              in ROT.
oleinit.cpp   OLE initialization.
Debug.cpp     Helper trace function for debugging.

</PRE><h3>To Run the Sample</h3>
 

<OL><P><LI>Edit the server registration file (rotmonk.reg) to point to the server
   executable's correct path. Double-click the registration file so that
   the server is registered on the machine where the server will be
   running.

<P><LI>To configure the server with dcomcnfg:
   a. Open dcomcnfg.exe where the server will be running.
   b. Select and double-click "DCOM ROT Monk Sample."
   c. Select the Security Tab.
   d. Select Custom Launch permission, and then Custom Access Permission.
   e. Select Launch Permission. Make sure that at least the following are
<P><PRE>      in the list:
      - System
      - Interactive
      - The user who will be logging on the client machine
</PRE>   f. Select Access Permission. Make sure that at least the following are
<P><PRE>      in the list:
      - System
      - Interactive
      - The user who will be logging on the client machine
</PRE>   g. Select the Identity Tab.
   h. Select "Interactive user".

<P><LI>Make sure you have a c:\temp\rotmonk directory, and share the temp
   directory so that the client machine can connect to this share. The
   server will create rotmonk.rmp file there, if the file does not exist.

<P><LI>Run the dbmon.exe (to catch OutputDebugString...) and then run the
   server, or Run the server in Debugger.

<P><LI>Run the client on the client machine. (You can also run dbmon.exe on the
   client machine, if you want to catch OutputDebugString from the client
   program.)
   a. Select Test, Machine Name.
   b. Under Machine name, specify the machine "&lt;machine name&gt;"
   c. Specify Moniker Name as "\\&lt;machine name&gt;\&lt;share Name&gt;\&lt;path to file
<P><PRE>      including file name&gt;"
</PRE>   d. Select Test, and then Bind to Object.

<P><LI>The server should output "Object Id 1 Ref Count 4 Object Count 1" in
   dbmon/debugger. When you run another client on the client machine, you
   should see that it gets connected to same object. The server will output
   "Object Id 1 Ref Count 4 Object Count 1". In this sample, the 1st object
   has the Object Id of 1, and is registered in the ROT. This is the only
   object registered in the ROT. If you get another Object ID, then the
   object has been created through ClassFactory.

<P><LI>Run OLEView on the server machine, and instantiate the "DCOM ROT Monk
   Sample". Double-click the IPersist interface. The server will output
   "Object Id 2 Ref Count 3 Object Count 2", which basically demonstrates
   that this (OLEView) client went through the ClassFactory and got a
   another object, as opposed to the same object in the previous case.
<P></OL>

	</FONT>
	</TD>
	</TR>
</TABLE>
<P>


<!--DOCBODY_END-->

<!--FOOTER_START-->
<table cellpadding=5 border=0 width="90%">
<tr>
<td>
	<HR WIDTH="90%">

<BLOCKQUOTE>
<FONT FACE="Verdana, Arial, Helvetica" SIZE="1">
<SPAN STYLE="font-family:verdana,arial,helvetica; font-size:8pt">
Additional query words: 95<BR>
Keywords          : LeTwoDCom kbfile<BR>
Version           : 95 4.0<BR>
Platform          : Win95<BR>
Issue type        : kbhowto<BR>

</SPAN>
</FONT>
<BR>
<BR>
THE INFORMATION PROVIDED IN THE MICROSOFT KNOWLEDGE BASE IS
PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND.  MICROSOFT DISCLAIMS
ALL WARRANTIES, EITHER EXPRESS OR IMPLIED, INCLUDING THE WARRANTIES
OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  IN NO
EVENT SHALL MICROSOFT CORPORATION OR ITS SUPPLIERS BE LIABLE FOR
ANY DAMAGES WHATSOEVER INCLUDING DIRECT, INDIRECT, INCIDENTAL,
CONSEQUENTIAL, LOSS OF BUSINESS PROFITS OR SPECIAL DAMAGES, EVEN IF
MICROSOFT CORPORATION OR ITS SUPPLIERS HAVE BEEN ADVISED OF THE
POSSIBILITY OF SUCH DAMAGES.  SOME STATES DO NOT ALLOW THE EXCLUSION
OR LIMITATION OF LIABILITY FOR CONSEQUENTIAL OR INCIDENTAL DAMAGES
SO THE FOREGOING LIMITATION MAY NOT APPLY.
</BLOCKQUOTE>
<P>
<center>
	<FONT FACE="Verdana,Arial,Helvetica" SIZE="1">
	Last reviewed:  March 3, 1998</FONT>
	<BR>
	<A href="../cpyright.htm" STYLE="font: bold 7pt Verdana,Arial,Helvetica">&copy; 1998 Microsoft Corporation. All rights reserved. Terms of Use.</A><BR>
	
</center>
</td>
</tr>
</table>

<!--FOOTER_END-->
</FONT>
</BODY>
</HTML>
