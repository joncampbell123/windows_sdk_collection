

<HTML>
<HEAD>
<TITLE>FIX: SuperPad Resizes Indefinitely When Activated In-Place </TITLE>

<!--STYLE_BEGIN-->
<style>@import url(../../msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="../../msdn_ie3.css">
<!--STYLE_END-->

<META HTTP-EQUIV="CONTENT-Type" CONTENT="text/html; charset=us-ascii">
<META NAME="ms.locale" CONTENT="EN-US">
<META NAME="Category" CONTENT="Support; KB Article">
<META NAME="KBID" CONTENT="Q121948">
<META NAME="KBModify" CONTENT="1997/09/18">
<META NAME="KBCreate" CONTENT="1994/10/24">
<META NAME="Keywords" CONTENT="kb16bitonly MfcOLE kbbuglist kbcode kbfixlist kbole kbprg">
<META NAME="KBArea" CONTENT="Support; KB; visualc">
<META NAME="Description" CONTENT="  The in-place window resizes indefinitely if you insert a SuperPad object into an OLE 2.0 container application, and then either type characters into it or resize the in-place window.  CAUSE =====  The problem is caused by some incorrect code in the...">
<META NAME="Product" CONTENT="Visual C++">
<META NAME="Platform" CONTENT="Windows">
<META NAME="Technology" CONTENT=" ">
<META NAME="Premium" CONTENT="support">

<META NAME="nyms" CONTENT="QARJ,QAR4,QAF8,QAIB,QAHP,QAUD,QAJB,QARK,QDL9,QBWQ,QBWO,QBWN,QA4Q,QAY5,QAXB V02180118">
</HEAD>

<BODY BGCOLOR="#FFFFFF" LEFTMARGIN="0" RIGHTMARGIN="0" TOPMARGIN="0">


<!--DOCBODY_START-->
<BR>
<CENTER>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" VALIGN="top" WIDTH="90%">
	<TR>
		<TD VALIGN="top">
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<H1>FIX: SuperPad Resizes Indefinitely When Activated In-Place</H1>
			</FONT>
			<FONT FACE="verdana,arial,helvetica" SIZE="1">
			Last reviewed:  September 18, 1997</FONT><BR>
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<B>Article ID: Q121948</B>
			</FONT>
		</TD>
	</TR>
	<TR>
	<TD>
	<FONT FACE="Verdana, Arial, Helvetica" SIZE=2>



 
1.50
WINDOWS
kbole kbprg kbbuglist kbfixlist kbcode
<P>
 
The information in this article applies to:

<UL><LI>The Microsoft Foundation Classes (MFC), included with Microsoft
   Visual C++ for Windows, version 1.5
</UL> 
<P>
<P><h2>SYMPTOMS</h2>
 
<P>
The in-place window resizes indefinitely if you insert a SuperPad object
into an OLE 2.0 container application, and then either type characters into
it or resize the in-place window.
<P>
<P><h2>CAUSE</h2>
 
<P>
The problem is caused by some incorrect code in the CEmbeddedItem::OnDraw
and CPadView::OnSize functions. The primary problem occurs because the
Windows edit control reports its border as part of its client area, so
the call to pView-&gt;GetClientRect(&amp;rectClient) in the CEmbededItem::OnDraw
function is two pixels off, length and width wise.
<P>
<P><h2>RESOLUTION</h2>
 
<P>
Substitute the CPadView::OnSize and CEmbeddedItem::OnDraw functions
located in the PADVIEW.CPP and PADITEM.CPP files respectively, with
these functions:
<P>
<PRE>void CPadView::OnSize(UINT nType, int cx, int cy)
</PRE>{
<PRE>   CWaitCursor wait;
   CEditView::OnSize(nType, cx, cy);

   CFrameWnd* pFrameWnd = GetParentFrame();
   ASSERT_VALID(pFrameWnd);

   if ((pFrameWnd-&gt;GetStyle() &amp; WS_VISIBLE) &amp;&amp;
      pFrameWnd-&gt;IsKindOf(RUNTIME_CLASS(COleIPFrameWnd)))
   {
      // update the cx part of the extent to the width of the control
      CEmbeddedItem* pItem =
         (CEmbeddedItem*)GetDocument()-&gt;GetEmbeddedItem();

      // only update if it has actually changed
      if (pItem-&gt;m_sizeExtent.cx != cx)
      {
         pItem-&gt;m_sizeExtent.cx = cx;
         OnEditChange();  // will notify client later
      }
   }
</PRE>}
<P>
BOOL CEmbeddedItem::OnDraw(CDC* pDC, CSize&amp; rSize)
{
<PRE>   // get view attached to the item
   CPadView* pView = GetView();

   // In some situations, OLE1 servers will ask for
   //  the presentation data during shutdown, even though it is not
   //  necessary (since the picture has not changed). This will
   //  happen when closing a frame window for example. By this time
   //  all the views are gone and there is no way to produce the
   //  metafile data, since the actual text is stored by the edit
   //  control (the view). In this case, we simply fail the call.
   if (pView == NULL)
      return FALSE;

   // edit controls have a border around them
   CRect rectClient;
   CRect margin;

   { // Calculate correct ClientRect
      pView-&gt;GetClientRect(&amp;rectClient);
      rectClient.InflateRect(-1,-1);
      if (pView-&gt;GetStyle() &amp; WS_HSCROLL)
         rectClient.bottom++;
      if (pView-&gt;GetStyle() &amp; WS_VSCROLL)
         rectClient.right++;
   }

   { // Calculate margins
      CRect rectEdit;
      pView-&gt;GetEditCtrl().GetRect(&amp;rectEdit);

      int HorzMargin = rectEdit.left - rectClient.left;
      int VertMargin = rectEdit.top - rectClient.top;

      margin.SetRect(HorzMargin,VertMargin,HorzMargin,VertMargin);

      if (pView-&gt;GetStyle() &amp; WS_HSCROLL)
         margin.bottom++;
      if (pView-&gt;GetStyle() &amp; WS_VSCROLL)
         margin.right++;
   }

   // get the font from the CEditView
   CFont* pFont = pView-&gt;GetFont();
   CFont* pOldFont = NULL;
   if (pFont != NULL)
      pOldFont = pDC-&gt;SelectObject(pFont);

   // get formatting rectangle
   CRect rect(rectClient);
   rect.left += margin.left;
   rect.top += margin.top;
   rect.right -= margin.right;
   rect.bottom = INT_MAX;

   pDC-&gt;SetBkMode(TRANSPARENT);

   // first just determine the correct extents of the text
   pDC-&gt;SaveDC();
   pDC-&gt;IntersectClipRect(0, 0, 0, 0);
                          // no drawing with NULL clipping
   if (pView-&gt;PrintInsideRect(pDC, rect, m_nBeg, m_nEnd) == 0)
   {
      TEXTMETRIC tm;
      pDC-&gt;GetTextMetrics(&amp;tm);
      rect.bottom = rect.top + tm.tmHeight + tm.tmExternalLeading;
   }
   pDC-&gt;RestoreDC(-1);

   // then, really output the text
   pDC-&gt;SetWindowOrg(rect.left-margin.left,rect.top-margin.top);
   pDC-&gt;SetWindowExt(margin.left + rect.Width() + margin.right,
      margin.top + rect.Height() + margin.bottom);
   pView-&gt;PrintInsideRect(pDC, rect, m_nBeg, m_nEnd);

   // adjust for border (rect.left is already adjusted)
   rect.left -= margin.left;
   rect.top -= margin.top;
   rect.right += margin.right;
   rect.bottom += margin.bottom;

   // select previous font
   if (pOldFont != NULL)
      pDC-&gt;SelectObject(pOldFont);

   // return HIMETRIC size
   rSize = rect.Size();
   pDC-&gt;LPtoHIMETRIC(&amp;rSize);
   return TRUE;
</PRE>}
<P>
<P><h2>STATUS</h2>
 
<P>
Microsoft has confirmed this to be a bug in the Microsoft products listed
at the beginning of this article. This bug was corrected in Visual C++
version 1.51 for Windows.
<P>
NOTE: The problem does not occur in Visual C++ version 2.0.
<P>

	</FONT>
	</TD>
	</TR>
</TABLE>
<P>


<!--DOCBODY_END-->

<!--FOOTER_START-->
<table cellpadding=5 border=0 width="90%">
<tr>
<td>
	<HR WIDTH="90%">

<BLOCKQUOTE>
<FONT FACE="Verdana, Arial, Helvetica" SIZE="1">
<SPAN STYLE="font-family:verdana,arial,helvetica; font-size:8pt">
Additional reference words: 1.50 2.50<BR>
KBCategory: kbole kbprg kbbuglist kbfixlist kbcode<BR>
KBSubcategory: MfcOLE<BR>
Keywords          : kb16bitonly MfcOLE kbbuglist kbcode kbfixlist kbole kbprg<BR>
Technology        : kbMfc<BR>
Version           : 1.50<BR>
Platform          : WINDOWS<BR>
Solution Type     : kbfix<BR>

</SPAN>
</FONT>
<BR>
<BR>
THE INFORMATION PROVIDED IN THE MICROSOFT KNOWLEDGE BASE IS
PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND.  MICROSOFT DISCLAIMS
ALL WARRANTIES, EITHER EXPRESS OR IMPLIED, INCLUDING THE WARRANTIES
OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  IN NO
EVENT SHALL MICROSOFT CORPORATION OR ITS SUPPLIERS BE LIABLE FOR
ANY DAMAGES WHATSOEVER INCLUDING DIRECT, INDIRECT, INCIDENTAL,
CONSEQUENTIAL, LOSS OF BUSINESS PROFITS OR SPECIAL DAMAGES, EVEN IF
MICROSOFT CORPORATION OR ITS SUPPLIERS HAVE BEEN ADVISED OF THE
POSSIBILITY OF SUCH DAMAGES.  SOME STATES DO NOT ALLOW THE EXCLUSION
OR LIMITATION OF LIABILITY FOR CONSEQUENTIAL OR INCIDENTAL DAMAGES
SO THE FOREGOING LIMITATION MAY NOT APPLY.
</BLOCKQUOTE>
<P>
<center>
	<FONT FACE="Verdana,Arial,Helvetica" SIZE="1">
	Last reviewed:  September 18, 1997</FONT>
	<BR>
	<A href="../cpyright.htm" STYLE="font: bold 7pt Verdana,Arial,Helvetica">&copy; 1998 Microsoft Corporation. All rights reserved. Terms of Use.</A><BR>
	
</center>
</td>
</tr>
</table>

<!--FOOTER_END-->
</FONT>
</BODY>
</HTML>
