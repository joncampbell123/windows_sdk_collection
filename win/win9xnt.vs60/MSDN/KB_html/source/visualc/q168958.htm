

<HTML>
<HEAD>
<TITLE>HOWTO: Exporting STL Components Inside &amp; Outside of a Class </TITLE>

<!--STYLE_BEGIN-->
<style>@import url(../../msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="../../msdn_ie3.css">
<!--STYLE_END-->

<META HTTP-EQUIV="CONTENT-Type" CONTENT="text/html; charset=us-ascii">
<META NAME="ms.locale" CONTENT="EN-US">
<META NAME="Category" CONTENT="Support; KB Article">
<META NAME="KBID" CONTENT="Q168958">
<META NAME="KBModify" CONTENT="1998/01/19">
<META NAME="KBCreate" CONTENT="1997/05/22">
<META NAME="Keywords" CONTENT="STLIss kbcode">
<META NAME="KBArea" CONTENT="Support; KB; visualc">
<META NAME="Description" CONTENT="  This article demonstrates how to:  1. Export an instantiation of a Standard Template Library (STL) class.  2. Export a class that contains a data member that is an STL object.  Note that you may not export a generalized template. The template must ...">
<META NAME="Product" CONTENT="Visual C++">
<META NAME="Platform" CONTENT="Windows">
<META NAME="Technology" CONTENT=" ">
<META NAME="Premium" CONTENT="support">

<META NAME="nyms" CONTENT="QA3P,QABO,QA36,QAB4,QANY,QAKM,QADF,QBFY,QAY2,QDNN,QBXF,QA4Q,QAW6,QBVV,QBE7 V02180118">
</HEAD>

<BODY BGCOLOR="#FFFFFF" LEFTMARGIN="0" RIGHTMARGIN="0" TOPMARGIN="0">


<!--DOCBODY_START-->
<BR>
<CENTER>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" VALIGN="top" WIDTH="90%">
	<TR>
		<TD VALIGN="top">
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<H1>HOWTO: Exporting STL Components Inside &amp; Outside of a Class</H1>
			</FONT>
			<FONT FACE="verdana,arial,helvetica" SIZE="1">
			Last reviewed:  January 19, 1998</FONT><BR>
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<B>Article ID: Q168958</B>
			</FONT>
		</TD>
	</TR>
	<TR>
	<TD>
	<FONT FACE="Verdana, Arial, Helvetica" SIZE=2>



 
 
The information in this article applies to:

<UL><LI>Microsoft Visual C++, 32-bit Editions, version 5.0
</UL> 
<P>
<P><h2>SUMMARY</h2>
 
<P>
This article demonstrates how to:

<OL><P><LI>Export an instantiation of a Standard Template Library (STL) class.

<P><LI>Export a class that contains a data member that is an STL object.
<P>
</OL>Note that you may not export a generalized template. The template must be
instantiated, that is, all of the template parameters must be supplied and
must be completely defined types at the point of instantiation. For
instance "stack&lt;int&gt;;" instantiates the STL stack class. The instantiation
forces all members of class stack&lt;int&gt; to be generated.
<P>
<P><h2>MORE INFORMATION</h2>
 
<P>
Beginning with Visual C++ 5.0, it is possible to force an instantiation of
a template class and export the instantiation. To export a template class
instantiation, use the following syntax:
<P>
<P><h3>To Export an STL Class</h3>
 

<OL><P><LI>In both the DLL and the .exe file, link with the same DLL version of the
   C run time. Either link both with msvcrt.lib (release build) or link
   both with msvcrtd.lib (debug build).

<P><LI>In the DLL, provide the __declspec specifier in the template
   instantiation declaration to export the STL class instantiation from
   the DLL.

<P><LI>In the .exe file, provide the extern and __declspec specifiers in the
   template instantiation declaration to import the class from the DLL.
   This results in a warning C4231 "nonstandard extension used : 'extern'
   before template explicit instantiation". You can ignore this warning.
<P>
</OL><h3>To Export a Class Containing a Data Member that is an STL Object</h3>
 

<OL><P><LI>In both the DLL and the .exe file, link with the same DLL version of the
   C run time. Either link both with msvcrt.lib (release build) or link
   both with msvcrtd.lib (debug build).

<P><LI>In the DLL, provide the __declspec specifier in the template
   instantiation declaration to export the STL class instantiation from
   the DLL.
<P>
   NOTE: You cannot skip step 2. You must export the instantiation of the
   STL class that you use to create the data member.

<P><LI>In the DLL, provide the __declspec specifier in the declaration of the
   class to export the class from the DLL.

<P><LI>In the .exe file, provide the __declspec specifier in the declaration of
   the class to import the class from the DLL.
<P>
</OL>NOTE: Some STL classes use other STL classes. These other classes must also
be exported. The classes that must be exported are listed in compiler
warnings if you compile with a warning level lower than 1; that is, /W2,
/W3, or /W4. Warning level 4 generates a lot of warning messages for STL
headers and is not currently recommended for that reason.
<P>
Some STL classes contain nested classes. These classes cannot be exported.
For instance, deque contains a nested class deque::iterator. If you export
deque, you will get a warning that you must export deque::iterator. If you
export deque::iterator, you get a warning that you must export deque. This
is caused by a designed limitation that once a template class is
instantiated, it cannot be re-instantiated and exported.
<P>
Because of this limitation, make sure that you export your instantiations
of the template classes before they are instantiated by any other code.
<P>
When you export an STL container parameterized with a user-defined type
(UDT), you must define the operators &lt; and == for your UDT. For example, if
you export vector&lt;MyClass&gt;, you must define MyClass::operator &lt; and MyClass
operator ==. This is because all STL container classes have member
comparison operators that require the existence of the operators &lt; and ==
for the contained type. Normally, these are not instantiated because they
are not used. When you instantiate an instance of a template class, all
member functions are generated. Since the STL container classes have member
functions that use the operators &lt; and == for the contained type, you must
implement them. If comparing objects of your UDT does not make sense, you
can define the comparison operators to simply return “true.”
<P>
When the symbol _DLL is defined during compiling (this symbol is implicitly
defined when compiling with /MD or /MDd to link with the DLL version of the
C Runtime), the following STL classes, and various global operators and
functions that operate on these classes, are already exported by the C
Runtime DLL. Therefore, you cannot export them from your DLL. This should
not cause a problem for the executable program that imports your class as
long as it also uses the DLL version of the C Runtime:
<P>
<PRE>Header      STL template class
------      ------------------
&lt;IOSFWD&gt;    basic_ios
&lt;IOSFWD&gt;    basic_streambuf
&lt;IOSFWD&gt;    basic_istream
&lt;IOSFWD&gt;    basic_string (also typedef'd as string and wstring)
&lt;IOSFWD&gt;    complex
&lt;LOCALE&gt;    messages
&lt;XLOCALE&gt;   codecvt
&lt;XLOCALE&gt;   ctype
&lt;XLOCMON&gt;   moneypunct
&lt;XLOCMON&gt;   money_get
&lt;XLOCMON&gt;   money_put
&lt;XLOCNUM&gt;   numpunct
</PRE></OL>&lt;XLOCTIME&gt;  time_get
&lt;XLOCTIME&gt;  time_put
<PRE>&lt;XSTRING&gt;   basic_string (also typedef'd as string and wstring)

</PRE>For specific details on which template parameters are used and which global
functions and operators are declared, please see the relevant header file.
<P>
<P><h3>Sample Code</h3>
 
<P>
<PRE>   // -------------------------------------------
   // MYHEADER.H

    //disable warnings on 255 char debug symbols
    #pragma warning (disable : 4786)
    //disable warnings on extern before template instantiation
    #pragma warning (disable : 4231)

    #include &lt;vector&gt;

    // Provide the storage class specifier (extern for an .exe file, null
    // for DLL) and the __declspec specifier (dllimport for .an .exe file,
    // dllexport for DLL).
    // You must define EXP_STL when compiling the DLL.
    // You can now use this header file in both the .exe file and DLL - a
    // much safer means of using common declarations than two different
    // header files.
    #ifdef EXP_STL
    #    define DECLSPECIFIER __declspec(dllexport)
    #    define EXPIMP_TEMPLATE
    #else
    #    define DECLSPECIFIER __declspec(dllimport)
    #    define EXPIMP_TEMPLATE extern
    #endif

    // Instantiate classes vector&lt;int&gt; and vector&lt;char&gt;
    // This does not create an object. It only forces the generation of all
    // of the members of classes vector&lt;int&gt; and vector&lt;char&gt;. It exports
    // them from the DLL and imports them into the .exe file.
    EXPIMP_TEMPLATE template class DECLSPECIFIER std::vector&lt;int&gt;;
    EXPIMP_TEMPLATE template class DECLSPECIFIER std::vector&lt;char&gt;;

    // Declare/Define a class that contains both a static and non-static
    // data member of an STL object.
    // Note that the two template instantiations above are required for
    // the data members to be accessible. If the instantiations above are
    // omitted, you may experience an access violation.
    // Note that since you are exporting a vector of MyClass, you must
    // provide implementations for the operator &lt; and the operator ==.
    class DECLSPECIFIER MyClass
    {
    public:
        std::vector&lt;int&gt; VectorOfInts;
        static std::vector&lt;char&gt; StaticVectorOfChars;

    public:
        bool operator &lt; (const MyClass &amp; c) const
        {
            return VectorOfInts &lt; c. VectorOfInts;
        }
        bool operator == (const MyClass &amp; c) const
        {
            return VectorOfInts == c. VectorOfInts;
        }
    };

    // Instantiate the class vector&lt;MyClass&gt;
    // This does not create an object. It only forces the generation of
    // all of the members of the class vector&lt;MyClass&gt;. It exports them
    // from the DLL and imports them into the .exe file.
    EXPIMP_TEMPLATE template class DECLSPECIFIER std::vector&lt;MyClass&gt;;

    // -------------------------------------------
    // Compile options needed: /GX /LDd /MDd /D"EXP_STL"
    //                     or: /GX /LD  /MD  /D"EXP_STL"
    // DLL.CPP

    #include "MyHeader.h"
    std::vector&lt;char&gt; MyClass::StaticVectorOfChars;


    // -------------------------------------------
    // Compile options needed: /GX /MDd
    //                     or: /GX /MD
    // EXE.CPP

    #include &lt;iostream&gt;
    #include "MyHeader.h"

    int main ()
    {
        MyClass x;

        for (int i=0; i&lt;5; i++) x.VectorOfInts.push_back(i);
        for (char j=0; j&lt;5; j++) x.StaticVectorOfChars.push_back('a' + j);

        std::vector&lt;int&gt;::iterator vii = x.VectorOfInts.begin();
        while (vii != x.VectorOfInts.end())
        {
            std::cout &lt;&lt; *vii;
            std::cout &lt;&lt; " displayed from x.VectorOfInts" &lt;&lt; std::endl;
            vii++;
        }
        std::vector&lt;char&gt;::iterator vci = x.StaticVectorOfChars.begin();
        while (vci != x.StaticVectorOfChars.end())
        {
            std::cout &lt;&lt; *vci;
            std::cout &lt;&lt; " displayed from MyClass::StaticVectorOfChars";
            std::cout &lt;&lt; std::endl;
            vci++;
        }

        std::vector&lt;MyClass&gt; vy;
        for (i=0; i=5; I++) vy.push_back(MyClass());

        return 1;
    }

</PRE><h2>REFERENCES</h2>
 
<P>
TITLE: Explicit Instantiation
<PRE>  URL: mk:@ivt:vclang/FB/DD/S44AE7.HTM

</PRE>TITLE: __declspec
<PRE>  URL: mk:@ivt:vccore/F3C/D3E/S4C390.HTM

</PRE>TITLE: stack
<PRE>  URL: mk:@ivt:vclang/STDLIBBLD/STACK_STACK.HTM

</PRE>TITLE: /MD, /ML, /MT, /LD (Use Run-Time Library)
<PRE>  URL: mk:@ivt:vccore/F19/D1E/S4D030.HTM
</PRE> 
<PRE>Keywords          : STLIss kbcode
Version           : WINNT:5.0;
Platform          : winnt
Issue type        : kbhowto</PRE>

	</FONT>
	</TD>
	</TR>
</TABLE>
<P>


<!--DOCBODY_END-->

<!--FOOTER_START-->
<table cellpadding=5 border=0 width="90%">
<tr>
<td>
	<HR WIDTH="90%">

<BLOCKQUOTE>
<FONT FACE="Verdana, Arial, Helvetica" SIZE="1">
<SPAN STYLE="font-family:verdana,arial,helvetica; font-size:8pt">
================================================================================<BR>

</SPAN>
</FONT>
<BR>
<BR>
THE INFORMATION PROVIDED IN THE MICROSOFT KNOWLEDGE BASE IS
PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND.  MICROSOFT DISCLAIMS
ALL WARRANTIES, EITHER EXPRESS OR IMPLIED, INCLUDING THE WARRANTIES
OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  IN NO
EVENT SHALL MICROSOFT CORPORATION OR ITS SUPPLIERS BE LIABLE FOR
ANY DAMAGES WHATSOEVER INCLUDING DIRECT, INDIRECT, INCIDENTAL,
CONSEQUENTIAL, LOSS OF BUSINESS PROFITS OR SPECIAL DAMAGES, EVEN IF
MICROSOFT CORPORATION OR ITS SUPPLIERS HAVE BEEN ADVISED OF THE
POSSIBILITY OF SUCH DAMAGES.  SOME STATES DO NOT ALLOW THE EXCLUSION
OR LIMITATION OF LIABILITY FOR CONSEQUENTIAL OR INCIDENTAL DAMAGES
SO THE FOREGOING LIMITATION MAY NOT APPLY.
</BLOCKQUOTE>
<P>
<center>
	<FONT FACE="Verdana,Arial,Helvetica" SIZE="1">
	Last reviewed:  January 19, 1998</FONT>
	<BR>
	<A href="../cpyright.htm" STYLE="font: bold 7pt Verdana,Arial,Helvetica">&copy; 1998 Microsoft Corporation. All rights reserved. Terms of Use.</A><BR>
	
</center>
</td>
</tr>
</table>

<!--FOOTER_END-->
</FONT>
</BODY>
</HTML>
