

<HTML>
<HEAD>
<TITLE>BUG: GetRowsEx() Incorrectly Handles Null Field Values </TITLE>

<!--STYLE_BEGIN-->
<style>@import url(../../msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="../../msdn_ie3.css">
<!--STYLE_END-->

<META HTTP-EQUIV="CONTENT-Type" CONTENT="text/html; charset=us-ascii">
<META NAME="ms.locale" CONTENT="EN-US">
<META NAME="Category" CONTENT="Support; KB Article">
<META NAME="KBID" CONTENT="Q153216">
<META NAME="KBModify" CONTENT="1996/07/10">
<META NAME="KBCreate" CONTENT="1996/07/02">
<META NAME="Keywords" CONTENT="kbprg kbbuglist">
<META NAME="KBArea" CONTENT="Support; KB; visualc">
<META NAME="Description" CONTENT="  The DAO SDK defines a function called GetRowsEx that is a method of the DAO recordset object. This function fails to handle null field values correctly for variable-length fields. If a null value exists in a field that is fetched with GetRowsEx(), ...">
<META NAME="Product" CONTENT="Visual C++">
<META NAME="Platform" CONTENT="Windows">
<META NAME="Technology" CONTENT=" ">
<META NAME="Premium" CONTENT="support">

<META NAME="nyms" CONTENT="QAKD,QAGI,QAI4,QAEF,QA7O,QA7N,QA5V,QAY5,QAJX,QAAP,QADR,QABI,QACJ,QBBI,QAIF V02180118">
</HEAD>

<BODY BGCOLOR="#FFFFFF" LEFTMARGIN="0" RIGHTMARGIN="0" TOPMARGIN="0">


<!--DOCBODY_START-->
<BR>
<CENTER>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" VALIGN="top" WIDTH="90%">
	<TR>
		<TD VALIGN="top">
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<H1>BUG: GetRowsEx() Incorrectly Handles Null Field Values</H1>
			</FONT>
			<FONT FACE="verdana,arial,helvetica" SIZE="1">
			Last reviewed:  July 10, 1996</FONT><BR>
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<B>Article ID: Q153216</B>
			</FONT>
		</TD>
	</TR>
	<TR>
	<TD>
	<FONT FACE="Verdana, Arial, Helvetica" SIZE=2>



 
The information in this article applies to:

<UL><LI>The DAO SDK included with:
   Microsoft Visual C++, 32-bit Edition, versions 4.0, 4.1, 4.2
</UL> 
<P>
<P><h2>SYMPTOMS</h2>
 
<P>
The DAO SDK defines a function called GetRowsEx that is a method of the DAO
recordset object. This function fails to handle null field values correctly
for variable-length fields. If a null value exists in a field that is
fetched with GetRowsEx(), the buffer doesn't get updated. For example, you
may find that the buffer contains the same value from the previous
GetRowsEx() call if you specified dbBindSTRING in the DAORSETBINDING
struct. Or, if you specified dbBindLPSTRING in the DAORSETBINDING struct,
you may find that the pointer points to incorrect data.
<P>
<P><h2>CAUSE</h2>
 
<P>
This a bug with the GetRowsEx() function.
<P>
<P><h2>RESOLUTION</h2>
 
<P>
Clear the buffer before calling the GetRowsEx() method. If a null value is
encountered, the buffer will remain unchanged for the field. Check the
buffer for whether the value has been modified after the GetRowsEx call. If
it hasn't changed, the value is null. See the code below for an example of
how to handle null values.
<P>
<P><h2>STATUS</h2>
 
<P>
Microsoft has confirmed this to be a bug in the Microsoft products listed
at the beginning of this article. We are researching this bug and will post
new information here in the Microsoft Knowledge Base as it becomes
available.
<P>
<P><h2>MORE INFORMATION</h2>
 
<P>
The following sample code demonstrates how to change the DoGetRowsEx()
function in the GETROWS DAO SDK sample so that it handles null values. This
function is very similar to the old one except the fetching size has been
changed to two records at a time, and the buffer where GetRowsEx() stores
the data is cleared before each call. Also, a check is performed to see if
the data is null and, if it is, the function places the text "null" in the
output string.
<P>
<P><h3>Sample Code</h3>
 
<P>
<PRE>#define FETCH_SIZE 2
#define MAX_FIRST_NAME_LENGTH 20
// Perform C++ GetRowsEx against the Employee table
void CGetRowsDlg::DoGetRowsEx()
</PRE>{
<PRE>    LPEMP           pEmpRows = new EMP[FETCH_SIZE];
    CListBox        *pListBox = (CListBox*)GetDlgItem(IDD_GETROWSLISTEX);
    CString         strLBRow;
    TCHAR           szId[16];
    LONG            lNumRecords;
    LONG            lCount;
    TCHAR           pBuf[MAX_EMP_REC * 15]; // allow avg of 15 chars/name

    while (!m_cEmpRecordSet.GetEOF())
    {

        //Clear values in buffer for variable-length fields
        for (long lCnt = 0; lCnt &lt; FETCH_SIZE; lCnt++)
        {
          _strnset(pEmpRows[lCnt].strFirstName,'\0',
              MAX_FIRST_NAME_LENGTH);
          pEmpRows[lCnt].strLastName=NULL;
        }

       try
        {
        lNumRecords = m_cEmpRecordSet.GetRowsEx(pEmpRows, sizeof(EMP),
                        &amp;Bindings[0], sizeof(Bindings) /
                        sizeof(DAORSETBINDING),
                        pBuf, sizeof(pBuf),
                        FETCH_SIZE);
        }
    catch (CdbException e)
        {
        //Differentiate between GetRowsEx Errors and other CdbExceptions
        // see defines in DAOGETRW.H
        if( e.m_hr == E_ROWTOOSHORT ||
            e.m_hr == E_BADBINDINFO ||
            e.m_hr == E_COLUMNUNAVAILABLE )
            {
                AfxMessageBox(_T("Error in GetRowsEx call."));
            }
        else
            {
                AfxMessageBox(_T("General CdbException"));
            }
        delete [] pEmpRows;
        return;
        }

    //Step through the returned rows
    for (lCount = 0; lCount &lt; lNumRecords; lCount++)
        {
        strLBRow.Empty();
        wsprintf(szId, _T("%d,  "), pEmpRows[lCount].lEmpId);
        strLBRow += szId;
        if (pEmpRows[lCount].strLastName!=NULL)
            strLBRow += pEmpRows[lCount].strLastName;
        else
            strLBRow += "null";

        strLBRow += _T(", ");
        if (pEmpRows[lCount].strFirstName[0]=='\0')
            strLBRow += "null";
        else
            strLBRow += (LPCTSTR) pEmpRows[lCount].strFirstName;
        pListBox-&gt;AddString(strLBRow);
        }

      if (!m_cEmpRecordSet.GetEOF())
         m_cEmpRecordSet.MoveNext(); // Need to move to next unread
                                     // record before fetching the next
                                     // set of records.
    }

    delete [] pEmpRows;
</PRE>}
<P>

	</FONT>
	</TD>
	</TR>
</TABLE>
<P>


<!--DOCBODY_END-->

<!--FOOTER_START-->
<table cellpadding=5 border=0 width="90%">
<tr>
<td>
	<HR WIDTH="90%">

<BLOCKQUOTE>
<FONT FACE="Verdana, Arial, Helvetica" SIZE="1">
<SPAN STYLE="font-family:verdana,arial,helvetica; font-size:8pt">
Additional reference words: 4.00 4.10 4.20 vcbuglist400<BR>
KBCategory: kbprg kbbuglist<BR>
KBSubcategory: dbDao
<P>


</SPAN>
</FONT>
<BR>
<BR>
THE INFORMATION PROVIDED IN THE MICROSOFT KNOWLEDGE BASE IS
PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND.  MICROSOFT DISCLAIMS
ALL WARRANTIES, EITHER EXPRESS OR IMPLIED, INCLUDING THE WARRANTIES
OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  IN NO
EVENT SHALL MICROSOFT CORPORATION OR ITS SUPPLIERS BE LIABLE FOR
ANY DAMAGES WHATSOEVER INCLUDING DIRECT, INDIRECT, INCIDENTAL,
CONSEQUENTIAL, LOSS OF BUSINESS PROFITS OR SPECIAL DAMAGES, EVEN IF
MICROSOFT CORPORATION OR ITS SUPPLIERS HAVE BEEN ADVISED OF THE
POSSIBILITY OF SUCH DAMAGES.  SOME STATES DO NOT ALLOW THE EXCLUSION
OR LIMITATION OF LIABILITY FOR CONSEQUENTIAL OR INCIDENTAL DAMAGES
SO THE FOREGOING LIMITATION MAY NOT APPLY.
</BLOCKQUOTE>
<P>
<center>
	<FONT FACE="Verdana,Arial,Helvetica" SIZE="1">
	Last reviewed:  July 10, 1996</FONT>
	<BR>
	<A href="../cpyright.htm" STYLE="font: bold 7pt Verdana,Arial,Helvetica">&copy; 1998 Microsoft Corporation. All rights reserved. Terms of Use.</A><BR>
	
</center>
</td>
</tr>
</table>

<!--FOOTER_END-->
</FONT>
</BODY>
</HTML>
