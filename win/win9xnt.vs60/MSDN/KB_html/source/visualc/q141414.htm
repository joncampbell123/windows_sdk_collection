

<HTML>
<HEAD>
<TITLE>HOWTO: Enumerate OLE and VB Controls from an OLE Control </TITLE>

<!--STYLE_BEGIN-->
<style>@import url(../../msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="../../msdn_ie3.css">
<!--STYLE_END-->

<META HTTP-EQUIV="CONTENT-Type" CONTENT="text/html; charset=us-ascii">
<META NAME="ms.locale" CONTENT="EN-US">
<META NAME="Category" CONTENT="Support; KB Article">
<META NAME="KBID" CONTENT="Q141414">
<META NAME="KBModify" CONTENT="1998/02/17">
<META NAME="KBCreate" CONTENT="1995/12/17">
<META NAME="Keywords" CONTENT="CDKIss MfcOLE">
<META NAME="KBArea" CONTENT="Support; KB; visualc">
<META NAME="Description" CONTENT="  In order for an OLE control to communicate with another control placed on the same Visual Basic form, the OLE control needs access to at least one interface pointer of the other control. This article illustrates a technique you can use to enumerate...">
<META NAME="Product" CONTENT="Visual C++">
<META NAME="Platform" CONTENT="Windows">
<META NAME="Technology" CONTENT=" ">
<META NAME="Premium" CONTENT="support">

<META NAME="nyms" CONTENT="QAB5,QA7O,QAOE,QAMN,QBS0,QA9Q,QAW6,QAHV,QBBS,QAPN,QAHT,QAH6,QA5F,QAMA,QAH4 V02180118">
</HEAD>

<BODY BGCOLOR="#FFFFFF" LEFTMARGIN="0" RIGHTMARGIN="0" TOPMARGIN="0">


<!--DOCBODY_START-->
<BR>
<CENTER>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" VALIGN="top" WIDTH="90%">
	<TR>
		<TD VALIGN="top">
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<H1>HOWTO: Enumerate OLE and VB Controls from an OLE Control</H1>
			</FONT>
			<FONT FACE="verdana,arial,helvetica" SIZE="1">
			Last reviewed:  February 17, 1998</FONT><BR>
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<B>Article ID: Q141414</B>
			</FONT>
		</TD>
	</TR>
	<TR>
	<TD>
	<FONT FACE="Verdana, Arial, Helvetica" SIZE=2>



 
 
The information in this article applies to:

<UL><LI>Standard and Professional Editions of Microsoft Visual Basic
   programming system for Windows, version 4.0
<LI>Microsoft Visual C++, 32-bit Edition, versions 2.0, 2.1, 2.2, 4.0, 5.0
</UL> 
<P>
<P><h2>SUMMARY</h2>
 
<P>
In order for an OLE control to communicate with another control placed on
the same Visual Basic form, the OLE control needs access to at least one
interface pointer of the other control. This article illustrates a
technique you can use to enumerate both OLE and Visual Basic controls
present on a particular form and retrieve an interface pointer to these
controls. Note that the same technique could be applied to enumerate
controls placed on other control containers, provided that container
exposes the functionality required to implement the technique.
<P>
<P><h2>MORE INFORMATION</h2>
 
<P>
Given a pointer to IOleClientSite, it is possible to enumerate through all
of the other controls on a form by making use of the following interfaces:
<P>
IOleClientSite
IOleContainer
IEnumUnknown
IUnknown
IOleObject
IOleClientSite
IOleControlSite
<P>
Note that most of these interfaces are container-side interfaces, so the
technique mentioned here is container dependent. For this method to work,
the container must provide support for IOleContainer, which is currently
defined as a mandatory interface in the OLE control container guidelines.
Both MFC version 4.0 and Visual Basic version 4.0 OLE control containers
provide support for this interface. Before using this method with another
control container, ensure that it provides support for IOleContainer.
<P>
The method itself is illustrated by the sample code listed in this article.
You can incorporate the code into an OLE control generated using
ControlWizard. Use the code to enumerate all the controls, internal Visual
Basic controls as well OLE controls, by calling IOleContainer::EnumObjects,
and passing the following flags as its first parameter:
<P>
<PRE>   OLECONTF_EMBEDDINGS: is used to retrieve OLE Controls.
   OLECONTF_OTHERS    : is used to retrieve other objects such as Visual
                        Basic internal controls.

   hr = lpContainer-&gt;EnumObjects(OLECONTF_EMBEDDINGS | OLECONTF_OTHERS,
                              &amp;lpEnumUnk);

</PRE>The differentiating aspect between OLE controls and other objects such as
internal Visual Basic controls is that only OLE controls support the
IOleObject interface. Hence, if a QueryInterface for IID_IOleObject fails
for an object, then it is a different type of object. Also, if the control
container provides support for Extended controls as does Visual Basic 4.0,
the Extended control for a particular OLE control can also be retrieved
using the method illustrated by the sample code.
<P>
Note that most of the functionality provided by the following sample code
depends solely on the extent of the functionality exposed by the control
container itself.
<P>
Also note that the LPOLECLIENTSITE pointer can be obtained through
a call to COleControl::m_xOleObject::GetClientSite() or through
COleControl::GetClientSite().
<P>
<P><h3>Sample Code</h3>
 
<P>
<PRE>void EnumAllControlNames(LPOLECLIENTSITE lpSite)
</PRE>{
<PRE>   LPOLECONTAINER lpContainer;
   LPENUMUNKNOWN lpEnumUnk;

   // Note that the IOleContainer interface is currently defined as
   // mandatory. It must be implemented by control containers,
   // in the OLE Control Containers Guidelines.
   HRESULT hr = lpSite-&gt;GetContainer(&amp;lpContainer);
   if(FAILED(hr)) {
      OutputDebugString(_T("Unable to get to the container.\n"));
      return;
   }

   // OLECONTF_EMBEDDINGS is used to retrieve OLE Controls.
   // OLECONTF_OTHERS is used to retrieve other objects such as
   // Visual Basic internal controls
   hr = lpContainer-&gt;EnumObjects(
                       OLECONTF_EMBEDDINGS | OLECONTF_OTHERS,
                       &amp;lpEnumUnk);
   if(FAILED(hr)) {
      lpContainer-&gt;Release();
      return;
   }

   LPUNKNOWN lpUnk;
   while (lpEnumUnk-&gt;Next(1, &amp;lpUnk, NULL) == S_OK) {
      LPOLEOBJECT lpObject = NULL;
      LPOLECONTROLSITE lpTargetSite = NULL;
      LPOLECLIENTSITE lpClientSite = NULL;
      LPDISPATCH lpDisp;

      hr = lpUnk-&gt;QueryInterface(
                    IID_IOleObject, (LPVOID*)&amp;lpObject);
      if(SUCCEEDED(hr)) {
         // This is an OLE control.
         // Navigate to the Extended Control because Visual Basic 4.0 uses
         // Extended controls.
         hr = lpObject-&gt;GetClientSite(&amp;lpClientSite);
         if(SUCCEEDED(hr)) {
            // You have the IOleClientSite interface
            hr = lpClientSite-&gt;QueryInterface(
                       IID_IOleControlSite, (LPVOID*)&amp;lpTargetSite);
            if(SUCCEEDED(hr)) {
               // You have the IOleControlSite interface
               // Get the IDispatch for the extended control.
               // Note that Extended controls are optional in the OLE
               // specifications for OLE Control Containers.
               hr = lpTargetSite-&gt;GetExtendedControl(&amp;lpDisp);
            }
         }
      }
      else {
         // This is either an internal VB control or the
         // VB form itself.
         hr = lpUnk-&gt;QueryInterface(
                       IID_IDispatch, (LPVOID*)&amp;lpDisp);
      }

      if(SUCCEEDED(hr)) {
         VARIANT va;
         VariantInit(&amp;va);
         DISPID dispid;
         DISPPARAMS dispParams = { NULL, NULL, 0, 0 };

         // Get the names of all the controls present in a VB form.
         LPWSTR lpName[1] = { (WCHAR *)L"Name" };
         hr = lpDisp-&gt;GetIDsOfNames(IID_NULL, lpName, 1,
                                      LOCALE_SYSTEM_DEFAULT, &amp;dispid);

         if(SUCCEEDED(hr)) {
            hr = lpDisp-&gt;Invoke(dispid/*0x80010000*/, IID_NULL,
                                  LOCALE_SYSTEM_DEFAULT,
                                  DISPATCH_PROPERTYGET |
                                  DISPATCH_METHOD,
                                  &amp;dispParams, &amp;va, NULL, NULL);
            if(SUCCEEDED(hr)) {
               CString szTmp((LPCWSTR)va.bstrVal);
               // szTmp now has the name.
               OutputDebugString(_T("And the name is ... ") + szTmp +
                                 _T("\n"));
            }
         }
         lpDisp-&gt;Release();
      }

      // Release interface pointers.
      if(lpObject)     lpObject-&gt;Release();
      if(lpTargetSite) lpTargetSite-&gt;Release();
      if(lpClientSite) lpClientSite-&gt;Release();

      lpUnk-&gt;Release();
   }    // End of While statement

   // Final clean up
   lpEnumUnk-&gt;Release();
   lpContainer-&gt;Release();
</PRE>}
<P>
Additional words: VB VC visualc cdk ocx
 
<PRE>Keywords          : CDKIss MfcOLE
Technology        : kbole kbMfc
Version           : Winnet:2.0,2.1,2.2,4.0,5.0
Platform          : NT WINDOWS
Issue type        : kbhowto</PRE>

	</FONT>
	</TD>
	</TR>
</TABLE>
<P>


<!--DOCBODY_END-->

<!--FOOTER_START-->
<table cellpadding=5 border=0 width="90%">
<tr>
<td>
	<HR WIDTH="90%">

<BLOCKQUOTE>
<FONT FACE="Verdana, Arial, Helvetica" SIZE="1">
<SPAN STYLE="font-family:verdana,arial,helvetica; font-size:8pt">
================================================================================<BR>

</SPAN>
</FONT>
<BR>
<BR>
THE INFORMATION PROVIDED IN THE MICROSOFT KNOWLEDGE BASE IS
PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND.  MICROSOFT DISCLAIMS
ALL WARRANTIES, EITHER EXPRESS OR IMPLIED, INCLUDING THE WARRANTIES
OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  IN NO
EVENT SHALL MICROSOFT CORPORATION OR ITS SUPPLIERS BE LIABLE FOR
ANY DAMAGES WHATSOEVER INCLUDING DIRECT, INDIRECT, INCIDENTAL,
CONSEQUENTIAL, LOSS OF BUSINESS PROFITS OR SPECIAL DAMAGES, EVEN IF
MICROSOFT CORPORATION OR ITS SUPPLIERS HAVE BEEN ADVISED OF THE
POSSIBILITY OF SUCH DAMAGES.  SOME STATES DO NOT ALLOW THE EXCLUSION
OR LIMITATION OF LIABILITY FOR CONSEQUENTIAL OR INCIDENTAL DAMAGES
SO THE FOREGOING LIMITATION MAY NOT APPLY.
</BLOCKQUOTE>
<P>
<center>
	<FONT FACE="Verdana,Arial,Helvetica" SIZE="1">
	Last reviewed:  February 17, 1998</FONT>
	<BR>
	<A href="../cpyright.htm" STYLE="font: bold 7pt Verdana,Arial,Helvetica">&copy; 1998 Microsoft Corporation. All rights reserved. Terms of Use.</A><BR>
	
</center>
</td>
</tr>
</table>

<!--FOOTER_END-->
</FONT>
</BODY>
</HTML>
