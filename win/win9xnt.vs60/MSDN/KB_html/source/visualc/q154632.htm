

<HTML>
<HEAD>
<TITLE>FIX: Accept Returns FALSE but GetLastError Returns 0 </TITLE>

<!--STYLE_BEGIN-->
<style>@import url(../../msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="../../msdn_ie3.css">
<!--STYLE_END-->

<META HTTP-EQUIV="CONTENT-Type" CONTENT="text/html; charset=us-ascii">
<META NAME="ms.locale" CONTENT="EN-US">
<META NAME="Category" CONTENT="Support; KB Article">
<META NAME="KBID" CONTENT="Q154632">
<META NAME="KBModify" CONTENT="1997/09/19">
<META NAME="KBCreate" CONTENT="1996/08/09">
<META NAME="Keywords" CONTENT="MfcSockets vcbuglist420 vcfixlist420 kbprg kbbuglist kbfixlist">
<META NAME="KBArea" CONTENT="Support; KB; visualc">
<META NAME="Description" CONTENT="  A call to CSocket or CAsyncSocket::Accept returns FALSE, but a call to GetLastError or WSAGetLastError returns 0. The same code works correctly with MFC version 4.0.  CAUSE =====  MFC maintains information in Thread Local Storage. In CAsyncSocket::...">
<META NAME="Product" CONTENT="Visual C++">
<META NAME="Platform" CONTENT="Windows">
<META NAME="Technology" CONTENT=" ">
<META NAME="Premium" CONTENT="support">

<META NAME="nyms" CONTENT="QAUD,QAD7,QAGK,QAGI,QAXC,QAH4,QAIF,QAY5,QALW,QAY2,QAAP,QAI4,QAR4,QAB4,QBV8 V02180118">
</HEAD>

<BODY BGCOLOR="#FFFFFF" LEFTMARGIN="0" RIGHTMARGIN="0" TOPMARGIN="0">


<!--DOCBODY_START-->
<BR>
<CENTER>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" VALIGN="top" WIDTH="90%">
	<TR>
		<TD VALIGN="top">
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<H1>FIX: Accept Returns FALSE but GetLastError Returns 0</H1>
			</FONT>
			<FONT FACE="verdana,arial,helvetica" SIZE="1">
			Last reviewed:  September 19, 1997</FONT><BR>
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<B>Article ID: Q154632</B>
			</FONT>
		</TD>
	</TR>
	<TR>
	<TD>
	<FONT FACE="Verdana, Arial, Helvetica" SIZE=2>



 
 
The information in this article applies to:

<UL><LI>The Microsoft Foundation Classes (MFC) included with:
   - Microsoft Visual C++, 32-bit Edition, versions 4.1 and 4.2
</UL> 
<P>
<P><h2>SYMPTOMS</h2>
 
<P>
A call to CSocket or CAsyncSocket::Accept returns FALSE, but a call to
GetLastError or WSAGetLastError returns 0. The same code works correctly
with MFC version 4.0.
<P>
<P><h2>CAUSE</h2>
 
<P>
MFC maintains information in Thread Local Storage. In CAsyncSocket::Accept,
the MFC code makes a call to DetachHandle that indirectly makes a call to
TlsGetValue. This occurs after a call to the WinSock API function accept().
The call to TlsGetValue resets the thread's error code to zero and the
error returned from the accept() call is lost.
<P>
<P><h2>RESOLUTION</h2>
 
<P>
If your class is derived directly from CAsyncSocket, then replace the
Accept function and modify it so that the error code is not lost.
<P>
This can be done by first borrowing the function from the
CAsyncSocket::Accept function found in the MFC source code in the file
SOCKCORE.CPP. Change the function to be implemented as follows:
<P>
<PRE>   #if _MFC_VER &gt;= 0x0410 &amp;&amp; _MFC_VER &lt;= 0x0420

   BOOL CMySocket::Accept(CAsyncSocket&amp; rConnectedSocket,
                          SOCKADDR* lpSockAddr, int* lpSockAddrLen)
   {
     ASSERT(rConnectedSocket.m_hSocket == INVALID_SOCKET);
     ASSERT(CAsyncSocket::FromHandle(INVALID_SOCKET) == NULL);

     CAsyncSocket::AttachHandle(INVALID_SOCKET, &amp;rConnectedSocket);

     SOCKET hTemp = accept(m_hSocket, lpSockAddr, lpSockAddrLen);

     if (hTemp == INVALID_SOCKET)
     {
   // &lt;===== STORE THE ERROR CODE RECEIVED FROM THE accept CALL
       int nError = WSAGetLastError();

       CAsyncSocket::DetachHandle(rConnectedSocket.m_hSocket, FALSE);

   // &lt;===== RE-SET THE ERROR CODE THAT WAS SET IN THE accept CALL
       WSASetLastError(nError);

       rConnectedSocket.m_hSocket = INVALID_SOCKET;
     }
     else if (CAsyncSocket::FromHandle(INVALID_SOCKET) != NULL)
     {
       rConnectedSocket.m_hSocket = hTemp;
       CAsyncSocket::DetachHandle(INVALID_SOCKET, FALSE);
       CAsyncSocket::AttachHandle(hTemp, &amp;rConnectedSocket);
     }

     return (hTemp != INVALID_SOCKET);
   }

   #endif  // _MFC_VER

</PRE>If your class is derived from CSocket, then you will have to replace
CAsyncSocket::Accept as well as CSocket::Accept. This is necessary because
CSocket::Accept directly calls CAsyncSocket::Accept. This can be
accomplished by providing your own Accept function, called AcceptFix. It
would be implemented just as the Accept function shown above. For example:
<P>
<PRE>   #if _MFC_VER &gt;= 0x0410 &amp;&amp; _MFC_VER &lt;= 0x0420

   BOOL CMySocket::AcceptFix(CAsyncSocket&amp; rConnectedSocket,
                             SOCKADDR* lpSockAddr, int* lpSockAddrLen)
   {
      ...
      // IMPLEMENTATION IS THE SAME AS THE ONE SHOWN ABOVE
      ...
      return (hTemp != INVALID_SOCKET);
   }

   #endif // _MFC_VER

</PRE>Then provide a replacement for CSocket::Accept and modify it to call
AcceptFix instead of CAsyncSocket::Accept. You can borrow the
CSocket::Accept function from SOCKCORE.CPP and modify it as follows:
<P>
<PRE>   #if _MFC_VER &gt;= 0x0410 &amp;&amp; _MFC_VER &lt;= 0x0420

   BOOL CMySocket::Accept(CAsyncSocket&amp; rConnectedSocket,
                          SOCKADDR* lpSockAddr, int* lpSockAddrLen)
   {
     if (m_pbBlocking != NULL)
     {
       WSASetLastError(WSAEINPROGRESS);
       return FALSE;
     }

     // &lt;===============  REPLACE THE FOLLOWING LINE
     // while (!CAsyncSocket::Accept(rConnectedSocket, lpSockAddr,...
     // &lt;===============  WITH THIS:

     while (!AcceptFix(rConnectedSocket, lpSockAddr, lpSockAddrLen))
     {
       if (GetLastError() == WSAEWOULDBLOCK)
       {
         if (!PumpMessages(FD_ACCEPT))
           return FALSE;
       }
       else
         return FALSE;
     }
     return TRUE;
   }

   #endif // _MFC_VER

</PRE><h2>STATUS</h2>
 
<P>
Microsoft has confirmed this to be a bug in the Microsoft products listed
at the beginning of this article. This bug has been corrected in the Visual
C++ 4.2b technology update.
<P>

	</FONT>
	</TD>
	</TR>
</TABLE>
<P>


<!--DOCBODY_END-->

<!--FOOTER_START-->
<table cellpadding=5 border=0 width="90%">
<tr>
<td>
	<HR WIDTH="90%">

<BLOCKQUOTE>
<FONT FACE="Verdana, Arial, Helvetica" SIZE="1">
<SPAN STYLE="font-family:verdana,arial,helvetica; font-size:8pt">
Additional query words: WSAEWOULDBLOCK
<P>

<BR>
Keywords          : MfcSockets vcbuglist420 vcfixlist420 kbprg kbbuglist kbfixlist<BR>
Technology        : kbMfc<BR>
Version           : 4.1 4.2<BR>
Platform          : NT WINDOWS<BR>
Issue type        : kbbug<BR>
Solution Type     : kbfix<BR>

</SPAN>
</FONT>
<BR>
<BR>
THE INFORMATION PROVIDED IN THE MICROSOFT KNOWLEDGE BASE IS
PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND.  MICROSOFT DISCLAIMS
ALL WARRANTIES, EITHER EXPRESS OR IMPLIED, INCLUDING THE WARRANTIES
OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  IN NO
EVENT SHALL MICROSOFT CORPORATION OR ITS SUPPLIERS BE LIABLE FOR
ANY DAMAGES WHATSOEVER INCLUDING DIRECT, INDIRECT, INCIDENTAL,
CONSEQUENTIAL, LOSS OF BUSINESS PROFITS OR SPECIAL DAMAGES, EVEN IF
MICROSOFT CORPORATION OR ITS SUPPLIERS HAVE BEEN ADVISED OF THE
POSSIBILITY OF SUCH DAMAGES.  SOME STATES DO NOT ALLOW THE EXCLUSION
OR LIMITATION OF LIABILITY FOR CONSEQUENTIAL OR INCIDENTAL DAMAGES
SO THE FOREGOING LIMITATION MAY NOT APPLY.
</BLOCKQUOTE>
<P>
<center>
	<FONT FACE="Verdana,Arial,Helvetica" SIZE="1">
	Last reviewed:  September 19, 1997</FONT>
	<BR>
	<A href="../cpyright.htm" STYLE="font: bold 7pt Verdana,Arial,Helvetica">&copy; 1998 Microsoft Corporation. All rights reserved. Terms of Use.</A><BR>
	
</center>
</td>
</tr>
</table>

<!--FOOTER_END-->
</FONT>
</BODY>
</HTML>
