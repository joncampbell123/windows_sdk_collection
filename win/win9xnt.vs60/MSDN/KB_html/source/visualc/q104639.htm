

<HTML>
<HEAD>
<TITLE>INFO: Dynamic Memory Allocation for Two-Dimensional Arrays </TITLE>

<!--STYLE_BEGIN-->
<style>@import url(../../msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="../../msdn_ie3.css">
<!--STYLE_END-->

<META HTTP-EQUIV="CONTENT-Type" CONTENT="text/html; charset=us-ascii">
<META NAME="ms.locale" CONTENT="EN-US">
<META NAME="Category" CONTENT="Support; KB Article">
<META NAME="KBID" CONTENT="Q104639">
<META NAME="KBModify" CONTENT="1997/09/30">
<META NAME="KBCreate" CONTENT="1993/09/23">
<META NAME="Keywords" CONTENT="CLngIss">
<META NAME="KBArea" CONTENT="Support; KB; visualc">
<META NAME="Description" CONTENT="  The C language does not internally support dynamic memory allocation for two-dimensional arrays. Creating such a structure requires some programming to set it up; however, once created the elements can be referred to by the familiar double bracket ...">
<META NAME="Product" CONTENT="Visual C++">
<META NAME="Platform" CONTENT="Windows">
<META NAME="Technology" CONTENT=" ">
<META NAME="Premium" CONTENT="support">

<META NAME="nyms" CONTENT="QA5V,QBFY,QAO2,QAO3,QAE1,QBVV,QAH4,QBWP,QAUD,QAJ5,QDL9,QBWQ,QBWO,QBWN,QDMN V02180118">
</HEAD>

<BODY BGCOLOR="#FFFFFF" LEFTMARGIN="0" RIGHTMARGIN="0" TOPMARGIN="0">


<!--DOCBODY_START-->
<BR>
<CENTER>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" VALIGN="top" WIDTH="90%">
	<TR>
		<TD VALIGN="top">
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<H1>INFO: Dynamic Memory Allocation for Two-Dimensional Arrays</H1>
			</FONT>
			<FONT FACE="verdana,arial,helvetica" SIZE="1">
			Last reviewed:  September 30, 1997</FONT><BR>
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<B>Article ID: Q104639</B>
			</FONT>
		</TD>
	</TR>
	<TR>
	<TD>
	<FONT FACE="Verdana, Arial, Helvetica" SIZE=2>



<P><h3> </h3>
 
The information in this article applies to:

<UL><LI>Microsoft C for MS-DOS, versions 6.0, 6.0a, 6.0ax
<LI>Microsoft C for OS/2, versions 6.0, 6.0a
<LI>Microsoft C/C++ for MS-DOS, version 7.0
<LI>Microsoft Visual C++ for Windows, versions 1.0, 1.5
<LI>Microsoft Visual C++ 32-bit Edition, versions 1.0, 2.0, 2.1, 4.0, 4.1,
   5.0
</UL> 
<P>
<P><h2>SUMMARY</h2>
 
<P>
The C language does not internally support dynamic memory allocation for
two-dimensional arrays. Creating such a structure requires some programming
to set it up; however, once created the elements can be referred to by the
familiar double bracket ([][]) notation. There is memory overhead involved
in creating the structure. This technique is platform-independent working
in the MS-DOS, Windows, Windows NT, and OS/2 operating systems.
<P>
<P><h2>MORE INFORMATION</h2>
 
<P>
For the compiler to generate code for two-dimensional array element
dereferencing, the number of columns of the array must be known at compile
time. Therefore, it is possible to dynamically allocate a two-dimensional
array if pointer declaration includes the "width" of the array. Below is a
code fragment that illustrates this:
<P>
<PRE>    char (*array)[columns];

    array = (char (*)[columns]) malloc(sizeof(char) * rows * columns);
    if (array == NULL)
    {
        printf("Not enough memory!\n");
        return;
    }

</PRE>However, to give both dimensions of a two-dimensional array at run time the
array must be dynamically allocated. In this case, a dynamically allocated
two-dimensional array should be thought of as an array of one-dimensional
arrays. There is some memory overhead, however, which requires allocation
of an array of array pointers that is not necessary for statically defined
two-dimensional arrays. Despite the overhead, each element of the two-
dimensional arrays can be referenced with the bracket notation just as for
a statically defined two-dimensional array.
<P>
These are the steps for dynamically allocating a two-dimensional array:

<OL><P><LI>Declare a double dereferenced pointer of a desired type.

<P><LI>Allocate the number of rows times the size of a pointer and assign
   the first dereference to the beginning of this allocation.

<P><LI>Loop through the rows and allocate the number of columns times the
   size of the element.
<P>
</OL>The structure conceptually resembles the following:
<P>
<PRE>   Array of                    Arrays of
   Pointers                    Elements

   ------     -------------------------                      -------
   |    | --&gt;|   |   |   |   |   |   |     . . . . . . .       |   |
   ------     -------------------------                      -------
   |    | --&gt;|   |   |   |   |   |   |     . . . . . . .       |   |
   ------     -------------------------                      -------
   |    | --&gt;|   |   |   |   |   |   |     . . . . . . .       |   |
   ------     -------------------------                      -------
   |    | --&gt;|   |   |   |   |   |   |     . . . . . . .       |   |
   ------     -------------------------                      -------
         .
         .
         .
         .
         .    -------------------------                      -------
   |    | --&gt;|   |   |   |   |   |   |     . . . . . . .       |   |
   ------     -------------------------                      -------
   |    | --&gt;|   |   |   |   |   |   |     . . . . . . .       |   |
   ------     -------------------------                      -------

</PRE></OL>Use _fmalloc() for MS-DOS and 16-Bit Windows to use the far/global
heap. Note for Windows: _fmalloc() is available to be used when
compiling with Microsoft C/C++ compiler versions 7.0, 8.0, and 8.0c.
Do not use GlobalAlloc and GlobalLock because this technique may use
up too many selectors for relatively small allocations.
<P>
Unlike a statically declared two-dimensional array, the rows are not
contiguous with one another. But because this is an array of arrays it
is possible to have a total structure larger than 64K without using
huge pointers. If either the number of rows or the size of the rows is
greater than 64K, then huge pointers are necessary.
<P>
<P><h3>Sample Code</h3>
 
<P>
<PRE>/* Semi-pseudo code for a two-dimensional array of char's
 * Note that this sample uses the far heap and uses far pointers.
 * For 32-Bit Windows applications on Windows NT or Win32S or for
 * OS/2, use malloc() and remove the _far keywords.
 */

    char _far * _far * array;
    unsigned int i;
    unsigned int rows, columns;  /* let's keep it within 64k */

    /*  Set the rows and columns to desired dimensions. */
    rows    = 8;
    columns = 12;

    array = (char _far * _far *) _fmalloc(sizeof(char _far *) * rows);
    if (array == NULL)
    {
        printf("Not enough memory\n");
        return;
    }
    for (i = 0; i &lt; rows; i++)
    {
        array[i] = (char _far *) _fmalloc(sizeof(char) * columns);
        if (array[i] == NULL)
        {
            printf("Not enough memory\n");
            /* handle error, _free() the previously allocated rows */
            return;
        }
    }

    /* to use the array: array[row][column] */
    array[0][1] = 'x';

    /* etc.   */

/* To Free the memory used by the array
</PRE>**
<PRE> */
    for (i = 0; i&lt; rows; i++)
        _ffree(array[i]);
    _ffree(array);
</PRE>

	</FONT>
	</TD>
	</TR>
</TABLE>
<P>


<!--DOCBODY_END-->

<!--FOOTER_START-->
<table cellpadding=5 border=0 width="90%">
<tr>
<td>
	<HR WIDTH="90%">

<BLOCKQUOTE>
<FONT FACE="Verdana, Arial, Helvetica" SIZE="1">
<SPAN STYLE="font-family:verdana,arial,helvetica; font-size:8pt">
Additional query words: kbinf halloc<BR>
Keywords          : CLngIss<BR>
Version           : MS-DOS:6.0ax,7.0;OS/2:6.0,6.00a;WINDOWS:1.0,1.5;WINDOWS NT:1.0,2.0,2.1,4.0,4.1,5.0<BR>
Platform          : MS-DOS NT OS/2 WINDOWS<BR>
Issue type        : kbinfo<BR>

</SPAN>
</FONT>
<BR>
<BR>
THE INFORMATION PROVIDED IN THE MICROSOFT KNOWLEDGE BASE IS
PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND.  MICROSOFT DISCLAIMS
ALL WARRANTIES, EITHER EXPRESS OR IMPLIED, INCLUDING THE WARRANTIES
OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  IN NO
EVENT SHALL MICROSOFT CORPORATION OR ITS SUPPLIERS BE LIABLE FOR
ANY DAMAGES WHATSOEVER INCLUDING DIRECT, INDIRECT, INCIDENTAL,
CONSEQUENTIAL, LOSS OF BUSINESS PROFITS OR SPECIAL DAMAGES, EVEN IF
MICROSOFT CORPORATION OR ITS SUPPLIERS HAVE BEEN ADVISED OF THE
POSSIBILITY OF SUCH DAMAGES.  SOME STATES DO NOT ALLOW THE EXCLUSION
OR LIMITATION OF LIABILITY FOR CONSEQUENTIAL OR INCIDENTAL DAMAGES
SO THE FOREGOING LIMITATION MAY NOT APPLY.
</BLOCKQUOTE>
<P>
<center>
	<FONT FACE="Verdana,Arial,Helvetica" SIZE="1">
	Last reviewed:  September 30, 1997</FONT>
	<BR>
	<A href="../cpyright.htm" STYLE="font: bold 7pt Verdana,Arial,Helvetica">&copy; 1998 Microsoft Corporation. All rights reserved. Terms of Use.</A><BR>
	
</center>
</td>
</tr>
</table>

<!--FOOTER_END-->
</FONT>
</BODY>
</HTML>
