

<HTML>
<HEAD>
<TITLE>FILE: OLE2BIN Sample - Storing COleClientItems in a Database </TITLE>

<!--STYLE_BEGIN-->
<style>@import url(../../msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="../../msdn_ie3.css">
<!--STYLE_END-->

<META HTTP-EQUIV="CONTENT-Type" CONTENT="text/html; charset=us-ascii">
<META NAME="ms.locale" CONTENT="EN-US">
<META NAME="Category" CONTENT="Support; KB Article">
<META NAME="KBID" CONTENT="Q177911">
<META NAME="KBModify" CONTENT="1998/02/03">
<META NAME="KBCreate" CONTENT="1997/12/10">
<META NAME="Keywords" CONTENT="MfcDatabase">
<META NAME="KBArea" CONTENT="Support; KB; visualc">
<META NAME="Description" CONTENT="  The OLE2BIN sample demonstrates how to save and load an MFC COleClientItem from a Access database (.mdb file). The storage and any COleClientItem data are stored.  STEP2 of the Container tutorial sample was used as the starting point to demonstrate...">
<META NAME="Product" CONTENT="Visual C++">
<META NAME="Platform" CONTENT="Windows">
<META NAME="Technology" CONTENT=" ">
<META NAME="Premium" CONTENT="support">

<META NAME="nyms" CONTENT="QA1S,QAUD,QAPN,QAUR,QAW6,QDN9,QAZV,QAU7,QDKY,QALW,QBVV,QAU9,QAPF,QBWS,QAY2 V02180118">
</HEAD>

<BODY BGCOLOR="#FFFFFF" LEFTMARGIN="0" RIGHTMARGIN="0" TOPMARGIN="0">


<!--DOCBODY_START-->
<BR>
<CENTER>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" VALIGN="top" WIDTH="90%">
	<TR>
		<TD VALIGN="top">
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<H1>FILE: OLE2BIN Sample - Storing COleClientItems in a Database</H1>
			</FONT>
			<FONT FACE="verdana,arial,helvetica" SIZE="1">
			Last reviewed:  February 3, 1998</FONT><BR>
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<B>Article ID: Q177911</B>
			</FONT>
		</TD>
	</TR>
	<TR>
	<TD>
	<FONT FACE="Verdana, Arial, Helvetica" SIZE=2>



 
 
The information in this article applies to:

<UL><LI>Microsoft Visual C++, 32-bit Editions, version 5.0
</UL> 
<P>
<P><h2>SUMMARY</h2>
 
<P>
The OLE2BIN sample demonstrates how to save and load an MFC COleClientItem
from a Access database (.mdb file). The storage and any COleClientItem data
are stored.
<P>
STEP2 of the Container tutorial sample was used as the starting point to
demonstrate this technique. A Database menu was added, with two submenus,
Save Object and Load Object. To save an object to the database, click a
COleClientItem to select it and then click Save Object on the Database
menu. You will be asked to provide a name for the object, which can then be
used later to load the object from the database.
<P>
To load an object, click Load Object on the Database menu. You will be
asked to select an object that was previously saved. When you first run the
sample, there is an object that has already been placed in the database.
<P>
<P><h2>MORE INFORMATION</h2>
 
<P>
The following file is available for download from the Microsoft
Software Library:
<P>
<PRE> ~ <A href="http://support.microsoft.com/download/support/mslfiles/ole2bin.exe">OLE2BIN.EXE</A> <I>(size: 82897 bytes)</I> 

</PRE>For more information about downloading files from the Microsoft Software
Library, please see the following article in the Microsoft Knowledge Base:
<P>
<PRE>   ARTICLE-ID: <B><A href="../zmiscellaneous/q119591.htm">Q119591</A></B>
   TITLE     : How to Obtain Microsoft Support Files from Online Services

</PRE>The core functionality of the sample is located in two functions,
CContainerView::OnDatabaseLoad() and CContainerView::OnDatabaseSave().
<P>
Below is the code for the OnDatabaseSave() function. The only item that is
not well documented is the m_bForceFlat member. This member tells the
archive to store the data without creating additional substorages. All the
data is saved into the one stream.
<P>
Also note that because the COleClientItem is serialized, not only is the
OLE storage saved, but all of the COleClientItem's data (position, display
aspect, and so on) is also saved.
<P>
Here is the OnDatabaseSave() method:
<P>
<PRE>   static const TCHAR szContents[] = _T("Contents");
   #define INITIAL_ALLOC_SIZE 100000

   void CContainerView::OnDatabaseSave()
   {
      LPLOCKBYTES pLockBytes = NULL;
      LPSTORAGE pStorage = NULL;

      ASSERT(m_pSelection != NULL);

      CNameDlg dlg;
      if (dlg.DoModal() == IDCANCEL || dlg.m_Name == "")
      {
         return;
      }

      CDatabase db;
      if (!db.OpenEx("DRIVER=Microsoft Access Driver
         (*.mdb);DBQ=BinDB.MDB;FIL=MS Access for Microsoft
         Access;UID=Admin;PWD=;"))
      {
         AfxMessageBox("Access ODBC Driver not installed");
         return;
      }

      CObjectSet rs(&amp;db);
      rs.Open();
      rs.AddNew();

      rs.m_Name = dlg.m_Name;

      GlobalFree(rs.m_OleObject.m_hData);

      rs.m_OleObject.m_hData = GlobalAlloc(GMEM_MOVEABLE,
         INITIAL_ALLOC_SIZE);

      if (FAILED(CreateILockBytesOnHGlobal(rs.m_OleObject.m_hData,FALSE,
                   &amp;pLockBytes)))
      {
         AfxMessageBox("Unable to retrieve LockBytes");
         return;
      }

      if (FAILED(StgCreateDocfileOnILockBytes(pLockBytes, STGM_DIRECT |
              STGM_CREATE | STGM_READWRITE | STGM_SHARE_EXCLUSIVE, 0,
              &amp;pStorage)))
      {
        AfxMessageBox("Failure creating storage on LockBytes");
        pLockBytes-&gt;Release();
        return;
      }

      COleStreamFile file;
      CFileException fe;
      if (!file.CreateStream(pStorage, szContents,
            CFile::modeReadWrite|CFile::shareExclusive|CFile::modeCreate,
            &amp;fe))
      {
        AfxThrowFileException(fe.m_cause, fe.m_lOsError);
      }

      // save to Contents stream
      CArchive saveArchive(&amp;file, CArchive::store |
                             CArchive::bNoFlushOnDelete);
      saveArchive.m_pDocument = GetDocument();
      saveArchive.m_bForceFlat = TRUE;

      TRY
      {
          m_pSelection-&gt;Serialize(saveArchive);
          saveArchive.Close();
          file.Close();

          // commit the storage
          SCODE sc = pStorage-&gt;Commit(STGC_ONLYIFCURRENT);
          if (sc != S_OK)
            AfxThrowOleException(sc);
      }
      CATCH_ALL(e)
      {
          file.Abort();   // will not throw an exception
          THROW_LAST();
      }
      END_CATCH_ALL


      rs.SetFieldDirty(&amp;rs.m_OleObject);
      rs.SetFieldNull(&amp;rs.m_OleObject, FALSE);

      STATSTG statstg;
      pLockBytes-&gt;Stat(&amp;statstg,  STATFLAG_NONAME);
      rs.m_OleObject.m_dwDataLength = statstg.cbSize.LowPart;

      rs.Update();
      rs.Close();

      pLockBytes-&gt;Release();
      pStorage-&gt;Release();
   }

</PRE>Here is the OnDatabaseLoad() method, which is just the opposite of the
OnDatabaseSave() method:
<P>
<PRE>   void CContainerView::OnDatabaseLoad()
   {
      LPSTORAGE pStorage = NULL;
      LPLOCKBYTES pLockBytes = NULL;

      // Make certain there are objects in the database
      // If there are, bring up dialog for user to select an object
      CDatabase db;
      if (!db.OpenEx("DRIVER=Microsoft Access Driver
         (*.mdb);DBQ=BinDB.MDB;FIL=MS Access for Microsoft
         Access;UID=Admin;PWD=;"))
      {
         AfxMessageBox("Access ODBC Driver not installed");
         return;
      }

      CObjNameSet rsObjName(&amp;db);

      rsObjName.Open();
      if (rsObjName.IsEOF())
      {
          rsObjName.Close();
          AfxMessageBox("No objects exist in the database.");
          return;
      }

      CObjDlg dlg(&amp;rsObjName);
      if (dlg.DoModal() == IDCANCEL)
      {
         return;
      }

      rsObjName.Close();

      CObjectSet rs(&amp;db);

      CContainerItem * pItem = new CContainerItem;

      rs.m_strFilter = "Name = '" + dlg.m_ObjectName + "'";

      rs.Open();

      if (FAILED(CreateILockBytesOnHGlobal(rs.m_OleObject.m_hData, FALSE,
                    &amp;pLockBytes)))
      {
          AfxMessageBox("Unable to retrieve LockBytes");
          return;
      }

      HRESULT hr = StgOpenStorageOnILockBytes(pLockBytes, NULL,
                    STGM_DIRECT | STGM_READ | STGM_SHARE_EXCLUSIVE  , NULL,
                    0, &amp;pStorage);

      if (FAILED(hr))
      {
         AfxMessageBox("Failure opening storage");
         pLockBytes-&gt;Release();
         return;
      }


      COleStreamFile file;
      CFileException fe;
      if (!file.OpenStream(pStorage, szContents,
             CFile::modeRead|CFile::shareExclusive, &amp;fe))
      {
         if (fe.m_cause == CFileException::fileNotFound)
            AfxThrowArchiveException(CArchiveException::badSchema);
         else
            AfxThrowFileException(fe.m_cause, fe.m_lOsError);
      }

      CArchive loadArchive(&amp;file, CArchive::load |
                           CArchive::bNoFlushOnDelete);
      loadArchive.m_pDocument = GetDocument();
      loadArchive.m_bForceFlat = TRUE;

      TRY
      {
         pItem-&gt;Serialize(loadArchive);     // load main contents
         loadArchive.Close();
         file.Close();
      }
      CATCH_ALL(e)
      {
         file.Abort();   // will not throw an exception
         // remove item because it didn't fully loaded
         GetDocument()-&gt;RemoveItem(pItem);
         THROW_LAST();
      }
      END_CATCH_ALL

      rs.Close();

      db.Close();

      pLockBytes-&gt;Release();

      GetDocument()-&gt;UpdateAllViews(NULL);
   }
</PRE>

	</FONT>
	</TD>
	</TR>
</TABLE>
<P>


<!--DOCBODY_END-->

<!--FOOTER_START-->
<table cellpadding=5 border=0 width="90%">
<tr>
<td>
	<HR WIDTH="90%">

<BLOCKQUOTE>
<FONT FACE="Verdana, Arial, Helvetica" SIZE="1">
<SPAN STYLE="font-family:verdana,arial,helvetica; font-size:8pt">
Additional query words: OLE Field BLOB Binary<BR>
Keywords          : MfcDatabase<BR>
Technology        : ole<BR>
Version           : WINNT:5.0<BR>
Platform          : winnt<BR>
Issue type        : kbfile<BR>
Solution Type     : kbsample<BR>

</SPAN>
</FONT>
<BR>
<BR>
THE INFORMATION PROVIDED IN THE MICROSOFT KNOWLEDGE BASE IS
PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND.  MICROSOFT DISCLAIMS
ALL WARRANTIES, EITHER EXPRESS OR IMPLIED, INCLUDING THE WARRANTIES
OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  IN NO
EVENT SHALL MICROSOFT CORPORATION OR ITS SUPPLIERS BE LIABLE FOR
ANY DAMAGES WHATSOEVER INCLUDING DIRECT, INDIRECT, INCIDENTAL,
CONSEQUENTIAL, LOSS OF BUSINESS PROFITS OR SPECIAL DAMAGES, EVEN IF
MICROSOFT CORPORATION OR ITS SUPPLIERS HAVE BEEN ADVISED OF THE
POSSIBILITY OF SUCH DAMAGES.  SOME STATES DO NOT ALLOW THE EXCLUSION
OR LIMITATION OF LIABILITY FOR CONSEQUENTIAL OR INCIDENTAL DAMAGES
SO THE FOREGOING LIMITATION MAY NOT APPLY.
</BLOCKQUOTE>
<P>
<center>
	<FONT FACE="Verdana,Arial,Helvetica" SIZE="1">
	Last reviewed:  February 3, 1998</FONT>
	<BR>
	<A href="../cpyright.htm" STYLE="font: bold 7pt Verdana,Arial,Helvetica">&copy; 1998 Microsoft Corporation. All rights reserved. Terms of Use.</A><BR>
	
</center>
</td>
</tr>
</table>

<!--FOOTER_END-->
</FONT>
</BODY>
</HTML>
