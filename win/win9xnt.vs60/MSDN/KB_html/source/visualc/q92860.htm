

<HTML>
<HEAD>
<TITLE>HOWTO: Read From or Write To CFile From Buffer Larger Than 64K </TITLE>

<!--STYLE_BEGIN-->
<style>@import url(../../msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="../../msdn_ie3.css">
<!--STYLE_END-->

<META HTTP-EQUIV="CONTENT-Type" CONTENT="text/html; charset=us-ascii">
<META NAME="ms.locale" CONTENT="EN-US">
<META NAME="Category" CONTENT="Support; KB Article">
<META NAME="KBID" CONTENT="Q92860 ">
<META NAME="KBModify" CONTENT="1997/07/22">
<META NAME="KBCreate" CONTENT="1992/11/16">
<META NAME="Keywords" CONTENT="kb16bitonly MfcFileIO kbhowto">
<META NAME="KBArea" CONTENT="Support; KB; visualc">
<META NAME="Description" CONTENT="  In certain situations, an application can read or write a file larger than 65,535 bytes using one large buffer that is usually allocated by calling the GlobalAlloc() function. Traditionally, to use one buffer the application must perform huge point...">
<META NAME="Product" CONTENT="Visual C++">
<META NAME="Platform" CONTENT="Windows">
<META NAME="Technology" CONTENT=" ">
<META NAME="Premium" CONTENT="support">

<META NAME="nyms" CONTENT="QAY5,QATJ,QA28,QA8T,QBV8,QAB9,QBFN,QAH4,QAY2,QAUD,QBMR,QA9Q,QAO3,QAO2,QACJ V02180118">
</HEAD>

<BODY BGCOLOR="#FFFFFF" LEFTMARGIN="0" RIGHTMARGIN="0" TOPMARGIN="0">


<!--DOCBODY_START-->
<BR>
<CENTER>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" VALIGN="top" WIDTH="90%">
	<TR>
		<TD VALIGN="top">
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<H1>HOWTO: Read From or Write To CFile From Buffer Larger Than 64K</H1>
			</FONT>
			<FONT FACE="verdana,arial,helvetica" SIZE="1">
			Last reviewed:  July 22, 1997</FONT><BR>
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<B>Article ID: Q92860 </B>
			</FONT>
		</TD>
	</TR>
	<TR>
	<TD>
	<FONT FACE="Verdana, Arial, Helvetica" SIZE=2>



<P><h3> </h3>
 
The information in this article applies to:

<UL><LI>The Microsoft Foundation Classes (MFC), included with:
<P><PRE>    - Microsoft C/C++ version 7.0
    - Microsoft Visual C++ for Windows, versions 1.0, 1.5, 1.51 1.52
</UL></PRE> 
<P>
<P><h2>SUMMARY</h2>
 
<P>
In certain situations, an application can read or write a file larger
than 65,535 bytes using one large buffer that is usually allocated by
calling the GlobalAlloc() function. Traditionally, to use one buffer
the application must perform huge pointer manipulations on a buffer
pointer and call the _lread() and _lwrite() functions (provided by
Microsoft Windows) in a loop.
<P>
In an application developed with the Microsoft Foundation Classes, an
attempt to use a huge pointer with the CFile::Read() or CFile::Write()
functions fails at the following assertion:
<P>
<PRE>   ASSERT(AfxIsValidAddress(lpBuf, nCount));

</PRE>The CFile::Read() and CFile::Write() functions each contain the
ASSERT.
<P>
<P><h2>MORE INFORMATION</h2>
 
<P>
Because the AfxIsValidAddress() function was not designed to work with
huge pointers, the ASSERT fails when the application specifies a huge
pointer.
<P>
Version 2.0 and later of the Microsoft Foundation Classes provides two
functions, CFile::ReadHuge() and CFile::WriteHuge() that can accept
huge pointers. Even though these functions are not listed in the
online or printed documentation, the DIBLOOK sample application uses
these functions. The AFX.H header file provides prototypes for these
CFile member functions.
<P>
In code developed with version 1.0 of the Microsoft Foundation
Classes, the method illustrated below demonstrates working around this
limitation. The Microsoft Foundation Classes Object Linking and
Embedding (OLE) Stream Get() and Put() functions implement this
method. For more information, please refer to the source code for
these functions in the OLECLI.CPP file in the MFC\SRC directory.
<P>
The text below provides the ReadHuge() and WriteHuge() functions to
read from and write to a CFile object from a very large buffer. These
functions use the _HugeCalcSize() helper function to determine whether
a memory read or write crosses a segment boundary.
<P>
A second code example demonstrates using the WriteHuge() function.
<P>
Source Code for ReadHuge() and WriteHuge() using
<P><h3>Functions from the Microsoft Foundation Class Library, version 1.0</h3>
 
<P>
<PRE>   //
   // Prototypes
   //
   static UINT _HugeCalcSize(DWORD cbTotal, const void FAR* lpStart);
   DWORD ReadHuge(void FAR* lpBuffer, DWORD dwCount, CFile* file);
   void  WriteHuge(const void FAR* lpBuffer, DWORD dwCount, CFile* file);

   //
   // Functions Definitions
   //
   static UINT _HugeCalcSize(DWORD cbTotal, const void FAR* lpStart)
   {
      // Return Size to Read/Write
      // (16K max unless limited by segment bounds)
      //
      DWORD cb = 0x10000L - _AFX_FP_OFF(lpStart);
      if (cb &gt; cbTotal)
         cb = cbTotal;
      return (cb &gt; 16384) ? 16384 : (UINT)cb;
   }

   DWORD ReadHuge(void FAR* lpBuffer, DWORD dwCount, CFile* file)
   {
      ASSERT_VALID(file);

      DWORD dwToRead = dwCount;
      while (dwToRead &gt; 0)
      {
         UINT nRead = _HugeCalcSize(dwToRead, lpBuffer);
         if (file-&gt;Read(lpBuffer, nRead) &lt; nRead)
            return ((dwCount - dwToRead) + nRead);
         dwToRead -= nRead;
         lpBuffer = ((BYTE _huge*)lpBuffer) + nRead;
      }
      return dwCount;
   }

   void WriteHuge(const void FAR* lpBuffer, DWORD dwCount, CFile* file)
   {
      ASSERT_VALID(file);

      DWORD dwToWrite = dwCount;
      while (dwToWrite &gt; 0)
      {
         UINT nWrite = _HugeCalcSize(dwToWrite, lpBuffer);
         file-&gt;Write(lpBuffer, nWrite);
         dwToWrite -= nWrite;
         lpBuffer = ((const BYTE _huge*)lpBuffer) + nWrite;
      }
   }

</PRE><h3>Sample Code That Uses WriteHuge()</h3>
 
<P>
<PRE>   // WriteTest():
   //
   // Uses WriteHuge() to write a buffer to disk using the CFile
   // class from Microsoft Foundation Classes version 1.0.
   //
   void WriteTest(CString strFileName, DWORD length)
   {
       HGLOBAL hBuff = GlobalAlloc(GHND, length);
       ASSERT(hBuff != NULL);
       char FAR* pBuff = (char FAR*) GlobalLock(hBuff);

       CFile* pFile = new CFile(strFileName, CFile::modeCreate |
                          CFile::modeWrite | CFile::typeBinary);

       DWORD index;

       // Fill Buffer with Test Pattern
       //
       for (index = 0; index &lt; length; index++)
       {
          *(pBuff+index) = (char) (index % 0x00000100);
       }

       // Write Buffer to Disk
       //
       ::WriteHuge(pBuff, length, pFile);

       pFile-&gt;Close();
       delete pFile;
       GlobalUnlock(hBuff);
       GlobalFree(hBuff);
   }
 

	</FONT>
	</TD>
	</TR>
</TABLE>
<P>


<!--DOCBODY_END-->

<!--FOOTER_START-->
<table cellpadding=5 border=0 width="90%">
<tr>
<td>
	<HR WIDTH="90%">

<BLOCKQUOTE>
<FONT FACE="Verdana, Arial, Helvetica" SIZE="1">
<SPAN STYLE="font-family:verdana,arial,helvetica; font-size:8pt">
Keywords            : kb16bitonly MfcFileIO kbhowto<BR>
Technology          : kbmfc<BR>
Version             : 1.0 1.5 1.51 1.52 7.0<BR>
Issue type          : kbhowto<BR>

</SPAN>
</FONT>
<BR>
<BR>
THE INFORMATION PROVIDED IN THE MICROSOFT KNOWLEDGE BASE IS
PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND.  MICROSOFT DISCLAIMS
ALL WARRANTIES, EITHER EXPRESS OR IMPLIED, INCLUDING THE WARRANTIES
OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  IN NO
EVENT SHALL MICROSOFT CORPORATION OR ITS SUPPLIERS BE LIABLE FOR
ANY DAMAGES WHATSOEVER INCLUDING DIRECT, INDIRECT, INCIDENTAL,
CONSEQUENTIAL, LOSS OF BUSINESS PROFITS OR SPECIAL DAMAGES, EVEN IF
MICROSOFT CORPORATION OR ITS SUPPLIERS HAVE BEEN ADVISED OF THE
POSSIBILITY OF SUCH DAMAGES.  SOME STATES DO NOT ALLOW THE EXCLUSION
OR LIMITATION OF LIABILITY FOR CONSEQUENTIAL OR INCIDENTAL DAMAGES
SO THE FOREGOING LIMITATION MAY NOT APPLY.
</BLOCKQUOTE>
<P>
<center>
	<FONT FACE="Verdana,Arial,Helvetica" SIZE="1">
	Last reviewed:  July 22, 1997</FONT>
	<BR>
	<A href="../cpyright.htm" STYLE="font: bold 7pt Verdana,Arial,Helvetica">&copy; 1998 Microsoft Corporation. All rights reserved. Terms of Use.</A><BR>
	
</center>
</td>
</tr>
</table>

<!--FOOTER_END-->
</FONT>
</BODY>
</HTML>
