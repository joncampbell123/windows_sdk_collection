

<HTML>
<HEAD>
<TITLE>BUG: Using float/double Function as Subscript Causes Bad Code </TITLE>

<!--STYLE_BEGIN-->
<style>@import url(../../msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="../../msdn_ie3.css">
<!--STYLE_END-->

<META HTTP-EQUIV="CONTENT-Type" CONTENT="text/html; charset=us-ascii">
<META NAME="ms.locale" CONTENT="EN-US">
<META NAME="Category" CONTENT="Support; KB Article">
<META NAME="KBID" CONTENT="Q68921 ">
<META NAME="KBModify" CONTENT="1997/07/17">
<META NAME="KBCreate" CONTENT="1991/02/01">
<META NAME="Keywords" CONTENT="kb16bitonly">
<META NAME="KBArea" CONTENT="Support; KB; visualc">
<META NAME="Description" CONTENT="  Multiple calls to float functions in the same logical statement may cause the floating-point accumulator to be overwritten if the result of one of the calls is used as a subscript. This problem may occur with the Microsoft C Compiler versions 6.0, ...">
<META NAME="Product" CONTENT="Visual C++">
<META NAME="Platform" CONTENT="Windows">
<META NAME="Technology" CONTENT=" ">
<META NAME="Premium" CONTENT="support">

<META NAME="nyms" CONTENT="QAUD,QBFY,QAH4,QAY5,QAGI,QAKP,QBV8,QAO4,QAB9,QALW,QAJQ,QAHH,QA4Q,QAEF,QAPF V02180118">
</HEAD>

<BODY BGCOLOR="#FFFFFF" LEFTMARGIN="0" RIGHTMARGIN="0" TOPMARGIN="0">


<!--DOCBODY_START-->
<BR>
<CENTER>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" VALIGN="top" WIDTH="90%">
	<TR>
		<TD VALIGN="top">
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<H1>BUG: Using float/double Function as Subscript Causes Bad Code</H1>
			</FONT>
			<FONT FACE="verdana,arial,helvetica" SIZE="1">
			Last reviewed:  July 17, 1997</FONT><BR>
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<B>Article ID: Q68921 </B>
			</FONT>
		</TD>
	</TR>
	<TR>
	<TD>
	<FONT FACE="Verdana, Arial, Helvetica" SIZE=2>



 
6.00 6.00a 6.00ax 7.00 | 6.00 6.00a | 1.00 1.50
<PRE>MS-DOS                 | OS/2       | WINDOWS
</PRE>kbtool kbbuglist
<P>
 
The information in this article applies to:

<UL><LI>The Microsoft C/C++ Compiler (CL.EXE) included with:
<P>
<P><PRE>    - Microsoft C for MS-DOS, versions 6.0, 6.0a, and 6.0ax
    - Microsoft C for OS/2, versions 6.0 and 6.0a
    - Microsoft C/C++ for MS-DOS, version 7.0
    - Microsoft Visual C++ for Windows, versions 1.0 and 1.5
</UL></PRE> 
<P>
<P><h2>SYMPTOMS</h2>
 
<P>
Multiple calls to float functions in the same logical statement may
cause the floating-point accumulator to be overwritten if the
result of one of the calls is used as a subscript. This problem may
occur with the Microsoft C Compiler versions 6.0, 6.0a, and 6.0ax,
but does not occur when the /qc (quick compile) option is
specified.
<P>
<P><h2>RESOLUTION</h2>
 
<P>
This problem occurs because of the C convention for returning
floating point values. To ensure that this problem never occurs,
you need to change the usual order of evaluation rules. One way to
resolve this problem is to use the PASCAL calling convention.
<P>
NOTE: C/C++ 7.0 works with this particular piece of code, however, it is
possible that this problem will occur with other samples.
<P>
<P><h2>STATUS</h2>
 
<P>
Microsoft has confirmed this to be a problem in the products listed at the
beginning of this article.
<P>
<P><h2>MORE INFORMATION</h2>
 
<P>
The sample code below illustrates this problem. Function f_one()
returns 0.0 in the floating-point accumulator (__fac). However, the
floating-point accumulator is not saved before f_two() is called. The
function f_two() returns 12.0 in __fac, which overwrites the 0.0
returned by f_one(). As a result, array[12] is changed, instead of
array[0]. As a workaround, the function's return value may be stored
in a temporary variable, or the two functions may be declared as
_pascal.
<P>
<P><h3>Sample Code</h3>
 
<P>
<PRE>/* Compile options needed: none
*/
#include &lt;stdio.h&gt;

</PRE>float f_one(void);
float f_two(void);
<P>
float fval[20];
<P>
<PRE>void main(void)
</PRE>{
<PRE>   int   i;

// This doesn't work.
   fval[(int)f_one()] = f_two();
   printf("fval[0] (should equal 12.0) = %f\n", fval[0]);

// This works.
   i = (int)f_one();
   fval[i] = f_two();
   printf("fval[0] (should equal 12.0) = %f\n", fval[0]);
</PRE>}
<P>
float f_one()
{
<PRE>   return((float)0.0);
</PRE>}
<P>
float f_two()
{
<PRE>   return((float)12.0);
</PRE>}
<P>

	</FONT>
	</TD>
	</TR>
</TABLE>
<P>


<!--DOCBODY_END-->

<!--FOOTER_START-->
<table cellpadding=5 border=0 width="90%">
<tr>
<td>
	<HR WIDTH="90%">

<BLOCKQUOTE>
<FONT FACE="Verdana, Arial, Helvetica" SIZE="1">
<SPAN STYLE="font-family:verdana,arial,helvetica; font-size:8pt">
Additional reference words: 1.00 1.50 6.00 6.00a 6.00ax 7.00 8.00 8.00c<BR>
KBCategory: kbtool kbbuglist<BR>
KBSubcategory: CLIss<BR>
Keywords            : kb16bitonly<BR>

</SPAN>
</FONT>
<BR>
<BR>
THE INFORMATION PROVIDED IN THE MICROSOFT KNOWLEDGE BASE IS
PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND.  MICROSOFT DISCLAIMS
ALL WARRANTIES, EITHER EXPRESS OR IMPLIED, INCLUDING THE WARRANTIES
OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  IN NO
EVENT SHALL MICROSOFT CORPORATION OR ITS SUPPLIERS BE LIABLE FOR
ANY DAMAGES WHATSOEVER INCLUDING DIRECT, INDIRECT, INCIDENTAL,
CONSEQUENTIAL, LOSS OF BUSINESS PROFITS OR SPECIAL DAMAGES, EVEN IF
MICROSOFT CORPORATION OR ITS SUPPLIERS HAVE BEEN ADVISED OF THE
POSSIBILITY OF SUCH DAMAGES.  SOME STATES DO NOT ALLOW THE EXCLUSION
OR LIMITATION OF LIABILITY FOR CONSEQUENTIAL OR INCIDENTAL DAMAGES
SO THE FOREGOING LIMITATION MAY NOT APPLY.
</BLOCKQUOTE>
<P>
<center>
	<FONT FACE="Verdana,Arial,Helvetica" SIZE="1">
	Last reviewed:  July 17, 1997</FONT>
	<BR>
	<A href="../cpyright.htm" STYLE="font: bold 7pt Verdana,Arial,Helvetica">&copy; 1998 Microsoft Corporation. All rights reserved. Terms of Use.</A><BR>
	
</center>
</td>
</tr>
</table>

<!--FOOTER_END-->
</FONT>
</BODY>
</HTML>
