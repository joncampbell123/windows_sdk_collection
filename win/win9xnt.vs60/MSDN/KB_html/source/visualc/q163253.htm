

<HTML>
<HEAD>
<TITLE>BUG: "Out of Memory" Error When Saving to an Existing File </TITLE>

<!--STYLE_BEGIN-->
<style>@import url(../../msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="../../msdn_ie3.css">
<!--STYLE_END-->

<META HTTP-EQUIV="CONTENT-Type" CONTENT="text/html; charset=us-ascii">
<META NAME="ms.locale" CONTENT="EN-US">
<META NAME="Category" CONTENT="Support; KB Article">
<META NAME="KBID" CONTENT="Q163253">
<META NAME="KBModify" CONTENT="1997/07/02">
<META NAME="KBCreate" CONTENT="1997/02/06">
<META NAME="Keywords" CONTENT="MfcDocView vcbuglist400 kbbuglist kbcode kbprg">
<META NAME="KBArea" CONTENT="Support; KB; visualc">
<META NAME="Description" CONTENT="  When you save to an existing file in a Visual C++ MFC application, an  Out of memory  error occurs. The error occurs only when you save over an existing file on a non-NT platform, such as Windows 95, that is on a network. For example, if you run th...">
<META NAME="Product" CONTENT="Visual C++">
<META NAME="Platform" CONTENT="Windows">
<META NAME="Technology" CONTENT=" ">
<META NAME="Premium" CONTENT="support">

<META NAME="nyms" CONTENT="QAUD,QDKW,QAUR,QAAP,QAH4,QAB4,QAGI,QAKP,QBWP,QAHD,QAEF,QBWS,QAU7,QABI,QALW V02180118">
</HEAD>

<BODY BGCOLOR="#FFFFFF" LEFTMARGIN="0" RIGHTMARGIN="0" TOPMARGIN="0">


<!--DOCBODY_START-->
<BR>
<CENTER>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" VALIGN="top" WIDTH="90%">
	<TR>
		<TD VALIGN="top">
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<H1>BUG: "Out of Memory" Error When Saving to an Existing File</H1>
			</FONT>
			<FONT FACE="verdana,arial,helvetica" SIZE="1">
			Last reviewed:  July 2, 1997</FONT><BR>
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<B>Article ID: Q163253</B>
			</FONT>
		</TD>
	</TR>
	<TR>
	<TD>
	<FONT FACE="Verdana, Arial, Helvetica" SIZE=2>



 
4.00 4.10 4.20
WINDOWS NT
kbprg kbbuglist kbcode
<P>
 
The information in this article applies to:

<UL><LI>The Microsoft Foundation Classes (MFC) included with:
   - Microsoft Visual C++, 32-bit Edition, versions 4.0, 4.1, 4.2
</UL> 
<P>
<P><h2>SYMPTOMS</h2>
 
<P>
When you save to an existing file in a Visual C++ MFC application, an "Out
of memory" error occurs. The error occurs only when you save over an
existing file on a non-NT platform, such as Windows 95, that is on a
network. For example, if you run the Scribble sample on a Windows NT
machine and try to save the scribble file to an existing file on a Windows
95 share, the error occurs.
<P>
<P><h2>CAUSE</h2>
 
<P>
MFC uses a class called CMirrorFile that protects a file in cases where an
error may occur when you are writing to a file. MFC first writes out to a
temporary file and then copies over to the final file when all writing is
done.
<P>
In the CMirrorFile::Open() function located in Doccore.cpp, the following
code exists:
<P>
<PRE>    DWORD dwLength = 0;
    PSECURITY_DESCRIPTOR pSecurityDescriptor = NULL;
    GetFileSecurity(lpszFileName, DACL_SECURITY_INFORMATION,
         NULL, dwLength, &amp;dwLength);
    pSecurityDescriptor = (PSECURITY_DESCRIPTOR) new BYTE[dwLength];

</PRE>In the case where a file is located on a non-NT share, the GetFileSecurity
call fails. It may return a large value and this can cause the new
statement to fail with an "out of memory" error. You need to select the
return value for GetFileSecurity.
<P>
<P><h2>RESOLUTION</h2>
 
<P>
There are a couple of ways to work around the problem.

<UL><LI>Override the CDocument::GetFile() function to return a CFile object
   rather than a CMirrorFile object. You won't get the protection feature
   of CMirrorFile which checks to see whether you can write the whole file
   to the disk first. This may not be a problem depending upon what the
   application does. See the code the CDocument::GetFile() in
   \Msdev\Mfc\Src\Doccore.cpp to see the default implementation.

<LI>Create your own CMirrorFile class and check the return value of the
   GetFileSecurity() call. If the call fails, ignore the code that modifies
   the securities of the file. For example, you can create your own
   CMirrorFile-derived class like the following code demonstrates:
<P>
</UL>**********
<PRE>#include &lt;afxpriv.h&gt;
#include "c:\msdev\mfc\src\afximpl.h"

</PRE>class CMyMirrorFile: public CMirrorFile
{
<PRE>      virtual BOOL Open(LPCTSTR lpszFileName, UINT nOpenFlags,
      CFileException* pError = NULL);
</PRE>};
<P>
BOOL CMyMirrorFile::Open(LPCTSTR lpszFileName, UINT nOpenFlags,
<PRE>      CFileException* pError)
</PRE>{
<PRE>    ASSERT(lpszFileName != NULL);
   m_strMirrorName.Empty();

</PRE>#ifndef _MAC
<PRE>   CFileStatus status;
   if (nOpenFlags &amp; CFile::modeCreate) //opened for writing
   {
      if (CFile::GetStatus(lpszFileName, status))
      {
         CString strRoot;
         AfxGetRoot(lpszFileName, strRoot);

         DWORD dwSecPerClus, dwBytesPerSec, dwFreeClus, dwTotalClus;
         int nBytes = 0;
         if (GetDiskFreeSpace(strRoot, &amp;dwSecPerClus, &amp;dwBytesPerSec,
</PRE>&amp;dwFreeClus,
<PRE>            &amp;dwTotalClus))
         {
            nBytes = dwFreeClus*dwSecPerClus*dwBytesPerSec;
         }
         if (nBytes &gt; 2*status.m_size) // at least 2x free space avail
         {
            // get the directory for the file
            TCHAR szPath[_MAX_PATH];
            LPTSTR lpszName;
            GetFullPathName(lpszFileName, _MAX_PATH, szPath, &amp;lpszName);
            *lpszName = NULL;

            //let's create a temporary file name
            GetTempFileName(szPath, _T("MFC"), 0,
               m_strMirrorName.GetBuffer(_MAX_PATH+1));
            m_strMirrorName.ReleaseBuffer();
         }
      }
   }
</PRE>#endif
<P>
<PRE>   if (!m_strMirrorName.IsEmpty() &amp;&amp;
      CFile::Open(m_strMirrorName, nOpenFlags, pError))
   {
      m_strFileName = lpszFileName;
</PRE>#ifndef _MAC
<PRE>      FILETIME ftCreate, ftAccess, ftModify;
      if (::GetFileTime((HANDLE)m_hFile, &amp;ftCreate, &amp;ftAccess, &amp;ftModify))
      {
         AfxTimeToFileTime(status.m_ctime, &amp;ftCreate);
         SetFileTime((HANDLE)m_hFile, &amp;ftCreate, &amp;ftAccess, &amp;ftModify);
      }

        // If GetFileSecurity returns an error, don't do anything with
        // file securities.
      DWORD dwLength = 0;
      PSECURITY_DESCRIPTOR pSecurityDescriptor = NULL;
      if (GetFileSecurity(lpszFileName, DACL_SECURITY_INFORMATION,
         NULL, dwLength, &amp;dwLength))
        {
            pSecurityDescriptor = (PSECURITY_DESCRIPTOR) new
</PRE>BYTE[dwLength];
<PRE>          if (::GetFileSecurity(lpszFileName, DACL_SECURITY_INFORMATION,
             pSecurityDescriptor, dwLength, &amp;dwLength))
          {
             SetFileSecurity(m_strMirrorName, DACL_SECURITY_INFORMATION,
</PRE>pSecurityDescriptor);
<PRE>          }
          delete[] (BYTE*)pSecurityDescriptor;
        }
</PRE>#endif
<PRE>      return TRUE;
   }
   m_strMirrorName.Empty();
   return CFile::Open(lpszFileName, nOpenFlags, pError);
</PRE>}
<P>
*************
<P>
Then you need to override CDocument::GetFile() to return an object of your
new derived class.
<P>
Please note that the work around uses the undocumented class CMirrorFile.
The work around may have to be modified to work in a future version of MFC.
Refer to this article again in the future for any updates and modifications
that may be required for future versions.
<P>
<P><h2>STATUS</h2>
 
<P>
Microsoft has confirmed this to be a bug in the Microsoft products listed
at the beginning of this article. We are researching this bug and will post
new information here in the Microsoft Knowledge Base as it becomes
available.
<P>

	</FONT>
	</TD>
	</TR>
</TABLE>
<P>


<!--DOCBODY_END-->

<!--FOOTER_START-->
<table cellpadding=5 border=0 width="90%">
<tr>
<td>
	<HR WIDTH="90%">

<BLOCKQUOTE>
<FONT FACE="Verdana, Arial, Helvetica" SIZE="1">
<SPAN STYLE="font-family:verdana,arial,helvetica; font-size:8pt">
KBCategory: kbprg kbbuglist kbcode<BR>
KBSubcategory: MfcDocView vcbuglist400<BR>
Additional reference words: 4.00 4.10 4.20<BR>
Keywords            : MfcDocView vcbuglist400 kbbuglist kbcode kbprg<BR>
Technology          : kbMfc<BR>
Version             : 4.00 4.10 4.20<BR>
Platform            : NT WINDOWS<BR>

</SPAN>
</FONT>
<BR>
<BR>
THE INFORMATION PROVIDED IN THE MICROSOFT KNOWLEDGE BASE IS
PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND.  MICROSOFT DISCLAIMS
ALL WARRANTIES, EITHER EXPRESS OR IMPLIED, INCLUDING THE WARRANTIES
OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  IN NO
EVENT SHALL MICROSOFT CORPORATION OR ITS SUPPLIERS BE LIABLE FOR
ANY DAMAGES WHATSOEVER INCLUDING DIRECT, INDIRECT, INCIDENTAL,
CONSEQUENTIAL, LOSS OF BUSINESS PROFITS OR SPECIAL DAMAGES, EVEN IF
MICROSOFT CORPORATION OR ITS SUPPLIERS HAVE BEEN ADVISED OF THE
POSSIBILITY OF SUCH DAMAGES.  SOME STATES DO NOT ALLOW THE EXCLUSION
OR LIMITATION OF LIABILITY FOR CONSEQUENTIAL OR INCIDENTAL DAMAGES
SO THE FOREGOING LIMITATION MAY NOT APPLY.
</BLOCKQUOTE>
<P>
<center>
	<FONT FACE="Verdana,Arial,Helvetica" SIZE="1">
	Last reviewed:  July 2, 1997</FONT>
	<BR>
	<A href="../cpyright.htm" STYLE="font: bold 7pt Verdana,Arial,Helvetica">&copy; 1998 Microsoft Corporation. All rights reserved. Terms of Use.</A><BR>
	
</center>
</td>
</tr>
</table>

<!--FOOTER_END-->
</FONT>
</BODY>
</HTML>
