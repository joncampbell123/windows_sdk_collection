

<HTML>
<HEAD>
<TITLE>HOWTO: Change the Mouse Pointer for a Window in MFC </TITLE>

<!--STYLE_BEGIN-->
<style>@import url(../../msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="../../msdn_ie3.css">
<!--STYLE_END-->

<META HTTP-EQUIV="CONTENT-Type" CONTENT="text/html; charset=us-ascii">
<META NAME="ms.locale" CONTENT="EN-US">
<META NAME="Category" CONTENT="Support; KB Article">
<META NAME="KBID" CONTENT="Q131991">
<META NAME="KBModify" CONTENT="1997/07/10">
<META NAME="KBCreate" CONTENT="1995/06/26">
<META NAME="Keywords" CONTENT="kbprg kbui MfcUI kbhowto">
<META NAME="KBArea" CONTENT="Support; KB; visualc">
<META NAME="Description" CONTENT="  In a Windows-based application, a window is always created based on a window class. The window class identifies several characteristics of the windows based on it, including the default mouse pointer (cursor). In some cases, an application may want...">
<META NAME="Product" CONTENT="Visual C++">
<META NAME="Platform" CONTENT="Windows">
<META NAME="Technology" CONTENT=" ">
<META NAME="Premium" CONTENT="support">

<META NAME="nyms" CONTENT="QAO2,QAO3,QAGI,QAUD,QAY5,QAPN,QABA,QAEV,QAGQ,QABO,QAIF,QDL9,QBWQ,QBWO,QBWN V02180118">
</HEAD>

<BODY BGCOLOR="#FFFFFF" LEFTMARGIN="0" RIGHTMARGIN="0" TOPMARGIN="0">


<!--DOCBODY_START-->
<BR>
<CENTER>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" VALIGN="top" WIDTH="90%">
	<TR>
		<TD VALIGN="top">
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<H1>HOWTO: Change the Mouse Pointer for a Window in MFC</H1>
			</FONT>
			<FONT FACE="verdana,arial,helvetica" SIZE="1">
			Last reviewed:  July 10, 1997</FONT><BR>
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<B>Article ID: Q131991</B>
			</FONT>
		</TD>
	</TR>
	<TR>
	<TD>
	<FONT FACE="Verdana, Arial, Helvetica" SIZE=2>



 
 
The information in this article applies to:

<UL><LI>The Microsoft Foundation Classes (MFC) included with:
<P>
<P><PRE>    - Microsoft Visual C++ for Windows, versions 1.5, 1.51, 1.52
    - Microsoft Visual C++, 32-bit Edition, versions 1.0, 2.0, 2.1,
      4.0, 5.0
</UL></PRE> 
<P>
<P><h2>SUMMARY</h2>
 
<P>
In a Windows-based application, a window is always created based on a
window class. The window class identifies several characteristics of the
windows based on it, including the default mouse pointer (cursor). In some
cases, an application may want to change the pointer associated with
certain windows that it creates. This article describes three methods an
MFC application can use to display different pointers at different times.
<P>
<P><h2>MORE INFORMATION</h2>
 
<P>
Here are some situations when you might want an MFC application to display
different pointers at different times:

<UL><LI>When the default pointer isn't a good user-interface object for a
   particular application. For example, an I-beam pointer is more suitable
   than the arrow for a text editor window in NotePad. This could involve
   changing the pointer for the entire run of the application.

<LI>When an application performs a lengthy operation, such as disk I/O, an
   hourglass pointer is more appropriate than the arrow. By changing the
   pointer to an hourglass, you provide good visual feedback to the user.
   This could involve changing the pointer for a limited period of time.
<P>
</UL><h3>Three Methods</h3>
 
<P>
Here are three ways an application can change the mouse pointer in a
window:

<UL><LI>Override the CWnd::OnSetCursor() function. Call Windows API SetCursor()
   function to change the pointer.

<LI>Register your own window class with the desired mouse pointer, override
   the CWnd::PreCreateWindow() function, and use the newly-registered
   window class to create the window.

<LI>To show the standard hourglass pointer, an application can call the
   CCmdTarget::BeginWaitCursor(), which displays the hourglass, and call
   CmdTarget::EndWaitCursor() to revert back to the default pointer. This
   scheme works only for the duration of a single message. If the mouse is
   moved before a call to EndWaitCursor is made, Windows sends a
   WM_SETCURSOR message to the window underneath the pointer. The default
   handling of this message resets the pointer to the default type, the one
   registered with the class, so you need to override CWnd::OnSetCursor()
   for that window, and reset the pointer back to the hourglass.
<P>
</UL><h3>Code to Illustrate the Three Methods</h3>
 
<P>
The following code shows by example how to change the mouse pointer of a
CView derived class window by using the three methods. m_ChangeCursor is a
member variable of CMyView class and is of type BOOL. It indicates whether
a different pointer type needs to be displayed.
<P>
<P><h3>Method One</h3>
 
<P>
Change the mouse pointer for the CMyView object by overriding
CWnd::OnSetCursor() function. Use ClassWizard to establish the message
map function CMyView::OnSetCursor() for Windows message WM_SETCURSOR
and supply the body of the function as follows:
<P>
<PRE>      BOOL CMyView::OnSetCursor(CWnd* pWnd, UINT nHitTest, UINT message)
      {
            if ( m_ChangeCursor )
              {
                  ::SetCursor(AfxGetApp()-&gt;LoadStandardCursor(IDC_WAIT));
                  return TRUE;
              }

            return CView::OnSetCursor(pWnd, nHitTest, message);
      }

</PRE><h3>Method Two</h3>
 
<P>
Register your own window class containing the desired mouse pointer using
either the AfxRegisterClass() or AfxRegisterWndClass() function. Then
create the view window based on the registered window class. For more
information on registering window classes in MFC, please see MFC Tech Note
1, "Window Class Registration."
<P>
<PRE>      BOOL CMyView::PreCreateWindow(CREATESTRUCT&amp; cs)
      {
          cs.lpszClass = AfxRegisterWndClass(
            CS_DBLCLKS | CS_HREDRAW | CS_VREDRAW, // use any window styles
            AfxGetApp()-&gt;LoadStandardCursor(IDC_WAIT),
            (HBRUSH) (COLOR_WINDOW + 1));         // background brush

          return CView::PreCreateWindow(cs)
      }

</PRE><h3>Method Three</h3>
 
<P>
Call the BeginWaitCursor() and EndWaitCursor() functions to change the
mouse pointer.
<P>
NOTE: CWinApp::DoWaitCursor(1) and CWinApp::DoWaitCursor(-1) work
similarly to BeginWaitCursor() and EndWaitCursor(), respectively.
<P>
<PRE>      void CMyView::PerformLengthyOperation()
      {
            BeginWaitCursor();  // or AfxGetApp()-&gt;DoWaitCursor(1)

            //...

            EndWaitCursor();    // or AfxGetApp()-&gt;DoWaitCursor(-1)
      }

   NOTE: If calls to BeginWaitCursor() and EndWaitCursor() are not in the
   same handler, you must override OnSetCursor as follows:

      BOOL CMyView::OnSetCursor(CWnd* pWnd, UINT nHitTest, UINT message)
      {
            if (m_ChangeCursor)
              {
                  RestoreWaitCursor();
                  return TRUE;
              }

            return CView::OnSetCursor(pWnd, nHitTest, message);
      }

</PRE>In this example, set m_ChangeCursor to TRUE just before the call to
BeginWaitCursor(), and set it back to FALSE after the call to
EndWaitCursor().
 

	</FONT>
	</TD>
	</TR>
</TABLE>
<P>


<!--DOCBODY_END-->

<!--FOOTER_START-->
<table cellpadding=5 border=0 width="90%">
<tr>
<td>
	<HR WIDTH="90%">

<BLOCKQUOTE>
<FONT FACE="Verdana, Arial, Helvetica" SIZE="1">
<SPAN STYLE="font-family:verdana,arial,helvetica; font-size:8pt">
Keywords            : kbprg kbui MfcUI kbhowto<BR>
Technology          : kbMfc<BR>
Version             : 1.51 1.52 1.0 2.0 2.1 4.0 5.0<BR>
Platform            : NT WINDOWS<BR>
Issue type          : kbhowto<BR>

</SPAN>
</FONT>
<BR>
<BR>
THE INFORMATION PROVIDED IN THE MICROSOFT KNOWLEDGE BASE IS
PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND.  MICROSOFT DISCLAIMS
ALL WARRANTIES, EITHER EXPRESS OR IMPLIED, INCLUDING THE WARRANTIES
OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  IN NO
EVENT SHALL MICROSOFT CORPORATION OR ITS SUPPLIERS BE LIABLE FOR
ANY DAMAGES WHATSOEVER INCLUDING DIRECT, INDIRECT, INCIDENTAL,
CONSEQUENTIAL, LOSS OF BUSINESS PROFITS OR SPECIAL DAMAGES, EVEN IF
MICROSOFT CORPORATION OR ITS SUPPLIERS HAVE BEEN ADVISED OF THE
POSSIBILITY OF SUCH DAMAGES.  SOME STATES DO NOT ALLOW THE EXCLUSION
OR LIMITATION OF LIABILITY FOR CONSEQUENTIAL OR INCIDENTAL DAMAGES
SO THE FOREGOING LIMITATION MAY NOT APPLY.
</BLOCKQUOTE>
<P>
<center>
	<FONT FACE="Verdana,Arial,Helvetica" SIZE="1">
	Last reviewed:  July 10, 1997</FONT>
	<BR>
	<A href="../cpyright.htm" STYLE="font: bold 7pt Verdana,Arial,Helvetica">&copy; 1998 Microsoft Corporation. All rights reserved. Terms of Use.</A><BR>
	
</center>
</td>
</tr>
</table>

<!--FOOTER_END-->
</FONT>
</BODY>
</HTML>
