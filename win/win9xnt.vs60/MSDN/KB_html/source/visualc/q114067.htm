

<HTML>
<HEAD>
<TITLE>FIX: C1001: code.c:1.25, Line 534 </TITLE>

<!--STYLE_BEGIN-->
<style>@import url(../../msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="../../msdn_ie3.css">
<!--STYLE_END-->

<META HTTP-EQUIV="CONTENT-Type" CONTENT="text/html; charset=us-ascii">
<META NAME="ms.locale" CONTENT="EN-US">
<META NAME="Category" CONTENT="Support; KB Article">
<META NAME="KBID" CONTENT="Q114067">
<META NAME="KBModify" CONTENT="1997/09/18">
<META NAME="KBCreate" CONTENT="1994/04/24">
<META NAME="Keywords" CONTENT="CLIss kb16bitonly kbbuglist kbfixlist kbtool">
<META NAME="KBArea" CONTENT="Support; KB; visualc">
<META NAME="Description" CONTENT="   Compiling the sample code shown below with any of the /Oc, /Oe, /Og, /Oi, or /Ol switches will cause version 8.0 of the compiler to generate the following error message:      fatal error C1001: INTERNAL COMPILER ERROR     (compiler file '@(#)code....">
<META NAME="Product" CONTENT="Visual C++">
<META NAME="Platform" CONTENT="Windows">
<META NAME="Technology" CONTENT=" ">
<META NAME="Premium" CONTENT="support">

<META NAME="nyms" CONTENT="QAH4,QAB4,QBFY,QAOT,QAAP,QAHE,QA4Q,QAR4,QAKR,QAKP,QBXT,QBVV,QA5V,QAM1,QAIB V02180118">
</HEAD>

<BODY BGCOLOR="#FFFFFF" LEFTMARGIN="0" RIGHTMARGIN="0" TOPMARGIN="0">


<!--DOCBODY_START-->
<BR>
<CENTER>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" VALIGN="top" WIDTH="90%">
	<TR>
		<TD VALIGN="top">
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<H1>FIX: C1001: code.c:1.25, Line 534</H1>
			</FONT>
			<FONT FACE="verdana,arial,helvetica" SIZE="1">
			Last reviewed:  September 18, 1997</FONT><BR>
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<B>Article ID: Q114067</B>
			</FONT>
		</TD>
	</TR>
	<TR>
	<TD>
	<FONT FACE="Verdana, Arial, Helvetica" SIZE=2>



 
7.00   | 1.00
MS-DOS | WINDOWS
kbtool kbfixlist kbbuglist
<P>
 
The information in this article applies to:

<UL><LI>The Microsoft C/C++ Compiler (CL.EXE), included with:
<P>
<P><PRE>    - Microsoft C/C++ for MS-DOS, version 7.0
    - Microsoft Visual C++ for Windows, version 1.0
</UL></PRE> 
<P>
<P>
<P><h2>SYMPTOMS</h2>
 
<P>
Compiling the sample code shown below with any of the /Oc, /Oe, /Og, /Oi,
or /Ol switches will cause version 8.0 of the compiler to generate the
following error message:
<P>
<PRE>    fatal error C1001: INTERNAL COMPILER ERROR
    (compiler file '@(#)code.c:1.25', line 534)
    Contact Microsoft Product Support Services

</PRE>The same code and compiler options will cause version 7.0 of the compiler
to generate the following error message:
<P>
<PRE>    fatal error C1001: INTERNAL COMPILER ERROR
    (compiler file '@(#)code.c:1.25', line 473)
    Contact Microsoft Product Support Services

</PRE>When compiling the sample code shown below both versions of the compiler
will also generate a C4124 warning stating that __fastcall with stack
checking is inefficient. However, compiling the sample code with the /Gs
switch to turn off stack checking does not avoid the C1001 error.
<P>
<P><h2>RESOLUTION</h2>
 
<P>
To avoid the C1001 error, do one or more of the following:
<P>
<PRE>    Do not compile with any of the /Oc, /Oe, /Og, /Oi, or /Ol
    switches.

    - or -

    Use the #pragma optimize directive to disable the optimizations
    listed above.

    - or -

    Restructure the code so that the problem does not occur. The
    piece of sample code show below is rather large because
    simplifying it at all causes the C1001 error to not occur.

    - or -

    Upgrade to Visual C++ for Windows version 1.5 since the problem
    has been fixed in that version.

</PRE><h2>STATUS</h2>
 
<P>
Microsoft has confirmed this to be a problem in the Microsoft products
listed above. This problem was corrected with Visual C++ version 1.0.
<P>
<P><h3>Sample Code</h3>
 
<P>
<PRE>/* Compile options needed:  /c and one or more of /Oc, /Oe, /Og, /Oi
</PRE>*  or -Ol
<PRE>*/

</PRE>typedef unsigned char U8;
<P>
typedef unsigned short U16;
typedef U16 __far* LPU16;
typedef U16 CTBYTE;
typedef U16 CTPARA;
typedef CTPARA __far* LPCTPARA;
typedef U16 DBHHANDLE;
typedef DBHHANDLE __far* LPDBHHANDLE;
typedef U16 RELSEG;
<P>
typedef unsigned int MASK;
<P>
typedef unsigned long U32;
typedef void __near* NPVOID;
typedef void __far* LPVOID;
<P>
typedef struct tagDBHEAPINFOSTRUCT
{
<PRE>    CTPARA ctparaTotal;
    CTPARA ctparaAvailTotal;
    CTPARA ctparaAvailBiggest;
    CTPARA ctparaAvailBiggestIfCompacted;
    CTPARA ctparaAvailBiggestFixed;
    CTPARA ctparaAvailBiggestFixedIfComp;
    U16 ctNodesUsed;
    U16 ctNodesFree;
</PRE>} DBHEAPINFOSTRUCT;
<P>
typedef DBHEAPINFOSTRUCT __far* LPDBHEAPINFOSTRUCT;
<P>
typedef struct tagDBNODEINFOSTRUCT
{
<PRE>    CTPARA ctparaUsed;
    CTPARA ctparaFree;
    RELSEG relsegNext;
    RELSEG relsegPrev;
    int fLocked;
</PRE>} DBNODEINFOSTRUCT;
<P>
typedef DBNODEINFOSTRUCT __far* LPDBNODEINFOSTRUCT;
<P>
typedef struct tagDLHEAPINFOSTRUCT
{
<PRE>    CTBYTE ctbyteTotal;
    CTBYTE ctbyteAvailTotal;
    CTBYTE ctbyteAvailBiggest;
    U16 ctNodesUsed;
    U16 ctNodesFree;
</PRE>} DLHEAPINFOSTRUCT;
<P>
typedef DLHEAPINFOSTRUCT __far* LPDLHEAPINFOSTRUCT;
<P>
typedef struct tagDLNODEINFOSTRUCT
{
<PRE>    CTBYTE ctbyteSize;
    CTBYTE ctbyteNext;
    int fFree;
</PRE>} DLNODEINFOSTRUCT;
<P>
typedef DLNODEINFOSTRUCT __far* LPDLNODEINFOSTRUCT;
<P>
__segment __fastcall DBHInit ( CTPARA, MASK, U16, LPCTPARA);
<PRE>void __fastcall DBHQueryHeap ( __segment, LPDBHEAPINFOSTRUCT);
void __fastcall DBHCompact ( __segment);
void __fastcall DBHTerminate ( __segment);

</PRE>DBHHANDLE __fastcall DBHAlloc ( __segment, CTPARA, MASK);
DBHHANDLE __fastcall DBHRealloc ( __segment, DBHHANDLE, CTPARA, MASK);
<PRE>int __fastcall DBHQueryNode(__segment, DBHHANDLE, LPDBNODEINFOSTRUCT);
</PRE>DBHHANDLE __fastcall DBHFree ( __segment, DBHHANDLE);
<P>
__segment __fastcall DBHLockGetSeg ( DBHHANDLE);
LPVOID __fastcall DBHLockGetLP ( DBHHANDLE);
DBHHANDLE __fastcall DBHUnlock ( DBHHANDLE);
<P>
<PRE>int __fastcall DLHInit ( DBHHANDLE, CTBYTE);
int __fastcall DLHQueryHeap ( DBHHANDLE, LPDLHEAPINFOSTRUCT);

</PRE>NPVOID __fastcall DLHAlloc ( DBHHANDLE, CTBYTE);
NPVOID __fastcall DLHRealloc ( DBHHANDLE, NPVOID, CTBYTE);
<PRE>int __fastcall DLHQueryNode ( NPVOID, LPDLNODEINFOSTRUCT);
void __fastcall DLHFree ( NPVOID);

</PRE>typedef struct tagARENAHDR
{
<PRE>    U8 rgbyStamp[2];
    MASK flags;
    U16 special;
    U16 ctLock;
    RELSEG relsegNext;
    RELSEG relsegPrev;
    CTPARA ctparaData;
    DBHHANDLE dbhHandle;
</PRE>} ARENAHDR;
<P>
typedef ARENAHDR __far* LPARENAHDR;
<P>
typedef struct tagHeapSegDesc HEAPSEGDESC;
typedef HEAPSEGDESC __far* LPHEAPSEGDESC;
<P>
typedef struct tagHeapSegDesc
{
<PRE>    U16 checksum;
    U16 flags;
    U16 segsize;
    U16 start;
    U16 rover;
    U16 last;
    LPHEAPSEGDESC nextseg;
    LPHEAPSEGDESC prevseg;
</PRE>} HEAPSEGDESC;
<P>
__segment ArenaSegFromHandle(__segment dhseg, DBHHANDLE dbhhnd);
DBHHANDLE UnlinkHandle(__segment dhseg, DBHHANDLE dbhhnd);
<P>
DBHHANDLE __fastcall DBHFree(__segment dhseg, DBHHANDLE dbhhnd )
{
<PRE>    __segment seg0;
    ARENAHDR __based(seg0) *bp0 = 0;
    __segment seg1;
    ARENAHDR __based(seg1) *bp1 = 0;
    __segment seg2;
    ARENAHDR __based(seg2) *bp2 = 0;

    seg1 = ArenaSegFromHandle( dhseg, dbhhnd);
    seg0 = (seg1 - bp1-&gt;relsegPrev);
    seg2 = (seg1 + bp1-&gt;relsegNext);
    bp0-&gt;relsegNext = seg2 - seg0;
    bp2-&gt;relsegPrev = seg2 - seg0;
    return UnlinkHandle( dhseg, dbhhnd);
</PRE>}
<P>

	</FONT>
	</TD>
	</TR>
</TABLE>
<P>


<!--DOCBODY_END-->

<!--FOOTER_START-->
<table cellpadding=5 border=0 width="90%">
<tr>
<td>
	<HR WIDTH="90%">

<BLOCKQUOTE>
<FONT FACE="Verdana, Arial, Helvetica" SIZE="1">
<SPAN STYLE="font-family:verdana,arial,helvetica; font-size:8pt">
Additional reference words: ICE 8.00 1.00<BR>
KBCategory: kbtool kbfixlist kbbuglist<BR>
KBSubcategory: CLIss<BR>
Keywords          : CLIss kb16bitonly kbbuglist kbfixlist kbtool<BR>
Version           : 7.00   | 1.00<BR>
Platform          : MS-DOS WINDOWS<BR>
Solution Type     : kbfix<BR>

</SPAN>
</FONT>
<BR>
<BR>
THE INFORMATION PROVIDED IN THE MICROSOFT KNOWLEDGE BASE IS
PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND.  MICROSOFT DISCLAIMS
ALL WARRANTIES, EITHER EXPRESS OR IMPLIED, INCLUDING THE WARRANTIES
OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  IN NO
EVENT SHALL MICROSOFT CORPORATION OR ITS SUPPLIERS BE LIABLE FOR
ANY DAMAGES WHATSOEVER INCLUDING DIRECT, INDIRECT, INCIDENTAL,
CONSEQUENTIAL, LOSS OF BUSINESS PROFITS OR SPECIAL DAMAGES, EVEN IF
MICROSOFT CORPORATION OR ITS SUPPLIERS HAVE BEEN ADVISED OF THE
POSSIBILITY OF SUCH DAMAGES.  SOME STATES DO NOT ALLOW THE EXCLUSION
OR LIMITATION OF LIABILITY FOR CONSEQUENTIAL OR INCIDENTAL DAMAGES
SO THE FOREGOING LIMITATION MAY NOT APPLY.
</BLOCKQUOTE>
<P>
<center>
	<FONT FACE="Verdana,Arial,Helvetica" SIZE="1">
	Last reviewed:  September 18, 1997</FONT>
	<BR>
	<A href="../cpyright.htm" STYLE="font: bold 7pt Verdana,Arial,Helvetica">&copy; 1998 Microsoft Corporation. All rights reserved. Terms of Use.</A><BR>
	
</center>
</td>
</tr>
</table>

<!--FOOTER_END-->
</FONT>
</BODY>
</HTML>
