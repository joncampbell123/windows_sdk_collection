

<HTML>
<HEAD>
<TITLE>FIX: Errors Occur When SQL Server Binary Field Over 64K </TITLE>

<!--STYLE_BEGIN-->
<style>@import url(../../msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="../../msdn_ie3.css">
<!--STYLE_END-->

<META HTTP-EQUIV="CONTENT-Type" CONTENT="text/html; charset=us-ascii">
<META NAME="ms.locale" CONTENT="EN-US">
<META NAME="Category" CONTENT="Support; KB Article">
<META NAME="KBID" CONTENT="Q133311">
<META NAME="KBModify" CONTENT="1997/09/18">
<META NAME="KBCreate" CONTENT="1995/07/27">
<META NAME="Keywords" CONTENT="MfcDatabase kbbuglist kbcode kbfixlist kbprg">
<META NAME="KBArea" CONTENT="Support; KB; visualc">
<META NAME="Description" CONTENT="  When you try to store more than 64K of data in a binary field using the SQL Server ODBC 2.0 driver version 2.00.1912, data is truncated. The following error may also occur with the 16-bit version of the driver:     Incorrect syntax near 'NULLNULL'....">
<META NAME="Product" CONTENT="Visual C++">
<META NAME="Platform" CONTENT="Windows">
<META NAME="Technology" CONTENT=" ">
<META NAME="Premium" CONTENT="support">

<META NAME="nyms" CONTENT="QAH4,QAY5,QAGB,QAGC,QABI,QABM,QAGI,QAAP,QABH,QAU9,QAXB,QAKD,QBV8,QACI,QAB9 V02180118">
</HEAD>

<BODY BGCOLOR="#FFFFFF" LEFTMARGIN="0" RIGHTMARGIN="0" TOPMARGIN="0">


<!--DOCBODY_START-->
<BR>
<CENTER>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" VALIGN="top" WIDTH="90%">
	<TR>
		<TD VALIGN="top">
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<H1>FIX: Errors Occur When SQL Server Binary Field Over 64K</H1>
			</FONT>
			<FONT FACE="verdana,arial,helvetica" SIZE="1">
			Last reviewed:  September 18, 1997</FONT><BR>
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<B>Article ID: Q133311</B>
			</FONT>
		</TD>
	</TR>
	<TR>
	<TD>
	<FONT FACE="Verdana, Arial, Helvetica" SIZE=2>



 
1.52 1.52a 1.52b | 2.00 2.10 2.20
<PRE>WINDOWS          | WINDOWS NT
</PRE>kbprg kbbuglist kbfixlist kbcode
<P>
 
The information in this article applies to:

<UL><LI>The Microsoft Foundation Classes (MFC) included with:
<P>
<P><PRE>    - Microsoft Visual C++ for Windows, versions 1.52, 1.52a, 1.52b
    - Microsoft Visual C++, 32-bit Edition, versions 2.0, 2.1, 2.2
</UL></PRE> 
<P>
<P><h2>SYMPTOMS</h2>
 
<P>
When you try to store more than 64K of data in a binary field using the SQL
Server ODBC 2.0 driver version 2.00.1912, data is truncated. The following
error may also occur with the 16-bit version of the driver:
<P>
<PRE>   Incorrect syntax near 'NULLNULL'.
   State:37000[Microsoft][ODBC SQL Server Driver][SQL Server]

</PRE>Note: 32-bit applications using the SQL Server Driver delivered with
<PRE>      Visual C++ 4.x (version 2.50.0126) should not exhibit this behavior.

</PRE><h2>CAUSE</h2>
 
<P>
The SQL Server driver fails to handle calls to SQLSetParam() correctly.
<P>
Also, the data needs to be retrieved and sent in chunks less than 64K. The
existing implementation for the 32-bit database classes reads and writes
the data in one large chunk and encounters network errors with the SQL
Server ODBC driver when sending chunks of data larger than 64K.
<P>
<P><h2>RESOLUTION</h2>
 
<P>
The SQLSetParam() ODBC 1.0 function has been replaced by the ODBC 2.0
SQLBindParameter() function. The MFC database classes use SQLSetParam to
maintain compatibility with ODBC 1.0 drivers. If you are using the SQL
Server ODBC 2.0 driver, you can work around the SQLSetParam() bug by
calling SQLBindParameter() instead.
<P>
If you are in a 32-bit environment, you'll also need to override some
functions to read and write the binary data in chunks of less than 64K
bytes.
<P>
To fix the MFC Database classes, perform the following steps:

<OL><P><LI>Copy the RFX_LongBinary() function from \MSVC\MFC\SRC\DBRFX.CPP into
   your own .CPP file, and rename the function to something like
   RFX_LongBinary2().

<P><LI>Modify the RFX_LongBinary() function by replacing the call to
   SQLSetParam() with a call to SQLBindParameter(). You'll see a line of
   code such as this:
<P>
<P><PRE>      AFX_SQL_SYNC(::SQLSetParam(pFX-&gt;m_hstmt,
       (unsigned short int)pFX-&gt;m_nParamFields, SQL_C_DEFAULT,
       // Get actual SQL type - may differ from CType (e.g. DECIMAL)
       (short int)pFX-&gt;GetColumnType(nField), value.m_dwDataLength,
       0, &amp;value, plLength));
</PRE><P>
   Replace it with this code:
<P>
<P><PRE>      AFX_SQL_SYNC(::SQLBindParameter(pFX-&gt;m_hstmt,
       (unsigned short int)pFX-&gt;m_nParamFields,SQL_PARAM_INPUT,
       SQL_C_DEFAULT,
       // Get actual SQL type - may differ from CType (e.g. DECIMAL)
       (short int)pFX-&gt;GetColumnType(nField), value.m_dwDataLength,
       0, &amp;value, sizeof(value), plLength));
</PRE><P>
   Replace the following code in the CFieldExchange::Value case:
<P>
<P><PRE>      *plLength = SQL_DATA_AT_EXEC;
</PRE><P>
   with this code:
<P>
<P><PRE>      *plLength=SQL_LEN_DATA_AT_EXEC(((LONG)value.m_dwDataLength));
</PRE>
<P><LI>For the 32-bit database classes, add code to the RFX_LongBinary2()
   function to get the binary data in chunks. Again, use the the
   RFX_LongBinary2() function below.
<P>
   Replace this code:
<P>
<P><PRE>      AFX_SQL_ASYNC(pFX-&gt;m_prs, ::SQLGetData(pFX-&gt;m_prs-&gt;m_hstmt,
       (UWORD)nField,SQL_C_BINARY, (UCHAR*)lpLongBinary,
       *plLength, plLength));
</PRE><P>
   with this code:
<P>
<P><PRE>      do
      {
<PRE></PRE>         DWORD dwChunkSize = value.m_dwDataLength - dwDataLength;
         if (dwChunkSize &gt; 0x8000)
            dwChunkSize = 0x8000;

         // Ignore expected data truncated warnings
         AFX_SQL_ASYNC(pFX-&gt;m_prs, ::SQLGetData(pFX-&gt;m_prs-&gt;m_hstmt,
          (unsigned short int)nField, SQL_C_BINARY,
          (UCHAR FAR*)lpLongBinary, dwChunkSize, plLength));

         dwDataLength += dwChunkSize;
         lpLongBinary += dwChunkSize;

      } while (nRetCode == SQL_SUCCESS || nRetCode ==
         SQL_SUCCESS_WITH_INFO);

   And do the following:

   a. At the top of the RFX_LongBinary2() function, declare the DWORD
      variable dwDataLength and initialize it to zero:

      void AFXAPI RFX_LongBinary2(CFieldExchange* pFX,
       const char *szName, CLongBinary&amp; value)
      {
         DWORD dwDataLength = 0;     // Add this line!
      .
      .
      .

   b. Include &lt;limits.h&gt; in the .CPP file that contains RFX_LongBinary2.
      You need this because the RFX_LongBinary code that you copied over
      has a reference to the LONG_MAX constant.

   c. Add a global static char* called szComma, and initialize it to
      point to a string literal that contains a single comma:

      static char* szComma = ",";

      Do this because RFX_LongBinary() refers to this variable, which is
      in the file DBRFX.CPP. Because it is declared static in that file,
      it cannot be seen outside of it, so it must be supplied in the file
      that contains RFX_LongBinary2().

</PRE><P><LI>Change the call to RFX_LongBinary() in your CRecordset DoFieldExchange()
   function so that the new RFX_LongBinary2() function is called.

<P><LI>For the 32-bit database classes, copy the code for Update(),
   UpdateInsertDelete(), ExecuteUpdateSQL(), ExecuteSetPosUpdate(), and
   SendLongBinaryData() into your own CRecordset functions. You'll need to
   add code to the SendLongBinaryData() function. The only reason the other
   functions must be copied to your recordset is because the Update()
   function is virtual. By doing this, you make certain that the corrected
   SendLongBinaryData function is called.
<P>
   Replace the following code in SendLongBinaryData():
<P>
<P><PRE>      AFX_SQL_ASYNC(this, ::SQLPutData(hstmt, (PTR)lpData,
       pLongBinary-&gt;m_dwDataLength));
      ::GlobalUnlock(pLongBinary-&gt;m_hData);
</PRE><P>
<P><PRE>      if (!Check(nRetCode))
      {
<PRE></PRE>         // cache away error
         CDBException* pException = new CDBException(nRetCode);
         pException-&gt;BuildErrorString(m_pDatabase, hstmt);

         // then cancel Execute operation
         Cancel();
         THROW(pException);
      }

   with this code:

      DWORD dwDataLength = 0;
      while (dwDataLength != pLongBinary-&gt;m_dwDataLength)
      {
         DWORD dwSend = pLongBinary-&gt;m_dwDataLength-dwDataLength;
         if (dwSend &gt; 0x8000)
            dwSend = 0x8000;
         AFX_SQL_ASYNC(this, ::SQLPutData(m_hstmtUpdate,
          (PTR)lpData, dwSend));
         if (!Check(nRetCode))
         {
            ::GlobalUnlock(pLongBinary-&gt;m_hData);
            // Cache away error
            CDBException* pException = new CDBException(nRetCode);
            pException-&gt;BuildErrorString(m_pDatabase, m_hstmtUpdate);
            // Then cancel Execute operation
            Cancel();
            THROW(pException);
         }
         lpData += dwSend;
         dwDataLength += dwSend;
      }

</PRE></OL><h3>Correction for SendLongBinaryData() Code</h3>
 
<P>
BOOL CMyRecordset::Update()
{
<PRE>   // Insert the CRecordset::Update() code from MFC\SRC\DBCORE.CPP
</PRE>}
<P>
BOOL CMyRecordset::UpdateInsertDelete()
{
<PRE>   // Insert the CRecordset::UpdateInsertDelete() code
   // from MFC\SRC\DBCORE.CPP
</PRE>}
<P>
<PRE>void CMyRecordset::ExecuteUpdateSQL()
</PRE>{
<PRE>   // Insert the CRecordset::ExecuteUpdateSQL() code
   // from MFC\SRC\DBCORE.CPP
</PRE>}
<P>
<PRE>void CMyRecordset::ExecuteSetPosUpdate()
</PRE>{
<PRE>   // Insert the CRecordset::ExecuteSetPosUpdate() code
   // from MFC\SRC\DBCORE.CPP
</PRE>}
<P>
<PRE>void CMyRecordset::SendLongBinaryData(HSTMT hstmt)
</PRE>{
<PRE>   RETCODE nRetCode;
   void* pv;
   AFX_SQL_ASYNC(this, ::SQLParamData(hstmt, &amp;pv));
   if (!Check(nRetCode))
   {
      // cache away error
      CDBException* pException = new CDBException(nRetCode);
      pException-&gt;BuildErrorString(m_pDatabase, hstmt);

      // then cancel Execute operation
      Cancel();
      THROW(pException);
   }

   while (nRetCode == SQL_NEED_DATA)
   {
      CLongBinary* pLongBinary = (CLongBinary*)pv;
      ASSERT_VALID(pLongBinary);

      const BYTE* lpData =
       (const BYTE*)::GlobalLock(pLongBinary-&gt;m_hData);
      ASSERT(lpData != NULL);

      DWORD dwDataLength = 0;
      while (dwDataLength != pLongBinary-&gt;m_dwDataLength)
      {
         DWORD dwSend =
          pLongBinary-&gt;m_dwDataLength-dwDataLength;
         if (dwSend &gt; 0x8000)
            dwSend = 0x8000;
         AFX_SQL_ASYNC(this,
          ::SQLPutData(m_hstmtUpdate, (PTR)lpData, dwSend));
         if (!Check(nRetCode))
         {
            ::GlobalUnlock(pLongBinary-&gt;m_hData);
            // Cache away error
            CDBException* pException =
             new CDBException(nRetCode);
            pException-&gt;BuildErrorString(
             m_pDatabase, m_hstmtUpdate);
            // Then cancel Execute operation
            Cancel();
            THROW(pException);
         }
         lpData += dwSend;
         dwDataLength += dwSend;
      }

      // Check for another DATA_AT_EXEC
      AFX_SQL_ASYNC(this, ::SQLParamData(hstmt, &amp;pv));
      if (!Check(nRetCode))
      {
         TRACE0("Error: failure handling long binary"
                "value during update.\n");
         ThrowDBException(nRetCode, hstmt);
      }
   }
</PRE>}
<P>
<P><h2>STATUS</h2>
 
<P>
Microsoft has confirmed this to be a bug in the Microsoft products listed
at the beginning of this article. This problem has been corrected in the 32-
bit SQL Server driver that ships with Visual C++ 4.0 and 4.1 (driver
version 2.50.0126).
<P>
<P><h2>REFERENCES</h2>
 
<P>
For more information about the ODBC 2.0 SQL Server driver bug
(SQLSetParam() not working), please see the following article in the
Microsoft Knowledge Base:
<P>
<PRE>   ARTICLE-ID: <B><A href="../odbc/q125306.htm">Q125306</A></B>
   TITLE     : BUG: Cannot Insert BLOB Data Sized Between 64K and 128K
</PRE>

	</FONT>
	</TD>
	</TR>
</TABLE>
<P>


<!--DOCBODY_END-->

<!--FOOTER_START-->
<table cellpadding=5 border=0 width="90%">
<tr>
<td>
	<HR WIDTH="90%">

<BLOCKQUOTE>
<FONT FACE="Verdana, Arial, Helvetica" SIZE="1">
<SPAN STYLE="font-family:verdana,arial,helvetica; font-size:8pt">
Additional reference words: 2.00 2.10 2.20 2.5 2.51 2.52 2.52a 3.0 3.1 3.10<BR>
3.2 3.20<BR>
KBCategory: kbprg kbbuglist kbfixlist kbcode<BR>
KBSubcategory: MfcDatabase<BR>
Keywords          : MfcDatabase kbbuglist kbcode kbfixlist kbprg<BR>
Technology        : kbMfc<BR>
Version           : 1.52 1.52a 1.52b | 2.00 2.10 2.2<BR>
Platform          : NT WINDOWS<BR>
Solution Type     : kbfix<BR>

</SPAN>
</FONT>
<BR>
<BR>
THE INFORMATION PROVIDED IN THE MICROSOFT KNOWLEDGE BASE IS
PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND.  MICROSOFT DISCLAIMS
ALL WARRANTIES, EITHER EXPRESS OR IMPLIED, INCLUDING THE WARRANTIES
OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  IN NO
EVENT SHALL MICROSOFT CORPORATION OR ITS SUPPLIERS BE LIABLE FOR
ANY DAMAGES WHATSOEVER INCLUDING DIRECT, INDIRECT, INCIDENTAL,
CONSEQUENTIAL, LOSS OF BUSINESS PROFITS OR SPECIAL DAMAGES, EVEN IF
MICROSOFT CORPORATION OR ITS SUPPLIERS HAVE BEEN ADVISED OF THE
POSSIBILITY OF SUCH DAMAGES.  SOME STATES DO NOT ALLOW THE EXCLUSION
OR LIMITATION OF LIABILITY FOR CONSEQUENTIAL OR INCIDENTAL DAMAGES
SO THE FOREGOING LIMITATION MAY NOT APPLY.
</BLOCKQUOTE>
<P>
<center>
	<FONT FACE="Verdana,Arial,Helvetica" SIZE="1">
	Last reviewed:  September 18, 1997</FONT>
	<BR>
	<A href="../cpyright.htm" STYLE="font: bold 7pt Verdana,Arial,Helvetica">&copy; 1998 Microsoft Corporation. All rights reserved. Terms of Use.</A><BR>
	
</center>
</td>
</tr>
</table>

<!--FOOTER_END-->
</FONT>
</BODY>
</HTML>
