

<HTML>
<HEAD>
<TITLE>PRB: LoadLibrary &amp; FreeLibrary on MFC Regular DLL Leak Memory </TITLE>

<!--STYLE_BEGIN-->
<style>@import url(../../msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="../../msdn_ie3.css">
<!--STYLE_END-->

<META HTTP-EQUIV="CONTENT-Type" CONTENT="text/html; charset=us-ascii">
<META NAME="ms.locale" CONTENT="EN-US">
<META NAME="Category" CONTENT="Support; KB Article">
<META NAME="KBID" CONTENT="Q150392">
<META NAME="KBModify" CONTENT="1997/08/07">
<META NAME="KBCreate" CONTENT="1996/04/29">
<META NAME="Keywords" CONTENT="MfcDLL kbcode kbprb kbprg">
<META NAME="KBArea" CONTENT="Support; KB; visualc">
<META NAME="Description" CONTENT="  When calling LoadLibrary followed by FreeLibrary on an MFC regular DLL, and watching the memory allocations associated with the calling program, you see that four memory objects are not freed when the DLL is unloaded.  CAUSE =====  The memory alloc...">
<META NAME="Product" CONTENT="Visual C++">
<META NAME="Platform" CONTENT="Windows">
<META NAME="Technology" CONTENT=" ">
<META NAME="Premium" CONTENT="support">

<META NAME="nyms" CONTENT="QAGI,QAH4,QAW6,QAPN,QBVV,QBW6,QA7H,QANG,QBQU,QABA,QAY5,QAYL,QAUD,QATX,QAIF V02180118">
</HEAD>

<BODY BGCOLOR="#FFFFFF" LEFTMARGIN="0" RIGHTMARGIN="0" TOPMARGIN="0">


<!--DOCBODY_START-->
<BR>
<CENTER>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" VALIGN="top" WIDTH="90%">
	<TR>
		<TD VALIGN="top">
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<H1>PRB: LoadLibrary &amp; FreeLibrary on MFC Regular DLL Leak Memory</H1>
			</FONT>
			<FONT FACE="verdana,arial,helvetica" SIZE="1">
			Last reviewed:  August 7, 1997</FONT><BR>
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<B>Article ID: Q150392</B>
			</FONT>
		</TD>
	</TR>
	<TR>
	<TD>
	<FONT FACE="Verdana, Arial, Helvetica" SIZE=2>



 
4.00 4.10
WINDOWS NT
kbprg kbprb kbcode
<P>
 
The information in this article applies to:

<UL><LI>The Microsoft Foundation Classes (MFC) included with:
   Microsoft Visual C++, 32-bit Edition, versions 4.0 and 4.1
</UL> 
<P>
<P><h2>SYMPTOMS</h2>
 
<P>
When calling LoadLibrary followed by FreeLibrary on an MFC regular DLL, and
watching the memory allocations associated with the calling program, you
see that four memory objects are not freed when the DLL is unloaded.
<P>
<P><h2>CAUSE</h2>
 
<P>
The memory allocated for the m_pszExeName, m_pszAppName, m_pszHelpFilePath,
and m_pszProfileName members of the DLL's CWinApp-derived object is not
automatically released when the DLL unloads.
<P>
<P><h2>RESOLUTION</h2>
 
<P>
If you have not added references or changes to these variables in your
code, you can release the allocated memory manually by doing one of the
following two procedures:

<UL><LI>If no other global or static objects except the global CWinApp-derived
   object rely on the strings, free the memory for them in the destructor
   of the global CWinApp-derived object. For example:
<P>
   CDllAppObject::~CDllAppObject()
   {
<P><PRE>     if(m_pszExeName)
       m_pszExeName = GlobalFree(m_pszExeName);
</PRE><P>
<P><PRE>     if(m_pszAppName)
       m_pszAppName = GlobalFree(m_pszAppName);
</PRE><P>
<P><PRE>     if(m_pszHelpFilePath)
       m_pszHelpFilePath = GlobalFree(m_pszHelpFilePath);
</PRE><P>
<P><PRE>     if(m_pszProfileName)
       m_pszProfileName = GlobalFree(m_pszProfileName);
</PRE>   }
<P>
   -or-

<LI>If other global or static objects rely on these strings, then free the
   memory allocated for them in your own implementation of the RawDllMain
   function. The RawDllMain function is called by the C Runtime after all
   global or static objects have had their destructors called.
<P>
   NOTE: Due to the complexity of this procedure and the knowledge that
   MFC's RawDllMain implementation may change in future versions of MFC,
   this approach is not recommended unless absolutely necessary.
<P>
   To gain access to and be able to delete the strings in your version of
   RawDLLMai, you must declare four global variables and initialize them in
   the DLL's CWinApp-derived object's InitInstance. For example:
<P>
<P><PRE>      LPCTSTR g_pszExeName = NULL;
      LPCTSTR g_pszAppName = NULL;
      LPCTSTR g_pszHelpFilePath = NULL;
      LPCTSTR g_pszProfileName = NULL;
</PRE><P>
<P><PRE>      BOOL CHeapDllApp::InitInstance()
      {
<PRE></PRE>        if(CWinApp::InitInstance())
        {
          g_pszExeName = m_pszExeName;
          g_pszAppName = m_pszAppName;
          g_pszHelpFilePath = m_pszHelpFilePath;
          g_pszProfileName = m_pszProfileName;

          return TRUE;
        }
        else
          return FALSE;
      }

   Then, in your version of RawDllMain, call GlobalFree on the global
   pointers when the reason for calling is DLL_PROCESS_DETACH. For example:

      extern LPCTSTR g_pszExeName;
      extern LPCTSTR g_pszAppName;
      extern LPCTSTR g_pszHelpFilePath;
      extern LPCTSTR g_pszProfileName;

      extern "C"
      BOOL WINAPI RawDllMain(HINSTANCE, DWORD dwReason, LPVOID)
      {
        if (dwReason == DLL_PROCESS_ATTACH)
        {
          // ... Code abbreviated from DLLMODUL.CPP
        }
        else if (dwReason == DLL_PROCESS_DETACH)
        {
          // restore module state after cleanup
          AFX_MODULE_STATE* pModuleState = AfxGetStaticModuleState();
          _AFX_THREAD_STATE* pState = AfxGetThreadState();
          VERIFY(AfxSetModuleState(pState-&gt;m_pPrevModuleState) ==
            pModuleState);
          DEBUG_ONLY(pState-&gt;m_pPrevModuleState = NULL);

          #ifndef _AFXDLL
            AfxCriticalTerm();
          #endif

          // NEW CODE ADDED HERE
          // -------------------

          if(g_pszExeName)
            GlobalFree((HGLOBAL)g_pszExeName);

          if(g_pszAppName)
            GlobalFree((HGLOBAL)g_pszAppName);

          if(g_pszHelpFilePath)
            GlobalFree((HGLOBAL)g_pszHelpFilePath);

          if(g_pszProfileName)
            GlobalFree((HGLOBAL)g_pszProfileName);
        }

        return TRUE;
      }

</PRE></UL>If you have added references or modified the contents of these pointer
variables, you need to free them in a manner appropriate to your usage. If
you used the second procedure and changed the location that one of these
variables points to after saving the address in InitInstance, the code
added to RawDllMain frees the old (wrong) contents of memory and not the
new contents that you allocated. When using the first procedure, make sure
you free the old contents pointed to by the particular variable as well as
any strings you have allocated yourself.
<P>
<P><h2>STATUS</h2>
 
<P>
This behavior is by design.
<P>
<P><h2>MORE INFORMATION</h2>
 
<P>
The m_pszExeName, m_pszAppName, m_pszHelpFilePath, and m_pszProfileName
members of CWinApp are allocated in the CWinApp::SetCurrentHandles function
(APPINIT.CPP line 107 in version 4.1). SetCurrentHandles is called during
the initialization of a Regular DLL by default.
<P>
The MFC source code in SetCurrentHandles says the following regarding the
memory allocations for these CWinApp strings and why the memory is not
automatically released:
<P>
NOTE: there are a number of _tcsdup (aka strdup) calls that are made here
for the exe path, help file path, and so on. This memory is not freed and
will be reported by various memory diagnostic utilities. This is not a bug.
These strings cannot be freed because they may be set by the application to
anything, even something that is not on the heap. Furthermore, they may be
accessed at any time, including during destructor calls. Because the order
of destructor calls with respect to the CWinApp object and any other
objects in the program is not deterministic, the CWinApp object cannot free
this memory.
<P>
<P><h2>REFERENCES</h2>
 
<P>
For additional information, please see the following article in the
Microsoft Knowledge Base:
<P>
<PRE>   ARTICLE-ID: <B><A href="../visualc/q148791.htm">Q148791</A></B>
   TITLE     : How to Provide Your Own DllMain in an MFC Regular DLL

</PRE>It describes how to provide your own DllMain function and applies to
replacing the RawDllMain function found in Dllmodul.cpp.
<P>

	</FONT>
	</TD>
	</TR>
</TABLE>
<P>


<!--DOCBODY_END-->

<!--FOOTER_START-->
<table cellpadding=5 border=0 width="90%">
<tr>
<td>
	<HR WIDTH="90%">

<BLOCKQUOTE>
<FONT FACE="Verdana, Arial, Helvetica" SIZE="1">
<SPAN STYLE="font-family:verdana,arial,helvetica; font-size:8pt">
Additional reference words: 4.00 4.10<BR>
KBCategory: kbprg kbprb kbcode<BR>
KBSubcategory: MfcDLL<BR>
Keywords          : MfcDLL kbcode kbprb kbprg<BR>
Technology        : kbMfc<BR>
Version           : 4.00 4.10<BR>
Platform          : NT WINDOWS<BR>

</SPAN>
</FONT>
<BR>
<BR>
THE INFORMATION PROVIDED IN THE MICROSOFT KNOWLEDGE BASE IS
PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND.  MICROSOFT DISCLAIMS
ALL WARRANTIES, EITHER EXPRESS OR IMPLIED, INCLUDING THE WARRANTIES
OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  IN NO
EVENT SHALL MICROSOFT CORPORATION OR ITS SUPPLIERS BE LIABLE FOR
ANY DAMAGES WHATSOEVER INCLUDING DIRECT, INDIRECT, INCIDENTAL,
CONSEQUENTIAL, LOSS OF BUSINESS PROFITS OR SPECIAL DAMAGES, EVEN IF
MICROSOFT CORPORATION OR ITS SUPPLIERS HAVE BEEN ADVISED OF THE
POSSIBILITY OF SUCH DAMAGES.  SOME STATES DO NOT ALLOW THE EXCLUSION
OR LIMITATION OF LIABILITY FOR CONSEQUENTIAL OR INCIDENTAL DAMAGES
SO THE FOREGOING LIMITATION MAY NOT APPLY.
</BLOCKQUOTE>
<P>
<center>
	<FONT FACE="Verdana,Arial,Helvetica" SIZE="1">
	Last reviewed:  August 7, 1997</FONT>
	<BR>
	<A href="../cpyright.htm" STYLE="font: bold 7pt Verdana,Arial,Helvetica">&copy; 1998 Microsoft Corporation. All rights reserved. Terms of Use.</A><BR>
	
</center>
</td>
</tr>
</table>

<!--FOOTER_END-->
</FONT>
</BODY>
</HTML>
