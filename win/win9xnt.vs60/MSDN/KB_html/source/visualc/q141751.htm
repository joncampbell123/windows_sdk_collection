

<HTML>
<HEAD>
<TITLE>SAMPLE: Adding Control Bars to Dialog Boxes in MFC </TITLE>

<!--STYLE_BEGIN-->
<style>@import url(../../msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="../../msdn_ie3.css">
<!--STYLE_END-->

<META HTTP-EQUIV="CONTENT-Type" CONTENT="text/html; charset=us-ascii">
<META NAME="ms.locale" CONTENT="EN-US">
<META NAME="Category" CONTENT="Support; KB Article">
<META NAME="KBID" CONTENT="Q141751">
<META NAME="KBModify" CONTENT="1997/07/07">
<META NAME="KBCreate" CONTENT="1995/12/24">
<META NAME="Keywords" CONTENT="CDialog CStatusBar CToolBar DLGCGR kbprg kbsample MfcUI">
<META NAME="KBArea" CONTENT="Support; KB; visualc">
<META NAME="Description" CONTENT=" This is the 32-bit version of this sample.   In a Microsoft Foundation Classes (MFC) application, you can attach control bars such as status bars and toolbars to a frame window. However, for many applications a simple dialog box-based user interface...">
<META NAME="Product" CONTENT="Visual C++">
<META NAME="Platform" CONTENT="Windows">
<META NAME="Technology" CONTENT=" ">
<META NAME="Premium" CONTENT="support">

<META NAME="nyms" CONTENT="QAB5,QA7O,QA01,QAOE,QAMN,QBTL,QAH6,QAH7,QAD7,QANX,QAEV,QANS,QAIB,QAIA,QAHV V02180118">
</HEAD>

<BODY BGCOLOR="#FFFFFF" LEFTMARGIN="0" RIGHTMARGIN="0" TOPMARGIN="0">


<!--DOCBODY_START-->
<BR>
<CENTER>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" VALIGN="top" WIDTH="90%">
	<TR>
		<TD VALIGN="top">
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<H1>SAMPLE: Adding Control Bars to Dialog Boxes in MFC</H1>
			</FONT>
			<FONT FACE="verdana,arial,helvetica" SIZE="1">
			Last reviewed:  July 7, 1997</FONT><BR>
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<B>Article ID: Q141751</B>
			</FONT>
		</TD>
	</TR>
	<TR>
	<TD>
	<FONT FACE="Verdana, Arial, Helvetica" SIZE=2>



 
 
The information in this article applies to:

<UL><LI>The Microsoft Foundation Classes (MFC) included with:
   - Microsoft Visual C++, 32-bit Edition, versions 4.0 4.1, 4.2, 5.0
</UL> 
<P>
This is the 32-bit version of this sample.
<P>
<P><h2>SUMMARY</h2>
 
<P>
In a Microsoft Foundation Classes (MFC) application, you can attach
control bars such as status bars and toolbars to a frame window. However,
for many applications a simple dialog box-based user interface is
sufficient. MFC does not provide built-in support for adding control bars
to dialog boxes.
<P>
DLGCBR32 is a sample application that demonstrates how to add a status
bar and toolbar to a dialog box. In addition, it demonstrates a number of
techniques related to using a modeless dialog box as the main window of an
MFC application.
<P>
The following file is available for download from the Microsoft Software
Library:
<P>
<PRE> ~ <A href="http://support.microsoft.com/download/support/mslfiles/dlgcbr32.exe">Dlgcbr32.exe</A> <I>(size: 72094 bytes)</I> 

</PRE>For more information about downloading files from the Microsoft Software
Library, please see the following article in the Microsoft Knowledge Base:
<P>
<PRE>   ARTICLE-ID: <B><A href="../zmiscellaneous/q119591.htm">Q119591</A></B>
   TITLE     : How to Obtain Microsoft Support Files from Online Services


</PRE><h2>MORE INFORMATION</h2>
 
<P>
To add a control bar to a dialog box, you must create the control bar as
usual, and then make room for the control bar within the client area of
the dialog box. For the control bar to function properly, the dialog box
must duplicate some of the functionality of frame windows. If you want
ON_UPDATE_COMMAND_UI handlers to work for the control bars, you also need
to derive new control bar classes, and handle the WM_IDLEUPDATECMDUI
message. If your dialog box is not the main window of your application,
you will also need to modify its parent frame window to pass the
WM_IDLEUPDATECMDUI message on to the dialog box's control bars.
<P>
To make room for a control bar within the client area of the dialog box,
follow these steps in your dialog box's OnInitDialog() function:

<OL><P><LI>Create the control bars.

<P><LI>Figure out how much room the control bars will take by using the
   reposQuery option of RepositionBars():
<P>
<P><PRE>      CRect rcClientStart;
      CRect rcClientNow;
      GetClientRect(rcClientStart);
      RepositionBars(AFX_IDW_CONTROLBAR_FIRST,
<PRE></PRE>                     AFX_IDW_CONTROLBAR_LAST,
                     0, reposQuery, rcClientNow);

</PRE><P><LI>Move all the controls in your dialog box to account for space used by
   control bars at the top or left of the client area. If your dialog box
   contains a menu, you also need to account for the space used by the
   menu:
<P>
<P><PRE>      CPoint ptOffset(rcClientNow.left - rcClientStart.left,
<PRE></PRE>                       rcClientNow.top - rcClientStart.top);

      CRect  rcChild;
      CWnd* pwndChild = GetWindow(GW_CHILD);
      while (pwndChild)
      {
         pwndChild-&gt;GetWindowRect(rcChild);
         ScreenToClient(rcChild);
         rcChild.OffsetRect(ptOffset);
         pwndChild-&gt;MoveWindow(rcChild, FALSE);
         pwndChild = pwndChild-&gt;GetNextWindow();
      }

</PRE><P><LI>Increase the dialog box window dimensions by the amount of space used
   by the control bars:
<P>
<P><PRE>      CRect rcWindow;
      GetWindowRect(rcWindow);
      rcWindow.right += rcClientStart.Width() - rcClientNow.Width();
      rcWindow.bottom += rcClientStart.Height() - rcClientNow.Height();
      MoveWindow(rcWindow, FALSE);
</PRE>
<P><LI>Position the control bars using RepositionBars().
<P>
</OL>To update the first pane of a status bar with menu item text, you must
handle WM_MENUSELECT, WM_ENTERIDLE, and WM_SETMESSAGESTRING in your dialog
box class. You need to duplicate the functionality of the CFrameWnd
handlers for these messages. See the CModelessMain class in the sample
program for examples of these message handlers.
<P>
To allow ON_UPDATE_COMMAND_UI handlers to work for other status bar panes
and for toolbar buttons, you must derive new control bar classes and
implement a message handler for WM_IDLEUPDATECMDUI. This is necessary
because the default control bar implementations of OnUpdateCmdUI() assume
the parent window is a frame window. However, it doesn't do anything but
pass the parent window pointer on to a function which only requires a
CCmdTarget pointer. Therefore, you can temporarily tell OnUpdateCmdUI()
that the parent window pointer you are giving it is a CFrameWnd pointer to
meet the compiler requirements. Here's an example:
<P>
<PRE>      LRESULT CDlgToolBar::OnIdleUpdateCmdUI(WPARAM wParam,
                                             LPARAM lParam)
      {
         if (IsWindowVisible())
         {
            CFrameWnd* pParent = (CFrameWnd*)GetParent();
            if (pParent)
               OnUpdateCmdUI(pParent, (BOOL)wParam);
         }
         return 0L;
      }

</PRE></OL>To pass WM_IDLEUPDATECMDUI messages on to dialog boxes other than the main
window, save dialog pointers in your frame window class and create a
WM_IDLEUPDATECMDUI handler in that class. The handler should send the
WM_IDLEUPDATECMDUI message on to the dialog child windows by using
CWnd::SendMessageToDescendants(). Then perform default processing for the
message within the frame window.
 

	</FONT>
	</TD>
	</TR>
</TABLE>
<P>


<!--DOCBODY_END-->

<!--FOOTER_START-->
<table cellpadding=5 border=0 width="90%">
<tr>
<td>
	<HR WIDTH="90%">

<BLOCKQUOTE>
<FONT FACE="Verdana, Arial, Helvetica" SIZE="1">
<SPAN STYLE="font-family:verdana,arial,helvetica; font-size:8pt">
Keywords            : CDialog CStatusBar CToolBar DLGCGR kbprg kbsample MfcUI<BR>
Technology          : kbMfc<BR>
Version             : 4.0 4.1 4.2 5.0<BR>
Platform            : NT WINDOWS<BR>
Resolution Type     : kbfile<BR>

</SPAN>
</FONT>
<BR>
<BR>
THE INFORMATION PROVIDED IN THE MICROSOFT KNOWLEDGE BASE IS
PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND.  MICROSOFT DISCLAIMS
ALL WARRANTIES, EITHER EXPRESS OR IMPLIED, INCLUDING THE WARRANTIES
OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  IN NO
EVENT SHALL MICROSOFT CORPORATION OR ITS SUPPLIERS BE LIABLE FOR
ANY DAMAGES WHATSOEVER INCLUDING DIRECT, INDIRECT, INCIDENTAL,
CONSEQUENTIAL, LOSS OF BUSINESS PROFITS OR SPECIAL DAMAGES, EVEN IF
MICROSOFT CORPORATION OR ITS SUPPLIERS HAVE BEEN ADVISED OF THE
POSSIBILITY OF SUCH DAMAGES.  SOME STATES DO NOT ALLOW THE EXCLUSION
OR LIMITATION OF LIABILITY FOR CONSEQUENTIAL OR INCIDENTAL DAMAGES
SO THE FOREGOING LIMITATION MAY NOT APPLY.
</BLOCKQUOTE>
<P>
<center>
	<FONT FACE="Verdana,Arial,Helvetica" SIZE="1">
	Last reviewed:  July 7, 1997</FONT>
	<BR>
	<A href="../cpyright.htm" STYLE="font: bold 7pt Verdana,Arial,Helvetica">&copy; 1998 Microsoft Corporation. All rights reserved. Terms of Use.</A><BR>
	
</center>
</td>
</tr>
</table>

<!--FOOTER_END-->
</FONT>
</BODY>
</HTML>
