

<HTML>
<HEAD>
<TITLE>How to Detect Mouse Clicks on Client Area of MDI Frame Windows </TITLE>

<!--STYLE_BEGIN-->
<style>@import url(../../msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="../../msdn_ie3.css">
<!--STYLE_END-->

<META HTTP-EQUIV="CONTENT-Type" CONTENT="text/html; charset=us-ascii">
<META NAME="ms.locale" CONTENT="EN-US">
<META NAME="Category" CONTENT="Support; KB Article">
<META NAME="KBID" CONTENT="Q133716">
<META NAME="KBModify" CONTENT="1997/10/10">
<META NAME="KBCreate" CONTENT="1995/08/01">
<META NAME="Keywords" CONTENT="MfcUI kbcode kbprg">
<META NAME="KBArea" CONTENT="Support; KB; visualc">
<META NAME="Description" CONTENT="  You can detect when a user clicks the mouse while the pointer is over the client area of your main MDI frame window (the area of the client not covered by any open MDI child windows). To do so, you must first subclass the MDIClient so you can inter...">
<META NAME="Product" CONTENT="Visual C++">
<META NAME="Platform" CONTENT="Windows">
<META NAME="Technology" CONTENT=" ">
<META NAME="Premium" CONTENT="support">

<META NAME="nyms" CONTENT="QBJZ,QAUD,QABO,QDL9,QBWQ,QBWO,QBWN,QBC9,QBC8,QANO,QABA,QAGI,QAQ7,QBSO,QA2O V02180118">
</HEAD>

<BODY BGCOLOR="#FFFFFF" LEFTMARGIN="0" RIGHTMARGIN="0" TOPMARGIN="0">


<!--DOCBODY_START-->
<BR>
<CENTER>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" VALIGN="top" WIDTH="90%">
	<TR>
		<TD VALIGN="top">
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<H1>How to Detect Mouse Clicks on Client Area of MDI Frame Windows</H1>
			</FONT>
			<FONT FACE="verdana,arial,helvetica" SIZE="1">
			Last reviewed:  October 10, 1997</FONT><BR>
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<B>Article ID: Q133716</B>
			</FONT>
		</TD>
	</TR>
	<TR>
	<TD>
	<FONT FACE="Verdana, Arial, Helvetica" SIZE=2>



 
1.50 1.51 1.52 | 1.00 2.00 2.10 2.20 4.00 4.10 4.20
<PRE>WINDOWS        | WINDOWS NT
</PRE>kbprg kbcode
<P>
 
The information in this article applies to:

<UL><LI>The Microsoft Foundation Classes (MFC) included with:
<P>
<P><PRE>    - Microsoft Visual C++ for Windows, versions 1.5, 1.51, 1.52
    - Microsoft Visual C++, 32-bit Edition, versions 1.0, 2.0, 2.1,
      2.2, 4.0, 4.1, 4.2
</UL></PRE> 
<P>
<P><h2>SUMMARY</h2>
 
<P>
You can detect when a user clicks the mouse while the pointer is over the
client area of your main MDI frame window (the area of the client not
covered by any open MDI child windows). To do so, you must first subclass
the MDIClient so you can intercept the mouse messages being sent to it.
This article shows by example how to do it using MFC. You can extend the
method outlined here to handle any messages sent to the MDIClient.
<P>
<P><h2>MORE INFORMATION</h2>
 
<P>
To manage its MDI child windows, the CMDIFrameWnd class creates a window of
the class "mdiclient" to cover its entire client area (also referred to as
the Application Workspace). MFC stores a handle to this MDIClient window in
a public member variable, m_hWndMDIClient, of the CMDIFrameWnd class.
<P>
The MDIClient is a standard Windows window, not an MFC object. However,
subclassing it allows you to treat it just as you would any other CWnd,
taking advantage of standard MFC features like message maps. For example,
you could use this technique to provide a context menu when the user clicks
the right mouse button. Or, as the Windows 95 desktop does, you could use
it to provide an easy means of selecting a group of iconized MDI child
windows, enclosing them within a tracker rectangle as the user drags with
the left mouse button button held down.
<P>
<P><h3>Steps to Subclass the MDIClient</h3>
 
<P>
Subclassing the MDIClient is actually quite easy as summarized in the
following three steps. For more detailed information about this process,
please see the following article in the Microsoft Knowledge Base:
<P>
<PRE>   ARTICLE-ID: <B><A href="../visualc/q129471.htm">Q129471</A></B>
   TITLE     : How to SubClass the MDIClient by Using MFC

</PRE><P><LI>Derive a class from CWnd, called CMyMDIClient for example, and add it to
   your project. You can use ClassWizard to help you do this.

<P><LI>If you are creating a 16-bit application, you need to add a public
   function called GetSuperWndProcAddr() to your new CMyMDIClient class. Do
   not do this step when building applications with 32-bit versions of
   Visual C++.
<P>
   WNDPROC* CMyMDIClient::GetSuperWndProcAddr()
<P><PRE>       {
       static WNDPROC NEAR pfnSuper = NULL;
       return &amp;pfnSuper;
       }
</PRE>
<P><LI>Include your class header file in MAINFRM.H. Embed a public member
   object of your new class in your CMainFrame class, for example
   CMyMDIClient m_MyMDIClient. If you have not already done so, override
   CMDIFrameWnd::OnCreate(). In your CMainFrame::OnCreate(), first call the
   base class implementation, CMDIFrameWnd::OnCreate(), which creates the
   MDIClient window itself and stores the handle in m_hWndMDIClient. Then
   subclass that window to your embedded member object:
<P>
<PRE>   int CMainFrame::OnCreate(LPCREATESTRUCT lpCreateStruct)
       {
       // Call the base class implementation to create the MDIClient
       // window.
       if (CMDIFrameWnd::OnCreate(lpCreateStruct) == -1)
         return -1;

       // Subclass the MDIClient window.
       if (!m_MyMDIClient.SubclassWindow(m_hWndMDIClient))
           {
           TRACE ("Failed to subclass MDI client window\n");
           return (-1);
           }

       ...
       }

</PRE></OL><h3>Code Sample</h3>
 
<P>
Once you subclass the MDIClient in this way, you can add any needed message
handlers directly to your CMyMDIClient class. To illustrate, the following
code displays your application's File menu as a context menu when the user
clicks the MDIClient using the right mouse button.
<P>
<PRE>   void CMyMDIClient::OnRButtonDown(UINT nFlags, CPoint point)
       {
       POINT ScreenPoint = point;
       CMenu* pMenuTrackPopup;

       // Get a pointer to the app's File menu popup.
       // AfxGetMainWnd() returns a pointer to the main frame window,
       // GetMenu() returns a pointer to the main menu of the application,
       // and GetSubMenu(0) retrieves the submenu at position 0 (here the
       // File menu).
       pMenuTrackPopup = ((AfxGetMainWnd())-&gt;GetMenu())-&gt;GetSubMenu(0);

       // Convert the mouse point to screen coordinates since that is what
       // TrackPopupMenu() expects.
       ClientToScreen(&amp;ScreenPoint);

       // Draw and track the "floating" popup
       pMenuTrackPopup-&gt;TrackPopupMenu(TPM_RIGHTBUTTON,
          ScreenPoint.x, ScreenPoint.y,
           AfxGetMainWnd(),    // Use the 'this' pointer if you want
                               // commands to be handled in your
                               // CMyMDIClient class instead
           NULL);

       // NOTE: Do not destroy this menu here!

       // Call the base class
       CWnd::OnRButtonDown(nFlags, point);
       }
</PRE>

	</FONT>
	</TD>
	</TR>
</TABLE>
<P>


<!--DOCBODY_END-->

<!--FOOTER_START-->
<table cellpadding=5 border=0 width="90%">
<tr>
<td>
	<HR WIDTH="90%">

<BLOCKQUOTE>
<FONT FACE="Verdana, Arial, Helvetica" SIZE="1">
<SPAN STYLE="font-family:verdana,arial,helvetica; font-size:8pt">
Additional reference words: kbinf 1.50 1.51 1.52 1.00 2.00 2.10 2.50 2.51<BR>
2.52 2.10 2.20 3.00 3.10 4.00 4.10 4.20<BR>
KBCategory: kbprg kbcode<BR>
KBSubcategory: MfcUI<BR>
Keywords          : MfcUI kbcode kbprg<BR>
Technology        : kbMfc<BR>
Version           : 1.50 1.51 1.52 | 1.00 2.00 2.10<BR>
Platform          : NT WINDOWS<BR>

</SPAN>
</FONT>
<BR>
<BR>
THE INFORMATION PROVIDED IN THE MICROSOFT KNOWLEDGE BASE IS
PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND.  MICROSOFT DISCLAIMS
ALL WARRANTIES, EITHER EXPRESS OR IMPLIED, INCLUDING THE WARRANTIES
OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  IN NO
EVENT SHALL MICROSOFT CORPORATION OR ITS SUPPLIERS BE LIABLE FOR
ANY DAMAGES WHATSOEVER INCLUDING DIRECT, INDIRECT, INCIDENTAL,
CONSEQUENTIAL, LOSS OF BUSINESS PROFITS OR SPECIAL DAMAGES, EVEN IF
MICROSOFT CORPORATION OR ITS SUPPLIERS HAVE BEEN ADVISED OF THE
POSSIBILITY OF SUCH DAMAGES.  SOME STATES DO NOT ALLOW THE EXCLUSION
OR LIMITATION OF LIABILITY FOR CONSEQUENTIAL OR INCIDENTAL DAMAGES
SO THE FOREGOING LIMITATION MAY NOT APPLY.
</BLOCKQUOTE>
<P>
<center>
	<FONT FACE="Verdana,Arial,Helvetica" SIZE="1">
	Last reviewed:  October 10, 1997</FONT>
	<BR>
	<A href="../cpyright.htm" STYLE="font: bold 7pt Verdana,Arial,Helvetica">&copy; 1998 Microsoft Corporation. All rights reserved. Terms of Use.</A><BR>
	
</center>
</td>
</tr>
</table>

<!--FOOTER_END-->
</FONT>
</BODY>
</HTML>
