

<HTML>
<HEAD>
<TITLE>How to Use _beginthreadex() and _endthreadex() </TITLE>

<!--STYLE_BEGIN-->
<style>@import url(../../msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="../../msdn_ie3.css">
<!--STYLE_END-->

<META HTTP-EQUIV="CONTENT-Type" CONTENT="text/html; charset=us-ascii">
<META NAME="ms.locale" CONTENT="EN-US">
<META NAME="Category" CONTENT="Support; KB Article">
<META NAME="KBID" CONTENT="Q132078">
<META NAME="KBModify" CONTENT="1997/09/26">
<META NAME="KBCreate" CONTENT="1995/06/27">
<META NAME="Keywords" CONTENT="CRTIss kbcode kbprg">
<META NAME="KBArea" CONTENT="Support; KB; visualc">
<META NAME="Description" CONTENT="  This article shows by example how to use the thread handle returned by _beginthreadex() with the synchronization API WaitForSingleObject() in multithreaded applications.  When developing a multithreaded Win32-based application with Visual C++, you ...">
<META NAME="Product" CONTENT="Visual C++">
<META NAME="Platform" CONTENT="Windows">
<META NAME="Technology" CONTENT=" ">
<META NAME="Premium" CONTENT="support">

<META NAME="nyms" CONTENT="QAUQ,QALX,QAM9,QAUD,QAY5,QBV8,QBVV,QAGB,QAGI,QBFY,QAB9,QALW,QA56,QA55,QAX6 V02180118">
</HEAD>

<BODY BGCOLOR="#FFFFFF" LEFTMARGIN="0" RIGHTMARGIN="0" TOPMARGIN="0">


<!--DOCBODY_START-->
<BR>
<CENTER>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" VALIGN="top" WIDTH="90%">
	<TR>
		<TD VALIGN="top">
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<H1>How to Use _beginthreadex() and _endthreadex()</H1>
			</FONT>
			<FONT FACE="verdana,arial,helvetica" SIZE="1">
			Last reviewed:  September 26, 1997</FONT><BR>
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<B>Article ID: Q132078</B>
			</FONT>
		</TD>
	</TR>
	<TR>
	<TD>
	<FONT FACE="Verdana, Arial, Helvetica" SIZE=2>



 
 
The information in this article applies to:

<UL><LI>The C Run-time (CRT) included with:
   Microsoft Visual C++, 32-bit Edition, versions 2.0, 2.1, 2.2, 4.0,
   5.0
</UL> 
<P>
<P><h2>SUMMARY</h2>
 
<P>
This article shows by example how to use the thread handle returned by
_beginthreadex() with the synchronization API WaitForSingleObject() in
multithreaded applications.
<P>
When developing a multithreaded Win32-based application with Visual C++,
you need to use the CRT thread functions to create any threads that call
CRT functions. To create and terminate threads, use either _beginthread()
and _endthread() or _beginthreadex() and _endthreadex(). If you use the
Win32 APIs CreateThread() and EndThread() instead, some of the CRT
functions used in the thread will not work. You need to use the CRT
functions to both create and end the threads or you lose the memory that
the CRT allocates for the thread.
<P>
<P><h2>MORE INFORMATION</h2>
 
<P>
The _beginthreadex() function gives you more control over how the thread is
created than _beginthread() does. The _endthreadex() function is also more
flexible. For example, with _beginthreadex(), you can use security
information, set the initial state of the thread (running or suspended),
and get the thread identifier of the newly created thread. You are also
able to use the thread handle returned by _beginthreadex() with the
synchronization APIs, which you cannot do with _beginthread().
<P>
It is safer to use _beginthreadex() than _beginthread(). If the thread
spawned by _beginthread() exits quickly, the handle returned to the caller
of _beginthread() may be invalid, or worse yet, point to another thread.
However, the handle returned by _beginthreadex() has to be closed by the
caller of _beginthreadex(), so it's guaranteed to be a valid handle if
_beginthreadex() did not return an error.
<P>
NOTE: The _beginthreadex() and _endthreadex() functions are not available
in Visual C++, 32-bit Edition, version 1.0.
<P>
The following sample code demonstrates how you can use the thread handle
returned by _beginthreadex() with the synchronization API
WaitForSingleObject(). The main thread waits for the second thread to
terminate before it continues. When the second thread calls _endthreadex(),
it causes its thread object to go to the signaled state. This allows the
primary thread to continue running. This cannot be done with _beginthread()
and _endthread(), because _endthread() calls the Win32 API CloseHandle(),
destroying the thread object before it can be set to the signaled state.
<P>
<P><h3>Sample Code</h3>
 
<P>
<PRE>/* Compile options needed: Default options for a multithreaded console
   application. You need to compile the code as a .CPP file.
*/

#include &lt;windows.h&gt;
#include &lt;stdio.h&gt;
#include &lt;process.h&gt;

</PRE>unsigned Counter;
<P>
unsigned __stdcall SecondThreadFunc( void* pArguments )
{
<PRE>    printf( "In second thread...\n" );

    while ( Counter &lt; 1000000 )
        Counter++;

    _endthreadex( 0 );
    return 0;
</PRE>}
<P>
<PRE>void main()
</PRE>{
<PRE>    HANDLE hThread;
    unsigned threadID;

    printf( "Creating second thread...\n" );

    // Create the second thread.

    hThread = (HANDLE)_beginthreadex( NULL, 0, &amp;SecondThreadFunc, NULL, 0,
        &amp;threadID );

    // Wait until second thread has terminated. If you comment out the line
    // below, Counter will not be correct because the thread has not
    // terminated, and Counter most likely has not been incremented to
    // 1000000 yet.

    WaitForSingleObject( hThread, INFINITE );

    printf( "Counter should be 1000000; it is-&gt; %d\n", Counter );

    // Destroy the thread object.

    CloseHandle( hThread );
</PRE>}
<P>
<P><h2>REFERENCES</h2>
 
<P>
For more information on these functions and multithreading, please see the
following sources:

<UL><LI>Visual C++ Run-Time Library Reference, Part 2, Run-Time Reference; the
   descriptions of _beginthread/_beginthreadex and _endthread/_endthreadex.

<LI>Win32 Programmer's Reference, Volume 2: Chapter 43, "Processes and
   Threads," and Chapter 44, "Synchronization."
</UL> 
<PRE>Keywords          : CRTIss kbcode kbprg
Version           : WinNT:2.0,2.1,2.2,4.0,5.0
Platform          : NT WINDOWS
Issue type        : kbhowto</PRE>

	</FONT>
	</TD>
	</TR>
</TABLE>
<P>


<!--DOCBODY_END-->

<!--FOOTER_START-->
<table cellpadding=5 border=0 width="90%">
<tr>
<td>
	<HR WIDTH="90%">

<BLOCKQUOTE>
<FONT FACE="Verdana, Arial, Helvetica" SIZE="1">
<SPAN STYLE="font-family:verdana,arial,helvetica; font-size:8pt">
================================================================================<BR>

</SPAN>
</FONT>
<BR>
<BR>
THE INFORMATION PROVIDED IN THE MICROSOFT KNOWLEDGE BASE IS
PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND.  MICROSOFT DISCLAIMS
ALL WARRANTIES, EITHER EXPRESS OR IMPLIED, INCLUDING THE WARRANTIES
OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  IN NO
EVENT SHALL MICROSOFT CORPORATION OR ITS SUPPLIERS BE LIABLE FOR
ANY DAMAGES WHATSOEVER INCLUDING DIRECT, INDIRECT, INCIDENTAL,
CONSEQUENTIAL, LOSS OF BUSINESS PROFITS OR SPECIAL DAMAGES, EVEN IF
MICROSOFT CORPORATION OR ITS SUPPLIERS HAVE BEEN ADVISED OF THE
POSSIBILITY OF SUCH DAMAGES.  SOME STATES DO NOT ALLOW THE EXCLUSION
OR LIMITATION OF LIABILITY FOR CONSEQUENTIAL OR INCIDENTAL DAMAGES
SO THE FOREGOING LIMITATION MAY NOT APPLY.
</BLOCKQUOTE>
<P>
<center>
	<FONT FACE="Verdana,Arial,Helvetica" SIZE="1">
	Last reviewed:  September 26, 1997</FONT>
	<BR>
	<A href="../cpyright.htm" STYLE="font: bold 7pt Verdana,Arial,Helvetica">&copy; 1998 Microsoft Corporation. All rights reserved. Terms of Use.</A><BR>
	
</center>
</td>
</tr>
</table>

<!--FOOTER_END-->
</FONT>
</BODY>
</HTML>
