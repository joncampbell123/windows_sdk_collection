

<HTML>
<HEAD>
<TITLE>FIX: Internal State of ControlBars Corrupted </TITLE>

<!--STYLE_BEGIN-->
<style>@import url(../../msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="../../msdn_ie3.css">
<!--STYLE_END-->

<META HTTP-EQUIV="CONTENT-Type" CONTENT="text/html; charset=us-ascii">
<META NAME="ms.locale" CONTENT="EN-US">
<META NAME="Category" CONTENT="Support; KB Article">
<META NAME="KBID" CONTENT="Q151446">
<META NAME="KBModify" CONTENT="1997/09/19">
<META NAME="KBCreate" CONTENT="1996/05/23">
<META NAME="Keywords" CONTENT="MfcUI kbbuglist kbcode kbfixlist kbprg kbui">
<META NAME="KBArea" CONTENT="Support; KB; visualc">
<META NAME="Description" CONTENT="  The internal state of the controlbars is corrupted when controlbars are docked and undocked. The size of the Registry key or the .INI file grows when SaveBarState is a result of this corruption.  CAUSE =====  The code for managing the controlbar do...">
<META NAME="Product" CONTENT="Visual C++">
<META NAME="Platform" CONTENT="Windows">
<META NAME="Technology" CONTENT=" ">
<META NAME="Premium" CONTENT="support">

<META NAME="nyms" CONTENT="QALS,QAH4,QAI4,QA4Q,QAR4,QAGI,QAUR,QAY5,QA7Y,QA2B,QAYY,QAYV,QAPF,QAJ9,QDIX V02180118">
</HEAD>

<BODY BGCOLOR="#FFFFFF" LEFTMARGIN="0" RIGHTMARGIN="0" TOPMARGIN="0">


<!--DOCBODY_START-->
<BR>
<CENTER>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" VALIGN="top" WIDTH="90%">
	<TR>
		<TD VALIGN="top">
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<H1>FIX: Internal State of ControlBars Corrupted</H1>
			</FONT>
			<FONT FACE="verdana,arial,helvetica" SIZE="1">
			Last reviewed:  September 19, 1997</FONT><BR>
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<B>Article ID: Q151446</B>
			</FONT>
		</TD>
	</TR>
	<TR>
	<TD>
	<FONT FACE="Verdana, Arial, Helvetica" SIZE=2>



 
4.00 4.10
WINDOWS NT
kbui kbprg kbbuglist kbcode kbfixlist
<P>
 
The information in this article applies to:

<UL><LI>The Microsoft Foundation Classes (MFC), included with:
   Microsoft Visual C++, 32-bit Edition, versions 4.0, 4.1
</UL> 
<P>
<P><h2>SYMPTOMS</h2>
 
<P>
The internal state of the controlbars is corrupted when controlbars are
docked and undocked. The size of the Registry key or the .INI file grows
when SaveBarState is a result of this corruption.
<P>
<P><h2>CAUSE</h2>
 
<P>
The code for managing the controlbar docking and undocking has a bug which
does not correctly remove information from the data structures. None of
this code can be overridden to fix the bug because it is undocumented
private implementation of the MFC.
<P>
<P><h2>RESOLUTION</h2>
 
<P>
The sample code at the end of this article cleans up the state of these
internal structures. The CleanUpControlBarState function cleans up the
information in the CDockState object passed to it. When the function
returns, the CDockState object has the clean information.
<P>
Call this function with the present state of the controlbars, and use the
information after calling CleanUpControlBarState.
<P>
<P><h2>STATUS</h2>
 
<P>
Microsoft has confirmed this to be a bug in the Microsoft products listed
at the beginning of this article. This bug was corrected in Visual C++ 32-
bit Edition version 4.2.
<P>
<P><h2>MORE INFORMATION</h2>
 
<P>
There are two ways to get information into a CDockState object:

<UL><LI>Call the CDockState::LoadState to load the state of the controlbars from
   the Registry or .INI file.

<LI>Use the CFrameWnd::GetDockState.
<P>
</UL>To save the state to the Registry or .INI file, use CDockState::SaveState.
Use CFrameWnd::SetDockState to set the state of the controlbars at run
time.
<P>
The following code was added to the Docktool sample. This code saves the
non-corrupted controlbar information to the .INI file:
<P>
<PRE>   void CMainFrame::OnClose()
   {
       // SaveBarState saves everything but the number of Columns in
       // the Palette we need to do that ourselves.
       SaveBarState(_T("General"));


   // Following code was added to the sample with Visual C++ 4.1
   #if _MFC_VER == 0x0400 || _MFC_VER == 0x0410

       CDockState state;
       GetDockState(state);

       CleanUpControlBarState(state);

       state.SaveState(_T("General"));

   #endif
   ...

</PRE><h3>Sample Code</h3>
 
<P>
<PRE>// In this case the function is defined as a global function.
// You could make it a member of one of your classes

</PRE>Add the following prototype to the end of your stdafx.h:
<P>
#if _MFC_VER == 0x0400 || _MFC_VER == 0x0410
<P>
<PRE>void CleanUpControlBarState(CDockState&amp; state);

</PRE>#endif
<P>
and add the following code to one of your CPP files:
<P>
#if _MFC_VER == 0x0400 || _MFC_VER == 0x0410
<PRE>void CleanUpControlBarState(CDockState&amp; state)
</PRE>{
<P>
<PRE>    for (int i = 0; i &lt; state.m_arrBarInfo.GetSize(); i++)
    {
        CControlBarInfo* pInfo1 = (CControlBarInfo*)state.m_arrBarInfo[i];

        for (int j = 0; j &lt; state.m_arrBarInfo.GetSize(); j++)
        {
            if (i == j)
                continue;

            CControlBarInfo* pInfo2 =
                (CControlBarInfo*)state.m_arrBarInfo[j];

            if (pInfo1-&gt;m_uMRUDockID == pInfo2-&gt;m_nBarID)
                continue;

            int nSize = pInfo2-&gt;m_arrBarID.GetSize();
            for (int k = 0; k &lt; nSize - 1; k++)
            {
                if ((LONG)pInfo2-&gt;m_arrBarID[k] ==
                    (LONG)pInfo1-&gt;m_nBarID + 0x10000)

                    pInfo2-&gt;m_arrBarID[k] = NULL;
            }
        }
    }

    for (i = 0; i &lt; state.m_arrBarInfo.GetSize(); i++)
    {
        CControlBarInfo* pInfo = (CControlBarInfo*)state.m_arrBarInfo[i];

        int nSize = pInfo-&gt;m_arrBarID.GetSize();
        for (int j = 0; j &lt; nSize - 1; j++)
        {
            if (pInfo-&gt;m_arrBarID[j]==NULL)
                continue;

            for (int k = j + 1; k &lt; nSize; k++)
            {
                if (pInfo-&gt;m_arrBarID[k]==NULL)
                    continue;

                if (pInfo-&gt;m_arrBarID[k]==pInfo-&gt;m_arrBarID[j])
                    pInfo-&gt;m_arrBarID[k] = NULL;
            }
        }

        while ((nSize!=0) &amp;&amp; (pInfo-&gt;m_arrBarID[nSize-1]==NULL))
        {
            nSize--;
            pInfo-&gt;m_arrBarID.RemoveAt(nSize);
        }
        if (nSize)
            pInfo-&gt;m_arrBarID.InsertAt(nSize, (void*)NULL);
    }
</PRE>}
<P>
#endif
<P>
NOTE: The sample code above uses undocumented functionality of the MFC. To
be compatible with future versions of MFC, enclose the code between the
following directives:
<P>
<PRE>   #if _MFC_VER == 0x0400 || _MFC_VER == 0x0410
   ...
   ...
   #endif

</PRE>Also include any call to CleanUpControlBarState between these directives.
<P>

	</FONT>
	</TD>
	</TR>
</TABLE>
<P>


<!--DOCBODY_END-->

<!--FOOTER_START-->
<table cellpadding=5 border=0 width="90%">
<tr>
<td>
	<HR WIDTH="90%">

<BLOCKQUOTE>
<FONT FACE="Verdana, Arial, Helvetica" SIZE="1">
<SPAN STYLE="font-family:verdana,arial,helvetica; font-size:8pt">
Additional reference words: 4.00 4.10 4.20 LoadBarState SaveBarState ini<BR>
                            grow vcbuglist400 vcfixlist420<BR>
KBCategory: kbui kbprg kbbuglist kbcode kbfixlist<BR>
KBSubcategory: MfcUI
<P>

Keywords          : MfcUI kbbuglist kbcode kbfixlist kbprg kbui<BR>
Technology        : kbMfc<BR>
Version           : 4.00 4.10<BR>
Platform          : NT WINDOWS<BR>
Solution Type     : kbfix<BR>

</SPAN>
</FONT>
<BR>
<BR>
THE INFORMATION PROVIDED IN THE MICROSOFT KNOWLEDGE BASE IS
PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND.  MICROSOFT DISCLAIMS
ALL WARRANTIES, EITHER EXPRESS OR IMPLIED, INCLUDING THE WARRANTIES
OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  IN NO
EVENT SHALL MICROSOFT CORPORATION OR ITS SUPPLIERS BE LIABLE FOR
ANY DAMAGES WHATSOEVER INCLUDING DIRECT, INDIRECT, INCIDENTAL,
CONSEQUENTIAL, LOSS OF BUSINESS PROFITS OR SPECIAL DAMAGES, EVEN IF
MICROSOFT CORPORATION OR ITS SUPPLIERS HAVE BEEN ADVISED OF THE
POSSIBILITY OF SUCH DAMAGES.  SOME STATES DO NOT ALLOW THE EXCLUSION
OR LIMITATION OF LIABILITY FOR CONSEQUENTIAL OR INCIDENTAL DAMAGES
SO THE FOREGOING LIMITATION MAY NOT APPLY.
</BLOCKQUOTE>
<P>
<center>
	<FONT FACE="Verdana,Arial,Helvetica" SIZE="1">
	Last reviewed:  September 19, 1997</FONT>
	<BR>
	<A href="../cpyright.htm" STYLE="font: bold 7pt Verdana,Arial,Helvetica">&copy; 1998 Microsoft Corporation. All rights reserved. Terms of Use.</A><BR>
	
</center>
</td>
</tr>
</table>

<!--FOOTER_END-->
</FONT>
</BODY>
</HTML>
