

<HTML>
<HEAD>
<TITLE>SAMPLE: Using a TimerProc Function in MFC Application </TITLE>

<!--STYLE_BEGIN-->
<style>@import url(../../msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="../../msdn_ie3.css">
<!--STYLE_END-->

<META HTTP-EQUIV="CONTENT-Type" CONTENT="text/html; charset=us-ascii">
<META NAME="ms.locale" CONTENT="EN-US">
<META NAME="Category" CONTENT="Support; KB Article">
<META NAME="KBID" CONTENT="Q130866">
<META NAME="KBModify" CONTENT="1997/07/31">
<META NAME="KBCreate" CONTENT="1995/05/30">
<META NAME="Keywords" CONTENT="MfcMisc kbfile kbprg">
<META NAME="KBArea" CONTENT="Support; KB; visualc">
<META NAME="Description" CONTENT="  The TMRPROC sample is designed to demonstrate how to use the SetTimer() API in an MFC Application in such a way that the TimerProc() callback function (a member of a C++ class) is used instead of handling WM_TIMER messages. There are two makefiles ...">
<META NAME="Product" CONTENT="Visual C++">
<META NAME="Platform" CONTENT="Windows">
<META NAME="Technology" CONTENT=" ">
<META NAME="Premium" CONTENT="support">

<META NAME="nyms" CONTENT="QADK,QATK,QAO3,QAO2,QAIJ,QAY5,QBFY,QAYL,QBV8,QAPN,QABO,QAB9,QDIV,QBXS,QBWT V02180118">
</HEAD>

<BODY BGCOLOR="#FFFFFF" LEFTMARGIN="0" RIGHTMARGIN="0" TOPMARGIN="0">


<!--DOCBODY_START-->
<BR>
<CENTER>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" VALIGN="top" WIDTH="90%">
	<TR>
		<TD VALIGN="top">
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<H1>SAMPLE: Using a TimerProc Function in MFC Application</H1>
			</FONT>
			<FONT FACE="verdana,arial,helvetica" SIZE="1">
			Last reviewed:  July 31, 1997</FONT><BR>
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<B>Article ID: Q130866</B>
			</FONT>
		</TD>
	</TR>
	<TR>
	<TD>
	<FONT FACE="Verdana, Arial, Helvetica" SIZE=2>



 
1.00 1.50 1.51 1.52 | 1.00 2.00 2.10 4.00
<PRE>WINDOWS             | WINDOWS NT
</PRE>kbprg kbfile
<P>
 
The information in this article applies to:

<UL><LI>The Microsoft Foundation Classes (MFC), included with:
<P>
<P><PRE>    - Microsoft Visual C++ for Windows, versions 1.0, 1.5, 1.51, 1.52
    - Microsoft Visual C++, 32-bit Edition, version 1.0, 2.0, 2.1, and
      4.0
</UL></PRE> 
<P>
<P><h2>SUMMARY</h2>
 
<P>
The TMRPROC sample is designed to demonstrate how to use the SetTimer() API
in an MFC Application in such a way that the TimerProc() callback function
(a member of a C++ class) is used instead of handling WM_TIMER messages.
There are two makefiles included:

<UL><LI>TMRPROC.MAK, generated by Visual C++ version 1.5.

<LI>TMRPRC32.MAK, generated by Visual C++ version 2.0.
<P>
</UL>Download TMRPROC.EXE, a self-extracting file, from the Microsoft Software
Library (MSL) on the following services:

<UL><LI>Microsoft Download Service (MSDL)
<P><PRE>      Dial (206) 936-6735 to connect to MSDL
      Download <A href="http://support.microsoft.com/download/support/mslfiles/tmrproc.exe">TMRPROC.EXE</A> <I>(size: 36624 bytes)</I> 
</PRE>
<LI>Internet (anonymous FTP)
<P><PRE>      ftp ftp.microsoft.com
      Change to the SOFTLIB\MSLFILES directory
      Get <A href="http://support.microsoft.com/download/support/mslfiles/tmrproc.exe">TMRPROC.EXE</A> <I>(size: 36624 bytes)</I> 
</PRE><P>
</UL>NOTE: When extracting files from TMRPROC.EXE, be sure to use the -d option
to create subdirectories.
<P>
<P><h2>MORE INFORMATION</h2>
 
<P>
The challenge of using callback functions as C++ class members can be
approached in several different ways, depending on the circumstances
surrounding the callback. In "Calling All Members:..." (see References
below), four different approaches are mentioned. They are:

<UL><LI>Not accessing any class members from within the static callback.

<LI>Storing the "this" pointer to the object in a static member.

<LI>Passing the "this" pointer to the callback function via a parameter
   supplied by APIs that use callbacks.

<LI>Storing a list of "this" pointers mapped to the list of objects
   servicing the callback in a static structure.
<P>
</UL>The TMRPROC sample application illustrates the second and fourth cases.
These are the most likely scenarios MFC Doc/View/UI type applications
encounter. Not accessing any members from a callback is quite limiting, and
passing the "this" pointer in a callback-supplied parameter is dependent on
the API. For these reasons, the sample does not address the first and third
cases.
<P>
<P><h3>TMRPROC.CPP and .H</h3>
 
<P>
Storing the "this" pointer to the object in a static member is demonstrated
in the CWinApp-derived class, CTmrprocApp.
<P>
There is no window associated with this class, so the output used to
indicate the timer event is done via OutputDebugString(). The pThis
variable is a static member variable that is initialized in the constructor
to contain the "this" pointer for the class. The TimerProc() callback is
simply a static member function of type "void CALLBACK EXPORT." It is
static, so no "this" pointer is passed in. For this reason, the pThis
member variable is used to store the CTmrprocApp's "this" pointer. Whenever
TimerProc() gets called, the current instance of CTmrprocApp can be
referenced through the CTmrprocApp::pThis member.
<P>
This is the simplest case. There are three functions added to the
CTmrprocApp class to accomplish this objective - TimerProc(),
CTmrprocApp::OnAppsettimer(), and CTmrprocApp::OnAppkilltimer(). The later
two are the menu handlers that allow the user to start and stop the timer.
<P>
<P><h3>TMRPRVW.CPP and .H</h3>
 
<P>
Storing a list of "this" pointers mapped to the list of objects servicing
the callback in a static structure is implemented in the view class,
CTmrprocView.
<P>
In this case, a little more work is required, but not much. Because a timer
needs to be set for each instance of the view class, a scheme must be
implemented to associate each timer ID with a corresponding view object.
The view object is identified by its "this" pointer and the timer by its
timer ID (passed back from SetTimer()). The view class associates these and
stores them in a CMapWordToPtr static member variable. This way, when each
view's TimerProc() is called, it can first look up its "this" pointer in
the pointer/ID map, and then update its own members.
<P>
There are several functions needed to start, stop, and reset the count on
the timer. The count is just a running count of the number of times
TimerProc() has been called for the current view. The following are the
start, stop, and reset functions:
<P>
<PRE>   CTmrprocView::OnTimerStart()    - Start timer in current view.
   CTmrprocView::OnTimerStop()     - Stop timer in current view.
   CTmrprocView::OnTimerReset()    - Reset count for current view.

</PRE>The following are some "all" type functions that can be used to start,
stop, and reset the timer for each view:
<P>
<PRE>   CTmrprocView::OnTimerAllStart() - Start timers for all views.
   CTmrprocView::OnTimerAllStop()  - Stop timers for all views.
   CTmrprocView::OnTimerAllReset() - Reset timer count for all views.

</PRE><h2>REFERENCES</h2>
 
<P>
MSDN Technical Articles, C/C++ Articles, "Calling All Members: Member
Functions As Callbacks," by Dale Rogerson.
<P>

	</FONT>
	</TD>
	</TR>
</TABLE>
<P>


<!--DOCBODY_END-->

<!--FOOTER_START-->
<table cellpadding=5 border=0 width="90%">
<tr>
<td>
	<HR WIDTH="90%">

<BLOCKQUOTE>
<FONT FACE="Verdana, Arial, Helvetica" SIZE="1">
<SPAN STYLE="font-family:verdana,arial,helvetica; font-size:8pt">
Additional reference words: 1.00 1.50 1.51 1.52 2.00 2.10 4.00 tmrproc<BR>
settimer<BR>
KBCategory: kbprg kbfile<BR>
KBSubcategory: MfcMisc<BR>
Keywords          : MfcMisc kbfile kbprg<BR>
Technology        : kbMfc<BR>
Version           : 1.00 1.50 1.51 1.52 | 1.00 2.00<BR>
Platform          : NT WINDOWS<BR>

</SPAN>
</FONT>
<BR>
<BR>
THE INFORMATION PROVIDED IN THE MICROSOFT KNOWLEDGE BASE IS
PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND.  MICROSOFT DISCLAIMS
ALL WARRANTIES, EITHER EXPRESS OR IMPLIED, INCLUDING THE WARRANTIES
OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  IN NO
EVENT SHALL MICROSOFT CORPORATION OR ITS SUPPLIERS BE LIABLE FOR
ANY DAMAGES WHATSOEVER INCLUDING DIRECT, INDIRECT, INCIDENTAL,
CONSEQUENTIAL, LOSS OF BUSINESS PROFITS OR SPECIAL DAMAGES, EVEN IF
MICROSOFT CORPORATION OR ITS SUPPLIERS HAVE BEEN ADVISED OF THE
POSSIBILITY OF SUCH DAMAGES.  SOME STATES DO NOT ALLOW THE EXCLUSION
OR LIMITATION OF LIABILITY FOR CONSEQUENTIAL OR INCIDENTAL DAMAGES
SO THE FOREGOING LIMITATION MAY NOT APPLY.
</BLOCKQUOTE>
<P>
<center>
	<FONT FACE="Verdana,Arial,Helvetica" SIZE="1">
	Last reviewed:  July 31, 1997</FONT>
	<BR>
	<A href="../cpyright.htm" STYLE="font: bold 7pt Verdana,Arial,Helvetica">&copy; 1998 Microsoft Corporation. All rights reserved. Terms of Use.</A><BR>
	
</center>
</td>
</tr>
</table>

<!--FOOTER_END-->
</FONT>
</BODY>
</HTML>
