

<HTML>
<HEAD>
<TITLE>FIX: OnMessagePending Not Called When a Timer is Active </TITLE>

<!--STYLE_BEGIN-->
<style>@import url(../../msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="../../msdn_ie3.css">
<!--STYLE_END-->

<META HTTP-EQUIV="CONTENT-Type" CONTENT="text/html; charset=us-ascii">
<META NAME="ms.locale" CONTENT="EN-US">
<META NAME="Category" CONTENT="Support; KB Article">
<META NAME="KBID" CONTENT="Q137632">
<META NAME="KBModify" CONTENT="1997/09/18">
<META NAME="KBCreate" CONTENT="1995/10/02">
<META NAME="Keywords" CONTENT="MfcSockets kbbuglist kbfixlist kbprg">
<META NAME="KBArea" CONTENT="Support; KB; visualc">
<META NAME="Description" CONTENT="  An override of CSocket::OnMessagePending is not called for an application that has an active timer.  One symptom might be painting problems because the default implementation of OnMessagePending is responsible for allowing the processing of WM_PAIN...">
<META NAME="Product" CONTENT="Visual C++">
<META NAME="Platform" CONTENT="Windows">
<META NAME="Technology" CONTENT=" ">
<META NAME="Premium" CONTENT="support">

<META NAME="nyms" CONTENT="QAEV,QAGI,QAYC,QAH4,QBVV,QAY5,QATK,QBHQ,QAR4,QAEF,QAIF,QBFY,QA56,QA55,QAXB V02180118">
</HEAD>

<BODY BGCOLOR="#FFFFFF" LEFTMARGIN="0" RIGHTMARGIN="0" TOPMARGIN="0">


<!--DOCBODY_START-->
<BR>
<CENTER>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" VALIGN="top" WIDTH="90%">
	<TR>
		<TD VALIGN="top">
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<H1>FIX: OnMessagePending Not Called When a Timer is Active</H1>
			</FONT>
			<FONT FACE="verdana,arial,helvetica" SIZE="1">
			Last reviewed:  September 18, 1997</FONT><BR>
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<B>Article ID: Q137632</B>
			</FONT>
		</TD>
	</TR>
	<TR>
	<TD>
	<FONT FACE="Verdana, Arial, Helvetica" SIZE=2>



 
1.52 1.52b | 2.10 2.20
<PRE>WINDOWS    | WINDOWS NT
</PRE>kbprg kbbuglist kbfixlist
<P>
 
The information in this article applies to:

<UL><LI>The Microsoft Foundation Classes (MFC) included with:
<P>
<P><PRE>    - Microsoft Visual C++ for Windows, versions 1.52 and 1.52b
    - Microsoft Visual C++, 32-bit Edition, versions 2.1 and 2.2
</UL></PRE> 
<P>
<P><h2>SYMPTOMS</h2>
 
<P>
An override of CSocket::OnMessagePending is not called for an application
that has an active timer.
<P>
One symptom might be painting problems because the default implementation
of OnMessagePending is responsible for allowing the processing of WM_PAINT
messages during blocking CSocket operations.
<P>
<P><h2>CAUSE</h2>
 
<P>
The function CSocket::PumpMessages is responsible for the message
processing during a blocking CSocket operation. It uses its own timer
to enable idle-time processing to occur periodically.
<P>
In this function, the processing of WM_TIMER messages occurs before the
processing of other messages, except for the socket notification messages
themselves. When a WM_TIMER message arrives for a different timer, the
PumpMessages function simply leaves it in the queue. The problem with this
is that when a WM_TIMER message is found, the processing of other messages
does not occur.
<P>
All messages are being retrieved using PeekMessage(), and because the
unidentified WM_TIMER message is not removed from the queue, it is the only
message, other than the socket messages, that are retrieved in subsequent
calls to PeekMessage.
<P>
Because OnMessagePending is only called for non-WM_TIMER messages, and
because the only message being retrieved by PeekMessage() IS a WM_TIMER
message, OnMessagePending won't be called for any messages after the first
WM_TIMER message is received.
<P>
<P><h2>RESOLUTION</h2>
 
<P>
<P><h3>For 32-bit MFC (Included with Visual C++ 2.x)</h3>
 
<P>
The resolution entails changing the PumpMessages function so that it always
calls OnMessagePending. Currently it only calls OnMessagePending when a non-
WM_TIMER message is received:

<OL><P><LI>Override the PumpMessages function in your own CSocket-derived class.
   Borrow the implementation that already exists. It can be found in this
   file: \&lt;MSVC Directory&gt;\Mfc\Src\Sockcore.cpp

<P><LI>Replace the following code in your own PumpMessages implementation.
<P>
   Change this code:
<P>
<P><PRE>      else if (::PeekMessage(&amp;msg, NULL, 0, 0, PM_NOREMOVE) &amp;&amp;
<PRE></PRE>                 OnMessagePending())
      {
          // allow user-interface updates

   to this code:

      if (::PeekMessage(&amp;msg, NULL, 0, 0, PM_NOREMOVE) &amp;&amp;
            OnMessagePending())
      {
          // allow user-interface updates

</PRE><P><LI>Include the header file &lt;afxpriv.h&gt; in your CSocket-derived
   class' implementation file.

<P><LI>There is reference to the DELETE_EXCEPTION macro in this function. The
   DELETE_EXCEPTION macro is used internally by MFC. Delete this line:
<P>
   DELETE_EXCEPTION(e);
<P>
</OL><h3>For 16-bit MFC</h3>
 
<P>
The default implementation of PumpMessages (in Sockcore.cpp) accesses
private MFC data structures. Because of this, you cannot easily reimplement
this code in your application. It might be possible to temporarily remove
the timer (set by SetTimer) that is causing the problem, but if that is not
the case, then the simplest workaround would be to rebuild the MFC library
with the change shown above (changing the 'else if' to 'if').
<P>
Once the change has been made, you can rebuild the MFC libraries to
incorporate the change. For details on how to rebuild the MFC libraries,
please see the Readme.txt file in the Mfc\Src directory and Appendix A of
the Class Library User's Guide. Microsoft recommends building the static
versions so that you do not have to rely on the presence of your modified
library. Otherwise, you will need to rename MFC250(D).DLL so that it does
not conflict with other versions of the DLL that might be on a user's
system.
<P>
<P><h2>STATUS</h2>
 
<P>
Microsoft has confirmed this to be a bug in the Microsoft products listed
at the beginning of this article. This problem was corrected in the version
of MFC that ships with Microsoft Visual C++, 32-bit Edition, version 4.0.
<P>

	</FONT>
	</TD>
	</TR>
</TABLE>
<P>


<!--DOCBODY_END-->

<!--FOOTER_START-->
<table cellpadding=5 border=0 width="90%">
<tr>
<td>
	<HR WIDTH="90%">

<BLOCKQUOTE>
<FONT FACE="Verdana, Arial, Helvetica" SIZE="1">
<SPAN STYLE="font-family:verdana,arial,helvetica; font-size:8pt">
Additional reference words: 4.00 SetTimer OnTimer time-out<BR>
CancelBlockingCall 2.52 2.52b 2.53 2.10 2.20 3.10 3.20<BR>
KBCategory: kbprg kbbuglist kbfixlist<BR>
KBSubcategory: MfcSockets<BR>
Keywords          : MfcSockets kbbuglist kbfixlist kbprg<BR>
Technology        : kbMfc<BR>
Version           : 1.52 1.52b | 2.10 2.20<BR>
Platform          : NT WINDOWS<BR>
Solution Type     : kbfix<BR>

</SPAN>
</FONT>
<BR>
<BR>
THE INFORMATION PROVIDED IN THE MICROSOFT KNOWLEDGE BASE IS
PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND.  MICROSOFT DISCLAIMS
ALL WARRANTIES, EITHER EXPRESS OR IMPLIED, INCLUDING THE WARRANTIES
OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  IN NO
EVENT SHALL MICROSOFT CORPORATION OR ITS SUPPLIERS BE LIABLE FOR
ANY DAMAGES WHATSOEVER INCLUDING DIRECT, INDIRECT, INCIDENTAL,
CONSEQUENTIAL, LOSS OF BUSINESS PROFITS OR SPECIAL DAMAGES, EVEN IF
MICROSOFT CORPORATION OR ITS SUPPLIERS HAVE BEEN ADVISED OF THE
POSSIBILITY OF SUCH DAMAGES.  SOME STATES DO NOT ALLOW THE EXCLUSION
OR LIMITATION OF LIABILITY FOR CONSEQUENTIAL OR INCIDENTAL DAMAGES
SO THE FOREGOING LIMITATION MAY NOT APPLY.
</BLOCKQUOTE>
<P>
<center>
	<FONT FACE="Verdana,Arial,Helvetica" SIZE="1">
	Last reviewed:  September 18, 1997</FONT>
	<BR>
	<A href="../cpyright.htm" STYLE="font: bold 7pt Verdana,Arial,Helvetica">&copy; 1998 Microsoft Corporation. All rights reserved. Terms of Use.</A><BR>
	
</center>
</td>
</tr>
</table>

<!--FOOTER_END-->
</FONT>
</BODY>
</HTML>
