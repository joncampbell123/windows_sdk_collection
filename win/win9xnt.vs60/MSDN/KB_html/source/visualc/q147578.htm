

<HTML>
<HEAD>
<TITLE>CWnd Derived MFC Objects and Multi-threaded Applications </TITLE>

<!--STYLE_BEGIN-->
<style>@import url(../../msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="../../msdn_ie3.css">
<!--STYLE_END-->

<META HTTP-EQUIV="CONTENT-Type" CONTENT="text/html; charset=us-ascii">
<META NAME="ms.locale" CONTENT="EN-US">
<META NAME="Category" CONTENT="Support; KB Article">
<META NAME="KBID" CONTENT="Q147578">
<META NAME="KBModify" CONTENT="1997/10/10">
<META NAME="KBCreate" CONTENT="1996/02/26">
<META NAME="Keywords" CONTENT="MFCThreadIss kbprg kbusage">
<META NAME="KBArea" CONTENT="Support; KB; visualc">
<META NAME="Description" CONTENT="  In a multi-threaded application written using MFC, you should not pass MFC objects across thread boundaries. As a general rule, a thread should access only those MFC objects that it creates. Failure to do so may cause run-time problems including as...">
<META NAME="Product" CONTENT="Visual C++">
<META NAME="Platform" CONTENT="Windows">
<META NAME="Technology" CONTENT=" ">
<META NAME="Premium" CONTENT="support">

<META NAME="nyms" CONTENT="QAUQ,QAW6,QAPN,QAGI,QAY5,QAH6,QAH7,QAD7,QAIB,QABH,QABI,QAIF,QBV8,QAB9,QAH4 V02180118">
</HEAD>

<BODY BGCOLOR="#FFFFFF" LEFTMARGIN="0" RIGHTMARGIN="0" TOPMARGIN="0">


<!--DOCBODY_START-->
<BR>
<CENTER>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" VALIGN="top" WIDTH="90%">
	<TR>
		<TD VALIGN="top">
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<H1>CWnd Derived MFC Objects and Multi-threaded Applications</H1>
			</FONT>
			<FONT FACE="verdana,arial,helvetica" SIZE="1">
			Last reviewed:  October 10, 1997</FONT><BR>
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<B>Article ID: Q147578</B>
			</FONT>
		</TD>
	</TR>
	<TR>
	<TD>
	<FONT FACE="Verdana, Arial, Helvetica" SIZE=2>



 
2.00 2.10 2.20 4.00
WINDOWS NT
kbprg kbusage
<P>
 
The information in this article applies to:

<UL><LI>The Microsoft Foundation Classes included with:
   Microsoft Visual C++, 32-bit Edition, versions 2.0, 2.1, 2.2, 4.0
</UL> 
<P>
<P><h2>SUMMARY</h2>
 
<P>
In a multi-threaded application written using MFC, you should not pass MFC
objects across thread boundaries. As a general rule, a thread should access
only those MFC objects that it creates. Failure to do so may cause run-time
problems including assertions or unexpected program behavior.
<P>
<P><h2>MORE INFORMATION</h2>
 
<P>
In a Win32 process, all the threads running in the process address space
can view all global and static data. A thread can use thread-local-storage
(TLS) to store any thread-specific data.
<P>
In a multi-threaded environment because windows are owned by threads, MFC
keeps the temporary and permanent window handle map in thread local
storage. The same is true for other handle maps like those for GDI objects
and device contexts. Keeping the window handle maps in thread local storage
ensures protection against simultaneous access by several threads.
<P>
The behavior of the functions CHandleMap::LookupPermanent() and
CHandleMap::LookupTemporary() is a direct consequence of these facts. Given
a window handle, these functions check the permanent and temporary window
handle maps of the current thread for the existence of an associated CWnd
derived MFC object. This means that if calls to these functions are made
from a thread to search for MFC objects that represent windows created in
other threads, these calls will fail.
<P>
There are several functions that call CHandleMap::LookupPermanent() and
CHandleMap::LookupTemporary(). CWnd::AssertValid() (and hence the macro
ASSERT_VALID for a CWnd object) is one such function. This function is
called to make validity checks on an object. If AssertValid() fails to find
an entry for the MFC object's m_hWnd member in any of the handle maps or
finds an incorrect entry, it fires an assertion. In Visual C++ 2.1, these
assertions are in file Wincore.cpp, lines 797 and 798. In Visual C++ 2.2,
they are in Wincore.cpp, lines 804 and 805. In Visual C++ 4.0, they are in
Wincore.cpp, lines 871 and 872.
<P>
Calls to the ASSERT_VALID macro are sprinkled all over the MFC source code.
Hence, from a particular thread, if you end up calling a function that
calls ASSERT_VALID on MFC window objects that belong to some other thread,
you get an assertion. If you do not get an assertion, you may still get
abnormal behavior because you are not allowed to directly manipulate
windows created by other threads.
<P>
The correct approach in such situations is to work with window handles, not
MFC objects. It is safe to pass window handles across thread boundaries.
If thread A passes a window handle to thread B, then thread B can use this
window handle to send or post messages to the window. When these messages
are processed, you are back in the context of thread A and calls to
CWnd::AssertValid() to check thread A's window handle maps will succeed.
<P>
In this scenario, thread B can also use the CWnd::FromHandle() function to
get a temporary CWnd object which is placed in thread B's temporary handle
map. However this object may be of only limited use, because in no way is
it in synchronization with the MFC object existing in thread A's handle
maps.
<P>
<P><h2>REFERENCES</h2>
 
<P>
MFC Encyclopedia article "Multithreading:Programming Tips" in the Window
Handle Maps section.
<P>
MFC Tech Note 3 "Mapping of Windows Handles to Objects."
<P>
MFC Source File Wincore.cpp, the function CWnd::AssertValid().
<P>

	</FONT>
	</TD>
	</TR>
</TABLE>
<P>


<!--DOCBODY_END-->

<!--FOOTER_START-->
<table cellpadding=5 border=0 width="90%">
<tr>
<td>
	<HR WIDTH="90%">

<BLOCKQUOTE>
<FONT FACE="Verdana, Arial, Helvetica" SIZE="1">
<SPAN STYLE="font-family:verdana,arial,helvetica; font-size:8pt">
Additional reference words: kbinf 2.00 2.10 2.20 3.00 3.10 3.20 4.00<BR>
threads assertion<BR>
KBCategory: kbprg kbusage<BR>
KBSubcategory: MFCThreadIss<BR>
Keywords          : MFCThreadIss kbprg kbusage<BR>
Technology        : kbMfc<BR>
Version           : 2.00 2.10 2.20 4.00<BR>
Platform          : NT WINDOWS<BR>

</SPAN>
</FONT>
<BR>
<BR>
THE INFORMATION PROVIDED IN THE MICROSOFT KNOWLEDGE BASE IS
PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND.  MICROSOFT DISCLAIMS
ALL WARRANTIES, EITHER EXPRESS OR IMPLIED, INCLUDING THE WARRANTIES
OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  IN NO
EVENT SHALL MICROSOFT CORPORATION OR ITS SUPPLIERS BE LIABLE FOR
ANY DAMAGES WHATSOEVER INCLUDING DIRECT, INDIRECT, INCIDENTAL,
CONSEQUENTIAL, LOSS OF BUSINESS PROFITS OR SPECIAL DAMAGES, EVEN IF
MICROSOFT CORPORATION OR ITS SUPPLIERS HAVE BEEN ADVISED OF THE
POSSIBILITY OF SUCH DAMAGES.  SOME STATES DO NOT ALLOW THE EXCLUSION
OR LIMITATION OF LIABILITY FOR CONSEQUENTIAL OR INCIDENTAL DAMAGES
SO THE FOREGOING LIMITATION MAY NOT APPLY.
</BLOCKQUOTE>
<P>
<center>
	<FONT FACE="Verdana,Arial,Helvetica" SIZE="1">
	Last reviewed:  October 10, 1997</FONT>
	<BR>
	<A href="../cpyright.htm" STYLE="font: bold 7pt Verdana,Arial,Helvetica">&copy; 1998 Microsoft Corporation. All rights reserved. Terms of Use.</A><BR>
	
</center>
</td>
</tr>
</table>

<!--FOOTER_END-->
</FONT>
</BODY>
</HTML>
