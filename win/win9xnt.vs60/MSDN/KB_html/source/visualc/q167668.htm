

<HTML>
<HEAD>
<TITLE>HOWTO: Pass a SafeArray of Strings in a VARIANT* </TITLE>

<!--STYLE_BEGIN-->
<style>@import url(../../msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="../../msdn_ie3.css">
<!--STYLE_END-->

<META HTTP-EQUIV="CONTENT-Type" CONTENT="text/html; charset=us-ascii">
<META NAME="ms.locale" CONTENT="EN-US">
<META NAME="Category" CONTENT="Support; KB Article">
<META NAME="KBID" CONTENT="Q167668">
<META NAME="KBModify" CONTENT="1997/07/31">
<META NAME="KBCreate" CONTENT="1997/04/28">
<META NAME="Keywords" CONTENT="MfcOLE VBKBAutomation kbfasttip">
<META NAME="KBArea" CONTENT="Support; KB; visualc">
<META NAME="Description" CONTENT="  When you look at the information available on passing SafeArrays between Visual C++ and Visual Basic, most pass the SafeArray in a parameter of type VARIANT. In MFC this translates into a  const VARIANT* varName  parameter. As an alternative, this ...">
<META NAME="Product" CONTENT="Visual C++">
<META NAME="Platform" CONTENT="Windows">
<META NAME="Technology" CONTENT=" ">
<META NAME="Premium" CONTENT="support">

<META NAME="nyms" CONTENT="QAD7,QAH6,QAH7,QBS0,QAG1,QA2K,QAUD,QAPN,QAH4,QAHE,QBWS,QAYZ,QAYV,QATX,QAMB V02180118">
</HEAD>

<BODY BGCOLOR="#FFFFFF" LEFTMARGIN="0" RIGHTMARGIN="0" TOPMARGIN="0">


<!--DOCBODY_START-->
<BR>
<CENTER>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" VALIGN="top" WIDTH="90%">
	<TR>
		<TD VALIGN="top">
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<H1>HOWTO: Pass a SafeArray of Strings in a VARIANT*</H1>
			</FONT>
			<FONT FACE="verdana,arial,helvetica" SIZE="1">
			Last reviewed:  July 31, 1997</FONT><BR>
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<B>Article ID: Q167668</B>
			</FONT>
		</TD>
	</TR>
	<TR>
	<TD>
	<FONT FACE="Verdana, Arial, Helvetica" SIZE=2>



 
 
The information in this article applies to:

<UL><LI>The Microsoft Foundation Classes (MFC) included with:
   - Microsoft Visual C++, 32-bit Editions, versions 2.0, 2.1, 2.2, 4.0,
<P><PRE>     4.0a, 4.1, 4.2, 4.2b, 5.0
</UL></PRE> 
<P>
<P><h2>SUMMARY</h2>
 
<P>
When you look at the information available on passing SafeArrays between
Visual C++ and Visual Basic, most pass the SafeArray in a parameter of type
VARIANT. In MFC this translates into a "const VARIANT&amp; varName" parameter.
As an alternative, this article explores how to pass a VARIANT* which in
MFC will be declared as a "VARIANT FAR* varName" parameter.
<P>
So why should you use one method over the other? Because most applications
allow modifications to a SafeArray passed in a VARIANT, but not all. In
Excel 95, you can pass a SafeArray in a VARIANT to a Visual C++ server,
modify the values in the server, return the modified SafeArray, and there
is no change in Excel 95. Another reason to use this technique is to work
around a limitation in Visual Basic when you use early binding.
<P>
<P><h2>MORE INFORMATION</h2>
 
<P>
To demonstrate this concept, start with a new "MFC AppWizard(exe)" project
called StrArray. In "Step 3 of 6," select Automation, and then click Finish
and OK to generate the project files.
<P>
Now create a single automation method using ClassWizard. In ClassWizard,
select "CStrArrayDoc" under "Class name:". Click the Automation Tab and
click "Add Method..." Enter the following values into the Add Method
dialog box:
<P>
<PRE>   External Name : Sort
   Internal Name : Sort
   Return Type   : long
   Parameter List:
      Name       : vArray
      Type       : VARIANT*

</PRE>Click OK and Edit Code.
<P>
To implement the Sort method, use the FastSort method of the MFCARRAY
sample mentioned in the REFERENCES section below. This allows you to see
the differences between passing the parameter as a "const VARIANT&amp; varName"
and a "VARIANT* varName". Modify the Sort method as follows:
<P>
<PRE>   ...
   #include &lt;afxpriv.h&gt;
   ...
   long CStrArrayDoc::Sort(VARIANT FAR* vArray)
   {
      long i, j, min;
      BSTR bstrTemp;
      SAFEARRAY FAR* psa = NULL;
      BSTR HUGEP *pbstr;
      HRESULT hr;
      DWORD dwTimeStart;
      LONG cElements, lLBound, lUBound;

      USES_CONVERSION;

      // Type check VARIANT parameter. It should contain a BSTR array
      // passed by reference. The array must be passed by reference it is
      // an in-out-parameter.
      if (V_VT(vArray) != (VT_ARRAY | VT_BSTR))
         AfxThrowOleDispatchException(1001,
           "Type Mismatch in Parameter. Pass a string array by reference");
      psa = V_ARRAY(vArray);
      // Check dimensions of the array.
      if (SafeArrayGetDim(psa) != 1)
         AfxThrowOleDispatchException(1002,
           "Type Mismatch in Parameter. Pass a one-dimensional array");

      dwTimeStart = GetTickCount();

      // Get array bounds.
      hr = SafeArrayGetLBound(psa, 1, &amp;lLBound);
      if (FAILED(hr))
          goto error;
      hr = SafeArrayGetUBound(psa, 1, &amp;lUBound);
      if (FAILED(hr))
          goto error;

      // Get a pointer to the elements of the array.
      hr = SafeArrayAccessData(psa, (void HUGEP* FAR*)&amp;pbstr);
      if (FAILED(hr))
         goto error;

      // Bubble sort.
      cElements = lUBound-lLBound+1;
      for (i = 0; i &lt; cElements-1; i++)
      {
         min = i;
         for (j = i+1; j &lt; cElements; j++)
         {
            // NULL is a valid value for a BSTR. This code treats a NULL
            // BSTR as less than other string values.
            if (pbstr[min] == NULL)
               continue;
            else if (pbstr[j] == NULL
               || lstrcmp(OLE2T(pbstr[j]), OLE2T(pbstr[min])) &lt; 0)
               min = j;
         }

         //Swap array[min] and array[i].
         bstrTemp = pbstr[min];
         pbstr[min] = pbstr[i];
         pbstr[i] = bstrTemp;
      }

      hr = SafeArrayUnaccessData(psa);
      if (FAILED(hr))
         goto error;

      return GetTickCount()-dwTimeStart;

   error:
      AfxThrowOleDispatchException(1003,
        "Unexpected Failure in FastSort method");
      return 0;
   }

</PRE>Now you can build and test the automation server. After you build the
server, run it as a stand-alone to register it. Run Visual Basic and create
a new Visual Basic project. Place a button on the form and modify the
handler to match the code below:
<P>
<PRE>   Private Sub Command1_Click()
      Dim o As Object
      Dim v As Variant
      ReDim v(50) As String
      Dim SortTime As Long

      Set o = CreateObject("StrArray.Document")

      upperbound = 1
      lowerbound = 100
      For n = 0 To 50
          v(n) = "Entry " &amp; Int((upperbound-lowerbound+1)*Rnd+lowerbound)
      Next n

      SortTime = o.Sort(v)
      MsgBox ("Done")
   End Sub

</PRE>The key to getting this syntax to work in Visual Basic is to first Dim the
array variable as a variant, and then ReDim it so that it becomes a variant
containing an array of strings. Now you are ready to test the server. Set
break points in the Visual Basic code before and after the call to Sort.
Run the Visual Basic application, click Command1 and use the watch window
to check the values for v.
<P>
<P><h2>REFERENCES</h2>
 
<P>
For more information, please see the following articles in the Microsoft
Knowledge Base:
<P>
<PRE>   ARTICLE-ID: <B><A href="../oleprog/q122287.htm">Q122287</A></B>
   TITLE     : Limits of VB 3.0 Disptest as Automation Controllers

   ARTICLE-ID: <B><A href="../oleprog/q131046.htm">Q131046</A></B>
   TITLE     : SAMPLE: BINARY: Transfer Binary Data Using OLE Automation

   ARTICLE-ID: <B><A href="../oleprog/q131086.htm">Q131086</A></B>
   TITLE     : SAMPLE: SAFEARAY: Use of Safe Arrays in Automation

   ARTICLE-ID: <B><A href="../oleprog/q140202.htm">Q140202</A></B>
   TITLE     : SAMPLE: MFCARRAY: Using Safe Arrays in MFC Automation

   ARTICLE-ID: <B><A href="../oleprog/q122289.htm">Q122289</A></B>
   TITLE     : Passing Structures in OLE Automation

   ARTICLE-ID: <B><A href="../visualc/q154172.htm">Q154172</A></B>
   TITLE     : How to Pass Binary Data Between an ActiveX Control and VB

</PRE>Microsoft Systems Journal, June 1996, "Q&amp;A OLE" by Don Box.
<P>
(c) Microsoft Corporation 1997, All Rights Reserved.
Contributions by Shawn W. Karr, Microsoft Corporation
 
<PRE>Keywords          : MfcOLE VBKBAutomation kbfasttip
Technology        : kbole kbmfc
Version           : 2.0 2.1 2.2 4.0 4.0a 4.1 4.2 5.0
Platform          : NT WINDOWS
Issue type        : kbhowto</PRE>

	</FONT>
	</TD>
	</TR>
</TABLE>
<P>


<!--DOCBODY_END-->

<!--FOOTER_START-->
<table cellpadding=5 border=0 width="90%">
<tr>
<td>
	<HR WIDTH="90%">

<BLOCKQUOTE>
<FONT FACE="Verdana, Arial, Helvetica" SIZE="1">
<SPAN STYLE="font-family:verdana,arial,helvetica; font-size:8pt">
================================================================================<BR>

</SPAN>
</FONT>
<BR>
<BR>
THE INFORMATION PROVIDED IN THE MICROSOFT KNOWLEDGE BASE IS
PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND.  MICROSOFT DISCLAIMS
ALL WARRANTIES, EITHER EXPRESS OR IMPLIED, INCLUDING THE WARRANTIES
OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  IN NO
EVENT SHALL MICROSOFT CORPORATION OR ITS SUPPLIERS BE LIABLE FOR
ANY DAMAGES WHATSOEVER INCLUDING DIRECT, INDIRECT, INCIDENTAL,
CONSEQUENTIAL, LOSS OF BUSINESS PROFITS OR SPECIAL DAMAGES, EVEN IF
MICROSOFT CORPORATION OR ITS SUPPLIERS HAVE BEEN ADVISED OF THE
POSSIBILITY OF SUCH DAMAGES.  SOME STATES DO NOT ALLOW THE EXCLUSION
OR LIMITATION OF LIABILITY FOR CONSEQUENTIAL OR INCIDENTAL DAMAGES
SO THE FOREGOING LIMITATION MAY NOT APPLY.
</BLOCKQUOTE>
<P>
<center>
	<FONT FACE="Verdana,Arial,Helvetica" SIZE="1">
	Last reviewed:  July 31, 1997</FONT>
	<BR>
	<A href="../cpyright.htm" STYLE="font: bold 7pt Verdana,Arial,Helvetica">&copy; 1998 Microsoft Corporation. All rights reserved. Terms of Use.</A><BR>
	
</center>
</td>
</tr>
</table>

<!--FOOTER_END-->
</FONT>
</BODY>
</HTML>
