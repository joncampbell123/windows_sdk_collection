

<HTML>
<HEAD>
<TITLE>HOWTO: Debug OLE Applications </TITLE>

<!--STYLE_BEGIN-->
<style>@import url(../../msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="../../msdn_ie3.css">
<!--STYLE_END-->

<META HTTP-EQUIV="CONTENT-Type" CONTENT="text/html; charset=us-ascii">
<META NAME="ms.locale" CONTENT="EN-US">
<META NAME="Category" CONTENT="Support; KB Article">
<META NAME="KBID" CONTENT="Q154116">
<META NAME="KBModify" CONTENT="1997/10/07">
<META NAME="KBCreate" CONTENT="1996/07/29">
<META NAME="Keywords" CONTENT="WBDebug kbinterop">
<META NAME="KBArea" CONTENT="Support; KB; visualc">
<META NAME="Description" CONTENT="  This article provides a tutorial to assist you in learning how to use the Visual C++ integrated debugger to debug OLE applications.  The Visual C++ integrated debugger supports simultaneous debugging of OLE client and server applications. You can e...">
<META NAME="Product" CONTENT="Visual C++">
<META NAME="Platform" CONTENT="Windows">
<META NAME="Technology" CONTENT=" ">
<META NAME="Premium" CONTENT="support">

<META NAME="nyms" CONTENT="QAGI,QASR,QAW6,QAH4,QA9Q,QAY4,QAIF,QAPN,QBQU,QAB9,QBV8,QAVX,QAY5,QBXS,QAYZ V02180118">
</HEAD>

<BODY BGCOLOR="#FFFFFF" LEFTMARGIN="0" RIGHTMARGIN="0" TOPMARGIN="0">


<!--DOCBODY_START-->
<BR>
<CENTER>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" VALIGN="top" WIDTH="90%">
	<TR>
		<TD VALIGN="top">
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<H1>HOWTO: Debug OLE Applications</H1>
			</FONT>
			<FONT FACE="verdana,arial,helvetica" SIZE="1">
			Last reviewed:  October 7, 1997</FONT><BR>
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<B>Article ID: Q154116</B>
			</FONT>
		</TD>
	</TR>
	<TR>
	<TD>
	<FONT FACE="Verdana, Arial, Helvetica" SIZE=2>



 
 
The information in this article applies to:

<UL><LI>The integrated debugger included with:
   - Microsoft Visual C++, 32-bit Edition, versions 2.0, 2.1, 2.2, 4.0,
<P><PRE>     4.1, 4.2, 5.0
</UL></PRE> 
<P>
<P><h2>SUMMARY</h2>
 
<P>
This article provides a tutorial to assist you in learning how to use
the Visual C++ integrated debugger to debug OLE applications.
<P>
The Visual C++ integrated debugger supports simultaneous debugging of
OLE client and server applications. You can easily step across and
into OLE clients and servers and have the ability to step across OLE Remote
Procedure Calls. A second instance of the debugger is automatically
spawned the first time an OLE client calls into an OLE server.
<P>
When building OLE servers, you may want to debug them in the context of
being activated by an OLE container, thus debugging both the container
and the server at the same time. This tutorial provides an example of
how to debug an OLE server when the main debuggee is an OLE container.
It shows how a second instance of the debugger is automatically spawned
when an OLE client calls into an OLE server. The tutorial is designed to
lead you step-by-step through the code that creates the OLE server
object and establishes the connection between the OLE container and the
OLE server. This is useful in tracking down problems that occur when the
OLE server does not get created or initialized correctly.
<P>
All regular debugging facilities are available as you debug your OLE
application.
<P>
<P><h2>MORE INFORMATION</h2>
 
<P>
<P><h3>Preparing to Debug</h3>
 
<P>
To prepare for OLE Client/Server debugging:

<OL><P><LI>Open the project for the OLE application and build a version with
   symbolic debugging information.

<P><LI>From the Tools menu, choose Options. Select the Debug tab. Ensure that
   the OLE RPC Debugging check box and the Just-In-Time (JIT) Debugging
   boxes are checked. (You must have Windows NT administrator privileges
   to enable OLE RPC Debugging.)

<P><LI>Choose OK. The information is now stored in the registry.

<P><LI>Set breakpoints at the points in the source files for your OLE
   application where you want to determine the state of the application.

<P><LI>Start a debugging session.
<P>
</OL><h3>Viewing Derived-Most Types</h3>
 
<P>
The QuickWatch dialog box provides support for the automatic downcast of
pointers in OLE and MFC debugging. The debugger automatically detects
when a pointer is pointing to a subclass of the type it is required to
point to. When the pointer is expanded, Visual C++ will add an extra
member that looks like another base class and indicates the
derived-most type. For example, if you are displaying a pointer to a
CObject and the pointer really points to a CComboBox, the QuickWatch
expression evaluator will recognize this and introduce a pseudo
CComboBox member so you can access the CComboBox members.
<P>
The rest of this tutorial takes you through a debug session, using MFC
sample code.
<P>
<P><h3>Creating the Object</h3>
 

<OL><P><LI> Build debug versions of the Microsoft Foundation Classes (MFC)
<P><PRE>    samples in the development environment. For Visual C++ 2.x, the
    projects to work with are in the following directories on the CD-ROM:
</PRE><P>
<P><PRE>     - MSVC20\SAMPLES\MFC\CONTAIN\STEP2
</PRE><P>
<P><PRE>     - MSVC20\SAMPLES\MFC\SCRIBBLE\STEP7
</PRE><P>
<P><PRE>    For Visual C++ 4.x, the projects to work with are in the following
    directories on the CD-ROM:
</PRE><P>
<P><PRE>     - MSDEV\SAMPLES\MFC\TUTORIAL\CONTAIN\STEP2
</PRE><P>
<P><PRE>     - MSDEV\SAMPLES\MFC\TUTORIAL\SCRIBBLE\STEP7
</PRE><P>
<P><PRE>    For Visual C++ 5.0, use the InfoViewer to copy the samples and use the
    default directories for copying. The sample names are same, CONTAINER
    and SCRIBBLE.
</PRE>
<P><LI> Run the SCRIBBLE.EXE file built in step 1 to update the registry to
<P><PRE>    point to this executable file.
</PRE>
<P><LI> Load the CONTAIN\STEP2 project into the development environment.

<P><LI> From the Tools menu, choose Options. Select the Debug tab, and make
<P><PRE>    sure OLE RPC Debugging is enabled as described in step 4 of the
    "Preparing to Debug" section in this article.
</PRE>
<P><LI> Open the CONTRVW.CPP file in CONTAIN\STEP2, and set a breakpoint on
<P><PRE>    the line that contains a call to CreateItem.
</PRE>
<P><LI> Start a debugging session to run CONTAIN.EXE. In the CONTAIN main
<P><PRE>    menu, choose Insert New Object from the Edit menu.
</PRE>
<P><LI> From the resulting Object Type list, choose Scrib Document, and then
<P><PRE>    choose the OK button. At this point, the debugger should stop at the
    breakpoint you set in step 5. This is the call to the Insert Object
    dialog's CreateItem function. The purpose of CreateItem is to create
    and initialize an object of the type you selected from the dialog
    box. The CreateItem function is passed a CCntrItem object and uses
    the object to handle this process.
</PRE><P>
<P><PRE>    NOTE: For a brief overview of what CCntrItem does, see its class
    definition in CNTRITEM.H. Then look at the definition of COleClientItem
    (from which CCntrItem is derived) in AFXOLE.H.
</PRE>
<P><LI> Step into the call to CreateItem. You are in the MFC source file
<P><PRE>    OLEDLGS1.CPP. Step over instructions until you get to the call to
    pNewItem-&gt;CreateItem.
</PRE>
<P><LI> Step into the call to pNewItem-&gt;CreateNewItem. Then step over
<P><PRE>    instructions until you get to the call to OleCreate. While stepping
    through the code, read the comments and note that storage is
    allocated for the object and its rendering format is established.
</PRE>
<P><LI>Step into the call to OleCreate. At this point, execution proceeds
<P><PRE>    through the RPC mechanism to the server code itself. Therefore, as
    the server code begins to execute, a new instance of the debugger is
    created in which to debug the server. A pseudo project for
    SCRIBBLE.EXE is loaded (as in JIT debugging), and the instruction
    pointer is set at the call to
    COleServerDoc::XPersistStorage::InitNew in OLESRV1.CPP. If you
    installed the .DBG files (see the "NT System Symbols Setup" icon in
    your Visual C++ program group), your callstack will include fully
    decorated names.
</PRE>
<P><LI>Step over instructions in Scribble's InitNew until you reach the
<P><PRE>    call to pThis-&gt;OnNewEmbedding. Then step into OnNewEmbedding.
</PRE>
<P><LI>Step over lines until you reach the call to OnNewDocument. Then step
<P><PRE>    into the call to COleServerDoc::OnNewDocument. You are now inside
    COleLinkingDoc::OnNewDocument. (COleServerDoc is derived from
    COleLinkingDoc.) Note the code in this small function: It creates
    a new document object and attaches it to the server (Scribble).
</PRE>
<P><LI>Step out twice to get back into
<P><PRE>    COleServerDoc::XPersistStorage::InitNew, where you first came into
    Scribble.
</PRE>
<P><LI>Step out one more time. This will cause the container to return from
<P><PRE>    its call to OleCreate, the function that first took you into Scribble.
    At this time, the instance of the debugger that has Contain loaded
    gets the focus, and you are back in OLECLI1.CPP immediately following
    the call to OleCreate. The embedded Scribble object has now been
    created but it is not yet fully initialized.
</PRE>
<P><LI>Step into the next line, which is the call to FinishCreate. Step
<P><PRE>    through the FinishCreate code to see how OLE finalizes the connection
    between the container and the server, and then step out of
    FinishCreate.
</PRE><P>
</OL>A Scribble object has now been created and initialized in memory, but it
is not yet editable in the container; Scribble hasn't been activated. In
fact, Contain still has only an IUnknown interface to Scribble. You can
see this by expanding the lpClientSite variable in the Locals Window.
<P>
<P><h3>Activating the Object</h3>
 

<OL><P><LI> Step out two more times to get back to Contain's OnInsertObject
<P><PRE>    function in CONTRVW.CPP.
</PRE>
<P><LI> In Contain's OnInsertObject function, step over five times to get to
<P><PRE>    the call to DoVerb. This function activates Scribble.
</PRE>
<P><LI> Step into the call to DoVerb. Then step over a few lines until you
<P><PRE>    come to the call to Activate.
</PRE>
<P><LI> Step into Activate. You are now in OLECLI3.CPP. Before going on, scan
<P><PRE>    through the code for Activate. Notice that a rectangle is first
    created for the embedded Scribble item to live in. GetClientSite
    is then called to establish an interface back to the container for the
    Scribble server. Then the server's DoVerb function is called to pass
    both of these to the server.
</PRE>
<P><LI> Step into the call to DoVerb. At this point, execution proceeds once
<P><PRE>    again through the RPC mechanism to the server code itself. As you
    would expect, the instruction pointer is pointing to the first
    instruction in the server's COleServerDoc:: XOleObject::DoVerb
    function.
</PRE>
<P><LI> Step to the call to OnDoVerb. Then step into OnDoVerb. OnDoVerb
<P><PRE>    consists of a switch statement that executes the command (verb)
    passed to it. In this case, the command is OLEIVERB_SHOW. Step over
    instructions until you get to OnShow.
</PRE>
<P><LI> Step into OnShow. Then step three lines to ActivateInPlace, and step
<P><PRE>    into ActivateInPlace.
</PRE><P>
<P><PRE>    The ActivateInPlace function does many things and is worth examining
    in detail. While it is beyond the scope of this tutorial to go into
    all the details, it is worthwhile to step through the code and
    observe the comments. At this point, step over each instruction until
    you get to the call to OnFrameWindowActivate in OLESRV1.CPP. Among
    other things, you will see the following tasks accomplished:
</PRE><P>
<P><PRE>     - Get the document type used in SetActiveObject calls.
</PRE><P>
<P><PRE>     - Get the in-place client-site interface.
</PRE><P>
<P><PRE>     - See if the container wants to go in-place right now.
</PRE><P>
<P><PRE>     - Get the parent window to create the COleIPFrameWnd.
</PRE><P>
<P><PRE>     - Create the inplace frame window.
</PRE><P>
<P><PRE>     - Send an activate notification to the container.
</PRE><P>
<P><PRE>     - Get the frame and doc window interfaces as well as other
       information.
</PRE><P>
<P><PRE>     - Set up the shared menu.
</PRE><P>
<P><PRE>     - Allow the server to install frame controls in the container.
</PRE><P>
<P><PRE>     - Update the zoom factor information before creating control bars.
</PRE><P>
<P><PRE>     - Resize the window to match the object.
</PRE><P>
<P><PRE>     - Set the active object.
</PRE><P>
<P><PRE>     - Add the frame and the document-level frame controls.
</PRE><P>
<P><PRE>     - Show any hidden modeless dialogs.
</PRE><P>
<P><PRE>     - Attempt toolbar negotiation.
</PRE><P>
<P><PRE>     - Install the menu and a hook that forwards messages from the menu
       to the inplace frame window.
</PRE><P>
<P><PRE>     - Make sure the object is scrolled into view.
</PRE><P>
<P><PRE>     - Show the inplace frame window and set the focus.
</PRE><P>
<P><PRE>    As you can see, ActivateInPlace does a lot of work and is very
    RPC-intensive.
</PRE>
<P><LI> Step into the first line of OnFrameWindowActivate. Observe that this
<P><PRE>    function sends the final notifications via the container to activate
    the server.
</PRE>
<P><LI> Continue the debugging session to finish executing
<P><PRE>    OnFrameWindowActivate. Under normal circumstances, Scribble would
    come up already activated in place within Contain. However, in this
    case, you have already executed past the code that set the focus to
    the activated server. Remember the call to pFrameWnd-&gt;SetFocus in the
    ActivateInPlace function in OLESRV1.CPP? By continuing to step
    through the code, you have reset the focus back to the debugger.
    Therefore, you must now switch tasks manually to Contain.
</PRE>
<P><LI>Switch tasks to Contain. You will see Scribble's menu and toolbar
<P><PRE>    within Contain, and you will be able to draw in the embedded item's
    rectangle.
</PRE><P>
</OL><h3>Finishing the Debug Session</h3>
 
<P>
When you finish with Scribble, close the document window. Contain's menu
and toolbar reappear and the Scribble debugging session ends within the
second instance of the debugger.
<P>
Although Scribble has terminated, the second instance of the debugger is
still running. To avoid complications, terminate the second instance of
the debugger. You need to do this because whenever you call into a
server to embed a new item or activate an existing one, the debugger
will start another instance to debug this server, even if it is the same
server that is already attached to another item in the document.
Therefore, it is possible (but not desirable) to have multiple instances
of the debugger debugging multiple instances of the same server all
connected to the same container.
<P>
Once the second instance of the debugger has been terminated, it is safe
to embed another Scrib Document object in Contain. It is not necessary
to terminate the container before doing so.
<P>
<P><h3>Trying New Things in Future Debug Sessions</h3>
 
<P>
Try stepping into (rather than over) some of the function calls. The
flow of control goes back and forth between the container and the server
many times, and the debugger will track this flow accurately, bringing
you into container code, then server code, and so forth. Functions of
interest include:
<P>
<PRE>   CanInPlaceActivate
   OnInPlaceActivate
   GetWindow
   OnUIActivate
   GetWindowContext
   SetActiveObject
   SetMenu
   ShowObject

</PRE></OL>The server maintains several pointers (interfaces) into the container's
code through which it calls the container's member functions. These
pointers include m_lpClientSite, lpInPlaceSite, and pFrameWnd.
 
<PRE>Keywords          : WBDebug kbinterop
Technology        : kbMfc kbole
Version           : WINNT:2.0,2.1,2.2,4.0,4.1,4.2,5.0;
Platform          : NT WINDOWS
Issue type        : kbhowto</PRE>

	</FONT>
	</TD>
	</TR>
</TABLE>
<P>


<!--DOCBODY_END-->

<!--FOOTER_START-->
<table cellpadding=5 border=0 width="90%">
<tr>
<td>
	<HR WIDTH="90%">

<BLOCKQUOTE>
<FONT FACE="Verdana, Arial, Helvetica" SIZE="1">
<SPAN STYLE="font-family:verdana,arial,helvetica; font-size:8pt">
================================================================================<BR>

</SPAN>
</FONT>
<BR>
<BR>
THE INFORMATION PROVIDED IN THE MICROSOFT KNOWLEDGE BASE IS
PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND.  MICROSOFT DISCLAIMS
ALL WARRANTIES, EITHER EXPRESS OR IMPLIED, INCLUDING THE WARRANTIES
OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  IN NO
EVENT SHALL MICROSOFT CORPORATION OR ITS SUPPLIERS BE LIABLE FOR
ANY DAMAGES WHATSOEVER INCLUDING DIRECT, INDIRECT, INCIDENTAL,
CONSEQUENTIAL, LOSS OF BUSINESS PROFITS OR SPECIAL DAMAGES, EVEN IF
MICROSOFT CORPORATION OR ITS SUPPLIERS HAVE BEEN ADVISED OF THE
POSSIBILITY OF SUCH DAMAGES.  SOME STATES DO NOT ALLOW THE EXCLUSION
OR LIMITATION OF LIABILITY FOR CONSEQUENTIAL OR INCIDENTAL DAMAGES
SO THE FOREGOING LIMITATION MAY NOT APPLY.
</BLOCKQUOTE>
<P>
<center>
	<FONT FACE="Verdana,Arial,Helvetica" SIZE="1">
	Last reviewed:  October 7, 1997</FONT>
	<BR>
	<A href="../cpyright.htm" STYLE="font: bold 7pt Verdana,Arial,Helvetica">&copy; 1998 Microsoft Corporation. All rights reserved. Terms of Use.</A><BR>
	
</center>
</td>
</tr>
</table>

<!--FOOTER_END-->
</FONT>
</BODY>
</HTML>
