

<HTML>
<HEAD>
<TITLE>How malloc() and free() Operate in Windows </TITLE>

<!--STYLE_BEGIN-->
<style>@import url(../../msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="../../msdn_ie3.css">
<!--STYLE_END-->

<META HTTP-EQUIV="CONTENT-Type" CONTENT="text/html; charset=us-ascii">
<META NAME="ms.locale" CONTENT="EN-US">
<META NAME="Category" CONTENT="Support; KB Article">
<META NAME="KBID" CONTENT="Q86841 ">
<META NAME="KBModify" CONTENT="1997/07/17">
<META NAME="KBCreate" CONTENT="1992/07/19">
<META NAME="Keywords" CONTENT="kb16bitonly">
<META NAME="KBArea" CONTENT="Support; KB; visualc">
<META NAME="Description" CONTENT="  Using Microsoft C/C++ versions 7.0 and Visual C++ for Windows and the Windows C run-time library (SLIBCEW.LIB, for example), the functions malloc() and free() both make calls to the Windows API to allocate memory.  However, unlike earlier versions ...">
<META NAME="Product" CONTENT="Visual C++">
<META NAME="Platform" CONTENT="Windows">
<META NAME="Technology" CONTENT=" ">
<META NAME="Premium" CONTENT="support">

<META NAME="nyms" CONTENT="QAGI,QBFY,QDL9,QBWO,QBWN,QBWQ,QAIF,QAY5,QBSO,QAKJ,QAJH,QBW6,QAPF,QAGQ,QBV8 V02180118">
</HEAD>

<BODY BGCOLOR="#FFFFFF" LEFTMARGIN="0" RIGHTMARGIN="0" TOPMARGIN="0">


<!--DOCBODY_START-->
<BR>
<CENTER>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" VALIGN="top" WIDTH="90%">
	<TR>
		<TD VALIGN="top">
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<H1>How malloc() and free() Operate in Windows</H1>
			</FONT>
			<FONT FACE="verdana,arial,helvetica" SIZE="1">
			Last reviewed:  July 17, 1997</FONT><BR>
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<B>Article ID: Q86841 </B>
			</FONT>
		</TD>
	</TR>
	<TR>
	<TD>
	<FONT FACE="Verdana, Arial, Helvetica" SIZE=2>



 
<PRE>7.00    | 1.00 1.50
</PRE>MS-DOS  | WINDOWS
kbprg kbfasttip
<P>
<P>
 
The information in this article applies to:

<UL><LI>The C Run-time (CRT), included with:
<P>
<P><PRE>    - Microsoft C/C++ for MS-DOS, version 7.0
    - Microsoft Visual C++ for Windows, versions 1.0 and 1.5
</UL></PRE> 
<P>
<P><h2>SUMMARY</h2>
 
<P>
Using Microsoft C/C++ versions 7.0 and Visual C++ for Windows and the
Windows C run-time library (SLIBCEW.LIB, for example), the functions
malloc() and free() both make calls to the Windows API to allocate memory.
<P>
However, unlike earlier versions of malloc() and free(), the C/C++ 7.0
or newer version of these functions use a smart suballocation
strategy, which both reduces the system-call overhead of these
functions and makes them more efficient in their selector usage.
<P>
As a result of these enhancements, it is now possible to use the C/C++
7.0 or newer version of malloc() and free() (or the C++ operators new
and delete) for some simple memory allocations in your application
designed for version 3.1 of the Microsoft Windows operating system.
<P>
<P><h2>MORE INFORMATION</h2>
 
<P>
The C run-time function "malloc" maps to either _fmalloc() (far
malloc) or _nmalloc() (near malloc) depending on the ambient memory
model.  Because most Windows applications use far data, the following
discussion will focus on the _fmalloc() function.
<P>
NOTE: This information on malloc also applies to C++ programming. In
C/C++ version 7.0 and later, the C++ operator "new" calls the ambient
memory model version of malloc [for example, in a large model C++
application, all calls to new end up calling _fmalloc() for the memory
allocation].
<P>
The suballocation strategy used by _fmalloc() in C/C++ version 7.0 and
later uses internal heap management to keep track of memory usage
rather than allowing Windows to do it all.
<P>
Each time an application calls _fmalloc(), the run-time heap manager
looks to see if it can satisfy the request within the segments that
have already been allocated from Windows. If it can, the heap manager
marks the block as used and returns a pointer to this memory (without
calling any Windows memory allocation APIs). If not enough space
exists, a new segment is allocated and linked in to the internal list
of allocated segments.
<P>
In protected mode Windows, these new segments are allocated using
GlobalAlloc(GMEM_MOVEABLE) for Windows applications and
GlobalAlloc(GMEM_MOVEABLE | GMEM_DDESHARE) for Windows DLLs. The
memory is then locked using GlobalLock(). When this segment finally
needs to be freed, the GlobalUnlock() and GlobalFree() functions are
used. [If using _nmalloc() under Windows, the functions LocalAlloc(),
LocalLock(), LocalUnlock(), and LocalFree() are used for this
process.]
<P>
One implication of using GMEM_DDESHARE for a DLL is that all
_fmalloc() requests made by a DLL continue to exist for the lifetime
of the DLL unless the application or DLL explicitly call _ffree(). If
the application terminates abnormally, the DLL may remain in memory if
it's dynamically linked to other applications. In this case, the
memory allocated by _fmalloc() for the application is not freed as the
application exits and remains allocated for the lifetime of the DLL.
<P>
Note that the Windows allocation flags used by malloc() and free() are
hard-coded into the C run-time library and cannot be changed;
therefore, if your program requires special flags (GMEM_NOTIFY, for
example), you must use the standard Windows API to do the allocation.
<P>
One additional advantage of this internal heap management is that you
will not get a new selector every time you call _fmalloc(). In earlier
versions of the C run-time library for Windows, each call to
_fmalloc() directly calls GlobalAlloc() and GlobalLock(), and a new
selector is allocated for each call to _fmalloc(). Because all Windows
applications share a limited number of selectors, it is best to
minimize selector usage.
<P>

	</FONT>
	</TD>
	</TR>
</TABLE>
<P>


<!--DOCBODY_END-->

<!--FOOTER_START-->
<table cellpadding=5 border=0 width="90%">
<tr>
<td>
	<HR WIDTH="90%">

<BLOCKQUOTE>
<FONT FACE="Verdana, Arial, Helvetica" SIZE="1">
<SPAN STYLE="font-family:verdana,arial,helvetica; font-size:8pt">
Additional reference words: kbinf 7.00 1.00 1.50<BR>
KBCategory: kbprg kbfasttip<BR>
KBSubcategory: CRTIss<BR>
Keywords            : kb16bitonly<BR>

</SPAN>
</FONT>
<BR>
<BR>
THE INFORMATION PROVIDED IN THE MICROSOFT KNOWLEDGE BASE IS
PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND.  MICROSOFT DISCLAIMS
ALL WARRANTIES, EITHER EXPRESS OR IMPLIED, INCLUDING THE WARRANTIES
OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  IN NO
EVENT SHALL MICROSOFT CORPORATION OR ITS SUPPLIERS BE LIABLE FOR
ANY DAMAGES WHATSOEVER INCLUDING DIRECT, INDIRECT, INCIDENTAL,
CONSEQUENTIAL, LOSS OF BUSINESS PROFITS OR SPECIAL DAMAGES, EVEN IF
MICROSOFT CORPORATION OR ITS SUPPLIERS HAVE BEEN ADVISED OF THE
POSSIBILITY OF SUCH DAMAGES.  SOME STATES DO NOT ALLOW THE EXCLUSION
OR LIMITATION OF LIABILITY FOR CONSEQUENTIAL OR INCIDENTAL DAMAGES
SO THE FOREGOING LIMITATION MAY NOT APPLY.
</BLOCKQUOTE>
<P>
<center>
	<FONT FACE="Verdana,Arial,Helvetica" SIZE="1">
	Last reviewed:  July 17, 1997</FONT>
	<BR>
	<A href="../cpyright.htm" STYLE="font: bold 7pt Verdana,Arial,Helvetica">&copy; 1998 Microsoft Corporation. All rights reserved. Terms of Use.</A><BR>
	
</center>
</td>
</tr>
</table>

<!--FOOTER_END-->
</FONT>
</BODY>
</HTML>
