

<HTML>
<HEAD>
<TITLE>SAMPLE: Using VBX Controls in a "Non-MFC" Application </TITLE>

<!--STYLE_BEGIN-->
<style>@import url(../../msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="../../msdn_ie3.css">
<!--STYLE_END-->

<META HTTP-EQUIV="CONTENT-Type" CONTENT="text/html; charset=us-ascii">
<META NAME="ms.locale" CONTENT="EN-US">
<META NAME="Category" CONTENT="Support; KB Article">
<META NAME="KBID" CONTENT="Q118494">
<META NAME="KBModify" CONTENT="1997/09/18">
<META NAME="KBCreate" CONTENT="1994/07/20">
<META NAME="Keywords" CONTENT="kb16bitonly MfcVBX kbcode kbfile kbprg">
<META NAME="KBArea" CONTENT="Support; KB; visualc">
<META NAME="Description" CONTENT="  Occasionally, you may want to have the capability of using VBX controls in an application that has been written in straight C instead of C++ or that was not written to use the entire Microsoft Foundation Classes framework. Although the support for ...">
<META NAME="Product" CONTENT="Visual C++">
<META NAME="Platform" CONTENT="Windows">
<META NAME="Technology" CONTENT=" ">
<META NAME="Premium" CONTENT="support">

<META NAME="nyms" CONTENT="QAPN,QAB5,QAGI,QAW6,QA7O,QAOE,QAMN,QAY5,QAJH,QAUD,QBV8,QATJ,QAH4,QA28,QAB9 V02180118">
</HEAD>

<BODY BGCOLOR="#FFFFFF" LEFTMARGIN="0" RIGHTMARGIN="0" TOPMARGIN="0">


<!--DOCBODY_START-->
<BR>
<CENTER>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" VALIGN="top" WIDTH="90%">
	<TR>
		<TD VALIGN="top">
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<H1>SAMPLE: Using VBX Controls in a "Non-MFC" Application</H1>
			</FONT>
			<FONT FACE="verdana,arial,helvetica" SIZE="1">
			Last reviewed:  September 18, 1997</FONT><BR>
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<B>Article ID: Q118494</B>
			</FONT>
		</TD>
	</TR>
	<TR>
	<TD>
	<FONT FACE="Verdana, Arial, Helvetica" SIZE=2>



 
1.00 1.50
WINDOWS
kbprg kbfile kbcode
<P>
 
The information in this article applies to:
<P>
<PRE>   The Microsoft Foundation Classes (MFC) included with:
    - Microsoft Visual C++ for Windows, versions 1.0 and 1.5
</PRE> 
<P>
<P><h2>SUMMARY</h2>
 
<P>
Occasionally, you may want to have the capability of using VBX controls in
an application that has been written in straight C instead of C++ or that
was not written to use the entire Microsoft Foundation Classes framework.
Although the support for VBX controls is available only to a Microsoft
Foundation Classes application, it is possible to create a minimal
Foundation Classes application which provides the ability to use VBX
controls.
<P>
The following sample, VBXC, demonstrates a technique for creating a minimal
MFC application which enables VBX support. The "minimal MFC application"
here is a C++ based module that uses the MFC CWinApp class and that can be
linked with a C based application to provide support for VBX controls.
<P>
Download VBXC.EXE, a self-extracting file, from the Microsoft Software
Library (MSL) on the following services:

<UL><LI>Microsoft Download Service (MSDL)
<P><PRE>      Dial (206) 936-6735 to connect to MSDL
      Download <A href="http://support.microsoft.com/download/support/mslfiles/vbxc.exe">VBXC.EXE</A> <I>(size: 41629 bytes)</I> 
</PRE>
<LI>Internet (anonymous FTP)
<P><PRE>      ftp ftp.microsoft.com
      Change to the \softlib\mslfiles directory
      Get <A href="http://support.microsoft.com/download/support/mslfiles/vbxc.exe">VBXC.EXE</A> <I>(size: 41629 bytes)</I> 
</PRE><P>
</UL><h2>MORE INFORMATION</h2>
 
<P>
Any application which uses VBX controls will have to be a Microsoft
Foundation Classes application. This simply means that it must have a
CWinApp object. This article shows you how to create this CWinApp object,
and provides the code necessary to support use of VBX controls. One of the
consequences of including a CWinApp object is that you are automatically
using the Foundation-provided WinMain function and the message loop
contained within the CWinApp::Run() function. However, you must have a
CWinApp object to use VBX controls in your application.
<P>
NOTE: Be aware that this is not intended as a replacement for knowledge of
the Microsoft Foundation Classes. You will be linking with and calling into
the MFC library functions, and you should be aware of how this will affect
your program.
<P>
The idea is to create a CWinApp object which initializes the VBX support
and then calls the underlying code in your application (i.e. it uses your
application's WinMain). After creating a module which contains such an
object, you can link with this module to obtain rudimentary support for VBX
controls. You can then enhance the module as necessary to obtain further
VBX capabilities. This article outlines the header and implementation files
for a module which will give you this capability.
<P>
Following is the general implementation of the module which is referred to
in this article as USEVBX:
<P>
<PRE>//////////////////////////////////////////////////
//   FILE USEVBX.H
//
#ifdef __cplusplus      // two underscores
</PRE>extern "C" {
#endif
<P>
<PRE>void InitializeVBX(HWND hDlg,LPCSTR lpszResourceName);

</PRE>#ifdef __cplusplus
}
#endif
<P>
<PRE>//
//  EOF - USEVBX.H
///////////////////////////////////////////////////

//////////////////////////////////////////////////
// FILE USEVBX.CPP
//
#include &lt;afxwin.h&gt;
#include &lt;afxext.h&gt;
#include "usevbx.h"

// Prototype the application's _WinMain
</PRE>extern "C"
<PRE>int PASCAL _WinMain(HINSTANCE hInstance,
                    HINSTANCE hPrevInstance,
                     LPSTR lpCmdLine,
                     int nCmdShow);

</PRE>class CVBXApp : public CWinApp
{
public:
<PRE>  virtual BOOL InitInstance();
  virtual int Run();
</PRE>};
<P>
BOOL CVBXApp::InitInstance()
{
<PRE>  EnableVBX();
  return CWinApp::InitInstance();
</PRE>}
<P>
<PRE>int CVBXApp::Run()
</PRE>{
<PRE>  // Call the main application's WinMain.
  return _WinMain(m_hInstance,m_hPrevInstance,
                  m_lpCmdLine,m_nCmdShow);
}

void InitializeVBX(HWND hDlg,LPCSTR lpszResourceName)
</PRE>{
<PRE>  CWnd wndDlg;
  wndDlg.Attach(hDlg);
  wndDlg.ExecuteDlgInit(lpszResourceName);
  wndDlg.Detach();
</PRE>}
<P>
CVBXApp theVBXApp;
<P>
<PRE>//
// EOF - USEVBX.CPP
////////////////////////////////////////////////////////


</PRE>Once you have created the USEVBX.CPP source module, integrate it into your
project in the following manner:

<OL><P><LI>Select Project/Edit and add the file USEVBX.CPP to your project.

<P><LI>Link in the appropriate MFC libraries. (e.g. MAFXCWD, LAFXCWD). You can
   do this by just selecting Options/Project, and checking the "Use
   Microsoft Foundation Classes" option, or you can explicitly put the
   library file name in your link options under Options/Project/
   Linker/Libraries. For more information on library naming conventions,
   see Appendix B of the "Class Library User's Guide".

<P><LI>Rename your current application's WinMain function to _WinMain.

<P><LI>For any dialog box which contains VBX controls, add a handler for
   WM_INITDIALOG which first calls InitializeVBX(hDlg,lpszResourceName).
   This will initialize the VBX controls with the properties you specify in
   App Studio. You should also include the USEVBX.H header file in any
   module which calls this function.
<P>
</OL>The InitializeVBX function first creates a CWnd object and attaches it to
your dialog box window so that it can perform the VBX initialization. It
then calls the function ExecuteDlgInit which performs ComboBox and VBX
initialization. After that it must detach the CWnd object so that the
dialog box window is not destroyed when the CWnd object is deleted (the
CWnd object is defined as a local so it will be deleted as soon as we exit
the function).
<P>
This will enable VBX support in your application. You will probably want to
be able to use App Studio to put VBXs on your dialog templates. You can't
do this with a non-Microsoft Foundation Classes resource file so you must
convert your current RC file. There is an article which discusses how to
perform this conversion. The article is available in the Microsoft
Knowledge Base and can be found by querying on the following words:
<P>
<PRE>  converting rc file symbol directives

</PRE></OL>The article is <B><A href="../visualc/q99391.htm">Q99391</A></B>, titled: "Converting an RC File to Use
Microsoft Foundation Classes".
<P>
Once you have a resource script which is compatible with the Microsoft
Foundation Classes you can use App Studio to put VBX controls on your
dialog templates. You can also use App Studio to set initial properties for
the controls, but for the initialization to be performed you must make the
call to InitializeVBX in the WM_INITDIALOG processing of your dialog box.
<P>
To access the properties of the VBX you will have to create a C interface
which implements the functionality contained in the CVBControl class. This
can be done as needed. NOTE: The example VBXC implements most of these
functions but the sample is for demonstration purposes only, and does not
include instructions on how to re-implement the entire CVBControl class.
For example, here is how you might add the capability to use the
SetNumProperty and GetNumProperty functions:

<OL><P><LI>Insert these prototypes directly after the InitializeVBX function in the
   header file USEVBX.H:
<P>
<PRE>// The last parameter in CVBControl::GetNumProperty has a
// default of 0 in C++ but the default of 0 must be supplied
// by the caller in C because default parameters are not
// allowed.


</PRE></OL>LONG GetNumProperty(HWND hVBX,LPCSTR lpszPropName,int index);
BOOL SetNumProperty(HWND hVBX,LPCSTR lpszPropName,
<PRE>                    LONG lValue,int index);

</PRE><P><LI>Now implement the functions in the file USEVBX.CPP:
<P>
<P>
</OL>LONG GetNumProperty(HWND hVBX,LPCSTR lpszPropName,int index)
{
<PRE>  CVBControl *pVBCtrl = (CVBControl *)CWnd::FromHandle(hVBX);
  ASSERT(pVBCtrl-&gt;IsKindOf(RUNTIME_CLASS(CVBControl)));

  return pVBCtrl-&gt;GetNumProperty(lpszPropName,index);
</PRE></OL>}
<P>
BOOL SetNumProperty(HWND hVBX,LPCSTR lpszPropName,
<PRE>                    LONG lValue,int index)
{
  CVBControl *pVBCtrl = (CVBControl *)CWnd::FromHandle(hVBX);
  ASSERT(pVBCtrl-&gt;IsKindOf(RUNTIME_CLASS(CVBControl)));

  return pVBCtrl-&gt;SetNumProperty(lpszPropName,lValue,index);
</PRE>}

<OL><P><LI>To call these functions, you can simply use the Windows API function
   GetDlgItem to get the handle to the VBX window and pass it to the
   property function. e.g.
<P>
<PRE>   // Toggle the TabStop property
   LONG l;
   HWND hwndVBX;
   hwndVBX = GetDlgItem(hDlg,IDC_VBX1);
   l = GetNumProperty(hwndVBX,"TabStop",0);
   SetNumProperty(hwndVBX,"TabStop",!l,0);

</PRE></OL>Note: There is an assertion which verifies that the CWnd object retrieved
is actually a CVBControl object. This might at first appear erroneous
because the function call CWnd::FromHandle could return a temporary object
which would simply be a CWnd, not a CVBControl. Considering that the
calling application is not likely to be creating CVBControl objects itself,
it seems that this function call would always return a temporary CWnd
object, and the assertion would fail.
<P>
However, VBX controls are a special case. MFC implements VBX controls by
always creating a permanent CVBControl object for every VBX control
created. These objects are attached to the window of the VBX and are
automatically deleted when the parent window of the VBX is destroyed.
<P>
Since there is a permanent CVBControl object attached to every VBX control
which has been successfully created, the call to CWnd::FromHandle will
always return the permanent CVBControl object. If it does not return the
permanent handle, an assertion should be flagged.
<P>
An example of when you would get an assertion failure would be if the
IDC_VBX1 identifier used above was actually the ID of a non-VBX control. In
this case, there would be no CVBControl object attached and the ASSERT
above would flag that.
<P>
NOTE: You can use this method to safely add VBX controls to a Windows
application written in C. You should not, however, use this method to add
other MFC classes to such an application. To do so would circumvent the MFC
framework and cause the following problems:

<OL><P><LI>You are not using the framework's message loop. This means that none of
   the command routing or pre-translation of messages will occur.

<P><LI>You are not calling the framework's idle processing. The biggest problem
   with this is that if you begin to use functions from the MFC libraries
   which create temporary objects (either directly or indirectly), those
   objects will never be deleted and you will have memory leaks.
<P>
</OL>If you would like to gain more of the functionality that the Microsoft
Foundation Classes can provide in your application, then you should begin
by doing a full conversion of your application to an MFC application. Refer
to the "Class Library User's Guide" and the "Class Library Reference" for
more information on how to convert your application to MFC.
<P>

	</FONT>
	</TD>
	</TR>
</TABLE>
<P>


<!--DOCBODY_END-->

<!--FOOTER_START-->
<table cellpadding=5 border=0 width="90%">
<tr>
<td>
	<HR WIDTH="90%">

<BLOCKQUOTE>
<FONT FACE="Verdana, Arial, Helvetica" SIZE="1">
<SPAN STYLE="font-family:verdana,arial,helvetica; font-size:8pt">
Additional reference words: kbinf 1.00 1.50 2.00 2.50<BR>
KBCategory: kbprg kbfile kbcode<BR>
KBSubcategory: MfcVBX<BR>
Keywords          : kb16bitonly MfcVBX kbcode kbfile kbprg<BR>
Technology        : kbMfc<BR>
Version           : 1.00 1.50<BR>
Platform          : WINDOWS<BR>

</SPAN>
</FONT>
<BR>
<BR>
THE INFORMATION PROVIDED IN THE MICROSOFT KNOWLEDGE BASE IS
PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND.  MICROSOFT DISCLAIMS
ALL WARRANTIES, EITHER EXPRESS OR IMPLIED, INCLUDING THE WARRANTIES
OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  IN NO
EVENT SHALL MICROSOFT CORPORATION OR ITS SUPPLIERS BE LIABLE FOR
ANY DAMAGES WHATSOEVER INCLUDING DIRECT, INDIRECT, INCIDENTAL,
CONSEQUENTIAL, LOSS OF BUSINESS PROFITS OR SPECIAL DAMAGES, EVEN IF
MICROSOFT CORPORATION OR ITS SUPPLIERS HAVE BEEN ADVISED OF THE
POSSIBILITY OF SUCH DAMAGES.  SOME STATES DO NOT ALLOW THE EXCLUSION
OR LIMITATION OF LIABILITY FOR CONSEQUENTIAL OR INCIDENTAL DAMAGES
SO THE FOREGOING LIMITATION MAY NOT APPLY.
</BLOCKQUOTE>
<P>
<center>
	<FONT FACE="Verdana,Arial,Helvetica" SIZE="1">
	Last reviewed:  September 18, 1997</FONT>
	<BR>
	<A href="../cpyright.htm" STYLE="font: bold 7pt Verdana,Arial,Helvetica">&copy; 1998 Microsoft Corporation. All rights reserved. Terms of Use.</A><BR>
	
</center>
</td>
</tr>
</table>

<!--FOOTER_END-->
</FONT>
</BODY>
</HTML>
