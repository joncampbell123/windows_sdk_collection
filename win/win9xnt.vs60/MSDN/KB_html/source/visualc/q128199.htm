

<HTML>
<HEAD>
<TITLE>How to Use _declspec(dllexport) in an MFC Extension DLL </TITLE>

<!--STYLE_BEGIN-->
<style>@import url(../../msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="../../msdn_ie3.css">
<!--STYLE_END-->

<META HTTP-EQUIV="CONTENT-Type" CONTENT="text/html; charset=us-ascii">
<META NAME="ms.locale" CONTENT="EN-US">
<META NAME="Category" CONTENT="Support; KB Article">
<META NAME="KBID" CONTENT="Q128199">
<META NAME="KBModify" CONTENT="1997/10/10">
<META NAME="KBCreate" CONTENT="1995/03/27">
<META NAME="Keywords" CONTENT="MfcDLL kbprg">
<META NAME="KBArea" CONTENT="Support; KB; visualc">
<META NAME="Description" CONTENT="  This article supplements MFC TechNote #33. It contains some duplicate information, some corrections, and provides supplemental information to assist you in exporting classes or class members from an extension DLL.  MORE INFORMATION  Building an Ext...">
<META NAME="Product" CONTENT="Visual C++">
<META NAME="Platform" CONTENT="Windows">
<META NAME="Technology" CONTENT=" ">
<META NAME="Premium" CONTENT="support">

<META NAME="nyms" CONTENT="QA3P,QABO,QAOG,QDNN,QAPF,QBAQ,QDKS,QBVV,QAY2,QALQ,QBXF,QBFY,QAH4,QACJ,QABA V02180118">
</HEAD>

<BODY BGCOLOR="#FFFFFF" LEFTMARGIN="0" RIGHTMARGIN="0" TOPMARGIN="0">


<!--DOCBODY_START-->
<BR>
<CENTER>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" VALIGN="top" WIDTH="90%">
	<TR>
		<TD VALIGN="top">
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<H1>How to Use _declspec(dllexport) in an MFC Extension DLL</H1>
			</FONT>
			<FONT FACE="verdana,arial,helvetica" SIZE="1">
			Last reviewed:  October 10, 1997</FONT><BR>
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<B>Article ID: Q128199</B>
			</FONT>
		</TD>
	</TR>
	<TR>
	<TD>
	<FONT FACE="Verdana, Arial, Helvetica" SIZE=2>



 
2.00 2.10 4.00
WINDOWS NT
kbprg
<P>
 
The information in this article applies to:

<UL><LI>The Microsoft Foundation Classes (MFC), included with:
   Microsoft Visual C++, 32-bit Edition, versions 2.0, 2.1, and 4.0
</UL> 
<P>
<P><h2>SUMMARY</h2>
 
<P>
This article supplements MFC TechNote #33. It contains some duplicate
information, some corrections, and provides supplemental information to
assist you in exporting classes or class members from an extension DLL.
<P>
<P><h2>MORE INFORMATION</h2>
 
<P>
<P><h3>Building an Extension DLL</h3>
 
<P>
You can use AppWizard to create an MFC Extension DLL project, and it will
automatically generate the appropriate compiler and linker settings. For
more details, please see the AppWizard entry in the MFC Encyclopedia, which
can be found in Books Online and in the printed documentation.
<P>
If you are converting an existing project to an MFC Extension DLL, start
with the standard rules for building an application using the _AFXDLL
version of MFC. Then follow these steps:

<OL><P><LI>Add /D_AFXEXT to the compiler flags. On the Project Settings dialog,
   select the C/C++ tab. Then select the Preprocessor category. Add _AFXEXT
   to the Preprocessor Definitions field, separating each of the items with
   commas.

<P><LI>Remove the /Gy compiler switch. On the Project Setting dialog, select
   the C/C++ tab. Then select the C Language category. Ensure that the
   "Enable Function-Level Linking" checkbox is cleared. This will make it
   easier to export classes because the linker will not remove unreferenced
   functions. If the original project is used to build a Regular DLL
   statically linked to MFC, change the /MT[d] compiler option to /MD[d].

<P><LI>Build an export library with the /DLL option to LINK. This will be set
   when you create a new target, specifying Win32 Dynamic-Link Library as
   the target type.
<P>
</OL><h3>Changing Your Header Files</h3>
 
<P>
The goal of an extension DLL is usually to export some common functionality
to one or more applications that can use that functionality. This boils
down to exporting classes and global functions, which are available for
your client applications.
<P>
To do this, you must ensure that each of the member functions is marked as
import or export as appropriate. This requires special declarations:
_declspec(dllexport) and _declspec(dllimport). When your classes are used
by the client applications, you want them to be declared as
_declspec(dllimport). When the extension DLL itself is being built, they
should be declared as _declspec(dllexport). In addition, the functions must
be actually exported, so that the client programs bind to them at load
time.
<P>
To export your entire class, use AFX_EXT_CLASS in the class definition.
This macro is defined by the framework as _declspec(dllexport) when both
_AFXDLL and _AFXEXT are defined, but as _declspec(dllimport) when _AFXEXT
is not defined. _AFXEXT as described above, is only defined when building
your extension DLL.
<P>
For example:
<P>
<PRE>   class AFX_EXT_CLASS CExampleExport : public CObject
   { ... class definition ... };

</PRE></OL>This example exports an entire class.
<P>
<P><h3>Not Exporting the Entire Class</h3>
 
<P>
Sometimes you may want to export just the individual necessary members of
your class. MFC TechNote #33 discusses some reasons for this in the section
titled "Ordinals and class _export and DLL naming." For example, if you are
exporting a CDialog-derived class, you might only need to export the
constructor and the DoModal call. You can export these members using the
DLL's .DEF file, but you can also use AFX_EXT_CLASS in much the same way on
the individual members you need to export.
<P>
For example:
<P>
<PRE>   class CExampleDialog : public CDialog
   {
   public:
     AFX_EXT_CLASS CExampleDialog();
     AFX_EXT_CLASS int DoModal();
     ...
     // rest of class definition
     ...
   };

</PRE>When you do this, you may run into an additional problem due to the fact
that you are no longer exporting all members of the class. The problem is
in the way that MFC macros work. Several of MFC's helper macros actually
declare or define data members. Therefore, these data members will also
need to be exported from your DLL.
<P>
For example, the DECLARE_DYNAMIC macro is defined as follows when building
an extension DLL:
<P>
<PRE>   #define DECLARE_DYNAMIC(class_name) \
   protected: \
     static CRuntimeClass* PASCAL _GetBaseClass(); \
   public: \
     static AFX_DATA CRuntimeClass class##class_name; \
     virtual CRuntimeClass* GetRuntimeClass() const; \

</PRE>The line that begins "static AFX_DATA" is declaring a static object inside
of your class. To export this class correctly and access the runtime
information from a client .EXE, you need to export this static object.
Because the static object is declared with the modifier AFX_DATA, you only
need to define AFX_DATA to be _declspec(dllexport) when building your DLL
and define it as _declspec(dllimport) when building your client executable.
As discussed above, AFX_EXT_CLASS is already defined in this way. So you
just need to re-define AFX_DATA to be the same as AFX_EXT_CLASS around your
class definition.
<P>
For example:
<P>
<PRE>   #undef  AFX_DATA
   #define AFX_DATA AFX_EXT_CLASS

   class CExampleView : public CView
   {
     DECLARE_DYNAMIC()
     // ... class definition ...
   };

   #undef  AFX_DATA
   #define AFX_DATA

</PRE>MFC always uses the AFX_DATA symbol on data items it defines within its
macros, so this technique will work for all such scenarios. For example it
will work for DECLARE_MESSAGE_MAP.
<P>
NOTE: if you are exporting the entire class rather than selected members of
the class, static data members are automatically exported.
<P>
<P><h3>Limitations of _AFXEXT</h3>
 
<P>
You can use the _AFXEXT pre-processor symbol for your extension DLLs as
long as you do not have multiple layers of extension DLLs. If you have
extension DLLs that call or derive from classes in your own extension DLLs,
which then derive from the MFC classes, you must use your own preprocessor
symbol to avoid ambiguity.
<P>
The problem is that in Win32, you must explicitly declare any data as
_declspec(dllexport) if it is to be exported from a DLL, and declare any
data as _declspec(dllimport) if it is to be imported from a DLL. When you
define _AFXEXT, the MFC headers make sure that AFX_EXT_CLASS is defined
correctly. When you have multiple layers, one symbol such as AFX_EXT_CLASS
is not sufficient because an extension DLL may be exporting new classes as
well as importing other classes from another extension DLL.
<P>
To deal with this problem, use a special pre-processor symbol that
indicates you are building the DLL itself versus just using the DLL. For
example, imagine two extension DLLs (A.DLL, and B.DLL). They each export
some classes in A.H and B.H, respectively. B.DLL uses the classes from
A.DLL. The header files would look something like this:
<P>
<PRE>   // A.H
   #ifdef A_IMPL
       #define CLASS_DECL_A  _declspec(dllexport)
   #else
       #define CLASS_DECL_A  _declspec(dllimport)
   #endif

   class CLASS_DECL_A CExampleA : public CObject
   { ... class definition ... };

   // B.H
   #ifdef B_IMPL
       #define CLASS_DECL_B  _declspec(dllexport)
   #else
       #define CLASS_DECL_B  _declspec(dllimport)
   #endif

   class CLASS_DECL_B CExampleB : public CExampleA
   { ... class definition .. };

</PRE>When A.DLL is built, it is built with /D A_IMPL, and when B.DLL is built,
it is built with /D B_IMPL. By using separate symbols for each DLL, you
ensure that CExampleB is exported and CExampleA is imported when building
B.DLL. CExampleA is exported when building A.DLL and imported when used by
B.DLL or some other client. This type of layering cannot be done when using
the built-in AFX_EXT_CLASS and _AFXEXT pre-processor symbols. The technique
described above solves this problem in a manner not unlike the mechanism
MFC itself uses when building its OLE, Database, and Network extension
DLLs.
<P>
<P><h3>Not Exporting the Entire Class</h3>
 
<P>
Again you will have to take special care when you are not exporting an
entire class. You have to ensure that the necessary data items created by
the MFC macros are exported correctly. This can be done by re-defining
AFX_DATA to your specific class' macro. This should be done any time you
are not exporting the entire class.
<P>
For example:
<P>
<PRE>   // A.H
   #ifdef A_IMPL
       #define CLASS_DECL_A  _declspec(dllexport)
   #else
       #define CLASS_DECL_A  _declspec(dllimport)
   #endif

   #undef  AFX_DATA
   #define AFX_DATA CLASS_DECL_A

   class CExampleA : public CObject
   {
     DECLARE_DYNAMIC()
     CLASS_DECL_A int SomeFunction();
     //... class definition ...
   };

   #undef AFX_DATA
   #define AFX_DATA

</PRE><h2>REFERENCES</h2>
 
<P>
MFC TechNote #33.
<P>
The DLLHUSK sample.
<P>
The C++ Language Reference: Appendix B Microsoft-Specific Modifiers, under
"Extended Storage-Class Attributes," under "Using dllimport and dllexport
in C++."
<P>

	</FONT>
	</TD>
	</TR>
</TABLE>
<P>


<!--DOCBODY_END-->

<!--FOOTER_START-->
<table cellpadding=5 border=0 width="90%">
<tr>
<td>
	<HR WIDTH="90%">

<BLOCKQUOTE>
<FONT FACE="Verdana, Arial, Helvetica" SIZE="1">
<SPAN STYLE="font-family:verdana,arial,helvetica; font-size:8pt">
Additional reference words: kbinf 2.00 2.10 3.00 3.10 4.00<BR>
KBCategory: kbprg<BR>
KBSubcategory: MfcDLL<BR>
Keywords          : MfcDLL kbprg<BR>
Technology        : kbMfc<BR>
Version           : 2.00 2.10 4.00<BR>
Platform          : NT WINDOWS<BR>

</SPAN>
</FONT>
<BR>
<BR>
THE INFORMATION PROVIDED IN THE MICROSOFT KNOWLEDGE BASE IS
PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND.  MICROSOFT DISCLAIMS
ALL WARRANTIES, EITHER EXPRESS OR IMPLIED, INCLUDING THE WARRANTIES
OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  IN NO
EVENT SHALL MICROSOFT CORPORATION OR ITS SUPPLIERS BE LIABLE FOR
ANY DAMAGES WHATSOEVER INCLUDING DIRECT, INDIRECT, INCIDENTAL,
CONSEQUENTIAL, LOSS OF BUSINESS PROFITS OR SPECIAL DAMAGES, EVEN IF
MICROSOFT CORPORATION OR ITS SUPPLIERS HAVE BEEN ADVISED OF THE
POSSIBILITY OF SUCH DAMAGES.  SOME STATES DO NOT ALLOW THE EXCLUSION
OR LIMITATION OF LIABILITY FOR CONSEQUENTIAL OR INCIDENTAL DAMAGES
SO THE FOREGOING LIMITATION MAY NOT APPLY.
</BLOCKQUOTE>
<P>
<center>
	<FONT FACE="Verdana,Arial,Helvetica" SIZE="1">
	Last reviewed:  October 10, 1997</FONT>
	<BR>
	<A href="../cpyright.htm" STYLE="font: bold 7pt Verdana,Arial,Helvetica">&copy; 1998 Microsoft Corporation. All rights reserved. Terms of Use.</A><BR>
	
</center>
</td>
</tr>
</table>

<!--FOOTER_END-->
</FONT>
</BODY>
</HTML>
