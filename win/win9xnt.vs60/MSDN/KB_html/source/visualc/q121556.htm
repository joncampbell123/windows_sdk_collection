

<HTML>
<HEAD>
<TITLE>PRB: Breakpoints Won't Work - 12 Reasons Why </TITLE>

<!--STYLE_BEGIN-->
<style>@import url(../../msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="../../msdn_ie3.css">
<!--STYLE_END-->

<META HTTP-EQUIV="CONTENT-Type" CONTENT="text/html; charset=us-ascii">
<META NAME="ms.locale" CONTENT="EN-US">
<META NAME="Category" CONTENT="Support; KB Article">
<META NAME="KBID" CONTENT="Q121556">
<META NAME="KBModify" CONTENT="1997/07/24">
<META NAME="KBCreate" CONTENT="1994/10/11">
<META NAME="Keywords" CONTENT="CvwIss kb3rdparty kbtshoot WBDebug">
<META NAME="KBArea" CONTENT="Support; KB; visualc">
<META NAME="Description" CONTENT="  This article describes 12 possible reasons why you may be having trouble getting breakpoints to work. It covers each of the following 12 situations where breakpoints do not work as expected:   - Can't set breakpoint in a Windows Exit Procedure (WEP...">
<META NAME="Product" CONTENT="Visual C++">
<META NAME="Platform" CONTENT="Windows">
<META NAME="Technology" CONTENT=" ">
<META NAME="Premium" CONTENT="support">

<META NAME="nyms" CONTENT="QBXS,QAH4,QAJQ,QBVV,QAGI,QAB9,QDL9,QBWQ,QBWO,QBWN,QDNN,QAY4,QAYL,QAIJ,QAVX V02180118">
</HEAD>

<BODY BGCOLOR="#FFFFFF" LEFTMARGIN="0" RIGHTMARGIN="0" TOPMARGIN="0">


<!--DOCBODY_START-->
<BR>
<CENTER>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" VALIGN="top" WIDTH="90%">
	<TR>
		<TD VALIGN="top">
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<H1>PRB: Breakpoints Won't Work - 12 Reasons Why</H1>
			</FONT>
			<FONT FACE="verdana,arial,helvetica" SIZE="1">
			Last reviewed:  July 24, 1997</FONT><BR>
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<B>Article ID: Q121556</B>
			</FONT>
		</TD>
	</TR>
	<TR>
	<TD>
	<FONT FACE="Verdana, Arial, Helvetica" SIZE=2>



<P><h3> </h3>
 
The information in this article applies to:

<UL><LI>Visual Workbench Integrated Debugger included with:
   - Microsoft Visual C++ for Windows, versions 1.0, 1.5, 1.51, 1.52
   - Microsoft Visual C++, 32-bit Edition, versions 1.0, 2.0, 4.0, 5.0
<LI>Microsoft CodeView for Windows, versions 4.0, 4.01, 4.10
<LI>Microsoft CodeView for MS-DOS, versions 4.0, 4.01, 4.10
</UL> 
<P>
<P><h2>SUMMARY</h2>
 
<P>
This article describes 12 possible reasons why you may be having trouble
getting breakpoints to work. It covers each of the following 12 situations
where breakpoints do not work as expected:

<UL><LI>Can't set breakpoint in a Windows Exit Procedure (WEP).

<LI>Problems when using Program Manager replacements.

<LI>Can't set breakpoint on expression that uses out-of-scope variables.

<LI>Breakpoints fail when multiple source files have the same name.

<LI>Can't set breakpoint in the WndProc of a child window in a DLL.

<LI>Can't set breakpoint in source file when corresponding symbolic
   information isn't loaded into memory by debugger.

<LI>Breakpoints missed when DLL unloaded and reloaded in same debug session.

<LI>Breakpoints missed when DLL loaded into memory before debug session
   starts.

<LI>Missed breakpoints when more than one copy of DLL on your hard disk.

<LI>Can't Set "Break When Expression Has Changed" Breakpoint on a variable
   local to a DLL.

<LI>Visual C++ Version 1.0 and 1.5 IDE debuggers won't stop on a
   breakpoint in an MFC message handler for the WM_QUERYENDSESSION Message.

<LI>Can't set breakpoints on desired lines if program is built without /Od
   option.
<P>
</UL><h2>MORE INFORMATION</h2>
 
<P>
<P><h3>Can't Set Breakpoint in a Windows Exit Procedure (WEP)</h3>
 
<P>
This is by design. Instead, you can call DebugBreak() or hard code an int 3
interrupt in your WEP using code like this:
<P>
<PRE>   #ifdef _DEBUG
      DebugBreak();
      // _asm int 3;     /* alternate */
   #endif

</PRE>Note: These two suggestions will only work if you explicitly load and free
the DLL in question using LoadLibrary() and FreeLibrary(), respectively.
If you implicitly load the DLL, see the following article:
<P>
<PRE>   ARTICLE: <B><A href="../visualc/q148734.htm">Q148734</A></B>
   TITLE  : How to Debug WEP(), _WEP(), and ExitInstance() in 16-bit DLLs.


</PRE><h3>Problems When Using Program Manager Replacements</h3>
 
<P>
Customers have reported problems with breakpoints when using Program
Manager replacements such as Norton Desktop for Windows or PC Tools for
Windows. Reported problems include:

<UL><LI>Missed breakpoints.
<LI>A general protection (GP) fault after pressing the F8, F10, or F5 key to
   continue when you reach the first breakpoint.
<LI>Loss of breakpoints once set.
<P>
</UL>Switching the Visual C++ integrated debugger to Hard mode may solve these
problems, but Microsoft recommends that you not use Program Manager
replacements while debugging.
<P>
<P><h3>Can't Set Breakpoint on Expression that Uses Out-of-Scope Variables</h3>
 
<P>
Attempting to set a breakpoint on an expression before the variables in the
expression have come into scope will not work unless specific steps are
taken. For example, you can't set a breakpoint when an expression has
changed (or is true) and that expression contains a variable local to a
function that has not yet been executed. The debugger can't evaluate the
expression because the variable has not yet been allocated on the stack.
<P>
To work around this problem, you can use the context operator to specify
the scope in which the expression should be evaluated. In the Expression
field of either CodeView or the IDE debugger, type in the expression using
this form:
<P>
<PRE>   {function_name,source_file.cpp,appdll.exe} expression

</PRE>This tells the debugger to evaluate the expression within the scope of
function_name. This is precisely what is needed if one or more of the
variables in the expression do not exist outside of function_name.
<P>
NOTE: "Break at Location if Expression has Changed [or is True]" also needs
the same qualification for the same reasons. For more detailed information
on the syntax and use of the context operator, please refer to Chapter 4 of
the "Visual C++ CodeView Debugger User's Guide," or search for "context
operator" in CodeView's Help menu.
<P>
<P><h3>Breakpoints Fail When Multiple Source Files Have the Same Name</h3>
 
<P>
If two or more source files in the project have the same name, breakpoint
problems are likely to occur. This often occurs in cases where the
user-named module has the same name as one of the components of a library
(debug version) they are linking with.
<P>
NOTE: This is always the case when an MFC application makes calls to a
_USRDLL because the MFC code is statically linked into both the .EXE and
the .DLL file. It is also the case for MFC OLE servers and containers that
statically link with the MFC libraries. In these cases, the debugger may
associate the debug information for a source file with the wrong copy of
its binary code in memory, and the breakpoint subsequently fails.
<P>
To work around this problem, try using the context operator described
above. In most cases, you can use the full paths to the source file and
corresponding executable module. CodeView is also able to handle these
cases with the "File.Open Module" menu option. Selecting this option will
display a module list that includes all copies of the same module. You can
then select the one you want.
<P>
<P><h3>Can't Set Breakpoint in the WndProc of a Child Window in a DLL</h3>
 
<P>
You cannot set a breakpoint in the WndProc of a child window in a DLL when
the calling program is not the parent. If the calling program creates a
child window that's defined in a DLL, you should have no problem setting a
breakpoint in the child window's WndProc because the calling program
contains its parent window. However, if the calling program didn't create
the child window directly, you won't be able to set a breakpoint in it.
This is actually an IDE debugger issue because it is a limitation for
Windows debuggers that are themselves Windows-based applications.
Therefore, the only workaround is to use CodeView for Windows, which is a
character-based application, not a true Windows-based application.
<P>
Can't Set Breakpoint in Source File When Corresponding Symbolic Info Isn't
Loaded into Memory by Debugger
 
<P>
You cannot set a breakpoint in any source file when the corresponding
symbolic information will not be loaded into memory by the debugger.
Symptoms include messages such as "the breakpoint cannot be set" or a
simple, non-informational beep. When setting breakpoints before the
debuggee has been started, the debugger uses a breakpoint list to keep
track of how and where to set breakpoints. When you actually begin the
debugging session, the debugger loads the symbolic information for all
designated debuggees and then walks through its breakpoint list, attempting
to set the breakpoints.
<P>
However, if one or more of the debuggees have not been designated to the
debugger, there will be no symbolic information for the debugger to use
when walking through its breakpoint list. Situations where this is likely
to occur include:

<UL><LI>Attempts to set breakpoints in a DLL before the call to LoadLibrary.

<LI>Setting a breakpoint in an OLE server before the container has started
   the server.

<LI>Other similar cases.
<P>
</UL>NOTE: After you receive notification that these breakpoints cannot be set,
the breakpoints will usually continue to show up in the breakpoint list,
but they will have a dash (-) to their left, indicating that they are
disabled (have not been set).
<P>
To prevent this behavior in Visual C++, specify all additional DLLs and
OLE servers in the Additional DLLs field in the Options.Debug... dialog
box. To prevent this behavior in in CodeView, use the /L command line
switch to notify CodeView that you want it to Load symbolic debug
information for additional .EXE and .DLL files. When this has been done,
breakpoints set in code that has not yet been loaded into memory will be
"virtual" breakpoints. When the code is actually loaded into memory by the
loader, these become physical breakpoints. Ensure that these additional
debuggees are not already running when you start your debugging session.
Failure to follow this rule will likely cause breakpoints to be missed.
<P>
<P><h3>Breakpoints Missed When DLL Unloaded and Reloaded in Same Debug Session</h3>
 
<P>
Neither CodeView for Windows or the IDE debugger will hit breakpoints once
a DLL has been unloaded and loaded again in the same debugging session.
This is because the DLL will probably have moved in memory, and neither
debugger handles the address fix-ups that would be required to reinsert the
<PRE>int 3's at the new locations. Unfortunately the bottom line here is that
</PRE>you can't debug a DLL once it has been unloaded; you have to exit the debug
session, and start over clean.
<P>
<P><h3>Breakpoints Missed When DLL Loaded into Memory Before Debug Session Starts</h3>
 
<P>
The debugger will sometimes get confused when a DLL has already been loaded
into memory before the debugging session is started. Although the DLL is
the same, the debugger sees the second (or more) instance as a separate
copy. If you're using CodeView, you can easily check to see if this is
happening. After setting the breakpoints in the DLL and running the calling
program until the DLL has been loaded, choose the Breakpoints menu option
under the Data menu. If the breakpoints have VE (virtual; Enabled) before
the brace, CodeView for Windows is using the wrong instance -- these
breakpoints should no longer be virtual because the DLL has been loaded
into memory, thus allowing virtual breakpoints to become physical
breakpoints. Unfortunately, the IDE debugger does not provide a way to find
out if a breakpoint is virtual. The solution is to make sure none of your
DLLs are in memory before the debugging session starts.
<P>
<P><h3>Missed Breakpoints When More than One Copy of DLL on Your Hard Disk</h3>
 
<P>
Having more than one copy of a DLL on your hard drive, especially if its in
your Windows directory, can also cause debugger confusion. What can happen
is that the debugger will load the symbolic information for the DLL
specified to it at run time (with the /L command line option for CodeView
for Windows, or in the "Additional DLLs" field in the IDE debugger), but
Windows has actually loaded a different copy of the DLL itself into memory.
Again, if you're using CodeView you can check for this by looking to see if
the breakpoints have VE before them. Because there is no way to force the
debugger to load a specific DLL (as opposed to loading symbolic information
for one with the /L switch), it is a good idea to keep only one version of
a DLL at a time in your path, current directory, and Windows directory.
<P>
If you have already done this step and are still having breakpoint
problems, be sure you have also followed the other steps listed above.
Often breakpoint problems are the result of several key steps being missed.
<P>
<P><h3>Can't Set "Break When Expression Has Changed" Breakpoint on DLL Local Var</h3>
 
<P>
Using virtual breakpoints involving expressions poses a special problem.
For example, setting a "Break When Expression Has Changed" breakpoint on a
variable local to a DLL function before the call to LoadLibrary would cause
the breakpoint to be virtual (there are no physical addresses for the DLL
in memory yet). In these cases, not only must the DLL have been specified
to the debugger at startup (thus causing its symbolic information to be
loaded, as discussed above), but the DLL's executable code must also be
loaded into memory before this kind of breakpoint can be set. This means
that the calling application's code must be executed to the point after its
call to LoadLibrary before the debugger will allow this type of breakpoint
to be set.
<P>
Visual C++ Version 1.0 and 1.5 IDE Debuggers Won't Stop on a Breakpoint
in an MFC Message Handler for the WM_QUERYENDSESSION Message
 
<P>
Even hard-coding an interrupt 3 (_asm int 3) has no effect. The 32-bit
version of Visual C++ works as expected, as does CodeView. Therefore, use
CodeView instead; it will stop as expected.
<P>
Can't Set Breakpoints on desired lines if program is built without /Od
option
 
<P>
This is by design. Some compiler optimizations concatenate code in the
executable file. The compiler switch /Od can be used to disable all
optimizations. To make sure breakpoints can be set, both the /Od and /Zi
option switches should be specified.
<P>
For more information, please see the following article in the Microsoft
Knowledge Base :
<P>
<PRE>   ARTICLE: <B><A href="../utilities/q60338.htm">Q60338</A></B>
   TITLE  : Unable to Set CodeView Breakpoint on Desired Line

</PRE><h2>REFERENCES</h2>
 
<P>
<PRE>   ARTICLE: <B><A href="../visualc/q150936.htm">Q150936</A></B>
   TITLE  : FIX: VC41 Debugger Fails to Stop on Breakpoints w/ Long Names
</PRE>

	</FONT>
	</TD>
	</TR>
</TABLE>
<P>


<!--DOCBODY_END-->

<!--FOOTER_START-->
<table cellpadding=5 border=0 width="90%">
<tr>
<td>
	<HR WIDTH="90%">

<BLOCKQUOTE>
<FONT FACE="Verdana, Arial, Helvetica" SIZE="1">
<SPAN STYLE="font-family:verdana,arial,helvetica; font-size:8pt">
Additional query words: eleven causes<BR>
Keywords            : CvwIss kb3rdparty kbtshoot WBDebug<BR>
Version             : 1.0 1.5 1.51 4.0 4.01 4.1 5.0<BR>
Platform            : MS-DOS NT WINDOWS<BR>
Issue type          : kbprb<BR>

</SPAN>
</FONT>
<BR>
<BR>
THE INFORMATION PROVIDED IN THE MICROSOFT KNOWLEDGE BASE IS
PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND.  MICROSOFT DISCLAIMS
ALL WARRANTIES, EITHER EXPRESS OR IMPLIED, INCLUDING THE WARRANTIES
OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  IN NO
EVENT SHALL MICROSOFT CORPORATION OR ITS SUPPLIERS BE LIABLE FOR
ANY DAMAGES WHATSOEVER INCLUDING DIRECT, INDIRECT, INCIDENTAL,
CONSEQUENTIAL, LOSS OF BUSINESS PROFITS OR SPECIAL DAMAGES, EVEN IF
MICROSOFT CORPORATION OR ITS SUPPLIERS HAVE BEEN ADVISED OF THE
POSSIBILITY OF SUCH DAMAGES.  SOME STATES DO NOT ALLOW THE EXCLUSION
OR LIMITATION OF LIABILITY FOR CONSEQUENTIAL OR INCIDENTAL DAMAGES
SO THE FOREGOING LIMITATION MAY NOT APPLY.
</BLOCKQUOTE>
<P>
<center>
	<FONT FACE="Verdana,Arial,Helvetica" SIZE="1">
	Last reviewed:  July 24, 1997</FONT>
	<BR>
	<A href="../cpyright.htm" STYLE="font: bold 7pt Verdana,Arial,Helvetica">&copy; 1998 Microsoft Corporation. All rights reserved. Terms of Use.</A><BR>
	
</center>
</td>
</tr>
</table>

<!--FOOTER_END-->
</FONT>
</BODY>
</HTML>
