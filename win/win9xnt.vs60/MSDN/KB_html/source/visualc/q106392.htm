

<HTML>
<HEAD>
<TITLE>PRB: C2666 Error Generated with Overloaded Operator </TITLE>

<!--STYLE_BEGIN-->
<style>@import url(../../msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="../../msdn_ie3.css">
<!--STYLE_END-->

<META HTTP-EQUIV="CONTENT-Type" CONTENT="text/html; charset=us-ascii">
<META NAME="ms.locale" CONTENT="EN-US">
<META NAME="Category" CONTENT="Support; KB Article">
<META NAME="KBID" CONTENT="Q106392">
<META NAME="KBModify" CONTENT="1997/08/26">
<META NAME="KBCreate" CONTENT="1993/11/07">
<META NAME="Keywords" CONTENT="CPPIss">
<META NAME="KBArea" CONTENT="Support; KB; visualc">
<META NAME="Description" CONTENT="  The following error     C2666: '+' : 'number' overloads have similar conversions  is generated when there is no single or exact match between multiple operators. In some cases, the type conversion may look trivial but actually is not, and an explic...">
<META NAME="Product" CONTENT="Visual C++">
<META NAME="Platform" CONTENT="Windows">
<META NAME="Technology" CONTENT=" ">
<META NAME="Premium" CONTENT="support">

<META NAME="nyms" CONTENT="QAKF,QAKM,QANY,QA4Q,QBFY,QAUD,QAPN,QAHH,QAEQ,QAHE,QALM,QBXS,QAAP,QAB4,QADX V02180118">
</HEAD>

<BODY BGCOLOR="#FFFFFF" LEFTMARGIN="0" RIGHTMARGIN="0" TOPMARGIN="0">


<!--DOCBODY_START-->
<BR>
<CENTER>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" VALIGN="top" WIDTH="90%">
	<TR>
		<TD VALIGN="top">
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<H1>PRB: C2666 Error Generated with Overloaded Operator</H1>
			</FONT>
			<FONT FACE="verdana,arial,helvetica" SIZE="1">
			Last reviewed:  August 26, 1997</FONT><BR>
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<B>Article ID: Q106392</B>
			</FONT>
		</TD>
	</TR>
	<TR>
	<TD>
	<FONT FACE="Verdana, Arial, Helvetica" SIZE=2>



 
 
The information in this article applies to:

<UL><LI>The Microsoft C/C++ Compiler (CL.EXE), included with:
   - Microsoft C/C++ for MS-DOS, version 7.0
   - Microsoft Visual C++ for Windows, versions 1.0, 1.5, 1.51, 1.52
   - Microsoft Visual C++ 32-bit Edition, versions 1.0, 2.0, 2.1, 4.0, 5.0
</UL> 
<P>
<P><h2>SYMPTOMS</h2>
 
<P>
The following error
<P>
<PRE>   C2666: '+' : 'number' overloads have similar conversions

</PRE>is generated when there is no single or exact match between multiple
operators. In some cases, the type conversion may look trivial but
actually is not, and an explicit type conversion or typecast is needed
to force the operators to match.
<P>
<P><h2>CAUSE</h2>
 
<P>
In the following sample, the line where the error is generated has the
form:
<P>
<PRE>   int + Fraction

</PRE>Because there is no exact match to the operators provided for this
operation, a set of candidate operator + must be determined.
<P>
First, there are the user-supplied operators:
<P>
<PRE>   + ( long,            const Fraction&amp; )
   + ( const Fraction&amp;, long )
   + ( const Fraction&amp;, const Fraction&amp; )

</PRE>Second, there are the built-in operators:
<P>
<PRE>   + ( int, float )

</PRE>The above is chosen because it is "int" plus an arbitrary type, and
the Fraction object can be converted only to a "float".
<P>
Now, the candidate selection list is:
<P>
<PRE>   + ( long,            const Fraction&amp; )
   + ( const Fraction&amp;, long )
   + ( const Fraction&amp;, const Fraction&amp; )
   + ( int,             float )

</PRE>Because there is more than one choice, the overload disambiguation
takes place.
<P>
The first argument is considered:
<P>
<PRE>   + ( long, ... )             Requires one standard conversion.
   + ( const Fraction&amp;, ... )  Requires one user-defined conversion.
   + ( int, ... )              Is an exact match.

</PRE>Therefore, the set of best candidates for the first argument consists
of:
<P>
<PRE>   + ( int, float )

</PRE>Then the second argument is considered:
<P>
<PRE>   + ( ..., const Fraction&amp; )   Requires only trivial conversions.
   + ( ..., long )              Requires 1 user-defined conversion and
                                one standard conversion.
   + ( ..., float )             Requires one user-defined conversion.

</PRE>Therefore, the set of best candidates for the second argument consists
of:
<P>
<PRE>   + ( const Fraction&amp;, const Fraction&amp; )
   + ( long,            const Fraction&amp; )

</PRE>The intersection of these two sets is NULL, it contains nothing,
and therefore the operation is ambiguous.
<P>
<P><h2>MORE INFORMATION</h2>
 
<P>
If you change the operator float to int, the candidate list will
contain "+ ( int, int )", which will still be the best candidate for
the left operand. The intersection of the two sets will still be
empty.
<P>
<P><h2>RESOLUTION</h2>
 

<OL><P><LI>Typecast the operand that is causing the ambiguity. For example:
<P>
<P><PRE>      c = 1234L + a;
</PRE><P>
<P><PRE>      -or-
</PRE><P>
<P><PRE>      c = (long)1234 + a;
</PRE>
<P><LI>Remove the float operator from the Fraction class. This prevents a
   default operator "+" from being provided by the compiler because
   there is no conversion provided by the user for the second
   argument. The selection is made from the list of three
   user-provided "+" operators.
<P>
   For the first argument, the first operator
<P>
<PRE>      + ( long,          const Fraction&amp; )

   is chosen because a trivial conversion is required for int to long.
   The same selection is also made for the second argument, making the
   operator

      + ( long,           const Fraction&amp; )

   common to both the selections, and thus resolving the ambiguity.

</PRE></OL><h3>Sample Code</h3>
 
<P>
<PRE>  /* Compile Options needed: none
  */

  class Fraction {
   private:
     int x;
     int y;
   public:
     Fraction(int a=0, int b=0) : x(a), y(b) { }
     ~Fraction(){}
     operator float () {return int(x);}
  };

  Fraction&amp; operator+(long i, const Fraction&amp; ) { Fraction f ; return f; }
  Fraction&amp; operator+(const  Fraction&amp; , const Fraction&amp; ){ Fraction f;
  return f; }
  Fraction&amp; operator+(const Fraction&amp;  , long i ) { Fraction f ; return f;}

  void main()
  {
     Fraction a(2,3), c;

     c =     1234 + a;   // error C2666: '+' : 4 overloads have
                // similar conversion
  }
</PRE>

	</FONT>
	</TD>
	</TR>
</TABLE>
<P>


<!--DOCBODY_END-->

<!--FOOTER_START-->
<table cellpadding=5 border=0 width="90%">
<tr>
<td>
	<HR WIDTH="90%">

<BLOCKQUOTE>
<FONT FACE="Verdana, Arial, Helvetica" SIZE="1">
<SPAN STYLE="font-family:verdana,arial,helvetica; font-size:8pt">
Additional query words: 8.00 8.00c 9.00 9.10<BR>
Keywords          : CPPIss<BR>
Version           : MS-DOS:7.0;WINDOWS:1.0,1.5,1.51,1.52;WINDOWS  NT:1.0,2.0,2.1,4.0,5.0<BR>
Issue type        : kbprb<BR>

</SPAN>
</FONT>
<BR>
<BR>
THE INFORMATION PROVIDED IN THE MICROSOFT KNOWLEDGE BASE IS
PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND.  MICROSOFT DISCLAIMS
ALL WARRANTIES, EITHER EXPRESS OR IMPLIED, INCLUDING THE WARRANTIES
OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  IN NO
EVENT SHALL MICROSOFT CORPORATION OR ITS SUPPLIERS BE LIABLE FOR
ANY DAMAGES WHATSOEVER INCLUDING DIRECT, INDIRECT, INCIDENTAL,
CONSEQUENTIAL, LOSS OF BUSINESS PROFITS OR SPECIAL DAMAGES, EVEN IF
MICROSOFT CORPORATION OR ITS SUPPLIERS HAVE BEEN ADVISED OF THE
POSSIBILITY OF SUCH DAMAGES.  SOME STATES DO NOT ALLOW THE EXCLUSION
OR LIMITATION OF LIABILITY FOR CONSEQUENTIAL OR INCIDENTAL DAMAGES
SO THE FOREGOING LIMITATION MAY NOT APPLY.
</BLOCKQUOTE>
<P>
<center>
	<FONT FACE="Verdana,Arial,Helvetica" SIZE="1">
	Last reviewed:  August 26, 1997</FONT>
	<BR>
	<A href="../cpyright.htm" STYLE="font: bold 7pt Verdana,Arial,Helvetica">&copy; 1998 Microsoft Corporation. All rights reserved. Terms of Use.</A><BR>
	
</center>
</td>
</tr>
</table>

<!--FOOTER_END-->
</FONT>
</BODY>
</HTML>
