

<HTML>
<HEAD>
<TITLE>DOC: How to Use the PX_Blob Function </TITLE>

<!--STYLE_BEGIN-->
<style>@import url(../../msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="../../msdn_ie3.css">
<!--STYLE_END-->

<META HTTP-EQUIV="CONTENT-Type" CONTENT="text/html; charset=us-ascii">
<META NAME="ms.locale" CONTENT="EN-US">
<META NAME="Category" CONTENT="Support; KB Article">
<META NAME="KBID" CONTENT="Q137333">
<META NAME="KBModify" CONTENT="1997/06/26">
<META NAME="KBCreate" CONTENT="1995/09/25">
<META NAME="Keywords" CONTENT="CDKIss kbcode vcfixlist500">
<META NAME="KBArea" CONTENT="Support; KB; visualc">
<META NAME="Description" CONTENT="  The PX_Blob function can be used to load or save an OLE control's property that stores Binary Large Object (BLOB) data. The CDK documentation incorrectly lists the prototype for the PX_Blob function as:     BOOL PX_Blob( CPropExchange* pPX, LPCTSTR...">
<META NAME="Product" CONTENT="Visual C++">
<META NAME="Platform" CONTENT="Windows">
<META NAME="Technology" CONTENT=" ">
<META NAME="Premium" CONTENT="support">

<META NAME="nyms" CONTENT="QAPN,QAGI,QASR,QBCF,QA7O,QAMN,QAB5,QAKD,QAYY,QBXN,QBR4,QAI4,QAIF,QBWC,QAH6 V02180118">
</HEAD>

<BODY BGCOLOR="#FFFFFF" LEFTMARGIN="0" RIGHTMARGIN="0" TOPMARGIN="0">


<!--DOCBODY_START-->
<BR>
<CENTER>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" VALIGN="top" WIDTH="90%">
	<TR>
		<TD VALIGN="top">
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<H1>DOC: How to Use the PX_Blob Function</H1>
			</FONT>
			<FONT FACE="verdana,arial,helvetica" SIZE="1">
			Last reviewed:  June 26, 1997</FONT><BR>
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<B>Article ID: Q137333</B>
			</FONT>
		</TD>
	</TR>
	<TR>
	<TD>
	<FONT FACE="Verdana, Arial, Helvetica" SIZE=2>



 
 
The information in this article applies to:

<UL><LI>The Microsoft Foundation Classes (MFC) included with:
   - Microsoft OLE Control Developer's Kit (CDK), versions 1.0, 1.1, 1.2
   - Microsoft Visual C++, 32-bit Edition, version 4.0, 4.1
</UL> 
<P>
<P><h2>SUMMARY</h2>
 
<P>
The PX_Blob function can be used to load or save an OLE control's property
that stores Binary Large Object (BLOB) data. The CDK documentation
incorrectly lists the prototype for the PX_Blob function as:
<P>
<PRE>   BOOL PX_Blob( CPropExchange* pPX, LPCTSTR pszPropName,
      HGLOBAL*&amp; hBlob, HGLOBAL hBlobDefault = NULL );

</PRE>The third parameter is incorrectly shown as being of type HGLOBAL*&amp;.
The correct function prototype is:
<P>
<PRE>   BOOL PX_Blob( CPropExchange* pPX, LPCTSTR pszPropName,
      HGLOBAL&amp; hBlob, HGLOBAL hBlobDefault = NULL );

</PRE>The documentation states that PX_Blob will cause the property's value to be
read from or written to the variable referenced by hBlob, as appropriate.
However, the documentation is unclear about what hBlob should be
referencing. In order to use PX_Blob, it is necessary that the first four
bytes of information that hBlob references be a ULONG containing the number
of bytes of data that make up the properties value following the ULONG.
<P>
This documentation error was corrected in Visual C++ version 5.0.
<P>
<P><h2>MORE INFORMATION</h2>
 
<P>
The following steps show how to use PX_Blob to serialize BLOB data:

<OL><P><LI>Declare a structure that contains a ULONG and the property data in the
   header file for the control. Because the first four bytes of a BLOB need
   to be a ULONG, creating a structure that contains a ULONG and the
   property data can simplify using PX_Blob.

<P><LI>Declare an HGLOBAL member in the control's class declaration. The
   HGLOBAL will be used to reference the BLOB containing the property
   data.

<P><LI>Initialize the HGLOBAL member to NULL in the control's constructor.

<P><LI>In the control's DoPropExchange method, check to see if the control's
   properties are being saved or loaded. If properties are being saved, do
   the following:
<P>
   a. GlobalAlloc the required number of bytes for the data that represents
<P><PRE>      the property value and add four additional bytes for the ULONG that
      contains the size of the data. The structure declared in Step 1 can
      be used when doing this.
</PRE><P>
   b. GlobalLock the handle returned from the GlobalAlloc call to get a
<P><PRE>      pointer of your structure type to that memory.
</PRE><P>
   c. Fill in the first part of your structure with the sizeof (your
<P><PRE>      property data).
</PRE><P>
   d. Fill in the second part of your structure with the actual data that
<P><PRE>      represents the control's property value.
</PRE><P>
   e. Call PX_Blob, unlock and free the global memory.

<P><LI>If the control's properties are being loaded, do the following:
<P>
   a. Call PX_Blob to get the handle to memory containing the property
<P><PRE>      data.
</PRE><P>
   b. Lock the handle to get a pointer to the actual property data.
<P>
   c. Set the value of the property, and then unlock and free the global
<P><PRE>      memory.
</PRE><P>
   d. If the preceding call to PX_Blob in didn't return a handle to memory
<P><PRE>      containing a BLOB containing the property value, initialize the
      property to a default value.
</PRE><P>
</OL>The essential point in the steps is to make sure the first four bytes of
information referenced by the hBlob passed to PX_Blob is a ULONG
representing the number of bytes of data to follow.
<P>
<P><h3>Sample Code</h3>
 
<P>
The following sample code illustrates, using the previously listed steps,
in the context of the MFC CIRC3 OLE control sample. The sample code uses
PX_Blob to serialize the Offset property of the CIRC3 OLE control.
<P>
<PRE>///////////////////////////////////////////////////////////////////////
// CIRC3CTL.H

//  STEP 1:
//  Declare a structure to make working with a BLOB easier.
   typedef struct tagOFFSET
   {
     ULONG size;
     short offset;
   } OFFSET;

   class CCirc3Ctrl : public COleControl
   {
   public:
     //  STEP 2:
     //  Declare an HGLOBAL member in the control's class declaration.
     HGLOBAL hOffset;
     ...
   };

///////////////////////////////////////////////////////////////////////
// CIRC3CTL.CPP

   CCirc3Ctrl::CCirc3Ctrl()
   {
     InitializeIIDs(&amp;IID_DCirc3, &amp;IID_DCirc3Events);

     //  STEP 3:
     //  Initialize the HGLOBAL member to NULL.
     hOffset = NULL;

     //  TODO: Initialize your control's instance data here.
   }

   void CCirc3Ctrl::DoPropExchange(CPropExchange* pPX)
   {
     ExchangeVersion(pPX, MAKELONG(_wVerMinor, _wVerMajor));
     COleControl::DoPropExchange(pPX);

     if (pPX-&gt;GetVersion() == (DWORD)MAKELONG(_wVerMinor, _wVerMajor))
     {
       PX_Bool(pPX, _T("CircleShape"), m_circleShape, TRUE);

       //****** NEW PX_Blob RELATED CODE STARTS HERE ******

       if(!pPX-&gt;IsLoading())
       {
         //  The control's properties are being saved.

         //  STEP 4.a:
         //  GlobalAlloc the size of your structure. This step could take
         //  place somewhere else and GMEM_FIXED isn't required.
         hOffset = GlobalAlloc(GMEM_FIXED, sizeof(OFFSET));

         if(hOffset != NULL)
         {
           //  STEP 4.b:
           //  GlobalLock the handle returned from the GlobalAlloc call.
           OFFSET * p_mem = (OFFSET*)GlobalLock(hOffset);

           if(p_mem != NULL)
           {
             //  STEP 4.c:
             //  Fill in the first part of your structure with the
             //  sizeof(your property data).
             p_mem-&gt;size = (long)sizeof(short); // The offset property is
                                                // a short.
             //  STEP 4.d:
             //  Fill in the second part of your structure with the actual
             //  data that represents the control's property value.
             p_mem-&gt;offset = m_circleOffset;

             //  STEP 4.e:
             //  Call PX_Blob, unlock and free your global memory.
             PX_Blob(pPX, _T("CircleOffset"), hOffset);

             GlobalUnlock(hOffset);
           }
           else
           {
             // The GlobalLock call failed. Pass in a NULL HGLOBAL for the
             // third parameter to PX_Blob. This will cause it to write a
             // value of zero for the BLOB data.
             HGLOBAL hTmp = NULL;

             PX_Blob(pPX, _T("CircleOffset"), hTmp);
           }

           GlobalFree(hOffset);
           hOffset = NULL;
         }
         else
           // The GlobalAlloc call failed. Pass in a NULL HGLOBAL for the
           // third parameter to PX_Blob. This will cause it to write a
           // value of zero for the BLOB data.
           PX_Blob(pPX, _T("CircleOffset"), hOffset);
       }
       else
       {
         //  Properties are being loaded into the control.

         //  STEP 5.a:
         //  Call PX_Blob to get the handle to the memory containing
         //  the property data.
         PX_Blob(pPX, _T("CircleOffset"), hOffset);

         //  Definitely error check hOffset
         if(hOffset != NULL)
         {
           // STEP 5.b:
           // Lock the memory to get a pointer to the actual property
           // data.
           OFFSET * p_mem = (OFFSET *)GlobalLock(hOffset);

           if(p_mem != NULL)
           {
             //  Step 5.c:
             //  Set the value of the property, unlock and free the global
             //  memory.
             m_circleOffset = p_mem-&gt;offset;
             GlobalUnlock(hOffset);
           }
           else
             m_circleOffset = 0;

           GlobalFree(hOffset);
           hOffset = NULL;
         }
         else
           //  STEP 5.d:
           //  If the preceeding call to PX_Blob didn't give a handle
           //  to memory containing a BLOB containing the property value,
           //  initialize the property value to a default value.
           m_circleOffset = 0;
       }

       //  Comment out the original PX_Short call for the original
       //  non-BLOB version of the Offset property used by the CIRC3
       //  sample.
       // PX_Short(pPX, _T("CircleOffset"), m_circleOffset, 0);

       //****** NEW PX_Blob RELATED CODE ENDS HERE ******

       PX_Long(pPX, _T("FlashColor"), (long &amp;)m_flashColor,
           RGB(0xFF, 0x00, 0x00));
       PX_String(pPX, _T("Note"), m_note, _T(""));
     }
     else if (pPX-&gt;IsLoading())
     {
       m_circleShape = TRUE;
       m_circleOffset = 0;
       m_flashColor = RGB(0xFF, 0x00, 0x00);
       m_note = _T("");
     }
   }
</PRE>

	</FONT>
	</TD>
	</TR>
</TABLE>
<P>


<!--DOCBODY_END-->

<!--FOOTER_START-->
<table cellpadding=5 border=0 width="90%">
<tr>
<td>
	<HR WIDTH="90%">

<BLOCKQUOTE>
<FONT FACE="Verdana, Arial, Helvetica" SIZE="1">
<SPAN STYLE="font-family:verdana,arial,helvetica; font-size:8pt">
Additional query words: 1.5 2.5 1.51 2.51 1.52 2.52 2.0 3.0 2.1 3.1 2.2 3.2<BR>
Keywords            : CDKIss kbcode vcfixlist500<BR>
Technology          : kbMfc kbole<BR>
Version             : 1.0 1.1 1.2 4.0 4.1<BR>
Platform            : NT WINDOWS<BR>
Issue type          : kbdocerr<BR>
Resolution Type     : kbdocfix<BR>

</SPAN>
</FONT>
<BR>
<BR>
THE INFORMATION PROVIDED IN THE MICROSOFT KNOWLEDGE BASE IS
PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND.  MICROSOFT DISCLAIMS
ALL WARRANTIES, EITHER EXPRESS OR IMPLIED, INCLUDING THE WARRANTIES
OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  IN NO
EVENT SHALL MICROSOFT CORPORATION OR ITS SUPPLIERS BE LIABLE FOR
ANY DAMAGES WHATSOEVER INCLUDING DIRECT, INDIRECT, INCIDENTAL,
CONSEQUENTIAL, LOSS OF BUSINESS PROFITS OR SPECIAL DAMAGES, EVEN IF
MICROSOFT CORPORATION OR ITS SUPPLIERS HAVE BEEN ADVISED OF THE
POSSIBILITY OF SUCH DAMAGES.  SOME STATES DO NOT ALLOW THE EXCLUSION
OR LIMITATION OF LIABILITY FOR CONSEQUENTIAL OR INCIDENTAL DAMAGES
SO THE FOREGOING LIMITATION MAY NOT APPLY.
</BLOCKQUOTE>
<P>
<center>
	<FONT FACE="Verdana,Arial,Helvetica" SIZE="1">
	Last reviewed:  June 26, 1997</FONT>
	<BR>
	<A href="../cpyright.htm" STYLE="font: bold 7pt Verdana,Arial,Helvetica">&copy; 1998 Microsoft Corporation. All rights reserved. Terms of Use.</A><BR>
	
</center>
</td>
</tr>
</table>

<!--FOOTER_END-->
</FONT>
</BODY>
</HTML>
