

<HTML>
<HEAD>
<TITLE>SAMPLE: Dynamic Column Binding with MFC ODBC Database Classes </TITLE>

<!--STYLE_BEGIN-->
<style>@import url(../../msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="../../msdn_ie3.css">
<!--STYLE_END-->

<META HTTP-EQUIV="CONTENT-Type" CONTENT="text/html; charset=us-ascii">
<META NAME="ms.locale" CONTENT="EN-US">
<META NAME="Category" CONTENT="Support; KB Article">
<META NAME="KBID" CONTENT="Q141802">
<META NAME="KBModify" CONTENT="1997/07/31">
<META NAME="KBCreate" CONTENT="1995/12/27">
<META NAME="Keywords" CONTENT="MfcDatabase kbprg kbsample kbusage kbfile">
<META NAME="KBArea" CONTENT="Support; KB; visualc">
<META NAME="Description" CONTENT=" This is a 32-bit version of the DYNCOL sample.   The DYNC32 sample demonstrates how to dynamically determine the number, types, and names of each column in a given table and then bind these columns to dynamically allocated objects in your CRecordset...">
<META NAME="Product" CONTENT="Visual C++">
<META NAME="Platform" CONTENT="Windows">
<META NAME="Technology" CONTENT=" ">
<META NAME="Premium" CONTENT="support">

<META NAME="nyms" CONTENT="QAE1,QAPN,QDMN,QAW6,QBSO,QAUD,QAGX,QAYY,QAGI,QAML,QAZV,QANE,QBWS,QACI,QA5V V02180118">
</HEAD>

<BODY BGCOLOR="#FFFFFF" LEFTMARGIN="0" RIGHTMARGIN="0" TOPMARGIN="0">


<!--DOCBODY_START-->
<BR>
<CENTER>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" VALIGN="top" WIDTH="90%">
	<TR>
		<TD VALIGN="top">
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<H1>SAMPLE: Dynamic Column Binding with MFC ODBC Database Classes</H1>
			</FONT>
			<FONT FACE="verdana,arial,helvetica" SIZE="1">
			Last reviewed:  July 31, 1997</FONT><BR>
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<B>Article ID: Q141802</B>
			</FONT>
		</TD>
	</TR>
	<TR>
	<TD>
	<FONT FACE="Verdana, Arial, Helvetica" SIZE=2>



 
 
The information in this article applies to:

<UL><LI>The Microsoft Foundation Classes (MFC) included with:
   - Microsoft Visual C++, 32-bit Edition, versions 4.0, 4.1, 4.2, 5.0
</UL> 
<P>
This is a 32-bit version of the DYNCOL sample.
<P>
<P><h2>SUMMARY</h2>
 
<P>
The DYNC32 sample demonstrates how to dynamically determine the number,
types, and names of each column in a given table and then bind these
columns to dynamically allocated objects in your CRecordset derived class.
<P>
This sample has been updated to work with the new implementation of
CRecordset in Visual C++ 4.2 while remaining compatible with 4.0 and 4.1.
<P>
The following file is available for download from the Microsoft Software
Library:
<P>
<PRE> ~ <A href="http://support.microsoft.com/download/support/mslfiles/dync32.exe">Dync32.exe</A> <I>(size: 50364 bytes)</I> 

</PRE>For more information about downloading files from the Microsoft Software
Library, please see the following article in the Microsoft Knowledge Base:
<P>
<PRE>   ARTICLE-ID: <B><A href="../zmiscellaneous/q119591.htm">Q119591</A></B>
   TITLE     : How to Obtain Microsoft Support Files from Online Services

</PRE>DYNC32.EXE contains subdirectories, so you will want to preserve the
directory structure. After you download it, place it in an empty
directory and extract the files it contains by using the -d option:
<P>
<PRE>   DYNC32.EXE -d

</PRE><h2>MORE INFORMATION</h2>
 
<P>
DYNC32 follows the basic procedures outlined in the documentation titled,
"Dynamically Binding Data Columns," found in Database Encyclopedia of the
Books OnLine. However, DYNC32 has no permanent members, therefore only one
list is generated that contains information for all the columns in the
table. If you have a subset of columns that are always present and are
therefore member variables of the CRecordset derived class, you will need
to follow the instructions in the article on generating only a list of the
columns not already bound. DYNC32 only constructs a single list and
implements methods for performing DoFieldExchange() and DoDataExchange()
for this list of dynamically allocated objects.
<P>
<P><h3>Generating the List</h3>
 
<P>
The first thing DYNC32 must do is determine how many columns are in the
database, and of what type. To do this, the CRecordset-derived object,
CDynCol32Set, contains a CColumns object to query this information. In
CDynCol32Set, the Open member function has been overridden so that the
column information can be retrieved before the base-class CRecordset::Open
function is called to open the database. After this information has been
accessed, a list of CColumnData objects is allocated to hold a description
of each column in the table, plus a pointer to a storage object allocated
for that column (to be used in the record field exchange routines).
<P>
<PRE>   BOOL CDyncol32Set::Open(UINT nOpenType, LPCSTR lpszSql, DWORD
</PRE>dwOptions)
<PRE>   {
     // use one CDatabase Object so we only prompt once for database Open
     // ***** allocated in constructor...

     if (! m_pDatabase-&gt;Open(NULL, FALSE, FALSE, "ODBC;"))
       return  FALSE;

     CTables tables(m_pDatabase);

     // prompt for a table to open
     CTablesDialog tableName(NULL,m_pDatabase);
     if (IDCANCEL == tableName.DoModal())
       return FALSE;

     // Specify the table to look at
     m_pColumns = new CColumns(m_pDatabase);
     m_pColumns-&gt;m_strTableNameParam = tableName.m_strTableNameSelected;

     // Set the database to be the CDynaSet's database if one hasn't
     // already been set (this should be the case)
     if (m_pColumns-&gt;m_pDatabase == NULL)
       m_pColumns-&gt;m_pDatabase = m_pDatabase;

     // Open the recordset to get the column info
     if (!m_pColumns-&gt;Open(CRecordset::forwardOnly, NULL,
   CRecordset::readOnly))

       return FALSE;

     // Initialize the number of fields dynamically allocated to CDynaSet
     m_nFields = 0;

     // Loop until we've seen all the columns
     while (!m_pColumns-&gt;IsEOF())
     {
       // Allocate a new CColumnData object for the current column
       CColumnData *pData = new CColumnData;

       // Store the colmun information
       pData-&gt;m_nDataType = m_pColumns-&gt;m_nDataType;
       pData-&gt;m_strColumnName = "[";
       pData-&gt;m_strColumnName += m_pColumns-&gt;m_strColumnName;
       pData-&gt;m_strColumnName +="]";

       // Allocate an object of the appropriate type to store
       // the column data
       switch(pData-&gt;m_nDataType)
       {
         case SQL_BIT:
           pData-&gt;m_pData = (void *)new BOOL;
           break;

         case SQL_TINYINT:
           pData-&gt;m_pData = (void *)new BYTE;
           break;

         case SQL_SMALLINT:
           pData-&gt;m_pData = (void *)new int;
           break;

          ...

         default:
           ASSERT(FALSE);
       }

       // Add the column descriptor to the list and
       // increment the number of columns in the
    CDynaSet

       m_pList.AddTail(pData);
       m_nFields++;

       // Get the next column's information
       m_pColumns-&gt;MoveNext();
     }

     // Free the HSTMT used to get the table info
     RETCODE nRetCode;
     AFX_SQL_SYNC(::SQLFreeStmt(m_pColumns-&gt;m_hstmt, SQL_CLOSE));
     // Return the base class if we got this far
     lpszSql = m_pColumns-&gt;m_strTableNameParam;

     // we don't need the columns recordset any more
     delete m_pColumns;
     return CRecordset::Open(nOpenType, lpszSql, dwOptions);
   }

</PRE><h3>Getting the Column Data into the Recordset</h3>
 
<P>
Once the CColumnData list has been generated, DoFieldExchange() must be
overridden to traverse this list and call the appropriate RFX routine for
each CColumnData's storage object.
<P>
<PRE>   void CDyncol32Set::DoFieldExchange(CFieldExchange* pFX)
   {
     // Set the type of exhange; same as AppWizard generated
     pFX-&gt;SetFieldType(CFieldExchange::outputColumn);

     // Get a pointer to the first CColumnData object in the list
     POSITION rPos = m_pList.GetHeadPosition();
     CColumnData *pData = (CColumnData *)m_pList.GetNext(rPos);

     // Loop until we've traversed all the columns
     while (pData)
     {
       // Call the appropriate RFX routine for the column's type
       switch(pData-&gt;m_nDataType)
       {
         case SQL_BIT:
           RFX_Bool(pFX, pData-&gt;m_strColumnName, *((BOOL *)(pData-
                                                            &gt;m_pData)));
           break;

         case SQL_TINYINT:
           RFX_Byte(pFX, pData-&gt;m_strColumnName, *((BYTE *)(pData-
                                                            &gt;m_pData)));
           break;

         case SQL_SMALLINT:
           RFX_Int(pFX, pData-&gt;m_strColumnName, *((int *)(pData-
                                                          &gt;m_pData)));
           break;

         ...

         default:
            ASSERT(FALSE);
       }

       // Set pData to NULL if that was the last column
       if (rPos)
         pData = (CColumnData *)m_pList.GetNext(rPos);
       else
         pData = NULL;
     }
   }

</PRE><h3>Getting the Recordset Data into the View</h3>
 
<P>
After getting the data into the recordset, the last thing to do is to get
this information into the CRecordView-derived class to be displayed. In
the case of DYNC32, it simply uses a GRID OCX control to do a straight
dump of the data onto the view. In order to do this, the CColumnData list
must again be traversed. Normally an appropriate DDX routine would be
called for each element in the list, but DYNC32 only puts the information
into the cells of a GRID OCX control to be displayed.
<P>
<PRE>   void CDyncol32View::DoDataExchange(CDataExchange* pDX)
   {
      CRecordView::DoDataExchange(pDX);
      //{{AFX_DATA_MAP(CDyncol32View)
      DDX_Control(pDX, IDC_GRID1, m_grid);
      //}}AFX_DATA_MAP
      RefreshData();
   }

   void CDyncol32View::RefreshData()
   {
     if (!m_pSet-&gt;IsOpen())
     return;
     // Get pointer to CDynaSet's CColumnData list
     CPtrList *pList = &amp;m_pSet-&gt;m_pList;

     // Get the first element
     POSITION rPos = pList-&gt;GetHeadPosition();
     CColumnData *pData = (CColumnData *)pList-&gt;GetNext(rPos);

     // Allocate a string buffer to be used in conversions
     CString strBuffer;

     // Set the initial row to fill in
     int row = 1;

     // Set the GRID to have the correct number of rows and columns
     m_grid.SetRows(m_pSet-&gt;m_nFields + 1);
     m_grid.SetCols(2);
     m_grid.SetColWidth(0, 2500);
     m_grid.SetColWidth(1, 2500);

     // Loop until we've traversed all the CColumnData objects
     while (pData)
     {
       // Insert the column name in the first column and move
       // to the second column to insert the data
       m_grid.SetRow(row);
       m_grid.SetCol(0);
       m_grid.SetText(pData-&gt;m_strColumnName);
       m_grid.SetCol(1);

       // Call the appropriate DDX
       switch(pData-&gt;m_nDataType)
       {
         case SQL_BIT:
           strBuffer = *((BOOL *) (pData-&gt;m_pData)) ? "TRUE" : "FALSE";
           m_grid.SetText(strBuffer);
           break;

        case SQL_TINYINT:
        {
          char *pBuffer = strBuffer.GetBuffer(32);
          _itoa(*((BYTE *)(pData-&gt;m_pData)), pBuffer, 10);
        }
        strBuffer.ReleaseBuffer();
        m_grid.SetText(strBuffer);
        break;

        case SQL_SMALLINT:
        case SQL_INTEGER:
        {
           char *pBuffer = strBuffer.GetBuffer(32);
           _itoa(*((int *)(pData-&gt;m_pData)), pBuffer, 10);
        }
        strBuffer.ReleaseBuffer();
        m_grid.SetText(strBuffer);
        break;

        ...

        default:
          ASSERT(FALSE);
       }
       // Increment the row and check to see if that was our
       // last CColumnData in the list
       row++;
       if (rPos)
         pData = (CColumnData *)pList-&gt;GetNext(rPos);
       else
         pData = NULL;
     }
   }

</PRE>The most fundamental concepts of the sample are contained within the
CColumns and CColumnData objects. The first allows DYNC32 to determine the
name and data type for each column in the table. With this information it
is able to allocate a linked list of CColumnData objects. Each CColumnData
object is a descriptor that contains the name, type and a pointer to a
data object of the correct type. Once this list has been constructed,
traversal routines must be put in the DoFieldExchange() and
DoDataExchange() routines to perform the appropriate RFX/DDX function with
the allocated data object.
<P>
Note that the implementation of CRecordset has changed from between
version 4.1 and 4.2. As a result, you will notice that CColumns::Open()
and CTables::Open(), the two overrides of CRecordset::Open() that are used
to directly call ODBC API functions, now include conditional code. This
code represents the minimum that must be done to update the recordsets to
4.2.
<P>
 
<PRE>Keywords          : MfcDatabase kbprg kbsample kbusage kbfile
Technology        : kbMfc
Version           : 4.0 4.1 4.2 5.0
Platform          : NT WINDOWS
Solution Type     : kbcode</PRE>

	</FONT>
	</TD>
	</TR>
</TABLE>
<P>


<!--DOCBODY_END-->

<!--FOOTER_START-->
<table cellpadding=5 border=0 width="90%">
<tr>
<td>
	<HR WIDTH="90%">

<BLOCKQUOTE>
<FONT FACE="Verdana, Arial, Helvetica" SIZE="1">
<SPAN STYLE="font-family:verdana,arial,helvetica; font-size:8pt">
================================================================================<BR>

</SPAN>
</FONT>
<BR>
<BR>
THE INFORMATION PROVIDED IN THE MICROSOFT KNOWLEDGE BASE IS
PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND.  MICROSOFT DISCLAIMS
ALL WARRANTIES, EITHER EXPRESS OR IMPLIED, INCLUDING THE WARRANTIES
OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  IN NO
EVENT SHALL MICROSOFT CORPORATION OR ITS SUPPLIERS BE LIABLE FOR
ANY DAMAGES WHATSOEVER INCLUDING DIRECT, INDIRECT, INCIDENTAL,
CONSEQUENTIAL, LOSS OF BUSINESS PROFITS OR SPECIAL DAMAGES, EVEN IF
MICROSOFT CORPORATION OR ITS SUPPLIERS HAVE BEEN ADVISED OF THE
POSSIBILITY OF SUCH DAMAGES.  SOME STATES DO NOT ALLOW THE EXCLUSION
OR LIMITATION OF LIABILITY FOR CONSEQUENTIAL OR INCIDENTAL DAMAGES
SO THE FOREGOING LIMITATION MAY NOT APPLY.
</BLOCKQUOTE>
<P>
<center>
	<FONT FACE="Verdana,Arial,Helvetica" SIZE="1">
	Last reviewed:  July 31, 1997</FONT>
	<BR>
	<A href="../cpyright.htm" STYLE="font: bold 7pt Verdana,Arial,Helvetica">&copy; 1998 Microsoft Corporation. All rights reserved. Terms of Use.</A><BR>
	
</center>
</td>
</tr>
</table>

<!--FOOTER_END-->
</FONT>
</BODY>
</HTML>
