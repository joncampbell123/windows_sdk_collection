

<HTML>
<HEAD>
<TITLE>HOWTO: Initilize Large Character Arrays </TITLE>

<!--STYLE_BEGIN-->
<style>@import url(../../msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="../../msdn_ie3.css">
<!--STYLE_END-->

<META HTTP-EQUIV="CONTENT-Type" CONTENT="text/html; charset=us-ascii">
<META NAME="ms.locale" CONTENT="EN-US">
<META NAME="Category" CONTENT="Support; KB Article">
<META NAME="KBID" CONTENT="Q38728 ">
<META NAME="KBModify" CONTENT="1997/10/10">
<META NAME="KBCreate" CONTENT="1988/12/02">
<META NAME="Keywords" CONTENT="CLngIss kbfasttip">
<META NAME="KBArea" CONTENT="Support; KB; visualc">
<META NAME="Description" CONTENT="  A common problem in C programming is initializing a large character array. There are several ways of doing this, as well as several potential problems.  MORE INFORMATION  Method 1 -- String Literals  One method of initializing character arrays is t...">
<META NAME="Product" CONTENT="Visual C++">
<META NAME="Platform" CONTENT="Windows">
<META NAME="Technology" CONTENT=" ">
<META NAME="Premium" CONTENT="support">

<META NAME="nyms" CONTENT="QABN,QAPN,QATX,QBFY,QAH4,QAHT,QAJB,QBFN,QAJQ,QAWN,QAKE,QBW7,QBWP,QBVV,QAY4 V02180118">
</HEAD>

<BODY BGCOLOR="#FFFFFF" LEFTMARGIN="0" RIGHTMARGIN="0" TOPMARGIN="0">


<!--DOCBODY_START-->
<BR>
<CENTER>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" VALIGN="top" WIDTH="90%">
	<TR>
		<TD VALIGN="top">
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<H1>HOWTO: Initilize Large Character Arrays</H1>
			</FONT>
			<FONT FACE="verdana,arial,helvetica" SIZE="1">
			Last reviewed:  October 10, 1997</FONT><BR>
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<B>Article ID: Q38728 </B>
			</FONT>
		</TD>
	</TR>
	<TR>
	<TD>
	<FONT FACE="Verdana, Arial, Helvetica" SIZE=2>



 
 
The information in this article applies to:

<UL><LI>Microsoft C for MS-DOS, versions 6.0, 6.0a, 6.0ax
<LI>Microsoft C/C++ for MS-DOS, version 7.0
<LI>Microsoft Visual C++ for Windows, versions 1.0, 1.5, 1.51, 1.52
<LI>Microsoft Visual C++ 32-bit Edition, versions 1.0, 2.0, 2.1, 4.0, 5.0
</UL> 
<P>
<P><h2>SUMMARY</h2>
 
<P>
A common problem in C programming is initializing a large character
array. There are several ways of doing this, as well as several
potential problems.
<P>
<P><h2>MORE INFORMATION</h2>
 
<P>
<P><h3>Method 1 -- String Literals</h3>
 
<P>
One method of initializing character arrays is to use a character string
literal. The minimum limit allowed by ANSI for a character string literal
after concatenation is 509 characters. The limit in early versions of
Microsoft C/C++ was between 512-2048 characters depending on the specific
version of the compiler. Because of the limit on the length of a string
literal, you cannot initialize character arrays longer than these limits
with this method. (These limits include the final null character of a C
"string." Thus the statement char a[] = "12"; results in a 3-element
array.)
<P>
<P>
Because there is also a limit on the line length in most editors, you
normally cannot directly put this many characters in a string literal.
The compiler will concatenate a series of quoted strings into a single
string, however, so the declaration
<P>
<PRE>   char a[] = "a"
              "b";

</PRE>is the same as:
<P>
<PRE>   char a[] = "ab";

</PRE>This allows placing large literal initializers into the code as shown
below. This method runs into the compiler limit.
<P>
<P>
<PRE>   char stuff[] =
      "xxx...xxx"
          ...
      "xxx...xxx";

</PRE>(The ANSI standard states that strings separated only by white space
are automatically concatenated.)
<P>
<P><h3>Method 2 -- Character Initializers</h3>
 
<P>
The following can be used:
<P>
<PRE>   char stuff [] =
      { 'a', ...
             ...
        ... 'z' };

</PRE>However, such an initializer is tedious to type. If using this method,
write a program that will read a data file and output the proper
initializer.
<P>
<P><h3>Method 3 -- Multidimensional Arrays</h3>
 
<P>
<PRE>   char stuff[][10] =  {
      "0123456789",
      ...
      "0123456789"  };

</PRE>The value 10 is not important EXCEPT that it must match the actual
length of the string constants. If any of the constants are shorter
than the length specified, the end of that row will be padded out with
zero bytes. If any are longer, the extra characters will be thrown
away. This results in a two dimensional array. Another pointer can be
used to access the following in almost any method desired:
<P>
<PRE>   char *stuffptr = (char *) stuff;

</PRE>This method seems to be the most convenient. The big problem with
using a pointer to try and address the array as a single dimensional
array is that the extra null characters make counting difficult,
particularly if all the initializer strings are not the same length.
Thus stuffptr[97] may not access the element you expect unless you
count very carefully.
<P>
<P><h3>Method 4 -- Assembly Modules</h3>
 
<P>
The array can also be defined in MASM and linked to your C program. In
MASM, once the correct segment and public definitions are done, write
the following:
<P>
<PRE>stuff   db      "abcdefghijkl"
        db      "morestuff"
        ...
        db      "laststuff"

</PRE>In C, access the array with the following:
<P>
<PRE>   extern char stuff[];   /*    char * stuff;   will NOT work    */

</PRE><h3>Method 5 -- Read from a File</h3>
 
<P>
Another method is to read the values into the array at run time from a
data file. If the file is read in large blocks (for example, using
read or fread), the I/O will be quite fast. This method also has the
advantage that the initialization string can be changed without having
to change and recompile the code.
 
<PRE>Keywords          : CLngIss kbfasttip
Version           : MS-DOS:6.0,6.00a,6.00ax,7.0; WINDOWS:1.0,1.5,1.51,1.52;  WINDOWS NT:1.0,2.0,2.1,4.0,5.0
Platform          : MS-DOS NT WINDOWS
Issue type        : kbhowto</PRE>

	</FONT>
	</TD>
	</TR>
</TABLE>
<P>


<!--DOCBODY_END-->

<!--FOOTER_START-->
<table cellpadding=5 border=0 width="90%">
<tr>
<td>
	<HR WIDTH="90%">

<BLOCKQUOTE>
<FONT FACE="Verdana, Arial, Helvetica" SIZE="1">
<SPAN STYLE="font-family:verdana,arial,helvetica; font-size:8pt">
================================================================================<BR>

</SPAN>
</FONT>
<BR>
<BR>
THE INFORMATION PROVIDED IN THE MICROSOFT KNOWLEDGE BASE IS
PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND.  MICROSOFT DISCLAIMS
ALL WARRANTIES, EITHER EXPRESS OR IMPLIED, INCLUDING THE WARRANTIES
OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  IN NO
EVENT SHALL MICROSOFT CORPORATION OR ITS SUPPLIERS BE LIABLE FOR
ANY DAMAGES WHATSOEVER INCLUDING DIRECT, INDIRECT, INCIDENTAL,
CONSEQUENTIAL, LOSS OF BUSINESS PROFITS OR SPECIAL DAMAGES, EVEN IF
MICROSOFT CORPORATION OR ITS SUPPLIERS HAVE BEEN ADVISED OF THE
POSSIBILITY OF SUCH DAMAGES.  SOME STATES DO NOT ALLOW THE EXCLUSION
OR LIMITATION OF LIABILITY FOR CONSEQUENTIAL OR INCIDENTAL DAMAGES
SO THE FOREGOING LIMITATION MAY NOT APPLY.
</BLOCKQUOTE>
<P>
<center>
	<FONT FACE="Verdana,Arial,Helvetica" SIZE="1">
	Last reviewed:  October 10, 1997</FONT>
	<BR>
	<A href="../cpyright.htm" STYLE="font: bold 7pt Verdana,Arial,Helvetica">&copy; 1998 Microsoft Corporation. All rights reserved. Terms of Use.</A><BR>
	
</center>
</td>
</tr>
</table>

<!--FOOTER_END-->
</FONT>
</BODY>
</HTML>
