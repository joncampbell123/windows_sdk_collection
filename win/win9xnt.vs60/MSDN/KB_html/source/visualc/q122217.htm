

<HTML>
<HEAD>
<TITLE>PRB: offsetof() Macro Fails with Virtual Base Class </TITLE>

<!--STYLE_BEGIN-->
<style>@import url(../../msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="../../msdn_ie3.css">
<!--STYLE_END-->

<META HTTP-EQUIV="CONTENT-Type" CONTENT="text/html; charset=us-ascii">
<META NAME="ms.locale" CONTENT="EN-US">
<META NAME="Category" CONTENT="Support; KB Article">
<META NAME="KBID" CONTENT="Q122217">
<META NAME="KBModify" CONTENT="1997/07/24">
<META NAME="KBCreate" CONTENT="1994/11/01">
<META NAME="Keywords" CONTENT="CodeGen CPPIss vcbuglist400">
<META NAME="KBArea" CONTENT="Support; KB; visualc">
<META NAME="Description" CONTENT="  Use of the offsetof() macro may cause the compiler to generate incorrect code when used with classes that have virtual base classes. This incorrect code results in a null pointer access, which causes an access violation when the application is exec...">
<META NAME="Product" CONTENT="Visual C++">
<META NAME="Platform" CONTENT="Windows">
<META NAME="Technology" CONTENT=" ">
<META NAME="Premium" CONTENT="support">

<META NAME="nyms" CONTENT="QAH4,QA2O,QABA,QBFY,QABO,QDKW,QDH9,QA4Q,QAUD,QAPN,QBW7,QA0K,QAI5,QAC2,QAKP V02180118">
</HEAD>

<BODY BGCOLOR="#FFFFFF" LEFTMARGIN="0" RIGHTMARGIN="0" TOPMARGIN="0">


<!--DOCBODY_START-->
<BR>
<CENTER>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" VALIGN="top" WIDTH="90%">
	<TR>
		<TD VALIGN="top">
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<H1>PRB: offsetof() Macro Fails with Virtual Base Class</H1>
			</FONT>
			<FONT FACE="verdana,arial,helvetica" SIZE="1">
			Last reviewed:  July 24, 1997</FONT><BR>
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<B>Article ID: Q122217</B>
			</FONT>
		</TD>
	</TR>
	<TR>
	<TD>
	<FONT FACE="Verdana, Arial, Helvetica" SIZE=2>



 
 
The information in this article applies to:

<UL><LI>Microsoft C/C++ Compiler (CL.EXE) included with:
   - Microsoft Visual C++, 32-bit Edition, versions 1.0, 2.0, 4.0, 4.1, 4.2
</UL> 
<P>
<P><h2>SYMPTOMS</h2>
 
<P>
Use of the offsetof() macro may cause the compiler to generate incorrect
code when used with classes that have virtual base classes. This incorrect
code results in a null pointer access, which causes an access violation
when the application is executed.
<P>
This problem occurs only for members declared in the virtual base class.
<P>
Note that according to the ANSI C++ Draft Working Papers, clause 18.1.5,
the offsetof macro is restricted to POD union and POD structure types.
POD types may not have base classes. Using the macro contrary to this
restriction results in undefined behavior.
<P>
<P><h2>RESOLUTION</h2>
 
<P>
The offsetof() macro returns the offset in bytes of a member from the
beginning of a class by casing NULL to a pointer of class/struct type. To
work around this problem, cast the address of the object to a char *, cast
the address of the member to a char *, and subtract the address of the
object from the address of the member. Please see the Sample Code in the
MORE INFORMATION section for an example.
<P>
While this workaround generates code that is as efficient as the offsetof()
macro, it does require that the class/struct be instanced, while offsetof()
does not.
<P>
<P><h2>STATUS</h2>
 
<P>
This is by design.
<P>
<P><h2>MORE INFORMATION</h2>
 
<P>
The following code demonstrates the problem and the workaround.
<P>
<P><h3>Sample Code</h3>
 
<P>
<PRE>   /* Compile options needed: none
   */

   #include &lt;stdio.h&gt;
   #include &lt;iostream.h&gt;
   #include &lt;stddef.h&gt;

   class A { public: int a; };
   class B : virtual public A { public: int v_a; };
   class C : virtual public A { public: int v_b; };
   class D : virtual public B, virtual public C { public: int b; };

   int main()
   {

      D xD;

      xD.b   = 16;
      xD.v_a = 8;
      xD.v_b = 4;
      xD.a   = 2;

      cout &lt;&lt; "sizeof(D) == " &lt;&lt; sizeof(D)   &lt;&lt; endl;
      cout &lt;&lt; "sizeof(C) == " &lt;&lt; sizeof(C)   &lt;&lt; endl;
      cout &lt;&lt; "sizeof(B) == " &lt;&lt; sizeof(B)   &lt;&lt; endl;
      cout &lt;&lt; "sizeof(A) == " &lt;&lt; sizeof(A)   &lt;&lt; endl &lt;&lt; endl;

   // The following code section works around the offsetof() problem
      cout &lt;&lt; "offsetof(D.b)   == " &lt;&lt; (char *)&amp;xD.b - (char *)&amp;xD &lt;&lt; endl;
      cout &lt;&lt; "offsetof(D.v_a) == " &lt;&lt; (char *)&amp;xD.v_a - (char *)&amp;xD &lt;&lt;
      endl;
      cout &lt;&lt; "offsetof(D.v_b) == " &lt;&lt; (char *)&amp;xD.v_b - (char *)&amp;xD &lt;&lt;
      endl;
      cout &lt;&lt; "offsetof(D.a)   == " &lt;&lt; (char *)&amp;xD.a - (char *)&amp;xD &lt;&lt; endl;
      cout &lt;&lt; endl;

   // The following statement is generated correctly
      cout &lt;&lt; "offsetof(D.b)   == " &lt;&lt; offsetof(D, b)   &lt;&lt; endl;

   // The following three statements cause access violations when executed
      cout &lt;&lt; "offsetof(D.v_a) == " &lt;&lt; offsetof(D, v_a) &lt;&lt; endl;
      cout &lt;&lt; "offsetof(D.v_b) == " &lt;&lt; offsetof(D, v_b) &lt;&lt; endl;
      cout &lt;&lt; "offsetof(D.a)   == " &lt;&lt; offsetof(D, a)   &lt;&lt; endl &lt;&lt; endl;

      cout &lt;&lt; "Press Enter...";
      cin.get();

      return 0;
   }
</PRE>

	</FONT>
	</TD>
	</TR>
</TABLE>
<P>


<!--DOCBODY_END-->

<!--FOOTER_START-->
<table cellpadding=5 border=0 width="90%">
<tr>
<td>
	<HR WIDTH="90%">

<BLOCKQUOTE>
<FONT FACE="Verdana, Arial, Helvetica" SIZE="1">
<SPAN STYLE="font-family:verdana,arial,helvetica; font-size:8pt">
Additional query words: 8.00 9.00 buglist1.00 buglist2.00 10.00 10.10 10.20<BR>
Keywords            : CodeGen CPPIss vcbuglist400<BR>
Version             : 1.0 2.0 4.0 4.1 4.2<BR>
Platform            : NT WINDOWS<BR>
Issue type          : kbprb<BR>

</SPAN>
</FONT>
<BR>
<BR>
THE INFORMATION PROVIDED IN THE MICROSOFT KNOWLEDGE BASE IS
PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND.  MICROSOFT DISCLAIMS
ALL WARRANTIES, EITHER EXPRESS OR IMPLIED, INCLUDING THE WARRANTIES
OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  IN NO
EVENT SHALL MICROSOFT CORPORATION OR ITS SUPPLIERS BE LIABLE FOR
ANY DAMAGES WHATSOEVER INCLUDING DIRECT, INDIRECT, INCIDENTAL,
CONSEQUENTIAL, LOSS OF BUSINESS PROFITS OR SPECIAL DAMAGES, EVEN IF
MICROSOFT CORPORATION OR ITS SUPPLIERS HAVE BEEN ADVISED OF THE
POSSIBILITY OF SUCH DAMAGES.  SOME STATES DO NOT ALLOW THE EXCLUSION
OR LIMITATION OF LIABILITY FOR CONSEQUENTIAL OR INCIDENTAL DAMAGES
SO THE FOREGOING LIMITATION MAY NOT APPLY.
</BLOCKQUOTE>
<P>
<center>
	<FONT FACE="Verdana,Arial,Helvetica" SIZE="1">
	Last reviewed:  July 24, 1997</FONT>
	<BR>
	<A href="../cpyright.htm" STYLE="font: bold 7pt Verdana,Arial,Helvetica">&copy; 1998 Microsoft Corporation. All rights reserved. Terms of Use.</A><BR>
	
</center>
</td>
</tr>
</table>

<!--FOOTER_END-->
</FONT>
</BODY>
</HTML>
