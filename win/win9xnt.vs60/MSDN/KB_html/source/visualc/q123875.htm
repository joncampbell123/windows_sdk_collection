

<HTML>
<HEAD>
<TITLE>_getimage() and _putimage() Functionality in Text Mode </TITLE>

<!--STYLE_BEGIN-->
<style>@import url(../../msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="../../msdn_ie3.css">
<!--STYLE_END-->

<META HTTP-EQUIV="CONTENT-Type" CONTENT="text/html; charset=us-ascii">
<META NAME="ms.locale" CONTENT="EN-US">
<META NAME="Category" CONTENT="Support; KB Article">
<META NAME="KBID" CONTENT="Q123875">
<META NAME="KBModify" CONTENT="1997/07/22">
<META NAME="KBCreate" CONTENT="1994/12/13">
<META NAME="Keywords" CONTENT="kb16bitonly">
<META NAME="KBArea" CONTENT="Support; KB; visualc">
<META NAME="Description" CONTENT="  The graphics library that ships with Microsoft C contains the functions _getimage() and _putimage() to read and write blocks of video memory. There is also a function called _imagesize() that you can use to determine the size of a buffer required t...">
<META NAME="Product" CONTENT="Visual C++">
<META NAME="Platform" CONTENT="Windows">
<META NAME="Technology" CONTENT=" ">
<META NAME="Premium" CONTENT="support">

<META NAME="nyms" CONTENT="QA4Q,QA5V,QDK0,QAYS,QAHC,QBFY,QA5W,QAEB,QAE8,QBW6,QATX,QAMB,QAUD,QAY5,QAEF V02180118">
</HEAD>

<BODY BGCOLOR="#FFFFFF" LEFTMARGIN="0" RIGHTMARGIN="0" TOPMARGIN="0">


<!--DOCBODY_START-->
<BR>
<CENTER>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" VALIGN="top" WIDTH="90%">
	<TR>
		<TD VALIGN="top">
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<H1>_getimage() and _putimage() Functionality in Text Mode</H1>
			</FONT>
			<FONT FACE="verdana,arial,helvetica" SIZE="1">
			Last reviewed:  July 22, 1997</FONT><BR>
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<B>Article ID: Q123875</B>
			</FONT>
		</TD>
	</TR>
	<TR>
	<TD>
	<FONT FACE="Verdana, Arial, Helvetica" SIZE=2>



 
6.00 6.00a 6.00ax 7.00 | 1.00 1.50
<PRE>MS-DOS                 | WINDOWS
</PRE>kbprg kbcode
<P>
 
The information in this article applies to:
<P>
<PRE>   The C Run-time (CRT) included with:
     - Microsoft C versions 6.0, 6.0a, and 6.0ax
     - Microsoft C/C++ version 7.0
     - Microsoft Visual C++ for Windows, versions 1.0 and 1.5
</PRE> 
<P>
<P><h2>SUMMARY</h2>
 
<P>
The graphics library that ships with Microsoft C contains the functions
_getimage() and _putimage() to read and write blocks of video memory. There
is also a function called _imagesize() that you can use to determine the
size of a buffer required to store an image. These image functions work
only in graphics modes. To obtain the functionality of _getimage() and
_putimage in a text mode, you need to create a pointer to video memory, and
access video memory directly through this pointer.
<P>
<P><h2>MORE INFORMATION</h2>
 
<P>
In the MS-DOS environment, video memory begins at segment 0xB000 for
monochrome text modes and segment 0xB800 for color text modes. Each
character is represented by two bytes; a byte containing the ASCII value of
the character to display and an additional byte representing the attributes
of the character. Attributes supported in monochrome modes include bold and
underline, while color mode attributes include foreground and background
color.
<P>
The sample code in this article uses the _FP_SEG and _FP_OFF macros to
initialize a global pointer to video memory (lpVM). Then it writes text to
the screen, allocates memory to store a text block, reads a text block from
the display, and writes that block to a new area of the display.
<P>
<P><h3>Sample Code</h3>
 
<P>
<PRE>/* Compile Options needed: /AL
*/

#include &lt;dos.h&gt;
#include &lt;conio.h&gt;
#include &lt;memory.h&gt;
#include &lt;malloc.h&gt;
#include &lt;process.h&gt;
#include &lt;stdio.h&gt;

char * lpVM;    // Global pointer to video memory - set in main()

/* Calculates offset from beginning of video memory to screen position */
int VidOff(int column, int row)
</PRE>{
<PRE>    return ( ( row * 80 ) + column ) * 2;
</PRE>}
<P>
<PRE>void PutChar(char c, int x, int y)
</PRE>{
<PRE>    *(lpVM+VidOff(x,y)) = c;
</PRE>}
<P>
<PRE>char GetChar(int x, int y)
</PRE>{
<PRE>    return *(lpVM+VidOff(x,y));
</PRE>}
<P>
<PRE>/* Reads block of video memory matching rectangular coordinates
</PRE>** into buffer (buf) note: buf must have been allocated with enough
** space for the block.  Similar to graphics.lib function _getimage().
<PRE>*/
void ReadBlock( char * buf, int left, int top, int right, int bottom)
</PRE>{
<PRE>    int row, destoffset, vidoffset;
    size_t rowsize;

    rowsize = ( right - left + 1 ) * 2;

    for ( row=top, destoffset=0; row&lt;=bottom; row++,
          destoffset+=rowsize )
    {
        vidoffset = VidOff(left, row);
        memcpy( buf+destoffset, lpVM+vidoffset, rowsize);
    }
</PRE>}
<P>
<PRE>/* Writes contents of buf to video memory matching coordinates.
</PRE>** Similar to graphics.lib function _putimage().
<PRE>*/
void WriteBlock( char * buf, int left, int top, int right, int bottom)
</PRE>{
<PRE>    int row, destoffset, vidoffset;
    size_t rowsize;

    rowsize = ( right - left + 1 ) * 2;

    for ( row=top, destoffset=0; row&lt;=bottom; row++,
          destoffset+=rowsize )
    {
        vidoffset = VidOff(left, row);
        memcpy( lpVM+vidoffset, buf+destoffset, rowsize);
    }
</PRE>}
<P>
<PRE>/* Calculates size requires for block of video memory fitting
</PRE>** coordinates and allocates space with malloc. Similar to
** graphics.lib function _imagesize(), but actually allocates
** the memory.
<PRE>*/
void * AllocBlock( int left, int top, int right, int bottom)
</PRE>{
<PRE>    size_t blocksize;

    blocksize = ( ( right - left + 1) * ( bottom - top + 1) ) * 2;

    return malloc( blocksize );
</PRE>}
<P>
<PRE>void main(void)
</PRE>{
<PRE>    int i,j;

    char * buf;

    system( "cls" );              // clear the display

    _FP_SEG( lpVM ) = 0xB800;     // B000 if monochrome
    _FP_OFF( lpVM ) = 0x0000;

    for (i=1; i&lt;20; i++)
    {
          PutChar( '\\', i, i );
          PutChar( '/', 80-i, i );
    }

    buf = AllocBlock( 5, 5, 80, 15 );

    ReadBlock( buf, 5, 5, 80, 15 );

    printf( "Block read. Press \"Enter\" to write block.\n" );

    getch();

    WriteBlock( buf, 5, 10, 80, 20 );

    getch();
    system( "cls" );              // clear the display
}

</PRE><h2>REFERENCES</h2>
 
<P>
Programmmer's Guide to PC &amp; PS/2 Video Systems by Richard Wilton (Microsoft
Press)
<P>

	</FONT>
	</TD>
	</TR>
</TABLE>
<P>


<!--DOCBODY_END-->

<!--FOOTER_START-->
<table cellpadding=5 border=0 width="90%">
<tr>
<td>
	<HR WIDTH="90%">

<BLOCKQUOTE>
<FONT FACE="Verdana, Arial, Helvetica" SIZE="1">
<SPAN STYLE="font-family:verdana,arial,helvetica; font-size:8pt">
Additional reference words: kbinf 6.00 6.00a 6.00ax 7.00 1.00 1.50<BR>
KBCategory: kbprg kbcode<BR>
KBSubcategory: CRTIss GraphicsIss<BR>
Keywords            : kb16bitonly<BR>

</SPAN>
</FONT>
<BR>
<BR>
THE INFORMATION PROVIDED IN THE MICROSOFT KNOWLEDGE BASE IS
PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND.  MICROSOFT DISCLAIMS
ALL WARRANTIES, EITHER EXPRESS OR IMPLIED, INCLUDING THE WARRANTIES
OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  IN NO
EVENT SHALL MICROSOFT CORPORATION OR ITS SUPPLIERS BE LIABLE FOR
ANY DAMAGES WHATSOEVER INCLUDING DIRECT, INDIRECT, INCIDENTAL,
CONSEQUENTIAL, LOSS OF BUSINESS PROFITS OR SPECIAL DAMAGES, EVEN IF
MICROSOFT CORPORATION OR ITS SUPPLIERS HAVE BEEN ADVISED OF THE
POSSIBILITY OF SUCH DAMAGES.  SOME STATES DO NOT ALLOW THE EXCLUSION
OR LIMITATION OF LIABILITY FOR CONSEQUENTIAL OR INCIDENTAL DAMAGES
SO THE FOREGOING LIMITATION MAY NOT APPLY.
</BLOCKQUOTE>
<P>
<center>
	<FONT FACE="Verdana,Arial,Helvetica" SIZE="1">
	Last reviewed:  July 22, 1997</FONT>
	<BR>
	<A href="../cpyright.htm" STYLE="font: bold 7pt Verdana,Arial,Helvetica">&copy; 1998 Microsoft Corporation. All rights reserved. Terms of Use.</A><BR>
	
</center>
</td>
</tr>
</table>

<!--FOOTER_END-->
</FONT>
</BODY>
</HTML>
