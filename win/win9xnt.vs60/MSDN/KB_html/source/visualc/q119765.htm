

<HTML>
<HEAD>
<TITLE>INFO: Example DDX Routine for Access Memo Fields </TITLE>

<!--STYLE_BEGIN-->
<style>@import url(../../msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="../../msdn_ie3.css">
<!--STYLE_END-->

<META HTTP-EQUIV="CONTENT-Type" CONTENT="text/html; charset=us-ascii">
<META NAME="ms.locale" CONTENT="EN-US">
<META NAME="Category" CONTENT="Support; KB Article">
<META NAME="KBID" CONTENT="Q119765">
<META NAME="KBModify" CONTENT="1997/09/11">
<META NAME="KBCreate" CONTENT="1994/08/23">
<META NAME="Keywords" CONTENT="MfcDatabase kbcode">
<META NAME="KBArea" CONTENT="Support; KB; visualc">
<META NAME="Description" CONTENT="  An application, using the ODBC database classes of the Microsoft Foundation Classes, can create a CRecordset derived class object which associates a CString or a CLongBinary member variable with a memo field within an Access database.  Technote #45...">
<META NAME="Product" CONTENT="Visual C++">
<META NAME="Platform" CONTENT="Windows">
<META NAME="Technology" CONTENT=" ">
<META NAME="Premium" CONTENT="support">

<META NAME="nyms" CONTENT="QA7O,QA7N,QAHP,QA1S,QAYY,QBDM,QDIM,QBFY,QA56,QA55,QAW6,QAPN,QAH4,QAEF,QAGI V02180118">
</HEAD>

<BODY BGCOLOR="#FFFFFF" LEFTMARGIN="0" RIGHTMARGIN="0" TOPMARGIN="0">


<!--DOCBODY_START-->
<BR>
<CENTER>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" VALIGN="top" WIDTH="90%">
	<TR>
		<TD VALIGN="top">
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<H1>INFO: Example DDX Routine for Access Memo Fields</H1>
			</FONT>
			<FONT FACE="verdana,arial,helvetica" SIZE="1">
			Last reviewed:  September 11, 1997</FONT><BR>
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<B>Article ID: Q119765</B>
			</FONT>
		</TD>
	</TR>
	<TR>
	<TD>
	<FONT FACE="Verdana, Arial, Helvetica" SIZE=2>



<P><h3> </h3>
 
The information in this article applies to:

<UL><LI>The Microsoft Foundation Classes (MFC) included with:
   - Microsoft Visual C++ for Windows, versions 1.5, 1.51, 1.52
   - Microsoft Visual C++, 32-bit Edition, versions 2.0, 2.1, 4.0,
<P><PRE>     4.1, 4.2, 5.0
</UL></PRE> 
<P>
<P><h2>SUMMARY</h2>
 
<P>
An application, using the ODBC database classes of the Microsoft Foundation
Classes, can create a CRecordset derived class object which associates a
CString or a CLongBinary member variable with a memo field within an Access
database.
<P>
Technote #45, "MFC/Database Support for Long Varchar/Varbinary," available
in the MFC Tech Notes helpfile in your Visual C++ program group discusses
this.
<P>
There are some limitations to using a CString object associated with a memo
field, as opposed to a CLongBinary, though:

<OL><P><LI>In the 16-bit versions of the Microsoft Foundation Classes, a CString
   object can only hold up to 32K of data, while a CLongBinary object can
   hold much more than 64K if needed.

<P><LI>The initial size allocation of the CString buffer is determined by the
   size of the memo field. Because the memo field isn't a fixed length, the
   length may be zero for a new record or may be very small in some cases.
   This can cause problems when using AddNew()/Edit() and Update(). As the
   user assigns data to the CString, the size of the CString buffer may
   change and the buffer for the CString will be re-allocated causing an
   assertion.

<P><LI>CStrings terminate with NULL characters and it is possible that memo
   fields may contain any binary data including NULLs.
<P>
</OL>There is, however, no explicit DDX routine to read the data from a
CLongBinary in a recordset and copy it to an edit control, or to
read the contents of the edit control back into the CLongBinary.
(Or a similar control, as 16-bit edit controls are limited to 64K.)
<P>
This article gives one example of such a DDX routine which reads
data from a CLongBinary into an edit control and back.
<P>
NOTE: A bug exists when using the 16-bit Access ODBC driver which is
included with Visual C++ 1.52 which does not allow mapping of CLongBinary
objects to Memo fields. For additional information, please see the
following article in the Microsoft Knowledge Base:
<P>
<PRE>   ARTICLE-ID: <B><A href="../visualc/q130438.htm">Q130438</A></B>
   TITLE     : BUG: Program Crashes When Memo Field Mapped to ClongBinary

</PRE></OL><h2>MORE INFORMATION</h2>
 
<P>
Note that the sample code below must explicitly call
SetFieldNull() and SetFieldDirty() to set the field as
NOT Null and as dirty when reading data from the control.
Without both of these calls, the field will not be updated
in the database.
<P>
The DDX routine shown, will need to be explicitly called
in your CFormView or CRecordView derived class's DoDataExchange()
member function outside of the AFX_DATA_MAP section.  For
example the following code associates a CRecordset member variable
CLongBinary m_lbMemo with an edit control with the ID IDC_EDIT_MEMO:
<P>
<PRE>   void CSampView::DoDataExchange(CDataExchange* pDX)
   {
      CRecordView::DoDataExchange(pDX);
      //{{AFX_DATA_MAP(CSampView)
      DDX_FieldText(pDX, IDC_EDIT_TITLE, m_pSet-&gt;m_strTitle, m_pSet);
      DDX_FieldText(pDX, IDC_EDIT_AREA, m_pSet-&gt;m_strArea, m_pSet);
      //}}AFX_DATA_MAP

      DDX_FieldMemo( pDX, IDC_EDIT_MEMO, m_pSet-&gt;m_lbMemo, m_pSet );
   }

</PRE><h2>REFERENCES</h2>
 
<P>
MFC Tech Notes (helpfile icon in your Visual C++ program group)

<UL><LI>Tech note #26, "DDX and DDV Routines" has additional
   information on working with DDX routines.

<LI>Tech note #45, "MFC/Database Support for Long
   Varchar/Varbinary" has additional information on working
   with large data, CLongBinary, CByteArray, and CString.
<P>
</UL><h3>Sample Code</h3>
 
<P>
<PRE>   /* Compile options needed:  Default MFC application project options
   */

   void DDX_FieldMemo( CDataExchange * pDX,
                       int nIDEdit, CLongBinary &amp; lbMemo,
                       CRecordset * pRecordset )
   {
       ASSERT_VALID( pRecordset );

       UINT nLen;
       HGLOBAL hGlob;
       LPSTR lpStr;
       char * pStrWithNull;
       HWND hWndCtrl = pDX-&gt;PrepareEditCtrl(nIDEdit);

       if ( !hWndCtrl )
       {
           ASSERT(FALSE);
           return;
       }

       if (pDX-&gt;m_bSaveAndValidate)
       {
           nLen = ::GetWindowTextLength(hWndCtrl);

           if ( nLen )
           {
               hGlob = GlobalAlloc( GPTR | GMEM_SHARE, (DWORD)nLen );
               if ( !hGlob )
               {
                   AfxThrowMemoryException();
               }
               lpStr = (LPSTR)GlobalLock( hGlob );
               if ( !lpStr )
               {
                   GlobalFree( hGlob );
                   AfxThrowMemoryException();
               }
               // Allocate space for the '\0' string terminator
               // Throws exception if needed
               pStrWithNull = new char[nLen+1];

               ::GetWindowText(hWndCtrl, pStrWithNull, nLen+1);
               // Cut off the null
               #ifndef _WIN32
                       _fmemcpy( lpStr, pStrWithNull, nLen );
               #else
                   memcpy( lpStr, pStrWithNull, nLen );
               #endif

               delete [] pStrWithNull;

               GlobalUnlock( hGlob );    // Don't leave it locked.
           }
           else // Empty
           {
               nLen = 0;
               hGlob = NULL;
           }

           // Free memory we are replacing
           GlobalUnlock( lbMemo.m_hData );
           GlobalFree( lbMemo.m_hData );

           // Put in new data
           lbMemo.m_dwDataLength = (DWORD) nLen;
           lbMemo.m_hData = hGlob;

           if (nLen == 0)
           {
               if ( pRecordset-&gt;IsFieldNullable(&amp;lbMemo) )
                   pRecordset-&gt;SetFieldNull( &amp;lbMemo, TRUE);
           }
           else
           {
               // It is required that we explicitly set it Dirty
               // and NOT Null
               pRecordset-&gt;SetFieldNull( &amp;lbMemo, FALSE );
               pRecordset-&gt;SetFieldDirty( &amp;lbMemo, TRUE );
           }
       }
       else    // Reading data from recordset into control
       {
           nLen = (UINT)lbMemo.m_dwDataLength;
           if ( nLen )
           {
               lpStr = (LPSTR)GlobalLock( lbMemo.m_hData );

               // Throws exception if needed
               pStrWithNull = new char[nLen+1];


               #ifndef _WIN32
                       _fmemcpy( pStrWithNull, lpStr, nLen );
               #else
                   memcpy( pStrWithNull, lpStr, nLen );
               #endif

               pStrWithNull[nLen] = 0;    // Set '\0' at end of string

               SetWindowText( hWndCtrl, pStrWithNull );

               delete [] pStrWithNull;
               GlobalUnlock( lbMemo.m_hData );
           }
           else
           {
               SetWindowText( hWndCtrl, "" );
           }
       }
   }
</PRE>

	</FONT>
	</TD>
	</TR>
</TABLE>
<P>


<!--DOCBODY_END-->

<!--FOOTER_START-->
<table cellpadding=5 border=0 width="90%">
<tr>
<td>
	<HR WIDTH="90%">

<BLOCKQUOTE>
<FONT FACE="Verdana, Arial, Helvetica" SIZE="1">
<SPAN STYLE="font-family:verdana,arial,helvetica; font-size:8pt">
Additional query words: SQL_LONGVARCHAR SQL_LONGVARBINARY<BR>
Keywords          : MfcDatabase kbcode<BR>
Technology        : kbMfc<BR>
Version           : WINDOWS:1.5,1.51,1.52; WINDOWS NT:2.0,2.1,4.0,5.0;<BR>
Platform          : NT WINDOWS<BR>

</SPAN>
</FONT>
<BR>
<BR>
THE INFORMATION PROVIDED IN THE MICROSOFT KNOWLEDGE BASE IS
PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND.  MICROSOFT DISCLAIMS
ALL WARRANTIES, EITHER EXPRESS OR IMPLIED, INCLUDING THE WARRANTIES
OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  IN NO
EVENT SHALL MICROSOFT CORPORATION OR ITS SUPPLIERS BE LIABLE FOR
ANY DAMAGES WHATSOEVER INCLUDING DIRECT, INDIRECT, INCIDENTAL,
CONSEQUENTIAL, LOSS OF BUSINESS PROFITS OR SPECIAL DAMAGES, EVEN IF
MICROSOFT CORPORATION OR ITS SUPPLIERS HAVE BEEN ADVISED OF THE
POSSIBILITY OF SUCH DAMAGES.  SOME STATES DO NOT ALLOW THE EXCLUSION
OR LIMITATION OF LIABILITY FOR CONSEQUENTIAL OR INCIDENTAL DAMAGES
SO THE FOREGOING LIMITATION MAY NOT APPLY.
</BLOCKQUOTE>
<P>
<center>
	<FONT FACE="Verdana,Arial,Helvetica" SIZE="1">
	Last reviewed:  September 11, 1997</FONT>
	<BR>
	<A href="../cpyright.htm" STYLE="font: bold 7pt Verdana,Arial,Helvetica">&copy; 1998 Microsoft Corporation. All rights reserved. Terms of Use.</A><BR>
	
</center>
</td>
</tr>
</table>

<!--FOOTER_END-->
</FONT>
</BODY>
</HTML>
