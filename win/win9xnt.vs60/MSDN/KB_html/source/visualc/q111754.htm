

<HTML>
<HEAD>
<TITLE>BUG: __Huge New Operator Fails with Variable Size </TITLE>

<!--STYLE_BEGIN-->
<style>@import url(../../msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="../../msdn_ie3.css">
<!--STYLE_END-->

<META HTTP-EQUIV="CONTENT-Type" CONTENT="text/html; charset=us-ascii">
<META NAME="ms.locale" CONTENT="EN-US">
<META NAME="Category" CONTENT="Support; KB Article">
<META NAME="KBID" CONTENT="Q111754">
<META NAME="KBModify" CONTENT="1997/07/22">
<META NAME="KBCreate" CONTENT="1994/02/17">
<META NAME="Keywords" CONTENT="kb16bitonly">
<META NAME="KBArea" CONTENT="Support; KB; visualc">
<META NAME="Description" CONTENT="  If a variable is used as the size parameter to the __huge new operator, the return value will be NULL or a pointer to a memory block that is smaller than requested.  CAUSE =====  The problem is that only the lower order word of the variable that is...">
<META NAME="Product" CONTENT="Visual C++">
<META NAME="Platform" CONTENT="Windows">
<META NAME="Technology" CONTENT=" ">
<META NAME="Premium" CONTENT="support">

<META NAME="nyms" CONTENT="QAGI,QAYL,QANY,QBFY,QAUD,QAEF,QAYA,QAKP,QAIF,QAHE,QAH4,QAI4,QAVX,QAVW,QABL V02180118">
</HEAD>

<BODY BGCOLOR="#FFFFFF" LEFTMARGIN="0" RIGHTMARGIN="0" TOPMARGIN="0">


<!--DOCBODY_START-->
<BR>
<CENTER>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" VALIGN="top" WIDTH="90%">
	<TR>
		<TD VALIGN="top">
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<H1>BUG: __Huge New Operator Fails with Variable Size</H1>
			</FONT>
			<FONT FACE="verdana,arial,helvetica" SIZE="1">
			Last reviewed:  July 22, 1997</FONT><BR>
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<B>Article ID: Q111754</B>
			</FONT>
		</TD>
	</TR>
	<TR>
	<TD>
	<FONT FACE="Verdana, Arial, Helvetica" SIZE=2>



 
1.00 1.50
WINDOWS
kbtool kbbuglist
<P>
 
The information in this article applies to:

<UL><LI>The Microsoft C/C++ Compiler (CL.EXE) included with:
<P><PRE>    - Microsoft Visual C++ for Windows, versions 1.0 and 1.5
</UL></PRE> 
<P>
<P><h2>SYMPTOMS</h2>
 
<P>
If a variable is used as the size parameter to the __huge new operator, the
return value will be NULL or a pointer to a memory block that is smaller
than requested.
<P>
<P><h2>CAUSE</h2>
 
<P>
The problem is that only the lower order word of the variable that is
passed as the length parameter will be used. Therefore, if the allocation
is less than 64K, the call will be successful. However, if the allocation
size is greater than 64K, the call to new will fail as follows:

<UL><LI>If the lower order word is 0 (zero), the call to new will return NULL.

<LI>If the lower order word is nonzero, then the call will return a valid
   pointer but the block of memory allocated will be smaller than
   requested.
<P>
</UL><h2>RESOLUTION</h2>
 
<P>
If the variable size is constant (that is, it never changes), then
substitute the absolute value as the parameter to the call to new. For
example, change the following
<P>
<PRE>   long lSize=0x20000;
   char __huge *pChar = new __huge char[lSize];

</PRE>to the following:
<P>
<PRE>   char __huge *pChar = new __huge char[0x20000];

</PRE>A call to _halloc can be used instead. For example, change the following
<P>
<PRE>   /* lSize==0x20000 */
   char __huge *pChar = new __huge char[lSize];

</PRE>to the following:
<P>
<PRE>   char __huge *pChar = (char __huge *) _halloc(lSize,sizeof(char));

</PRE>NOTE: If using _halloc. be sure to use _hfree instead of delete. Also, you
need to include &lt;malloc.h&gt;.
<P>
<P><h2>STATUS</h2>
 
<P>
Microsoft has confirmed this to be a problem in Microsoft C/C++ for MS-DOS,
versions 8.0 and 8.0c. We are researching this problem and will post new
information here in the Microsoft Knowledge Base as it becomes available.
<P>
<P><h2>MORE INFORMATION</h2>
 
<P>
The problem can be seen by generating an assembly listing of the code.
Included below is a section of code and the accompanying assembly listing
generated by using the /Fc compiler switch:
<P>
<P><h3>Sample Code</h3>
 
<P>
<PRE>/*
</PRE>/ Compile options needed: /Fc
<PRE>*/

#include &lt;iostream.h&gt;

void main(void)
</PRE>{
<PRE> long test=0x20000;
 char __huge * ptr;

 ptr=new __huge char[test];

// ; Line 10
//    *** 000015  b8 01 00        mov ax,OFFSET 1
//    *** 000018  50          push    ax
//    *** 000019  8b 46 f6        mov ax,WORD PTR -10[bp]
//    *** 00001c  8b 56 f8        mov dx,WORD PTR -8[bp]
//    *** 00001f  ba 00 00        mov dx,OFFSET 0
//    *** 000022  52          push    dx
//    *** 000023  50          push    ax
//    *** 000024  e8 00 00        call    ??2@YAPIXKI@Z
//    *** 000027  83 c4 06        add sp,OFFSET 6
//    *** 00002a  89 46 fa        mov WORD PTR -6[bp],ax
//    *** 00002d  89 56 fc        mov WORD PTR -4[bp],dx
//;


 if (ptr!=NULL)
  cout &lt;&lt; "Success!";
 else
  cout &lt;&lt; "Failure!";
</PRE>}
<P>
This line is the cause of the problem:
<P>
<PRE>//    *** 00001f  ba 00 00        mov dx,OFFSET 0

</PRE>This destroys the upper word of the length and effectively limits you to
allocating only up to 64K.
<P>

	</FONT>
	</TD>
	</TR>
</TABLE>
<P>


<!--DOCBODY_END-->

<!--FOOTER_START-->
<table cellpadding=5 border=0 width="90%">
<tr>
<td>
	<HR WIDTH="90%">

<BLOCKQUOTE>
<FONT FACE="Verdana, Arial, Helvetica" SIZE="1">
<SPAN STYLE="font-family:verdana,arial,helvetica; font-size:8pt">
Additional reference words: 1.00 1.50 8.00 8.00c halloc free<BR>
KBCategory: kbtool kbbuglist<BR>
KBSubcategory: CLIss<BR>
Keywords            : kb16bitonly<BR>

</SPAN>
</FONT>
<BR>
<BR>
THE INFORMATION PROVIDED IN THE MICROSOFT KNOWLEDGE BASE IS
PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND.  MICROSOFT DISCLAIMS
ALL WARRANTIES, EITHER EXPRESS OR IMPLIED, INCLUDING THE WARRANTIES
OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  IN NO
EVENT SHALL MICROSOFT CORPORATION OR ITS SUPPLIERS BE LIABLE FOR
ANY DAMAGES WHATSOEVER INCLUDING DIRECT, INDIRECT, INCIDENTAL,
CONSEQUENTIAL, LOSS OF BUSINESS PROFITS OR SPECIAL DAMAGES, EVEN IF
MICROSOFT CORPORATION OR ITS SUPPLIERS HAVE BEEN ADVISED OF THE
POSSIBILITY OF SUCH DAMAGES.  SOME STATES DO NOT ALLOW THE EXCLUSION
OR LIMITATION OF LIABILITY FOR CONSEQUENTIAL OR INCIDENTAL DAMAGES
SO THE FOREGOING LIMITATION MAY NOT APPLY.
</BLOCKQUOTE>
<P>
<center>
	<FONT FACE="Verdana,Arial,Helvetica" SIZE="1">
	Last reviewed:  July 22, 1997</FONT>
	<BR>
	<A href="../cpyright.htm" STYLE="font: bold 7pt Verdana,Arial,Helvetica">&copy; 1998 Microsoft Corporation. All rights reserved. Terms of Use.</A><BR>
	
</center>
</td>
</tr>
</table>

<!--FOOTER_END-->
</FONT>
</BODY>
</HTML>
