

<HTML>
<HEAD>
<TITLE>INFO: Foundation Classes Common Asserts, Causes, and Solutions </TITLE>

<!--STYLE_BEGIN-->
<style>@import url(../../msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="../../msdn_ie3.css">
<!--STYLE_END-->

<META HTTP-EQUIV="CONTENT-Type" CONTENT="text/html; charset=us-ascii">
<META NAME="ms.locale" CONTENT="EN-US">
<META NAME="Category" CONTENT="Support; KB Article">
<META NAME="KBID" CONTENT="Q117326">
<META NAME="KBModify" CONTENT="1997/07/18">
<META NAME="KBCreate" CONTENT="1994/06/26">
<META NAME="Keywords" CONTENT="kb16bitonly kbprg MfcMisc kbprg">
<META NAME="KBArea" CONTENT="Support; KB; visualc">
<META NAME="Description" CONTENT="  This article presents a list of over 50 common Microsoft Foundation Class (MFC) assertions [ASSERT() statements in the Foundation class source code] that programmers using Visual C++ may commonly come across. The current version of this text is pri...">
<META NAME="Product" CONTENT="Visual C++">
<META NAME="Platform" CONTENT="Windows">
<META NAME="Technology" CONTENT=" ">
<META NAME="Premium" CONTENT="support">

<META NAME="nyms" CONTENT="QBFY,QA55,QA56,QAIB,QBXT,QA5V,QAGI,QABI,QABA,QAPN,QABO,QACR,QAOE,QAAP,QAB4 V02180118">
</HEAD>

<BODY BGCOLOR="#FFFFFF" LEFTMARGIN="0" RIGHTMARGIN="0" TOPMARGIN="0">


<!--DOCBODY_START-->
<BR>
<CENTER>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" VALIGN="top" WIDTH="90%">
	<TR>
		<TD VALIGN="top">
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<H1>INFO: Foundation Classes Common Asserts, Causes, and Solutions</H1>
			</FONT>
			<FONT FACE="verdana,arial,helvetica" SIZE="1">
			Last reviewed:  July 18, 1997</FONT><BR>
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<B>Article ID: Q117326</B>
			</FONT>
		</TD>
	</TR>
	<TR>
	<TD>
	<FONT FACE="Verdana, Arial, Helvetica" SIZE=2>



<P><h3> </h3>
 
The information in this article applies to:

<UL><LI>The Microsoft Foundation Classes (MFC) included with:
   - Microsoft Visual C++ for Windows, versions 1.0, 1.5
   - Microsoft Visual C++ 32-bit Edition, version 1.0
</UL> 
<P>
<P><h2>SUMMARY</h2>
 
<P>
This article presents a list of over 50 common Microsoft Foundation
Class (MFC) assertions [ASSERT() statements in the Foundation class source
code] that programmers using Visual C++ may commonly come across. The
current version of this text is primarily for Visual C++ 1.0 and 1.5.
It lists some of the most likely causes, and possible solutions, for
each assertion.
<P>
In Visual C++ 2.0, a help file entitled "Knowledge Base" can be installed
in the Visual C++ program group. The help file has a section titled "MFC
3.0 Common Asserts".
<P>
<P><h2>MORE INFORMATION</h2>
 
<P>
While writing and debugging a Microsoft Foundation Classes program,
you may often receive an "Assertion Failed" message indicating
something has gone wrong in your application. There are many
techniques you can use to track down the possible cause of the
assertion.

<OL><P><LI>The most important bit of information to get when the assertion is
   hit is the file and line number of the assertion! This will allow
   you to go to the Foundation class source code which caused the
   assertion and see what was happening.
<P>
   The source code for the Microsoft Foundation Classes is under your
   Visual C++ (or C/C++ 7.0) directory in MFC\SRC. Headers and .INL
   files are in MFC\INCLUDE. Reading this source code when you get
   an assertion is often the best way to figure out what is happening
   and to solve your problem.

<P><LI>If you are unfamiliar with how ASSERT(),ASSERT_VALID(), AssertValid(),
   AfxIsValidAddress(), and TRACE() work, you will want to read the
   on-line help on these macros and functions. These are also described
   in the Visual C++ 1.5 "Class Library User's Guide" chapter 15,
   Diagnostics. Remember to run the DebugWin utility to display your
   applications TRACE messages. Debugging output will display in the
   DebugWin window. You may need to run the "MFC Trace Options" utility,
   AFX Tracer, to enable tracing.

<P><LI>When you hit an assertion, you will usually want to figure out where
   in your own code the call was made which eventually resulted in the
   assertion. If running under a debugger, you can choose "Retry" when
   the assertion comes up. This will hit a hard-coded breakpoint which
   puts you into the debugger. From there you can examine the call-stack.
   In Visual C++ this can be done by pressing Ctrl+K or choosing to examine
   the call-stack from the Debug menu. You can also set a breakpoint on
   the opening curly bracket of AfxAssertFailedLine() in AFXASERT.CPP in
   your Visual C++ MFC\SRC directory. Knowledge Base article <B><A href="../visualc/q108112.htm">Q108112</A></B>,
   "How to View the Call Stack After an MFC ASSERT" describes this
   in more detail.

<P><LI>If you need to track down threads of execution, or which functions
   access what variables, you will probably want to build a browser
   library for the Foundation Class libraries. This is described in
   Knowledge Base article <B><A href="../visualc/q98656.htm">Q98656</A></B>, "Using Class Library Browser
   Information in Your Project."

<P><LI>General Debugging:
<P>
   Many assertions you will hit are caused by memory corruption or
   invalid parameters passed to Windows API functions. Using MFC
   diagnostics techniques and the debugging versions of Windows 3.1
   along with the DebugWin utility can help greatly in tracking
   down such errors.
<P>
   Basic MFC debugging techniques are discussed in the Visual C++
   1.5 "Class Library User's Guide" chapter 15, Diagnostics. The
   most important technique is to use the DEBUG_NEW macro described
   there and to set the global afxMemDF variable to always check
   validity of memory blocks allocated with new. To do so, just
   add the following code to your InitInstance()
<P>
<P><PRE>      #ifdef _DEBUG
<PRE></PRE>         afxMemDF |= checkAlwaysMemDF;
      #endif

   There are two very good articles on using MFC diagnostics for
   debugging in the Microsoft System Journal. The articles are
   "Built-in Diagnostic Facilities in the Microsoft Foundation
   Classes Simplify Debugging" and "MFC Diagnostic Facilities
   Part II: More-Sophisticated Debugging Techniques" in MSJ
   Volume 8 #2 and #3 (February 1993 and March 1993). These
   articles can also be found on the MSDN CD.

   Using the debugging version of Windows 3.1 will also allow you
   to catch many errors that later cause assertions. The debugging
   version of Windows does much stricter error checking and
   validation than the retail version and can catch many errors
   you might otherwise miss. The debugging version of Windows comes
   with Visual C++, but is not installed by default. You can
   install it by running setup, checking only the "Tools" checkbox,
   and changing the tools to be installed to include only the
   debugging version of Windows. Use the N2D.BAT file to change
   to the debugging version and the D2N.BAT to change back (without
   Windows running, of course). The DebugWin utilities Options,
   Settings allows you to change settings for the debugging version
   of Windows. Suggested options to set would be "Validate Heap"
   which validates internal local heap data structures, "Check
   Free Blocks" which verifies that local free memory isn't written
   into invalidly, and "Fill Buffers" which helps detect overwrite
   problems with buffers passed to some API functions.

   You may want to add the lines

      [debug]
      OutputTo=NUL

   to your SYSTEM.INI file so that no debugging output is sent until you
   have DebugWin (or some debugger) running. This can avoid problems with
   Windows starting up and needing to output error messages, which can
   cause applications to run slowly. For more information on the debugging
   version of Windows see Appendix C of the Windows SDK "Programming Tools"
   manual. The Win31 Help helpfile (in your Visual C++ program group) also
   has information on this under Overviews, Windows Debugging Version.

</PRE></OL><h3>Format of Assertions List:</h3>
 
<P>
For each of the following assertions, the following information is
listed:
<P>
<PRE>   - File and line number of the assertion.
   - Version of C/C++ or Visual C++ the assertion occurs in.
   - Foundation class function the assertion occurs in.
   - The actual code of the ASSERT() statement, if useful.
   - Possible causes of the assertion.
   - Possible solutions which will avoid the assertion.

</PRE>These assertions are listed from most common to less common. Where
there is more than one common assertion in a single source file, all
assertions for that file are listed together, again from most to less
common.
<P>
<P><h3>Assertions List</h3>
 
<P>
AFXMEM.CPP  Line 363  - Visual C++ 1.5
AFXMEM.CPP  Line 358  - Visual C++ 1.0
MEMORY.CPP  Line 334  - C/C++ 7.0
FreeMemoryDebug()
<P>
This assert can be caused by freeing an incorrect memory type.
For example, using delete on memory allocated with malloc(),
or using the global delete operator on a CObject class instead
of CObject::delete.
<P>
This assert can also be caused by attempting to delete an object
created on the frame (stack). For example, deleting a local
variable inside a function. It has often been caused by
previously corrupted memory.
<P>
 
<P>
AFXMEM.CPP  Line 383  - Visual C++ 1.5
AFXMEM.CPP  Line 378  - Visual C++ 1.0
FreeMemoryDebug()
<P>
This assert can be caused by calling new to allocate an object
in one _USRDLL and using delete to deallocate the object in a
different _USRDLL. Use _AFXDLL instead if this is needed.
<P>
 
<P>
VBCTRL.CPP  Line 298  - Visual C++ 1.0 and 1.5
CVBControl::Trace()
<P>
Fatal errors for CVBControls cause this assert after using TRACE
to output an error message.
<P>
The message before this is very often "Invalid Control Object".
Accessing a VBX control before it is valid or created can cause
this error. Make sure that your VBX control has been created
before using it.
<P>
For a CDialog derived class this means after the dialogs
WM_INITDIALOG handler has been hit. You can access the VBX
control in your OnInitDialog() handler, but only after calling
CDialog::OnInitDialog().
<P>
For a CFormView derived class, the VBX control should not be accessed
until after OnInitialUpdate() has been called. If overriding
OnInitialUpdate(), make sure to call CFormView::OnInitialUpdate()
first.
<P>
 
<P>
WINCORE.CPP  Line 181  - Visual C++ 1.5
WINCORE.CPP  Line 132  - Visual C++ 1.0
CWnd::Attach()
<P>
<PRE>ASSERT(m_hWnd == NULL);     // only attach once, detach on destroy

</PRE>This assert will be caused by attempting to use the same CWnd object
to subclass another window (the same other window) twice.
A CWnd must not already be associated with a window if it
is going to attach to a new window.
<P>
 
<P>
WINCORE.CPP  Line 182  - Visual C++ 1.5
WINCORE.CPP  Line 133  - Visual C++ 1.0
CWnd::Attach(HWND hWndNew)
<P>
ASSERT(FromHandlePermanent(hWndNew) == NULL);
<PRE>                 // must not already be in permanent map

</PRE>This assert is caused if the window a CWnd is trying to
attach to is already attached to some other MFC object.
You can only have one MFC object attached to any window,
otherwise the message maps cannot function correctly.
<P>
 
<P>
WINCORE.CPP  Line 574  - Visual C++ 1.5
WINCORE.CPP  Line 509  - Visual C++ 1.0
CWnd::GetSuperWndProcAddr()
<P>
static WNDPROC NEAR pfnSuper = NULL;
<PRE>ASSERT(pfnSuper == NULL);       // should never be changed !!!
              // if this is non-NULL, then a derived class of CWnd
              //  forgot to override 'superWndProc' as well as 'className'

</PRE>This can be caused by calling SubClassWindow() or SubClassDlgItem()
without overriding GetSuperWndProcAddr() in your CWnd derived class.
This has also been caused by memory corruption.
<P>
 
<P>
WINCORE.CPP  Line 398  - Visual C++ 1.5
WINCORE.CPP  Line 349  - Visual C++ 1.0
CWnd::Create()
<P>
<PRE>// can't use for desktop or pop-up windows (use CreateEx instead)
</PRE>...
ASSERT((dwStyle &amp; WS_POPUP) == 0);
<P>
CWnd::Create() doesn't allow WS_POPUP style.
Use CreateEx() instead.
<P>
 
<P>
WINCORE.CPP  Line 1228  - Visual C++ 1.5
WINCORE.CPP  Line 1127  - Visual C++ 1.0
CWnd::OnCommand()
<P>
<PRE>// control notification
</PRE>ASSERT(::IsWindow(hWndCtrl)); ASSERT(::IsWindow(hWndCtrl)); //
<P>
This assert is caused if a WM_COMMAND is received without a valid
child control ID. Some third party controls may send such WM_COMMAND
messages. Override CWnd::OnCommand() to avoid this assert.
<P>
 
<P>
WINCORE.CPP  Line 1017 - Visual C++ 1.5
WINCORE.CPP  Line 916  - Visual C++ 1.0
CWnd::WindowProc()
<P>
This has been reported to have been caused by non-NEAR
ON_REGISTERED_MESSAGE messages in _USRDLL's. This was also
associated with a General Protection Fault occurring on lines
913-914 instead of the assert. Override CWnd::WindowProc() to
avoid this problem. See Knowledge Base article <B><A href="../visualc/q99787.htm">Q99787</A></B>, "PRB: GP
Fault From ON_REGISTERED_MESSAGE() in _USRDLL" for more details.
<P>
 
<P>
WINCORE.CPP  Line 543  - Visual C++ 1.5
WINCORE.CPP  Line 478  - Visual C++ 1.0
CWnd::DestroyWindow()
<P>
This has been caused by destroying or closing windows before a
message pump was active - for example, in InitInstance.
<P>
 
<P>
WINCORE.CPP  Line 384  - Visual C++ 1.5
WINCORE.CPP  Line 335  - Visual C++ 1.0
CWnd::PreCreateWindow()
<P>
<PRE>// no WNDCLASS provided - use child window default
</PRE>ASSERT(cs.style &amp; WS_CHILD);
<P>
This assert is because the CWnd default style requires
a WS_CHILD window class style. Use CFrameWnd derived
classes for non-child windows.
<P>
 
<P>
WINBTN.CPP  Line 109  - Visual C++ 1.0 and 1.5
CBitmapButton::DrawItem()
<P>
<PRE>// must have at least the first bitmap loaded before calling DrawItem()
ASSERT(m_bitmap.m_hObject != NULL);     // required

</PRE>Failed to load CBitmapButton bitmap for normal image.
Note that ID's for AutoLoad() and LoadBitmaps() need to be "STRING" ID's!
<P>
 
<P>
APPPRNT.CPP  Line 52  - Visual C++ 1.0
CWinApp::UpdatePrinterSelection()
<P>
ASSERT(lpDevNames != NULL);
<P>
To duplicate, you can run the Scribble or Viewex samples.
Choose File, Print, click Print Setup. Change the printer
driver to a different printer. Choose OK. Select Cancel
from the Print dialog. Select File, Print (or Print Setup).
It will assert. Ignoring this causes a General Protection
Fault.
<P>
You can fix this by modifying CWinApp::DoPrintDialog in APPPRNT.CPP.
Modify the line:
<PRE>   while((nResponse = pPD-&gt;DoModal()) != IDOK)
</PRE>to
<PRE>   int nResponse = pPD-&gt;DoModal();
   while(nResponse != IDOK &amp;&amp; nResponse != IDCANCEL)

</PRE>You will need to rebuild the MFC libraries after this modification.
This is fixed in Visual C++ 1.5.
<P>
 
<P>
WINCTRL.CPP  Line 284  - Visual C++ 1.0 and 1.5
CWnd::SubClassWindow()
<P>
Before this assert, two TRACE messages will be output:
<P>
Error: Trying to use SubClassWindow with incorrect CWnd derived class
<PRE>   hWnd = 0xABCD is not a CWndClassName

</PRE>This assert will be hit if the window procedure of the window
the SubClassWindow() is attempting to subclass is different from
the window procedure of any previous window SubClassWindow() was
called on for this CWnd derived class type.
<P>
This is checked for as follows. GetSuperWndProcAddr() should be
overridden to return a pointer to a WINDPROC variable. When
SubClassWindow() is called, it uses this pointer to set the WNDPROC
pointer to point to window procedure of the window being subclassed.
<P>
Now, if GetSuperWndProcAddr() returned a non-null pointer then this
CWnd derived class's SubClassWindow() was likely used previously to
subclass a window. (This is because GetSuperWndProcAddr() often
returns a pointer to a static variable.)  SubClassWindow() should
only be getting called again to subclass a window of the same
window class (WNDCLASS) that it had previously been used to subclass.
<P>
Note that SubClassDlgItem() maps to a call to SubClassWindow(). For
an example of using such subclassing, and of overriding
GetSuperWndProcAddr(), see the CTRLTEST sample.
<P>
 
<P>
WINCTRL.CPP  Line 272  - Visual C++ 1.0 and 1.5
CWnd::SubClassWindow()
<P>
ASSERT(oldWndProc != (WNDPROC)AfxWndProc);
<P>
This assert occurs because the window being subclassed has
either already been subclassed by another CWnd derived class,
or IS a CWnd window.
<P>
 
<P>
WINCTRL.CPP Lines 121, 123, and 125  - Visual C++ 1.0 and 1.5
<P>
CListBox::DrawItem()
CListBox::MeasureItem()
CListBox::CompareItem()
<P>
These are default asserts. If you have an owner draw listbox,
you must override these member functions.
<P>
 
<P>
OBJCORE.CPP  Lines 38, 40  - Visual C++ 1.0 and 1.5
CObject::IsKindOf()
<P>
ASSERT(this != NULL);
<PRE>// it better be in valid memory, at least for CObject size
</PRE>ASSERT(AfxIsValidAddress(this, sizeof(CObject)));
<P>
This assert is caused by calling IsKindOf() on an invalid CWnd
derived class object. Most likely the object was either not
initialized (a NULL or wild pointer) or memory has been corrupted.
<P>
This has also been caused by trying to access a VBX control
before it is fully created. When handling OnInitDialog(), post
custom message to set VBX properties instead
<P>
 
<P>
DLGDATA.CPP  Line 516  - Visual C++ 1.5
DLGDATA.CPP  Line 491  - Visual C++ 1.0
DDX_Control()
<P>
ASSERT(!pDX-&gt;m_bSaveAndValidate);
<P>
This assert is caused by calling UpdateData() or UpdateData(TRUE)
without calling UpdateData(FALSE) at least once first.
<P>
Make sure to call base class CFormView::OnInitialUpdate()
or CDialog::OnInitDialog() to have such a call made, or make
it yourself before calling UpdateData(TRUE).
<P>
 
<P>
DLGDATA.CPP  Line 41  - Visual C++ 1.0 and 1.5
CDataExchange::PrepareCtrl()
<P>
HWND hWndCtrl = ::GetDlgItem(m_pDlgWnd-&gt;m_hWnd, nIDC);
if (hWndCtrl == NULL)
{
<PRE>   TRACE1("Error: no data exchange control with ID 0x%04X\n", nIDC);
   ASSERT(FALSE);
   ...

</PRE>This assertion will generate the TRACE statement
"Error: no data exchange control with ID 0xABCD" before
asserting. It can be caused by removing a control associated
with data exchange variables.
<P>
It can also be caused in _AFXDLL applications and DLLs (using
MFC200.DLL or MFC250.DLL), when the ID of a dialog template in
the DLL matches the ID of a dialog template in the applciation.
The reason for this is that _AFXDLL applications and DLL's search
both the application's and DLL's resources when loading dialog
templates or other resources. If a CDialog derived class in an
_AFXDLL DLL is associated with a dialog template in that DLL, but
there is also a dialog template with the same ID in the _AFXDLL
application the DLL is linked to, when the dialog is created in
the DLL it might get the dialog template in the application which,
unsurprisingly, doesn't contain the DDX/DDV control which was in
the DLL's dialog template. To avoid this assertion, just make sure
that ID's of resources in _AFXDLL applications and DLL's don't
match.
<P>
 
<P>
DLGDATA.CPP  Lines 250 and 269  - Visual C++ 1.5
DLGDATA.CPP  Lines 233 and 252  - Visual C++ 1.0
DLGDATA.CPP  Lines 276 and 193  - Visual C++ 4.0
DDX_Radio()
<P>
ASSERT(::GetWindowLong(hWndFirstCtrl, GWL_STYLE) &amp; WS_GROUP);
<P>
<PRE>ASSERT(value == -1);    // only set once

</PRE>These asserts may be hit if DDX_Radio() is called on a radio
button other than the first radio button in a group, or if
it is called more than once for the radio buttons in a group.
The first radio button in the group should have the WS_GROUP
window style while none of the other buttons in the group should
have it.
<P>
 
<P>
DOCTEMPL.CPP  Line 325  - Visual C++ 1.5
DOCTEMPL.CPP  Line 207  - Visual C++ 1.0
CDocTemplate::InitialUpdateFrame()
<P>
This assert has been reported due to incorrect order of creation
of CDocTemplate and framework objects, and incorrect allocation
of memory for CFrameWnd objects.
<P>
 
<P>
WINHAND.CPP  Line 169  - Visual C++ 1.5
WINHAND.CPP  Line 129  - Visual C++ 1.0
CHandleMap::SetPermanent()
<P>
ASSERT(!LookupPermanent(h, pObject)); // must not be in there
<P>
This assert can be caused by not releasing a device context (DC)
that was attached to a CDC object or by calling Attach on a
GDI resource already associated with some other MFC object and
thus in the permanent handle map.
<P>
 
<P>
WINHAND.CPP  Lines 145 and 173  - Visual C++ 1.0
CHandleMap::RemoveHandle()
CHandleMap::DeleteTemp()
<P>
This assert can be hit if detaching a temporary object. A
workaround to this is described in the Knowledge Base article
<B><A href="../visualc/q98867.htm">Q98867</A></B>, "BUG: Temporary Object Memory Leak in Foundation Classes."
This is fixed in Visual C++ version 1.1 for Windows NT and in
Visual C++ 1.5 for Windows.
<P>
 
<P>
VIEWEDIT.CPP  Line 453  - Visual C++ 1.5
VIEWEDIT.CPP  Line 417  - Visual C++ 1.0
CEditView::PaginateTo()
<P>
ASSERT(nPageSave &gt; 1);
<P>
This can be caused if your view overrides OnPrepareDC() and does
not call the base class CEditView::OnPrepareDC(). In general,
for printing, you should set the number of pages to print in
OnPreparePrinting() or OnBeginPrinting(). See the documentation
for these functions for more information.
<P>
 
<P>
APPUI.CPP  Line 241  - Visual C++ 1.5
APPUI.CPP  Line 296  - Visual C++ 1.0
_AfxGetSafeOwner()
<P>
ASSERT_VALID(pParent);
<P>
This error can be caused by specifying an invalid parent window for
CDialog, or any of the common dialog classes such as CPrintDialog.
Make sure that you are specifying a correct CWnd * as the parent of
the dialog. This is often set in the CDialog constructor.
<P>
 
<P>
APPUI.CPP  Line 336  - Visual C++ 1.5
APPUI.CPP  Line 362  - Visual C++ 1.0
AfxMessageBox()
<P>
There will be a TRACE output ""Error: failed to load message box
prompt string 0xABCD" before this assert. The assert is caused
by a LoadString failure. Since the string resource doesn't exist,
either it was incorrectly specified, or the user didn't loaded a
needed RC file, such as afxres.rc (see MFC Technote 23, "Standard
MFC Resources").
<P>
 
<P>
<PRE>AFXWIN1.INL  Line 22   - Visual C++ 1.5
AFXWIN1.INL  Line 25   - Visual C++ 1.51
</PRE>APPCORE.CPP  Line 602  - Visual C++ 1.0
APPCORE.CPP  Line 559  - Visual C++ 1.1 for Windows NT
AfxWinInit()
<P>
<PRE>//Visual C++ 1.5 and 1.51
</PRE>ASSERT(afxCurrentInstanceHandle != NULL);
<P>
<PRE>// Visual C++ 1.0 and 1.1
ASSERT(pApp != NULL);   // must have one CWinApp derived object defined

</PRE>A CWinApp derived class object is required for all MFC applications.
See Knowledge Base article <B><A href="../visualc/q85496.htm">Q85496</A></B>, "PRB: Assertion Failed - WINAPP.CPP,
Line 258" for more information. Under some conditions CWinApp objects
are required for _USRDLL's.
<P>
 
<P>
DLGCORE.CPP  Line 69  - Visual C++ 1.0 and 1.5
_AfxDlgProc()
<P>
A TRACE message "Warning: something went wrong in dialog init" will
be output before this assert. This assert can be caused by
LocalAlloc() failures or other dialog problems, such as dialog
controls on the dialog template having fatal errors during their
construction.
<P>
 
<P>
WINGDI.CPP  Lines 284, 299, 310, 321, and 332  - Visual C++ 1.0 and 1.5
CDC::SelectObject() (multiple locations for overloaded function)
<P>
ASSERT( m_hDC != NULL );
<P>
This assert can be caused when attempting to use a CDC object
on which none of GetDC(), CreateDC(), or Attach() have been called.
<P>
 
<P>
WINGDI.CPP  Line 820  - Visual C++ 1.5
WINGDI.CPP  Line 796  - Visual C++ 1.0
CGdiObject::FromHandle()
<P>
ASSERT(pObject == NULL || pObject-&gt;m_hObject == h);
<P>
This can be caused by trying to create a new object before
deleting a previous one. For example, calling
m_font.CreateFontIndirect() twice without calling
m_font.DeleteObject() between the calls will cause this.
<P>
 
<P>
WINGDI.CPP  Line 826  - Visual C++ 1.5
WINGDI.CPP  Line 802  - Visual C++ 1.0
CGdiObject::Attach()
<P>
<PRE>ASSERT(m_hObject == NULL);      // only attach once, detach on destroy

</PRE>This can be caused by not selecting GDI objects out of a CDC
that had been selected in to (with SelectObject()).
<P>
 
<P>
FILECORE.CPP  Lines 335 and 351  - Visual C++ 1.5
FILECORE.CPP  Lines 341, 358  - Visual C++ 1.0
CFile::Read(), CFile::Write()
<P>
This can be caused by working with a buffer larger than 64K.
See the Knowledge Base article <B><A href="../visualc/q92860.htm">Q92860</A></B>, "Read From or Write To
CFile From Buffer Larger than 64K" for more information on how to
work around this.
<P>
 
<P>
STRCORE.CPP  Line 276  - Visual C++ 1.5
STRCORE.CPP  Line 336  - Visual C++ 1.0
CString::GetBufferSetLength()
<P>
ASSERT(nNewLength &gt;= 0);
<P>
This can be caused by using CWnd::GetWindowText(CString&amp;)
when there is no window title. It is a known Windows problem
that GetWindowTextLength() returns -1 for "Drop List" combo
boxes. You can use CWnd::GetWindowText( LPSTR, int max )
to avoid this problem. See Knowledge Base article <B><A href="../visualc/q99199.htm">Q99199</A></B>,
"PRB: Cwnd::GetWindowText(CSting&amp;) Asserts w/ Drop-Down COmbo"
for more information.
<P>
 
<P>
WINMDI.CPP  Line 410  - Visual C++ 1.5
WINMDI.CPP  Line 375  - Visual C++ 1.0
CMDIChildWnd::PreCreateWindow()
<P>
ASSERT(cs.style &amp; WS_CHILD);
<PRE>   // MFC V2 requires that MDI Children are created with proper styles,
   //  usually: WS_CHILD | WS_VISIBLE | WS_OVERLAPPEDWINDOW.
   // See Technical note TN019 for more details on MFC V1-&gt;V2 migration.

</PRE>CMDIChildWnd classes require the WS_CHILD style. See MFC Technote 19.
<P>
 
<P>
WINMDI.CPP  Line 434  - Visual C++ 1.5
WINMDI.CPP  Line 399  - Visual C++ 1.0
CMDIChildWnd::Create()
<P>
ASSERT(pMainWnd != NULL);
<P>
MDI children require a frame window first.
<P>
 
<P>
DCPREV.CPP  Line 289  - Visual C++ 1.0 and 1.5
CPreviewDC::MirrorFont()
<P>
ASSERT(cyDesired &gt;= 0 &amp;&amp; cyActual &gt;= 0);
<P>
Some small TT fonts have been reported to cause this assert in
print preview
<P>
 
<P>
VIEWSCRL.CPP  Line 155  - Visual C++ 1.5
VIEWSCRL.CPP  Line 153  - Visual C++ 1.0
CScrollView::SetScrollSizes()
<P>
ASSERT(sizeTotal.cx &gt;= 0 &amp;&amp; sizeTotal.cy &gt;= 0);
<P>
This assert is caused if scroll sizes are not correctly initialized
- if no second parameter is passed to SetScrollSizes().
<P>
 
<P>
VIEWSCRL.CPP  Lines 662 and 668  - Visual C++ 1.5
VIEWSCRL.CPP  Lines 528 and 534  - Visual C++ 1.0
CScrollView::OnHScroll()
CScrollView::OnVScroll()
<P>
ASSERT(pScrollBar == GetScrollBarCtrl(SB_HORZ)); // may be nulll
ASSERT( pScrollBar == GetScrollBarCtrl(SB_VERT) );
<P>
This assert explicitly checks to see if the message was generated
by a control. If the message might not generated by a control,
commenting out this assert is one option.
<P>
 
<P>
AFXWIN1.INL Line 25  - Visual C++ 1.5
AFXWIN.INL  Line 27  - Visual C++ 1.0
AfxGetResourceHandle()
<P>
ASSERT(afxCurrentResourceHandle != NULL);
<P>
This assert has been reported to be caused by problems with the
constructors of global objects.
<P>
 
<P>
AFXDLGS.INL  Line 27  - Visual C++ 1.0 and 1.5
CFontDialog::GetCurrentFont()
<P>
ASSERT( m_hWnd != NULL )
<P>
This assert is caused by calling GetCurrentFont() while the dialog is
NOT actually displaying. For example, after the DoModal() has returned.
GetCurrentFont() must be called while dialog is active.
<P>
 
<P>
APPHELP.CPP  Line 34  - Visual C++ 1.0 and 1.5
AfxFormatStrings()
{
<PRE>   char szFormat[256];
   if (!_AfxLoadString(nIDS, szFormat) != 0)
   {
    TRACE1("Error: failed to load AfxFormatString string 0x%04x\n", nIDS);
    ASSERT(FALSE);

</PRE>This assert is caused by a LoadString() failure. Before the assert,
TRACE will output " Error: failed to load AfxFormatString string 0xABCD".
A common cause of this is not including the resources needed, such
as resources for print preview. See MFC Technote 23, "Standard MFC
Resources" for more information.
<P>
 
<P>
TIMECORE.CPP  Line 43  - Visual C++ 1.0 and 1.5
CTime::CTime()
<P>
This assert is caused by the mktime() function returning -1.
Although there are a number of previous error checks for the
validity of the parameters being passed to mktime, these
asserts do not catch all possible bad dates or times. Check
all data being passed to this function carefully.
<P>
 
<P>
FILETXT.CPP  Line 71  - Visual C++ 1.0 and 1.5
CStdioFile::Open()
<P>
ASSERT((nOpenFlags &amp; CFile_shareMask) == 0);
<P>
CStdioFile represents C run-time stream file opened by fopen().
The fopen() function doesn't accept share flags.
<P>
 
<P>
WINMENU.CPP  Line 70  - Visual C++ 1.0 and 1.5
CMenu::Attach()
<P>
<PRE>ASSERT(m_hMenu == NULL);        // only attach once, detach on destroy

</PRE>This assert can be caused by doing two LoadMenu() calls without
doing a DestroyMenu() call between them.
<P>

	</FONT>
	</TD>
	</TR>
</TABLE>
<P>


<!--DOCBODY_END-->

<!--FOOTER_START-->
<table cellpadding=5 border=0 width="90%">
<tr>
<td>
	<HR WIDTH="90%">

<BLOCKQUOTE>
<FONT FACE="Verdana, Arial, Helvetica" SIZE="1">
<SPAN STYLE="font-family:verdana,arial,helvetica; font-size:8pt">
Additional query words: 2.00 2.10 2.50<BR>
Keywords            : kb16bitonly kbprg MfcMisc kbprg<BR>
Technology          : kbMfc<BR>
Version             : 1.0 1.5<BR>
Platform            : NT WINDOWS<BR>
Issue type          : kbinfo<BR>

</SPAN>
</FONT>
<BR>
<BR>
THE INFORMATION PROVIDED IN THE MICROSOFT KNOWLEDGE BASE IS
PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND.  MICROSOFT DISCLAIMS
ALL WARRANTIES, EITHER EXPRESS OR IMPLIED, INCLUDING THE WARRANTIES
OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  IN NO
EVENT SHALL MICROSOFT CORPORATION OR ITS SUPPLIERS BE LIABLE FOR
ANY DAMAGES WHATSOEVER INCLUDING DIRECT, INDIRECT, INCIDENTAL,
CONSEQUENTIAL, LOSS OF BUSINESS PROFITS OR SPECIAL DAMAGES, EVEN IF
MICROSOFT CORPORATION OR ITS SUPPLIERS HAVE BEEN ADVISED OF THE
POSSIBILITY OF SUCH DAMAGES.  SOME STATES DO NOT ALLOW THE EXCLUSION
OR LIMITATION OF LIABILITY FOR CONSEQUENTIAL OR INCIDENTAL DAMAGES
SO THE FOREGOING LIMITATION MAY NOT APPLY.
</BLOCKQUOTE>
<P>
<center>
	<FONT FACE="Verdana,Arial,Helvetica" SIZE="1">
	Last reviewed:  July 18, 1997</FONT>
	<BR>
	<A href="../cpyright.htm" STYLE="font: bold 7pt Verdana,Arial,Helvetica">&copy; 1998 Microsoft Corporation. All rights reserved. Terms of Use.</A><BR>
	
</center>
</td>
</tr>
</table>

<!--FOOTER_END-->
</FONT>
</BODY>
</HTML>
