

<HTML>
<HEAD>
<TITLE>HOWTO: Determine the Amount of Physical Memory Installed </TITLE>

<!--STYLE_BEGIN-->
<style>@import url(../../msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="../../msdn_ie3.css">
<!--STYLE_END-->

<META HTTP-EQUIV="CONTENT-Type" CONTENT="text/html; charset=us-ascii">
<META NAME="ms.locale" CONTENT="EN-US">
<META NAME="Category" CONTENT="Support; KB Article">
<META NAME="KBID" CONTENT="Q117889">
<META NAME="KBModify" CONTENT="1997/10/03">
<META NAME="KBCreate" CONTENT="1994/07/11">
<META NAME="Keywords" CONTENT="CLngIss">
<META NAME="KBArea" CONTENT="Support; KB; visualc">
<META NAME="Description" CONTENT="  You may want to programmatically determine the amount of physical memory installed in a computer. When the computer runs under an operating system that has virtual memory or emulates other operating systems, you may not be able to determine the amo...">
<META NAME="Product" CONTENT="Visual C++">
<META NAME="Platform" CONTENT="Windows">
<META NAME="Technology" CONTENT=" ">
<META NAME="Premium" CONTENT="support">

<META NAME="nyms" CONTENT="QAUD,QA2O,QABA,QA6E,QALW,QBW6,QDJP,QAY5,QAKG,QAEF,QAA1,QDIR,QBFY,QAY2,QAYA V02180118">
</HEAD>

<BODY BGCOLOR="#FFFFFF" LEFTMARGIN="0" RIGHTMARGIN="0" TOPMARGIN="0">


<!--DOCBODY_START-->
<BR>
<CENTER>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" VALIGN="top" WIDTH="90%">
	<TR>
		<TD VALIGN="top">
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<H1>HOWTO: Determine the Amount of Physical Memory Installed</H1>
			</FONT>
			<FONT FACE="verdana,arial,helvetica" SIZE="1">
			Last reviewed:  October 3, 1997</FONT><BR>
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<B>Article ID: Q117889</B>
			</FONT>
		</TD>
	</TR>
	<TR>
	<TD>
	<FONT FACE="Verdana, Arial, Helvetica" SIZE=2>



<P><h3> </h3>
 
The information in this article applies to:

<UL><LI>Microsoft C/C++ for MS-DOS, version 7.0
<LI>Microsoft Visual C++ for Windows, versions 1.0, 1.5
<LI>Microsoft Visual C++ 32-bit Edition, versions 1.0, 2.0, 4.0, 5.0
<LI>Microsoft Macro Assembler (MASM) for MS-DOS, versions 5.1, 6.0
<LI>Microsoft MASM for MS-DOS and Windows NT, version 6.11
</UL> 
<P>
<P><h2>SUMMARY</h2>
 
<P>
You may want to programmatically determine the amount of physical memory
installed in a computer. When the computer runs under an operating system
that has virtual memory or emulates other operating systems, you may not be
able to determine the amount of installed memory from the APIs that the
particular operating system provides. In the case of 80x86-based machines,
you can obtain that information from the CMOS data.
<P>
<P><h2>MORE INFORMATION</h2>
 
<P>
"Reading" CMOS data isn't as simple as obtaining a pointer to point to a
particular memory location. You must output values to an I/O port and then
read values from another port. The Run-Time Library functions "inp" and
"outp" can be used in straight C/C++ code; or, you can use the in and out
assembly instructions with MASM programs (or with inline assembly in
version 6.0 and later of the compiler).
<P>
The procedure is straightforward: write values to I/O port 0x70 and read
them from 0x71. The values 0x15 and 0x16 are used to get the amount of base
memory installed, while 0x17 and 0x18 are used to get the amount of
expansion memory (up to 15360 kilobytes) installed. Expansion memory is
memory above the 1-MB boundary and should not be confused with expanded
memory.
<P>
Under Win32, the _inp and _outp functions are system-level (priveleged)
instructions.  Attempting to use Example 1 of the Sample Code below will
result either in unresolved externals at link, _inp and _outp, (when using
the C functions) or an Application Error at execution (when using the ASM
functions).  However, one may simply call the Win32 GlobalMemoryStatus API
using a pointer to a MEMORYSTATUS structure to determine the amount of
physical memory.  See Example 2 below.
<P>
<P><h3>Sample Code #1</h3>
 
<P>
<PRE>/* Compile options needed: none
*/

   #include &lt;conio.h&gt;
   #include &lt;stdio.h&gt;

   unsigned short GetBaseMemC();
   unsigned short GetExpMemC();
   unsigned short GetBaseMemASM();
   unsigned short GetExpMemASM();

void main( void )
</PRE>{
<PRE>   printf( "\nGetBaseMemC() returns %u.\n", (unsigned int) GetBaseMemC() );
   printf( "\nGetExpMemC()  returns %u.\n", (unsigned int) GetExpMemC() );
   printf( "\nGetBaseMemASM() returns %u.\n",
            (unsigned int)GetBaseMemASM() );
   printf( "\nGetExpMemASM()  returns %u.\n",
            (unsigned int) GetExpMemASM() );
}
   unsigned short GetBaseMemC()
   {
       // using run-time library functions
       unsigned short base;
       outp( 0x70, 0x15 );
       base = inp( 0x71 ); // retrieve low byte
       outp( 0x70, 0x16 );
       base += inp(0x71) &lt;&lt; 8; // retrieve hi-byte,
                               // shift and add to base
       return base; // return K's of base memory
   }

   unsigned short GetExpMemC()
   {
       // using run-time library functions
       unsigned short extend;
       outp( 0x70, 0x17 );
       extend = inp( 0x71 ); // retrieve low byte
       outp( 0x70, 0x18 );
       extend += inp(0x71) &lt;&lt; 8; // retrieve hi-byte,
                                 // shift and add to extend
       return extend; // return K's of expansion memory
   }

   unsigned short GetBaseMemASM()
   {
       // using in-line assembly
       unsigned short base;
       _asm
       {
              mov dx, 71h // port to read from

              mov ax, 15h // lo-byte value
              out 70h, al // write to port
              jmp a       // allow bus to settle down
           a:
              in al, dx   // read from port
              mov byte ptr [base], al // write to lo-byte

              mov ax, 16h // hi-byte value
              out 70h, al // writing
              jmp b       // settling
           b:
              in al, dx   // reading
              mov byte ptr [base+1], al // write to hi-byte
       }

       return base; // return K's of base memory
   }

   unsigned short GetExpMemASM()
   {
       // using in-line assembly
       unsigned short extend;
       _asm
       {
              mov dx, 71h // port to read from

              mov ax, 17h // lo-byte value
              out 70h, al // write to port
              jmp a       // allow bus to settle down
           a:
              in al, dx   // read from port
              mov byte ptr [extend], al // write to lo-byte

              mov ax, 18h // hi-byte value
              out 70h, al // writing
              jmp b       // settling
           b:
              in al, dx   // reading
              mov byte ptr [extend+1], al // write to hi-byte
       }

       return extend; // return K's of expansion memory
   }


</PRE><h3>Sample Code #2</h3>
 
<P>
<PRE>#include &lt;stdio.h&gt;
#include &lt;windows.h&gt;

</PRE>DWORD MyGetMem(void)
{
<PRE>   MEMORYSTATUS MemoryStatus;

   memset( &amp;MemoryStatus, sizeof(MEMORYSTATUS), 0 );
   MemoryStatus.dwLength = sizeof(MEMORYSTATUS);

   GlobalMemoryStatus( &amp;MemoryStatus );

   return( MemoryStatus.dwTotalPhys );
</PRE>}
<P>
<PRE>void main( void )
</PRE>{
<PRE>   printf( "Physical memory install = %u bytes.\n", (unsigned int)
</PRE>MyGetMem() );
}
<P>
<P><h2>REFERENCES</h2>
 
<P>
The "Programmer's PC Sourcebook," 2nd ed., published by Microsoft Press,
contains more information about the layout of the CMOS data area.
<P>
The "Win32 Programmer's Reference" contains more information on the
GlobalMemoryStatus function as does the Functions Reference of the SDKs :
Win32 SDK : Win32 book included in the Visual C++ version 4.0 Books Online.
<P>
The "Run-Time Library Reference Manual" contains more information about the
inp and outp functions.
 
<PRE>Keywords          : CLngIss
Version           : MS- DOS:5.1,6.0,6.11,7.0;WIN3X:1.0,1.5;WINNT:1.0,2.0,4.0,5.0,6.11;
Platform          : MS-DOS NT WINDOWS
Issue type        : kbhowto</PRE>

	</FONT>
	</TD>
	</TR>
</TABLE>
<P>


<!--DOCBODY_END-->

<!--FOOTER_START-->
<table cellpadding=5 border=0 width="90%">
<tr>
<td>
	<HR WIDTH="90%">

<BLOCKQUOTE>
<FONT FACE="Verdana, Arial, Helvetica" SIZE="1">
<SPAN STYLE="font-family:verdana,arial,helvetica; font-size:8pt">
================================================================================<BR>

</SPAN>
</FONT>
<BR>
<BR>
THE INFORMATION PROVIDED IN THE MICROSOFT KNOWLEDGE BASE IS
PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND.  MICROSOFT DISCLAIMS
ALL WARRANTIES, EITHER EXPRESS OR IMPLIED, INCLUDING THE WARRANTIES
OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  IN NO
EVENT SHALL MICROSOFT CORPORATION OR ITS SUPPLIERS BE LIABLE FOR
ANY DAMAGES WHATSOEVER INCLUDING DIRECT, INDIRECT, INCIDENTAL,
CONSEQUENTIAL, LOSS OF BUSINESS PROFITS OR SPECIAL DAMAGES, EVEN IF
MICROSOFT CORPORATION OR ITS SUPPLIERS HAVE BEEN ADVISED OF THE
POSSIBILITY OF SUCH DAMAGES.  SOME STATES DO NOT ALLOW THE EXCLUSION
OR LIMITATION OF LIABILITY FOR CONSEQUENTIAL OR INCIDENTAL DAMAGES
SO THE FOREGOING LIMITATION MAY NOT APPLY.
</BLOCKQUOTE>
<P>
<center>
	<FONT FACE="Verdana,Arial,Helvetica" SIZE="1">
	Last reviewed:  October 3, 1997</FONT>
	<BR>
	<A href="../cpyright.htm" STYLE="font: bold 7pt Verdana,Arial,Helvetica">&copy; 1998 Microsoft Corporation. All rights reserved. Terms of Use.</A><BR>
	
</center>
</td>
</tr>
</table>

<!--FOOTER_END-->
</FONT>
</BODY>
</HTML>
