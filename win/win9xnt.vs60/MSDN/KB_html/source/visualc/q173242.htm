

<HTML>
<HEAD>
<TITLE>HOWTO: Use Masks to Set/Get Item States in CListCtrl </TITLE>

<!--STYLE_BEGIN-->
<style>@import url(../../msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="../../msdn_ie3.css">
<!--STYLE_END-->

<META HTTP-EQUIV="CONTENT-Type" CONTENT="text/html; charset=us-ascii">
<META NAME="ms.locale" CONTENT="EN-US">
<META NAME="Category" CONTENT="Support; KB Article">
<META NAME="KBID" CONTENT="Q173242">
<META NAME="KBModify" CONTENT="1997/09/03">
<META NAME="KBCreate" CONTENT="1997/08/28">
<META NAME="Keywords" CONTENT="MfcMisc">
<META NAME="KBArea" CONTENT="Support; KB; visualc">
<META NAME="Description" CONTENT="  With the CListCtrl class there are no explicit function calls to set or retrieve the states of the list items. This functionality is handled with flags or masks. This article explains how to use these masks to get list items and change their states...">
<META NAME="Product" CONTENT="Visual C++">
<META NAME="Platform" CONTENT="Windows">
<META NAME="Technology" CONTENT=" ">
<META NAME="Premium" CONTENT="support">

<META NAME="nyms" CONTENT="QALS,QAHE,QAE1,QAGI,QAY5,QA2Q,QAG2,QBXS,QBWP,QAXC,QAI4,QBM2,QBV8,QBDM,QAUD V02180118">
</HEAD>

<BODY BGCOLOR="#FFFFFF" LEFTMARGIN="0" RIGHTMARGIN="0" TOPMARGIN="0">


<!--DOCBODY_START-->
<BR>
<CENTER>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" VALIGN="top" WIDTH="90%">
	<TR>
		<TD VALIGN="top">
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<H1>HOWTO: Use Masks to Set/Get Item States in CListCtrl</H1>
			</FONT>
			<FONT FACE="verdana,arial,helvetica" SIZE="1">
			Last reviewed:  September 3, 1997</FONT><BR>
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<B>Article ID: Q173242</B>
			</FONT>
		</TD>
	</TR>
	<TR>
	<TD>
	<FONT FACE="Verdana, Arial, Helvetica" SIZE=2>



 
 
The information in this article applies to:

<UL><LI>The Microsoft Foundation Classes (MFC) included with:
   - Microsoft Visual C++, 32-bit Editions, versions 4.2, 5.0
</UL> 
<P>
<P><h2>SUMMARY</h2>
 
<P>
With the CListCtrl class there are no explicit function calls to set or
retrieve the states of the list items. This functionality is handled with
flags or masks. This article explains how to use these masks to get list
items and change their states.
<P>
<P><h2>MORE INFORMATION</h2>
 
<P>
The CListCtrl class supports the GetItemState, SetItemState and GetNextItem
functions. If you use GetNextItem with the appropriate mask, you should be
able to locate the desired list item by its order or its state. To change
the state you would call GetItemState on the item you have located to
obtain the current desired state flag(s), make modifications to the flag(s)
and call SetItemState.
<P>
<P><h3>GetNextItem</h3>
 
<P>
The GetNextItem function takes two parameters. The first indicates which
item (0 based) in the list after which you should begin your search. The
current item is excluded from the search. To search the entire list, supply
a -1 for this parameter.
<P>
The second parameter indicates the state that identifies the item for which
you are searching. For the CListCtrl, the flags all begin with LVNI_. (see
the documentation on CListCtrl::GetNextItem for a complete list).
<P>
<P><h3>GetItemState, SetItemState</h3>
 
<P>
The GetItemState function will returns a UINT indicating current state
flag(s) of the indicated list item. SetItemState accepts a UINT to set the
state flag(s) of the indicated list item. Both of these functions take a
UINT mask that indicates which of the state flags should be affected.
<P>
<P><h2>REFERENCES</h2>
 
<P>
<P><h3>Sample Code</h3>
 
<P>
The following code demonstrates how to select all items in the CListCtrl
that begin with the letter "A" and deselect all others. Note that
m_listCtrl is a ClassWizard added control data member declared as
CListCtrl.
<P>
<PRE>   void CMyView::OnInitialUpdate()
   {
      CFormView::OnInitialUpdate();

      m_listCtrl.InsertColumn(0, "Western States", LVCFMT_LEFT, 150);

      LV_ITEM lvItem;
      ZeroMemory(&amp;lvItem, sizeof(lvItem));
      lvItem.mask = LVIF_TEXT | LVIF_STATE;

      lvItem.iItem = 0;
      lvItem.state = LVIS_CUT | LVIS_SELECTED;
      lvItem.pszText = "Washington";
      m_listCtrl.InsertItem(&amp;lvItem); // initially selected

      lvItem.iItem = 1;
      lvItem.state = LVIS_CUT | LVIS_SELECTED;
      lvItem.pszText = "Arizona";
      m_listCtrl.InsertItem(&amp;lvItem); // initially selected

      lvItem.iItem = 2;
      lvItem.state = LVIS_CUT;
      lvItem.pszText = "Alaska";
      m_listCtrl.InsertItem(&amp;lvItem);

      lvItem.iItem = 3;
      lvItem.state = LVIS_CUT;
      lvItem.pszText = "California";
      m_listCtrl.InsertItem(&amp;lvItem);

      lvItem.iItem = 4;
      lvItem.state = LVIS_CUT;
      lvItem.pszText = "Nevada";
      m_listCtrl.InsertItem(&amp;lvItem);

      UINT nState;
      CString strText;
      int iItem = -1;

      // as long as GetNextItem found an item...
      while ((iItem = m_listCtrl.GetNextItem(iItem, LVNI_ALL)) &gt; -1 )
      {
         // get item string
         strText = m_listCtrl.GetItemText(iItem, 0);

         // show initial state of flags
         nState = m_listCtrl.GetItemState(iItem, LVIS_SELECTED | LVIS_CUT);
         TRACE("%s state flag is %0x\n", strText, nState);

         // Get only LVIS_SELECTED flag
         // note that LVIS_CUT is not returned in nState
         nState = m_listCtrl.GetItemState(iItem, LVIS_SELECTED);

         // select states beginning with 'A'
         if (strText[0] == 'A' &amp;&amp; !nState) {
            TRACE("%s needed to be selected\n", strText);
            m_listCtrl.SetItemState(iItem,
               LVIS_SELECTED,  // nState
               LVIS_SELECTED); // nMask

         // deselect states that don't begin with 'A'
         } else if (strText[0] != 'A' &amp;&amp; nState) {
            TRACE("%s needed to be deselected\n", strText);
            m_listCtrl.SetItemState(iItem,
               0,              // nState
               LVIS_SELECTED); // nMask
         }

         // show new flags if modified, note that LVIS_CUT wasn't affected
         nState = m_listCtrl.GetItemState(iItem, LVIS_SELECTED | LVIS_CUT);
         TRACE("%s state flag is now %0x\n", strText, nState);
      }
   }
</PRE> 
<PRE>Keywords          : MfcMisc
Technology        : kbMfc
Version           : WINDOWS NT:4.2,5.0
Platform          : NT WINDOWS</PRE>

	</FONT>
	</TD>
	</TR>
</TABLE>
<P>


<!--DOCBODY_END-->

<!--FOOTER_START-->
<table cellpadding=5 border=0 width="90%">
<tr>
<td>
	<HR WIDTH="90%">

<BLOCKQUOTE>
<FONT FACE="Verdana, Arial, Helvetica" SIZE="1">
<SPAN STYLE="font-family:verdana,arial,helvetica; font-size:8pt">
================================================================================<BR>

</SPAN>
</FONT>
<BR>
<BR>
THE INFORMATION PROVIDED IN THE MICROSOFT KNOWLEDGE BASE IS
PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND.  MICROSOFT DISCLAIMS
ALL WARRANTIES, EITHER EXPRESS OR IMPLIED, INCLUDING THE WARRANTIES
OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  IN NO
EVENT SHALL MICROSOFT CORPORATION OR ITS SUPPLIERS BE LIABLE FOR
ANY DAMAGES WHATSOEVER INCLUDING DIRECT, INDIRECT, INCIDENTAL,
CONSEQUENTIAL, LOSS OF BUSINESS PROFITS OR SPECIAL DAMAGES, EVEN IF
MICROSOFT CORPORATION OR ITS SUPPLIERS HAVE BEEN ADVISED OF THE
POSSIBILITY OF SUCH DAMAGES.  SOME STATES DO NOT ALLOW THE EXCLUSION
OR LIMITATION OF LIABILITY FOR CONSEQUENTIAL OR INCIDENTAL DAMAGES
SO THE FOREGOING LIMITATION MAY NOT APPLY.
</BLOCKQUOTE>
<P>
<center>
	<FONT FACE="Verdana,Arial,Helvetica" SIZE="1">
	Last reviewed:  September 3, 1997</FONT>
	<BR>
	<A href="../cpyright.htm" STYLE="font: bold 7pt Verdana,Arial,Helvetica">&copy; 1998 Microsoft Corporation. All rights reserved. Terms of Use.</A><BR>
	
</center>
</td>
</tr>
</table>

<!--FOOTER_END-->
</FONT>
</BODY>
</HTML>
