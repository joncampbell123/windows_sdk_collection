

<HTML>
<HEAD>
<TITLE>FIX: Setting Default Value Using CreateField Gives Wrong Value </TITLE>

<!--STYLE_BEGIN-->
<style>@import url(../../msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="../../msdn_ie3.css">
<!--STYLE_END-->

<META HTTP-EQUIV="CONTENT-Type" CONTENT="text/html; charset=us-ascii">
<META NAME="ms.locale" CONTENT="EN-US">
<META NAME="Category" CONTENT="Support; KB Article">
<META NAME="KBID" CONTENT="Q171316">
<META NAME="KBModify" CONTENT="1997/12/01">
<META NAME="KBCreate" CONTENT="1997/07/11">
<META NAME="Keywords" CONTENT="MfcDAO VS97FixlistSP3">
<META NAME="KBArea" CONTENT="Support; KB; visualc">
<META NAME="Description" CONTENT="  An MFC DAO application built using Visual C++ version 4.2x and linked to MFC42.DLL incorrectly sets the default value for a field. For example, if CDaoTableDef::CreateField() is called with the CDaoFieldInfo::m_strDefaultValue set to  default value...">
<META NAME="Product" CONTENT="Visual C++">
<META NAME="Platform" CONTENT="Windows">
<META NAME="Technology" CONTENT=" ">
<META NAME="Premium" CONTENT="support">

<META NAME="nyms" CONTENT="QAH4,QABA,QA56,QA55,QAKD,QDO3,QBFY,QAR4,QBXS,QAPN,QAM1,QAGI,QDIX,QAKP,QBE7 V02180118">
</HEAD>

<BODY BGCOLOR="#FFFFFF" LEFTMARGIN="0" RIGHTMARGIN="0" TOPMARGIN="0">


<!--DOCBODY_START-->
<BR>
<CENTER>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" VALIGN="top" WIDTH="90%">
	<TR>
		<TD VALIGN="top">
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<H1>FIX: Setting Default Value Using CreateField Gives Wrong Value</H1>
			</FONT>
			<FONT FACE="verdana,arial,helvetica" SIZE="1">
			Last reviewed:  December 1, 1997</FONT><BR>
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<B>Article ID: Q171316</B>
			</FONT>
		</TD>
	</TR>
	<TR>
	<TD>
	<FONT FACE="Verdana, Arial, Helvetica" SIZE=2>



 
 
The information in this article applies to:

<UL><LI>Microsoft Visual C++, 32-bit Editions, version 5.0sp1
</UL> 
<P>
<P><h2>SYMPTOMS</h2>
 
<P>
An MFC DAO application built using Visual C++ version 4.2x and linked to
MFC42.DLL incorrectly sets the default value for a field. For example, if
CDaoTableDef::CreateField() is called with the
CDaoFieldInfo::m_strDefaultValue set to "default value", you will find that
a "d" is added as the default value instead of the whole string.
<P>
For sample code that demonstrates the problem, see the MORE INFORMATION
section below.
<P>
<P><h2>CAUSE</h2>
 
<P>
There is a bug in version 4.21.7160 of MFC42.DLL (this is the MFC DLL that
comes with Visual C++ 5.0 Service Pack 1). In the AfxSetDefaultValue()
function located in DAOCORE.CPP, you can see the following code:
<P>
<PRE>   .
   .
   .
   else
   {
      // Call DAO 3.0 method
      // put_DefaultValue takes BSTR param not VARIANT
      HRESULT (STDMETHODCALLTYPE DAOField::*pMethod)(BSTR) =
      (HRESULT (STDMETHODCALLTYPE
       DAOField::*)(BSTR))pDAOField-&gt;put_DefaultValue;
      BSTR bstr = strDefaultValue.AllocSysString();
      DAO_CHECK((pDAOField-&gt;*pMethod)(bstr));
      SysFreeString(bstr);
   }

</PRE>The bstr value needs to be created as an ANSI BSTR, which DAO expects in a
non-UNICODE application rather than a UNICODE BSTR that the code is
creating.
<P>
<P><h2>RESOLUTION</h2>
 
<P>
You can work around this problem by deriving a new class from CDaoTableDef
that defines a new CreateField() function. If you use this code in your
Visual C++ 4.2x application and later decide to build your application with
Visual C++ 5.0 or greater (which uses DAO 3.5 and doesn't experience the
bug), you don't want to use new class. The code demonstrates one way that
you can check the _MFC_VER constant to determine whether the code is
needed:
<P>
<P><h3>.H File</h3>
 
<P>
<PRE>   #if _MFC_VER &lt;0x0421
   class CNewDaoTableDef: public CDaoTableDef
   {
   public:
      CNewDaoTableDef(CDaoDatabase * pDatabase):CDaoTableDef(pDatabase){};

      void CreateField(CDaoFieldInfo&amp; fieldinfo);
      void SetFieldInfo(DAOField* pDAOField, CDaoFieldInfo&amp; fieldinfo);
   };
   #endif  // _MFC_VER &lt;0x421

</PRE><h3>.CPP File</h3>
 
<P>
<PRE>   #if _MFC_VER &lt;0x0421
   void CNewDaoTableDef::CreateField(CDaoFieldInfo&amp; fieldinfo)
   {
      ASSERT_VALID(this);

      DAOField* pDAOField;

      // Create the DAO field object (setting basic properties)
      DAO_CHECK(m_pDAOTableDef-&gt;CreateField(
                COleVariant(fieldinfo.m_strName, VT_BSTRT),
                COleVariant(fieldinfo.m_nType),
                COleVariant(fieldinfo.m_lSize), &amp;pDAOField));
      TRY
      {
         SetFieldInfo(pDAOField, fieldinfo);

         // Append the field object to the fields collection
         if (m_pDAOFields == NULL)
            InitFieldsCollection();

         DAO_CHECK(m_pDAOFields-&gt;Append(pDAOField));
       }
       CATCH_ALL(e)
       {
         pDAOField-&gt;Release();
         THROW_LAST();
       }
       END_CATCH_ALL

       pDAOField-&gt;Release();
   }

   void CNewDaoTableDef::SetFieldInfo(DAOField* pDAOField, CDaoFieldInfo&amp;
                                      fieldinfo)
   {
      // Assumes name, type and size set on direct DAO CreateField call
      ASSERT(pDAOField != NULL);

      if (fieldinfo.m_lAttributes != 0)
        DAO_CHECK(pDAOField-&gt;put_Attributes(fieldinfo.m_lAttributes));

      if (fieldinfo.m_nOrdinalPosition != 0)
      {
      DAO_CHECK(pDAOField
                -&gt;put_OrdinalPosition(fieldinfo.m_nOrdinalPosition));
      }

      if (fieldinfo.m_bRequired)
         DAO_CHECK(pDAOField-&gt;put_Required(AFX_DAO_TRUE));

      if (fieldinfo.m_bAllowZeroLength)
         DAO_CHECK(pDAOField-&gt;put_AllowZeroLength(AFX_DAO_TRUE));

      if (!fieldinfo.m_strForeignName.IsEmpty())
      {
         COleVariant var(fieldinfo.m_strForeignName, VT_BSTRT);
         DAO_CHECK(pDAOField-&gt;put_ForeignName(V_BSTR(&amp;var)));
      }

      if (!fieldinfo.m_strValidationRule.IsEmpty())
      {
        COleVariant var(fieldinfo.m_strValidationRule, VT_BSTRT);
        DAO_CHECK(pDAOField-&gt;put_ValidationRule(V_BSTR(&amp;var)));
      }

      if (!fieldinfo.m_strValidationText.IsEmpty())
      {
        COleVariant var(fieldinfo.m_strValidationText, VT_BSTRT);
        DAO_CHECK(pDAOField-&gt;put_ValidationText(V_BSTR(&amp;var)));
      }

      if (!fieldinfo.m_strDefaultValue.IsEmpty())
      {
        COleVariant var(fieldinfo.m_strDefaultValue, VT_BSTRT);
        DAO_CHECK(pDAOField-&gt;put_DefaultValue(V_BSTR(&amp;var)));
      }
   }
   #endif // _MFC_VER &lt;0x0421

</PRE><h2>STATUS</h2>
 
<P>
Microsoft has confirmed this to be a bug in the Microsoft products listed
at the beginning of this article. This bug has been fixed in Visual Studio
97 Service Pack 3.
<P>
For more information, please see the following article in the Microsoft
Knowledge Base:
<P>
<PRE>   ARTICLE-ID: <B><A href="../vstudio/q170365.htm">Q170365</A></B>
   TITLE     : INFO: Visual Studio 97 Service Packs - What, Where, and Why

</PRE><h2>MORE INFORMATION</h2>
 
<P>
<P><h3>Sample Code</h3>
 
<P>
This sample code fails if the application is built with Visual C++ 4.2x and
you use the newer MFC42.DLL (the one with Visual C++ 5.0 service pack 1).
<P>
<PRE>   CDaoDatabase db;
   db.Open(_T("db.mdb"));

   CDaoTableDef td(&amp;db);
   // Replace the line above with the following code to fix the problem:
   // #if _MFC_VER &lt; 0x0421
   //   CNewDaoTableDef td(&amp;db);  // need to use new class w/ VC++ 4.2x
   // #else
   //   CDaoTableDef td(&amp;db); // building with VC++ 5.0 the bug doesn't
   // exist #endif

   td.Create(_T("FieldTest"));

   CDaoFieldInfo fi;
   fi.m_strName = _T("testfield");
   fi.m_nType = dbText;
   fi.m_lSize = 50;
   fi.m_lAttributes = dbFixedField;
   fi.m_nOrdinalPosition = 0;
   fi.m_bRequired = FALSE;
   fi.m_bAllowZeroLength = TRUE;
   fi.m_lCollatingOrder = dbSortGeneral ;
   fi.m_strDefaultValue = _T("default value");
   td.CreateField(fi);
   td.Append();

   CDaoRecordset rs(&amp;db);
   rs.Open(dbOpenDynaset, _T("Select * from FieldTest3"));
   rs.AddNew();
   rs.Update();
   rs.Close();
   db.Close();
</PRE>

	</FONT>
	</TD>
	</TR>
</TABLE>
<P>


<!--DOCBODY_END-->

<!--FOOTER_START-->
<table cellpadding=5 border=0 width="90%">
<tr>
<td>
	<HR WIDTH="90%">

<BLOCKQUOTE>
<FONT FACE="Verdana, Arial, Helvetica" SIZE="1">
<SPAN STYLE="font-family:verdana,arial,helvetica; font-size:8pt">
Additional query words: 5.0sp1 4.2b<BR>
Keywords          : MfcDAO VS97FixlistSP3<BR>
Technology        : kbMfc<BR>
Version           : 5.0sp1<BR>
Platform          : NT WINDOWS<BR>
Issue type        : kbbug<BR>
Solution Type     : kbfix kbservicepack<BR>

</SPAN>
</FONT>
<BR>
<BR>
THE INFORMATION PROVIDED IN THE MICROSOFT KNOWLEDGE BASE IS
PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND.  MICROSOFT DISCLAIMS
ALL WARRANTIES, EITHER EXPRESS OR IMPLIED, INCLUDING THE WARRANTIES
OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  IN NO
EVENT SHALL MICROSOFT CORPORATION OR ITS SUPPLIERS BE LIABLE FOR
ANY DAMAGES WHATSOEVER INCLUDING DIRECT, INDIRECT, INCIDENTAL,
CONSEQUENTIAL, LOSS OF BUSINESS PROFITS OR SPECIAL DAMAGES, EVEN IF
MICROSOFT CORPORATION OR ITS SUPPLIERS HAVE BEEN ADVISED OF THE
POSSIBILITY OF SUCH DAMAGES.  SOME STATES DO NOT ALLOW THE EXCLUSION
OR LIMITATION OF LIABILITY FOR CONSEQUENTIAL OR INCIDENTAL DAMAGES
SO THE FOREGOING LIMITATION MAY NOT APPLY.
</BLOCKQUOTE>
<P>
<center>
	<FONT FACE="Verdana,Arial,Helvetica" SIZE="1">
	Last reviewed:  December 1, 1997</FONT>
	<BR>
	<A href="../cpyright.htm" STYLE="font: bold 7pt Verdana,Arial,Helvetica">&copy; 1998 Microsoft Corporation. All rights reserved. Terms of Use.</A><BR>
	
</center>
</td>
</tr>
</table>

<!--FOOTER_END-->
</FONT>
</BODY>
</HTML>
