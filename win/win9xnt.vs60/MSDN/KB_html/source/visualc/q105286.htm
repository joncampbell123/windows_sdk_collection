

<HTML>
<HEAD>
<TITLE>HOWTO: Clean Up Temporary MFC Object in _USRDLL DLLs </TITLE>

<!--STYLE_BEGIN-->
<style>@import url(../../msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="../../msdn_ie3.css">
<!--STYLE_END-->

<META HTTP-EQUIV="CONTENT-Type" CONTENT="text/html; charset=us-ascii">
<META NAME="ms.locale" CONTENT="EN-US">
<META NAME="Category" CONTENT="Support; KB Article">
<META NAME="KBID" CONTENT="Q105286">
<META NAME="KBModify" CONTENT="1997/07/31">
<META NAME="KBCreate" CONTENT="1993/10/17">
<META NAME="Keywords" CONTENT="MfcDLL kbhowto">
<META NAME="KBArea" CONTENT="Support; KB; visualc">
<META NAME="Description" CONTENT="  The Microsoft Foundation Class (MFC) Libraries create temporary objects that are used inside of message handler functions. In MFC applications, these temporary objects are automatically cleaned up in the CWinApp::OnIdle() function that is called in...">
<META NAME="Product" CONTENT="Visual C++">
<META NAME="Platform" CONTENT="Windows">
<META NAME="Technology" CONTENT=" ">
<META NAME="Premium" CONTENT="support">

<META NAME="nyms" CONTENT="QAGI,QAPN,QAY5,QAW6,QBF0,QAB9,QBV8,QAIF,QAEV,QAM9,QALX,QBVV,QAYV,QA3P,QAUD V02180118">
</HEAD>

<BODY BGCOLOR="#FFFFFF" LEFTMARGIN="0" RIGHTMARGIN="0" TOPMARGIN="0">


<!--DOCBODY_START-->
<BR>
<CENTER>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" VALIGN="top" WIDTH="90%">
	<TR>
		<TD VALIGN="top">
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<H1>HOWTO: Clean Up Temporary MFC Object in _USRDLL DLLs</H1>
			</FONT>
			<FONT FACE="verdana,arial,helvetica" SIZE="1">
			Last reviewed:  July 31, 1997</FONT><BR>
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<B>Article ID: Q105286</B>
			</FONT>
		</TD>
	</TR>
	<TR>
	<TD>
	<FONT FACE="Verdana, Arial, Helvetica" SIZE=2>



 
 
The information in this article applies to:

<UL><LI>The Microsoft Foundation Classes (MFC) included with:
   - Microsoft C/C++ version 7.0
   - Microsoft Visual C++ for Windows, version(s) 1.0, 1.5, 1.51 1.52
   - Microsoft Visual C++, 32-bit Edition, version(s) 1.0, 2.0, 2.1, 4.0
</UL> 
<P>
<P><h2>SUMMARY</h2>
 
<P>
The Microsoft Foundation Class (MFC) Libraries create temporary objects
that are used inside of message handler functions. In MFC applications,
these temporary objects are automatically cleaned up in the
CWinApp::OnIdle() function that is called in between processing messages.
However, in MFC dynamic-link libraries (DLLs) built using the _USRDLL
model, the OnIdle() function is not automatically called. As a result,
temporary objects are not automatically cleaned up. To clean up temporary
objects, the DLL must explicitly call OnIdle(1) periodically.
<P>
<P><h2>MORE INFORMATION</h2>
 
<P>
MFC maintains a set of maps that associate windows' handles with MFC
objects. When the FromHandle() function is called, it checks the map to see
whether an MFC object exists that is associated with the handle. If there
is, FromHandle() returns a pointer to the object; if not, FromHandle()
creates a temporary object. These temporary objects are cleaned up when
CWinApp::OnIdle() is called with a count of 1.
<P>
In an MFC application, the OnIdle() function is called when the message
loop is idle. It is called inside of a ::PeekMessage() loop that checks for
new messages. The ::PeekMessage() loop is in the function CWinApp::Run().
The OnIdle() function is passed an "lCount" parameter, which indicates how
many times OnIdle() has been called since the last message. When OnIdle()
is called with an lCount equal to 1, the temporary objects are cleaned up.
However, because an MFC _USRDLL DLL does not contain a main message loop,
OnIdle() is not automatically called and the temporary objects are not
cleaned up. To clean up the temporary objects, the DLL must call OnIdle()
explicitly.
<P>
In general, it can be difficult to determine the best time to call OnIdle()-
-it needs to be called often enough that temporary objects do not
accumulate, and it needs to be called when no temporary objects are in use.
Below are three strategies for calling OnIdle() in _USRDLL DLLs:

<OL><P><LI>Call the OnIdle() function at the beginning of each exported
   function. This will clean up the temporary objects each time the
   DLL is entered. This method works as long as the DLL doesn't
   re-enter itself by calling other functions in the DLL that also
   clean up temporary objects when they exit. Also, the function in
   the DLL must not yield to Windows by calling functions such as
   CWnd::MessageBox(), CDialog::DoModal(), and ::PeekMessage(). These
   functions allow other applications to process messages. If any of
   these other applications were called back in to the DLL, it would
   cause the temporary objects to be cleaned up.

<P><LI>Have the DLL export a function to be used only for cleaning up
   temporary objects. Then have each application that uses the DLL
   call this function when its main message loop is idle. This will
   allow functions in the DLL to call other functions in the DLL with
   out prematurely cleaning up the temporary objects. Note, however,
   that this approach is not safe if the DLL's functions, such as
   CWnd::MessageBox(), CDialog::DoModal(), and ::PeekMessage(), yield
   to Windows. The DLLTRACE sample shipped with Visual C++
   demonstrates this approach.

<P><LI>Maintain a counter that indicates whether the DLL is in the middle
   of a function. At the beginning of each exported function,
   increment the counter by 1; at the end of the function, decrement
   the counter by 1. If at the end of the function the counter is
   zero, then it is safe to call OnIdle(). The following code
   demonstrates one way to implement this approach:
<P>
</OL><h3>Sample Code</h3>
 
<P>
<PRE>   static DWORD dwEntryCount = 0;

   void LockTemporaryObjects()
   {
        InterlockedIncrement (&amp;dwEntryCount);
   }

   void UnlockTemporaryObjects()
   {
       if (dwEntryCount == 0)
   return;//Keep us from going negative

    if (0 == InterlockedDecrement((&amp;dwEntryCount))
       {
           AfxGetApp()-&gt;CWinApp::OnIdle(0);  // Updates UI objects
           AfxGetApp()-&gt;CWinApp::OnIdle(1);  // Free's tempory objects
       }
   }

</PRE></OL>The LockTemporaryObjects() and UnlockTemporaryObjects() function are
then used as follows:
<P>
<P><h3>Sample Code</h3>
 
<P>
<PRE>   void PASCAL FAR EXPORT MyDllRoutine()
   {
        TRY
        {
              LockTemporaryObjects();

         // Do work

            UnlockTemporaryObjects();
        }
        CATCH_ALL(e)
        {
            // Good idea to deal with exceptions in _USRDLL anyway
            UnlockTemporaryObjects();
        }
        END_CATCH_ALL
   }

</PRE>These approaches are easy to implement for functions that the DLL
explicitly exports; however, it is also possible to enter the DLL through
the window procedure used by MFC windows created in the DLL. If the DLL
creates a window that has a long lifetime, such as a modeless dialog box or
a frame window, then you may want to clean up temporary objects in between
calls to the this window's window procedure. You can do this by overriding
the WindowProc() function for the window object. This function is called
once for each message that the window processes. Because it is very common
for message handlers to call functions that end up sending more messages to
the window, you need to use the counter method mentioned above to make sure
that you aren't cleaning up temporary objects that are still being used.
The following code fragment demonstrates how this could be done for a
modeless dialog box in a class derived from CDialog:
<P>
<PRE>   CMyDialog::WindowProc(UINT message, WPARAM wParam, LPARAM lParam)
     {
        LockTemporaryObjects();
        LRESULT lResult = CDialog::WindowProc( message, wParam, lParam);
        UnlockTemporaryObjects();
        return lResult;
      }
</PRE> 
<PRE>Keywords          : MfcDLL kbhowto
Technology        : kbmfc
Version           : 1.0 1.5 1.51 1.52 2.0 2.1 4.0 7.
Platform          : MS-DOS NT WINDOWS</PRE>

	</FONT>
	</TD>
	</TR>
</TABLE>
<P>


<!--DOCBODY_END-->

<!--FOOTER_START-->
<table cellpadding=5 border=0 width="90%">
<tr>
<td>
	<HR WIDTH="90%">

<BLOCKQUOTE>
<FONT FACE="Verdana, Arial, Helvetica" SIZE="1">
<SPAN STYLE="font-family:verdana,arial,helvetica; font-size:8pt">
================================================================================<BR>

</SPAN>
</FONT>
<BR>
<BR>
THE INFORMATION PROVIDED IN THE MICROSOFT KNOWLEDGE BASE IS
PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND.  MICROSOFT DISCLAIMS
ALL WARRANTIES, EITHER EXPRESS OR IMPLIED, INCLUDING THE WARRANTIES
OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  IN NO
EVENT SHALL MICROSOFT CORPORATION OR ITS SUPPLIERS BE LIABLE FOR
ANY DAMAGES WHATSOEVER INCLUDING DIRECT, INDIRECT, INCIDENTAL,
CONSEQUENTIAL, LOSS OF BUSINESS PROFITS OR SPECIAL DAMAGES, EVEN IF
MICROSOFT CORPORATION OR ITS SUPPLIERS HAVE BEEN ADVISED OF THE
POSSIBILITY OF SUCH DAMAGES.  SOME STATES DO NOT ALLOW THE EXCLUSION
OR LIMITATION OF LIABILITY FOR CONSEQUENTIAL OR INCIDENTAL DAMAGES
SO THE FOREGOING LIMITATION MAY NOT APPLY.
</BLOCKQUOTE>
<P>
<center>
	<FONT FACE="Verdana,Arial,Helvetica" SIZE="1">
	Last reviewed:  July 31, 1997</FONT>
	<BR>
	<A href="../cpyright.htm" STYLE="font: bold 7pt Verdana,Arial,Helvetica">&copy; 1998 Microsoft Corporation. All rights reserved. Terms of Use.</A><BR>
	
</center>
</td>
</tr>
</table>

<!--FOOTER_END-->
</FONT>
</BODY>
</HTML>
