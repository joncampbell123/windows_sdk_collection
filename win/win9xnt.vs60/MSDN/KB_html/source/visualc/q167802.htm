

<HTML>
<HEAD>
<TITLE>SAMPLE: EXCEPTEX Traps MFC and Win32 Structured Exceptions </TITLE>

<!--STYLE_BEGIN-->
<style>@import url(../../msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="../../msdn_ie3.css">
<!--STYLE_END-->

<META HTTP-EQUIV="CONTENT-Type" CONTENT="text/html; charset=us-ascii">
<META NAME="ms.locale" CONTENT="EN-US">
<META NAME="Category" CONTENT="Support; KB Article">
<META NAME="KBID" CONTENT="Q167802">
<META NAME="KBModify" CONTENT="1997/10/02">
<META NAME="KBCreate" CONTENT="1997/04/30">
<META NAME="Keywords" CONTENT="MfcDAO MfcDatabase MfcMisc kbsample kbfile">
<META NAME="KBArea" CONTENT="Support; KB; visualc">
<META NAME="Description" CONTENT="  EXCEPTEX is a sample that demonstrates techniques for trapping of both Win32 Structured Exceptions and C++ Exceptions. For C++ exceptions, various helper functions are provided that demonstrate how to crack open the more commonly used exception cla...">
<META NAME="Product" CONTENT="Visual C++">
<META NAME="Platform" CONTENT="Windows">
<META NAME="Technology" CONTENT=" ">
<META NAME="Premium" CONTENT="support">

<META NAME="nyms" CONTENT="QAH4,QBFY,QAB4,QDMH,QA1O,QABN,QAY5,QAKJ,QAGI,QA4Q,QAH6,QBV8,QAB9,QAU5,QAHI V02180118">
</HEAD>

<BODY BGCOLOR="#FFFFFF" LEFTMARGIN="0" RIGHTMARGIN="0" TOPMARGIN="0">


<!--DOCBODY_START-->
<BR>
<CENTER>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" VALIGN="top" WIDTH="90%">
	<TR>
		<TD VALIGN="top">
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<H1>SAMPLE: EXCEPTEX Traps MFC and Win32 Structured Exceptions</H1>
			</FONT>
			<FONT FACE="verdana,arial,helvetica" SIZE="1">
			Last reviewed:  October 2, 1997</FONT><BR>
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<B>Article ID: Q167802</B>
			</FONT>
		</TD>
	</TR>
	<TR>
	<TD>
	<FONT FACE="Verdana, Arial, Helvetica" SIZE=2>



 
 
The information in this article applies to:

<UL><LI>Microsoft Visual C++, 32-bit Enterprise Edition, versions 4.2, 5.0
<LI>Microsoft Visual C++, 32-bit Editions, versions 4.0, 4.1, 4.2, 5.0
</UL> 
<P>
<P><h2>SUMMARY</h2>
 
<P>
EXCEPTEX is a sample that demonstrates techniques for trapping of both
Win32 Structured Exceptions and C++ Exceptions. For C++ exceptions, various
helper functions are provided that demonstrate how to crack open the more
commonly used exception classes. For Win32 Structured Exceptions, a helper
function is provided that identifies the type of Win32 exception thrown.
<P>
The following files is available for download from the Microsoft
Software Library:
<P>
<PRE> ~ <A href="http://support.microsoft.com/download/support/mslfiles/exceptex.exe">Exceptex.exe</A> <I>(size: 42708 bytes)</I> 

</PRE>For more information about downloading files from the Microsoft Software
Library, please see the following article in the Microsoft Knowledge Base:
<P>
<PRE>   ARTICLE-ID: <B><A href="../zmiscellaneous/q119591.htm">Q119591</A></B>
   TITLE     : How to Obtain Microsoft Support Files from Online Services

</PRE><h2>MORE INFORMATION</h2>
 
<P>
<P><h3>Merging Win32 and C++ Exception Handling</h3>
 
<P>
C++ Exception handling and Win32 Structured Exception Handling use
different syntax to trap exceptions.
<P>
<PRE>    // C++ Exception Handler
    try
    {
        // Do something that may raise an exception
    }
    catch( &lt;class name&gt; &lt;instance of class&gt; )
    {
        // handle exception
    }

    // Win32 Structured Exception Handler
    __try
    {
        // Do something that may raise an exception
    }
    __except( expression )
    {
        // handle exception
    }

</PRE>The fundamental difference being that C++ exception handling expects to
catch an instance of a type, whereas Win32 Structured Exception Handling
catches only three unsigned ints.
<P>
You can, however, merge both C++ and Win32 Exception handling via the
_set_se_translator() function. This causes a Win32 exception to be passed
to the handler function of your choice, which can wrap Win32 Exception
information in a class, and "throw" it as a C++ exception. This happens
automatically when a Win32 Exception occurs, and appears seamlessly to the
program as a C++ exception (see Exception Handling Differences in the VC
5.0 infoviewer). This is done for you automatically if you use the LOG
macros and related support Log() functions.
<P>
<PRE>    // Class for containing information on a Win32 Structured Exception
    class SEH_Exception {
    private:
        SEH_Exception() {}
        unsigned int m_uSECode;
    public:
        SEH_Exception(unsigned int uSECode) : m_uSECode(uSECode) {}
        ~SEH_Exception() {}
        unsigned int getSeHNumber() { return m_uSECode; }
    };

    // Handler function that passes on Win32 Exception information in the
    // C++ class SEH_Exception
    void MappingSEHtoCPPExceptions( unsigned int uExceptionCode,
                                                  _EXCEPTION_POINTERS* )
    {
        throw SEH_Exception( uExceptionCode );
    }

    // Initialize Exception Handling
    void LogEnable( ... )
    {
        // Set Win32 Exceptions to be handled as C++ typed exceptions
        _set_se_translator(MappingSEHtoCPPExceptions);

        ...
    }

</PRE>In this case, LogEnable would be called once, early in the program's
execution, and any Win32 exceptions raised could be caught with C++ syntax.
The EXCEPTEX sample demonstrates this using the code given above.
<P>
<P><h3>Types of C++ Exceptions</h3>
 
<P>
There are several categories of C++ exceptions that can be caught by an MFC-
based program:

<UL><LI>Instances of classes derived from MFC's CException
<LI>Instances of a class encapsulating a Win32 Exception
<LI>Instances of a class _com_error which is raised by Visual C++ 5.0
   native COM support available via the #import directive.
<P>
</UL>For each of these, EXCEPTEX offers a function called LogException,
overloaded for the specific type of exception being caught. In each case,
an exception raises an instance or a pointer of a specific type, typically
a C++ class. There are over-loaded versions of LogException for each of the
types of C++ Exception listed above.
<P>
Below is an example of the declaration for the overloaded LogException
function that catches a pointer to the MFC CException class.
<P>
<PRE>    // Crack open and log details of different types of exceptions
    extern void LogException( CException    *e,
                              LPCSTR        lpszTimeStamp,
                              LPCSTR        lpszFile,
                              int           nLine        );

</PRE>LogException also tracks the file name and line number where the exception
macro was last used in the call stack (if used with a helper LOG macro).
<P>
Each of these helper functions cracks open the exception and stores the
results in a string array that you can process as necessary. The function
for dumping the contents of this string array to the TRACE() macro is
LogDisplay().
<P>
<P><h3>Simplifying try/catch Blocks with Helper Macros</h3>
 
<P>
Littering try/catch blocks in your code can get messy after a while.
However, it is possible to simplify exception blocks through the use of
macros. EXCEPTEX provides three macros to simplify this process, and each
offers different functionality for logging/handling of exceptions. Each of
the macros are also written to work for both Visual C++ 4.X and Visual C++
5.0, so they must check the version of the compiler you are using.
<P>
Below is the simplest of the macros, LOGQ (quiet Exception Handling with no
logging). It expects that a Boolean variable named bRetVal is available in
your code. It must be true so that the macro can allow execution of the
code that may raise an exception, and it sets it to FALSE if an exception
is raised.
<P>
<PRE>    #if _MSC_VER &lt; 1100    // For version VC++ 4.2 or earlier

        #define LOGQ( f ) if( bRetVal == TRUE )                \
                          {                                    \
                             try                               \
                             {                                 \
                                 f;                            \
                             }                                 \
                             catch( CException *e )            \
                             {                                 \
                                bRetVal = FALSE;               \
                                 e-&gt;Delete();                  \
                             }                                 \
                             catch( SEH_Exception )            \
                             {                                 \
                                bRetVal = FALSE;               \
                             }                                 \
                             catch(...)                        \
                             {                                 \
                                bRetVal = FALSE;               \
                             }                                 \
                          }

    #else

        #define LOGQ( f ) if( bRetVal == TRUE )                \
                          {                                    \
                             try                               \
                             {                                 \
                                f;                             \
                             }                                 \
                             catch( CException *e )            \
                             {                                 \
                                bRetVal = FALSE;               \
                                e-&gt;Delete();                   \
                             }                                 \
                             catch( _com_error )               \
                             {                                 \
                                bRetVal = FALSE;               \
                              }                                \
                             catch( SEH_Exception )            \
                             {                                 \
                                bRetVal = FALSE;               \
                             }                                 \
                             catch(...)                        \
                             {                                 \
                                bRetVal = FALSE;               \
                             }                                 \
                          }

    #endif


</PRE>The #ifdef _MSC_VER restricts the definition of the macro to be specific to
either Visual C++ 4.X or 5.0. The 5.0 version includes a catch for the
newly introduced _com_error exception (generated by code created from
#import).
<P>
You would use LOGQ as shown below:
<P>
<PRE>    int     i = 0;
    int     j;
    BOOL    bRetVal = TRUE;

    // This code is not safe
    j = 1 / i;        // Raises Win32 Divide By Zero exception

    // This code is safe
    LOGQ( j = 1 / i; )

</PRE>There are two other versions of the LOG macros provided by EXCEPTEX. The
second LOG macro uses the overloaded LogException() helpers described
above.
<P>
<PRE>    #define LOGE( f ) try                               \
                      {                                 \
                          f;                            \
                      }                                 \
                      catch( CException *e )            \
                      {                                 \
                          LogException( e,              \
                                        __TIMESTAMP__,  \
                                        __FILE__,       \
                                        __LINE__      );\
                      }                                 \
                      ...

</PRE>This macro does not make use of the flag bRetVal. It will always execute
the code encapsulated by the macro, catch any exceptions raised and log
their contents.
<P>
The final LOG macro provided by EXCEPTEX, LOGR, combines both LOGQ and
LOGE. It checks to see if it should execute the code and log any exception
that is raised.
<P>
<PRE>    #define LOGR( f ) if( bRetVal == TRUE )                 \
                      {                                     \
                          try                               \
                          {                                 \
                              f;                            \
                          }                                 \
                          catch( CException *e )            \
                          {                                 \
                              LogException( e,              \
                                            __TIMESTAMP__,  \
                                            __FILE__,       \
                                            __LINE__      );\
                              bRetVal = FALSE;              \
                          }                                 \
                          ...
                        }

</PRE><h3>Other Useful Functions</h3>
 
<P>
The EXCEPTEX sample provides three more functions to assist exception
handling:
<P>
<PRE>    LogDisplay()          Dumps contents of all logged exceptions out
                          via TRACE macros.

    LogDisplay( ... )     Dumps contents of all logged exceptions out
                          to an instance of CListBox.

    LogSaveToFile( ... )  Dumps contents of all logged exceptions out
                          to a file.

</PRE><h3>LOG.H and LOG.CPP</h3>
 
<P>
LOG.H and LOG.CPP contain all of the code in EXCEPTEX to handle exceptions.
The remainder of the sample is to demonstrate the macros/functions found in
LOG.H and LOG.CPP. These two files can be easily added to an existing
project, and have been written to compile in either Visual C++ 4.X or 5.0
under both ANSI and UNICODE builds. To use them, add #include "log.h" to
the files that will be using the LOGE or LOGR macro. If you want to crack
Win32 Structured Exceptions also, you must call LogEnable once near the
beginning of your program.
<P>
<PRE>   // One time initialization of data
    LogEnable(false);     // false to verbose mode

</PRE>Add the LOG macro in code you want to get exception data from.
<P>
<PRE>   ...
   LOGE(myFunction())
   ...

</PRE>Note that the file and line number reported will be the last LOG macro on
the stack. If myFunction() calls myFun1() and myFun2(), you will have to
wrap each function call with a LOG macro for the output to display which
call the exception occurred in.
<P>
You may not always want to use the LOG macros or even the LogException()
helpers as provided. They are offered both as a convenience and as well as
to demonstrate comprehensive exception handling, and for logging the
results of any exception caught. They are not provided as the end-all, be-
all for exception handling in every production environment.
<P>
<P><h3>Troubleshooting</h3>
 
<P>
The following code shows how not to use the helper macros
<P>
<PRE>    LOGQ( int i = 0; )
    LOGQ( int j = 1 / i; )    // Will this raise a divide by zero?

</PRE>This code generates a compiler error as i is only defined in the scope
of the first LOGQ macro.  Remember that LOGQ expands to:
<P>
<PRE>    ...
    try
    {
        int i = 0;
    }
    ...

    ...
    try
    {
        int j = 1 / i;  // error C2065: 'i' : undeclared
    }
    ...

</PRE><h3>/W4 and #import</h3>
 
<P>
If you are using the /W4 flag in Visual C++ and #import, you will see 8
warnings generated off the include files that #import utilizes.
<P>
<PRE>    comutil.h(905) :  warning C4310: cast truncates constant value
    comutil.h(928) :  warning C4310: cast truncates constant value
    comutil.h(1030) : warning C4310: cast truncates constant value
    comutil.h(1281) : warning C4310: cast truncates constant value
    comutil.h(1307) : warning C4310: cast truncates constant value
    comutil.h(1476) : warning C4310: cast truncates constant value
    comdef.h(242) :   warning C4244: 'return' : conversion from 'int' to
                      'unsigned short', possible loss of data

</PRE>These error messages can be ignored and should not affect your code.
<P>
<P><h3>For More Information</h3>
 
<P>
The following VC++ 5.0 infoviewer topic present a good introduction to
exception handling techniques:
<P>
<PRE>   Exception Handling: Frequently Asked Questions
   mk:@ivt:vccore/F26/D2A/S31BE4.HTM

   Exception Handling Differences
   mk:@ivt:vccore/F26/D2B/S4CC99.HTM

</PRE>The following article demonstrates techniques that could be used to expand
the EXCEPTEX sample to handle DAO SDK exceptions.
<P>
<PRE>   ARTICLE-ID: <B><A href="../visualc/q152695.htm">Q152695</A></B>
   TITLE:      How to Catch and Decipher DAO SDK-Based Exceptions

</PRE>A definitive source on Win32 Exception Handling can be found in:
<P>
"Advanced Windows" by Jeffrey Richter, ISBN 1-57231-548-2
 
<PRE>Keywords          : MfcDAO MfcDatabase MfcMisc kbsample kbfile
Technology        : kbMfc
Version           : WINDOWS NT: 4.0, 4.1, 4.2, 5.0
Platform          : NT WINDOWS</PRE>

	</FONT>
	</TD>
	</TR>
</TABLE>
<P>


<!--DOCBODY_END-->

<!--FOOTER_START-->
<table cellpadding=5 border=0 width="90%">
<tr>
<td>
	<HR WIDTH="90%">

<BLOCKQUOTE>
<FONT FACE="Verdana, Arial, Helvetica" SIZE="1">
<SPAN STYLE="font-family:verdana,arial,helvetica; font-size:8pt">
================================================================================<BR>

</SPAN>
</FONT>
<BR>
<BR>
THE INFORMATION PROVIDED IN THE MICROSOFT KNOWLEDGE BASE IS
PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND.  MICROSOFT DISCLAIMS
ALL WARRANTIES, EITHER EXPRESS OR IMPLIED, INCLUDING THE WARRANTIES
OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  IN NO
EVENT SHALL MICROSOFT CORPORATION OR ITS SUPPLIERS BE LIABLE FOR
ANY DAMAGES WHATSOEVER INCLUDING DIRECT, INDIRECT, INCIDENTAL,
CONSEQUENTIAL, LOSS OF BUSINESS PROFITS OR SPECIAL DAMAGES, EVEN IF
MICROSOFT CORPORATION OR ITS SUPPLIERS HAVE BEEN ADVISED OF THE
POSSIBILITY OF SUCH DAMAGES.  SOME STATES DO NOT ALLOW THE EXCLUSION
OR LIMITATION OF LIABILITY FOR CONSEQUENTIAL OR INCIDENTAL DAMAGES
SO THE FOREGOING LIMITATION MAY NOT APPLY.
</BLOCKQUOTE>
<P>
<center>
	<FONT FACE="Verdana,Arial,Helvetica" SIZE="1">
	Last reviewed:  October 2, 1997</FONT>
	<BR>
	<A href="../cpyright.htm" STYLE="font: bold 7pt Verdana,Arial,Helvetica">&copy; 1998 Microsoft Corporation. All rights reserved. Terms of Use.</A><BR>
	
</center>
</td>
</tr>
</table>

<!--FOOTER_END-->
</FONT>
</BODY>
</HTML>
