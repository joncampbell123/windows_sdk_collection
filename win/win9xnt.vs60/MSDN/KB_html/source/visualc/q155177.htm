

<HTML>
<HEAD>
<TITLE>FIX: Sockets Application Hangs or Exhibits Poor Performance </TITLE>

<!--STYLE_BEGIN-->
<style>@import url(../../msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="../../msdn_ie3.css">
<!--STYLE_END-->

<META HTTP-EQUIV="CONTENT-Type" CONTENT="text/html; charset=us-ascii">
<META NAME="ms.locale" CONTENT="EN-US">
<META NAME="Category" CONTENT="Support; KB Article">
<META NAME="KBID" CONTENT="Q155177">
<META NAME="KBModify" CONTENT="1997/09/19">
<META NAME="KBCreate" CONTENT="1996/08/22">
<META NAME="Keywords" CONTENT="MfcSockets kbbuglist kbfixlist kbprg">
<META NAME="KBArea" CONTENT="Support; KB; visualc">
<META NAME="Description" CONTENT="  A Microsoft Foundation Classes (MFC) sockets application seems to hang until a message is generated for the application (for example, by moving the mouse over a window), or an application appears to take more than two seconds on single calls to Rec...">
<META NAME="Product" CONTENT="Visual C++">
<META NAME="Platform" CONTENT="Windows">
<META NAME="Technology" CONTENT=" ">
<META NAME="Premium" CONTENT="support">

<META NAME="nyms" CONTENT="QAEV,QAY5,QAUD,QAYC,QAGI,QAR4,QAL2,QBVV,QAJH,QDJO,QAI4,QAH4,QAHT,QAGX,QA4P V02180118">
</HEAD>

<BODY BGCOLOR="#FFFFFF" LEFTMARGIN="0" RIGHTMARGIN="0" TOPMARGIN="0">


<!--DOCBODY_START-->
<BR>
<CENTER>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" VALIGN="top" WIDTH="90%">
	<TR>
		<TD VALIGN="top">
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<H1>FIX: Sockets Application Hangs or Exhibits Poor Performance</H1>
			</FONT>
			<FONT FACE="verdana,arial,helvetica" SIZE="1">
			Last reviewed:  September 19, 1997</FONT><BR>
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<B>Article ID: Q155177</B>
			</FONT>
		</TD>
	</TR>
	<TR>
	<TD>
	<FONT FACE="Verdana, Arial, Helvetica" SIZE=2>



 
4.00 4.10
WINDOWS NT
kbprg kbbuglist kbfixlist
<P>
 
The information in this article applies to:

<UL><LI>Microsoft Visual C++, 32-bit Edition, versions 4.0, 4.1
</UL> 
<P>
<P><h2>SYMPTOMS</h2>
 
<P>
A Microsoft Foundation Classes (MFC) sockets application seems to hang
until a message is generated for the application (for example, by moving
the mouse over a window), or an application appears to take more than two
seconds on single calls to Receive or Send.
<P>
In other cases the socket operations might execute more quickly if messages
are being continuously generated (for example, by moving the mouse quickly
over the application's window).
<P>
<P><h2>CAUSE</h2>
 
<P>
There is code in Sockcore.cpp that can prevent proper processing of socket
notification messages if the messages arrive at a very specific time
interval. The “More Information” section below describes this problem in
further detail.
<P>
<P><h2>RESOLUTION</h2>
 
<P>
In your CSocket derived class, provide an override of the virtual function
CSocket::OnMessagePending as follows:
<P>
#if _MFC_VER == 0x0400 || _MFC_VER == 0x0410
<P>
<PRE>#define WM_SOCKET_NOTIFY  0x0373
#define WM_SOCKET_DEAD    0x0374
#define WM_KICKIDLE       0x036A

</PRE>#endif
<P>
BOOL CMySocket::OnMessagePending()
{
#if _MFC_VER &gt;= 0x0420
<P>
<PRE>  return CSocket::OnMessagePending();

</PRE>#else
<P>
<PRE>  if(CSocket::OnMessagePending())
    return TRUE;


  MSG msg;
  // Don't flood the queue with WM_KICKIDLE messages.
  while(::PeekMessage(&amp;msg,NULL,WM_KICKIDLE,WM_KICKIDLE,PM_REMOVE));

  if(::PeekMessage( &amp;msg,
                   NULL,
                   WM_SOCKET_NOTIFY,
                   WM_SOCKET_DEAD,
                   PM_NOREMOVE))
  {
    // Post another message so that we don't block on the
    // WaitMessage call in CSocket::OnMessagePending.
    ::PostMessage(NULL,WM_KICKIDLE,0,0);
  }
  return FALSE;

</PRE>#endif  // _MFC_VER
}
<P>
<P><h2>STATUS</h2>
 
<P>
Microsoft has confirmed this to be a bug in the Microsoft products listed
at the beginning of this article. This bug was corrected in Microsoft
Visual C++, version 4.2.
<P>
<P><h2>MORE INFORMATION</h2>
 
<P>
The following code can be found in CSocket::PumpMessages in Sockcore.cpp:
<P>
<PRE>  ...

  if (::PeekMessage(&amp;msg, NULL, 0, 0, PM_NOREMOVE) &amp;&amp;
      OnMessagePending())
  {
    // allow user-interface updates
    pThread-&gt;OnIdle(-1);
  }
  else
  {
    // no work to do -- allow CPU to sleep
    WaitMessage();
  }

</PRE>The problems mentioned in the “Symptoms” section are caused by this block
of code, for the following reasons:
<P>
<P><h3>Application Hangs Until Mouse Moves</h3>
 
<P>
The behavior of WaitMessage is such that if a message in the queue has been
peeked at, then WaitMessage will not return until a new message arrives.
<P>
So if the socket notification we are looking for arrives just before the
call to PeekMessage, then the PeekMessage call looks at it and WaitMessage
won't return until a new message arrives. So, a new message must be
generated before WaitMessage breaks out.
<P>
<P><h3>Socket Operations Are Very Slow</h3>
 
<P>
MFC has a built-in protection against cases where notifications are not
arriving; it provides occasional time-outs so that the socket operation is
attempted again even though the notification never arrived. The default
time-out period is two seconds.
<P>
If the notification message was peeked at (as described above), then
WaitMessage won't return even though the operation is ready to be
completed. The application won't continue for at least two seconds. In some
cases, the WM_TIMER message is also inadvertently peeked at, in which case
the application exhibits the behavior shown above (hangs until a new
message, such as a WM_MOUSEMOVE arrives).
<P>
In some situations, even though the application does not hang, it could
take two seconds to perform the operation even though the notification
message for the socket action has already arrived. This is what can cause
the poor performance.
<P>
IMPORTANT NOTE: The CSocket class was written with the assumption that the
socket has notifications enabled [that is, AsyncSelect(0) has NOT been
called]. MFC provides protection against some cases where the notification
posting has been disabled by using a time-out mechanism, which causes the
operation to be re-tried. However, the workaround shown above does not take
into account timer messages primarily because it can cause a CPU burden if
another timer is active in the application. Thus, MFC's mechanism for
protecting CSocket objects that have disabled their notifications won't
necessarily be fixed when this workaround is implemented.
<P>
So you should ensure that notifications are always enabled for your CSocket
objects. One of the reasons some developers disable notifications is to
prevent multiple FD_READ notifications. If that is the case, then perhaps a
better workaround might be to use IOCtl to determine whether there is data
available on the socket.
<P>
For additional information on this approach, please see the following
article in the Microsoft Knowledge Base:
<P>
<PRE>   ARTICLE-ID: <B><A href="../visualc/q138694.htm">Q138694</A></B>
   TITLE     : FIX: Using CSocket w/ CArchive Causes Block from Extra
               FD_READ
</PRE>

	</FONT>
	</TD>
	</TR>
</TABLE>
<P>


<!--DOCBODY_END-->

<!--FOOTER_START-->
<table cellpadding=5 border=0 width="90%">
<tr>
<td>
	<HR WIDTH="90%">

<BLOCKQUOTE>
<FONT FACE="Verdana, Arial, Helvetica" SIZE="1">
<SPAN STYLE="font-family:verdana,arial,helvetica; font-size:8pt">
KBCategory: kbprg kbbuglist kbfixlist<BR>
KBSubcategory: MfcSockets<BR>
Additional reference words: 4.00 4.10 kbdsd CAsyncSocket CSocketFile<BR>
Keywords          : MfcSockets kbbuglist kbfixlist kbprg<BR>
Technology        : kbMfc<BR>
Version           : 4.00 4.10<BR>
Platform          : NT WINDOWS<BR>
Solution Type     : kbfix<BR>

</SPAN>
</FONT>
<BR>
<BR>
THE INFORMATION PROVIDED IN THE MICROSOFT KNOWLEDGE BASE IS
PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND.  MICROSOFT DISCLAIMS
ALL WARRANTIES, EITHER EXPRESS OR IMPLIED, INCLUDING THE WARRANTIES
OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  IN NO
EVENT SHALL MICROSOFT CORPORATION OR ITS SUPPLIERS BE LIABLE FOR
ANY DAMAGES WHATSOEVER INCLUDING DIRECT, INDIRECT, INCIDENTAL,
CONSEQUENTIAL, LOSS OF BUSINESS PROFITS OR SPECIAL DAMAGES, EVEN IF
MICROSOFT CORPORATION OR ITS SUPPLIERS HAVE BEEN ADVISED OF THE
POSSIBILITY OF SUCH DAMAGES.  SOME STATES DO NOT ALLOW THE EXCLUSION
OR LIMITATION OF LIABILITY FOR CONSEQUENTIAL OR INCIDENTAL DAMAGES
SO THE FOREGOING LIMITATION MAY NOT APPLY.
</BLOCKQUOTE>
<P>
<center>
	<FONT FACE="Verdana,Arial,Helvetica" SIZE="1">
	Last reviewed:  September 19, 1997</FONT>
	<BR>
	<A href="../cpyright.htm" STYLE="font: bold 7pt Verdana,Arial,Helvetica">&copy; 1998 Microsoft Corporation. All rights reserved. Terms of Use.</A><BR>
	
</center>
</td>
</tr>
</table>

<!--FOOTER_END-->
</FONT>
</BODY>
</HTML>
