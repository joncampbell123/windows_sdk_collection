

<HTML>
<HEAD>
<TITLE>HOWTO: How to Work Around Bugs in Template Libraries </TITLE>

<!--STYLE_BEGIN-->
<style>@import url(../../msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="../../msdn_ie3.css">
<!--STYLE_END-->

<META HTTP-EQUIV="CONTENT-Type" CONTENT="text/html; charset=us-ascii">
<META NAME="ms.locale" CONTENT="EN-US">
<META NAME="Category" CONTENT="Support; KB Article">
<META NAME="KBID" CONTENT="Q182046">
<META NAME="KBModify" CONTENT="1998/03/05">
<META NAME="KBCreate" CONTENT="1998/03/04">
<META NAME="Keywords" CONTENT="AtlIss CPPIss MfcMisc STLIss kbcode">
<META NAME="KBArea" CONTENT="Support; KB; visualc">
<META NAME="Description" CONTENT="  Occasionally, bugs are found in a template library. Because all of the source code for the library is available, it is tempting to go into the source code and modify the library. This is not advisable because there may be unintended side effects fr...">
<META NAME="Product" CONTENT="Visual C++">
<META NAME="Platform" CONTENT="Windows">
<META NAME="Technology" CONTENT=" ">
<META NAME="Security" CONTENT="PUBLIC ">
<META NAME="Premium" CONTENT="support">

<META NAME="nyms" CONTENT="QA36,QDKW,QABO,QAH6,QBHQ,QAH4,QAG4,QBH6,QAY5,QDIX,QAKP,QA2O,QAPN,QABA,QAP2 V02180118">
</HEAD>

<BODY BGCOLOR="#FFFFFF" LEFTMARGIN="0" RIGHTMARGIN="0" TOPMARGIN="0">


<!--DOCBODY_START-->
<BR>
<CENTER>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" VALIGN="top" WIDTH="90%">
	<TR>
		<TD VALIGN="top">
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<H1>HOWTO: How to Work Around Bugs in Template Libraries</H1>
			</FONT>
			<FONT FACE="verdana,arial,helvetica" SIZE="1">
			Last reviewed:  March 5, 1998</FONT><BR>
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<B>Article ID: Q182046</B>
			</FONT>
		</TD>
	</TR>
	<TR>
	<TD>
	<FONT FACE="Verdana, Arial, Helvetica" SIZE=2>



 
 
The information in this article applies to:

<UL><LI>Microsoft Visual C++, 32-bit Editions, versions 5.0, 5.0sp1, 5.0sp2,
   5.0sp3
</UL> 
<P>
<P><h2>SUMMARY</h2>
 
<P>
Occasionally, bugs are found in a template library. Because all of the
source code for the library is available, it is tempting to go into the
source code and modify the library. This is not advisable because there may
be unintended side effects from the modifications to the library. In
addition, technical support staff from the library vendor may decline to
support a modified library.
<P>
This article describes the following methods to work around bugs in
template libraries without modifying the library, by using features of the
C++ language:

<OL><P><LI>Specialize the template function that has the bug.
</OL>2. Specialize the template class member that has the bug.
3. Specialize the template class that has the bug.
4. Derive from the template class to extend its functionality.
5. Use a #define/#undef pair around a #include to change a symbol name in a
<PRE>   template header that may be causing a conflict.

</PRE></OL><h2>MORE INFORMATION</h2>
 
<P>
Below are several descriptions of how to work around bugs in a template
library. One or more of these workarounds may be applicable in any given
case.
<P>
The first three methods discuss specializing a template. To discover all of
the specializations required, compile without optimizations (to prevent
inlining any of these functions). Then either use DUMPBIN /SYMBOLS or use
the /MAP linker option to generate a map file. In either case, you can find
all of the specializations of the template class, function, or member used
in the application. You need to provide a separate template specialization
for each of these.
<P>
Method 1. Specialize the template function that has the bug.
<P>
To workaround a bug in the template function CopyElements in AfxTempl.h
that causes a series of elements to be incorrectly copied, you can
specialize CopyElements for each type used in your program. The template
declaration in AfxTempl.h is:
<P>
<PRE>   template&lt;class TYPE&gt; inline void AFXAPI
   CopyElements(TYPE* pDest, const TYPE* pSrc, int nCount)
   {
   ...
   }

</PRE>Supply a specialization for each object type that is used in CopyElements.
For example, suppose you use CopyElements for an array of class MyType.
Then your specialization would look similar to the following:
<P>
<PRE>   template&lt;&gt;
   inline void AFXAPI
   CopyElements&lt;MyType&gt;(MyType* pDest, const MyType* pSrc, int nCount)
   {
   // You supply the code to copy the elements.
   }

</PRE>Method 2. Specialize the template class member that has the bug.
<P>
To workaround a bug in the template class member function
deque&lt;T&gt;::_Buyback(), you can specialize this member
function for each type of deque in your program. For instance, if you
used a deque&lt;MyType&gt; in your program, you can specialize _Buyback() as
follows:
<P>
<PRE>   template&lt;&gt;
   void std::deque&lt;MyType&gt;::_Buyback()
   {
   // You supply the code.
   }

</PRE>Method 3. Specialize the template class that has the bug.
<P>
It is usually simpler to specialize class members that contain bugs.
However, there are some circumstances when the whole class must be
specialized. For instance, Visual C++ 5.0 doesn't support partial template
specialization. This means that class iterator_traits&lt;T*&gt; does not exist,
which means you can't use iterator_traits with a pointer type. In this
case, you can specialize iterator_traits for each of the pointer types in
your program:
<P>
<PRE>   namespace std {
       template&lt;&gt;
       struct iterator_traits&lt;MyType*&gt; {
           typedef ptrdiff_t difference_type;
           typedef MyType value_type;
           typedef MyType* pointer;
           typedef MyType&amp; reference;
           typedef random_access_iterator_tag iterator_category;
       };
   }

</PRE>Method 4. Derive from the template class to extend its functionality.
<P>
Suppose that you need class CComPtr (defined in Atlbase.h) to have
additional members const operator -&gt;() const and operator const T*() const.
To accomplish this, create a template class and derive from it, and provide
the additional member functions you need:
<P>
<PRE>   template &lt;class T&gt;
   class CMyComPtr : public CComPtr&lt;T&gt;
   {
   public:
       operator const T*() const {return (const T*)p;}
       const T* operator-&gt;() const {_ASSERTE(p!=NULL);return (const T*)p;}

       // You supply the other required member functions.
   };

</PRE>Your derived class should mimic the behavior of the base class as closely
as possible, with the exception of the added members, to extend the
functionality of the base class. The derived class does not need to supply
an implementation of every member of the base class. But pay careful
attention to construction and copy (assignment operators and copy
constructors) so that your derived class can be used in the same ways as
the base class.
<P>
Method 5. Use a #define/#undef pair around a #include to change a symbol
name in a template header that may be causing a conflict.
<P>
For instance, suppose you had a source file MyProg.cpp:
<P>
<PRE>   #include &lt;vector&gt;
   class MyTest {
   public:
       int _Ty;
       bool operator &lt; (const MyTest&amp;) const;
       bool operator == (const MyTest&amp;) const;
   };
   int main ()
   {
       std::vector&lt;MyTest&gt; a;
       return 1;
   }

</PRE>Which results in the following:
<P>
<PRE>   error C2300: 'MyTest' : class does not have a destructor called '~Ty'

</PRE>This is clearly a bug. The cause of the bug is that the template parameter
"class _Ty" in one of the STL headers conflicts with the data member named
"_Ty" in class MyTest. To work around the problem, you need to change one
of the symbols--either "class _Ty" or "int _Ty". Renaming "int _Ty" in
MyTest is the preferred way to work around this problem. If this is not
possible, as a last resort you can change the template parameter "class
_Ty" to "class _Ty0" without modifying the STL library. This can be done by
surrounding the include directive for the vector header with #define/#undef
directives as follows:
<P>
<PRE>   #define _Ty _Ty0
   #include &lt;vector&gt;
   #undef _Ty
</PRE>

	</FONT>
	</TD>
	</TR>
</TABLE>
<P>


<!--DOCBODY_END-->

<!--FOOTER_START-->
<table cellpadding=5 border=0 width="90%">
<tr>
<td>
	<HR WIDTH="90%">

<BLOCKQUOTE>
<FONT FACE="Verdana, Arial, Helvetica" SIZE="1">
<SPAN STYLE="font-family:verdana,arial,helvetica; font-size:8pt">
Additional query words: STL ATL afxtempl.h<BR>
Keywords          : AtlIss CPPIss MfcMisc STLIss kbcode<BR>
Technology        : mfc<BR>
Version           : WINNT:5.0,5.0sp1,5.0sp2,5.0sp3<BR>
Platform          : winnt<BR>
Issue type        : kbhowto<BR>

</SPAN>
</FONT>
<BR>
<BR>
THE INFORMATION PROVIDED IN THE MICROSOFT KNOWLEDGE BASE IS
PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND.  MICROSOFT DISCLAIMS
ALL WARRANTIES, EITHER EXPRESS OR IMPLIED, INCLUDING THE WARRANTIES
OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  IN NO
EVENT SHALL MICROSOFT CORPORATION OR ITS SUPPLIERS BE LIABLE FOR
ANY DAMAGES WHATSOEVER INCLUDING DIRECT, INDIRECT, INCIDENTAL,
CONSEQUENTIAL, LOSS OF BUSINESS PROFITS OR SPECIAL DAMAGES, EVEN IF
MICROSOFT CORPORATION OR ITS SUPPLIERS HAVE BEEN ADVISED OF THE
POSSIBILITY OF SUCH DAMAGES.  SOME STATES DO NOT ALLOW THE EXCLUSION
OR LIMITATION OF LIABILITY FOR CONSEQUENTIAL OR INCIDENTAL DAMAGES
SO THE FOREGOING LIMITATION MAY NOT APPLY.
</BLOCKQUOTE>
<P>
<center>
	<FONT FACE="Verdana,Arial,Helvetica" SIZE="1">
	Last reviewed:  March 5, 1998</FONT>
	<BR>
	<A href="../cpyright.htm" STYLE="font: bold 7pt Verdana,Arial,Helvetica">&copy; 1998 Microsoft Corporation. All rights reserved. Terms of Use.</A><BR>
	
</center>
</td>
</tr>
</table>

<!--FOOTER_END-->
</FONT>
</BODY>
</HTML>
