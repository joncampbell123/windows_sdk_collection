

<HTML>
<HEAD>
<TITLE>PRB: Using Extension DLL, Database/OLE/Sockets in Regular DLL </TITLE>

<!--STYLE_BEGIN-->
<style>@import url(../../msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="../../msdn_ie3.css">
<!--STYLE_END-->

<META HTTP-EQUIV="CONTENT-Type" CONTENT="text/html; charset=us-ascii">
<META NAME="ms.locale" CONTENT="EN-US">
<META NAME="Category" CONTENT="Support; KB Article">
<META NAME="KBID" CONTENT="Q154126">
<META NAME="KBModify" CONTENT="1997/07/31">
<META NAME="KBCreate" CONTENT="1996/07/30">
<META NAME="Keywords" CONTENT="MfcDAO MfcDatabase MfcDLL MfcOLE kbcode kbprg">
<META NAME="KBArea" CONTENT="Support; KB; visualc">
<META NAME="Description" CONTENT="  When using an Extension DLL from a Regular DLL, you may run into one or more of a set of related problems. Note that because the MFC Database, OLE, and Sockets support DLLs are implemented as Extension DLLs, you might see similar problems if you ar...">
<META NAME="Product" CONTENT="Visual C++">
<META NAME="Platform" CONTENT="Windows">
<META NAME="Technology" CONTENT=" ">
<META NAME="Premium" CONTENT="support">

<META NAME="nyms" CONTENT="QAOG,QAGI,QABA,QDNN,QAH4,QAY5,QAW6,QAPN,QAY2,QAUD,QAIF,QA9Q,QAPF,QA3P,QAZV V02180118">
</HEAD>

<BODY BGCOLOR="#FFFFFF" LEFTMARGIN="0" RIGHTMARGIN="0" TOPMARGIN="0">


<!--DOCBODY_START-->
<BR>
<CENTER>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" VALIGN="top" WIDTH="90%">
	<TR>
		<TD VALIGN="top">
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<H1>PRB: Using Extension DLL, Database/OLE/Sockets in Regular DLL</H1>
			</FONT>
			<FONT FACE="verdana,arial,helvetica" SIZE="1">
			Last reviewed:  July 31, 1997</FONT><BR>
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<B>Article ID: Q154126</B>
			</FONT>
		</TD>
	</TR>
	<TR>
	<TD>
	<FONT FACE="Verdana, Arial, Helvetica" SIZE=2>



 
 
The information in this article applies to:

<UL><LI>The Microsoft Foundation Classes (MFC) included with:
   - Microsoft Visual C++, 32-bit Edition, versions 4.0, 4.1, 4.2,
<P><PRE>     4.2b, 5.0
</UL></PRE> 
<P>
<P><h2>SYMPTOMS</h2>
 
<P>
When using an Extension DLL from a Regular DLL, you may run into one or
more of a set of related problems. Note that because the MFC Database, OLE,
and Sockets support DLLs are implemented as Extension DLLs, you might see
similar problems if you are using these MFC features, even if you're not
explicitly using any of your own Extension DLLs. Some symptoms are:

<UL><LI>When attempting to de-serialize an object of a type of class
   defined in the Extension DLL, the message appears in the TRACE debug
   window and the object fails to serialize:
<P>
<P><PRE>      Warning: Cannot load CYourClass from archive. Class not defined.
</PRE><P>
   An exception indicating 'bad class' may be thrown.

<LI>Resources stored in the Extension DLL fail to load because
   AfxFindResourceHandle returns NULL or an incorrect resource handle.

<LI>DllGetClassObject, DllCanUnloadNow, and the UpdateRegistry, Revoke,
   RevokeAll, and RegisterAll member functions of COleObjectFactory fail
   to locate a class factory defined in the Extension DLL.

<LI>AfxDoForAllClasses doesn't do for any classes in the Extension DLL.

<LI>Standard MFC database, sockets, or OLE resources fail to load. For
   example, AfxLoadString(AFX_IDP_SQL_CONNECT_FAIL) returns an
   empty string, even when the Regular DLL is properly using the MFC
   Database classes.
<P>
</UL><h2>CAUSE</h2>
 
<P>
The Extension DLL is not wired into the CDynLinkLibrary object chain
of the Regular DLL.
<P>
<P><h2>RESOLUTION</h2>
 
<P>
Create and export an initialization function in the Extension DLL that
creates a CDynLinkLibrary object. Call this initialization function exactly
once from each Regular DLL that uses the Extension DLL. For an example of
this, see the Sample Code section below.
<P>
If you are using any MFC OLE, MFC Database (or DAO), or MFC Sockets support
in your Regular DLL, you need to call a predefined initialization function
for each MFCO4xD.DLL, MFCD4xD.DLL, and MFCN4xD.DLL you are using. These are
the DLLs that are linked to automatically when using MFC OLE, MFC Database,
or MFC Sockets support, respectively. For example, if you are using MFC OLE
in an application or DLL, that app or DLL uses the MFCO4xD.DLL. See the
References section below for more information.
<P>
For database support, add a call to AfxDbInitModule() to your Regular DLL's
CWinApp::InitInstance function. Make sure this call occurs before any base-
class call or any added code that accesses the MFCD4xD.DLL. This function
takes no parameters and returns void.
<P>
For OLE support, add a call to AfxOleInitModule() to your Regular DLL's
CWinApp::InitInstance. Note that the COleControlModule InitInstance()
function calls AfxOleInitModule() already, so if you are building an OLE
control and are using COleControlModule, you should not add this call to
AfxOleInitModule().
<P>
For Sockets support, add a call to AfxNetInitModule() to your Regular
DLL's CWinApp::InitInstance.
<P>
Note that release builds of MFC DLLs and applications do not use separate
DLLs for database, sockets, or OLE support. It is safe to call these
initialization functions in release mode, however.
<P>
<P><h2>STATUS</h2>
 
<P>
This behavior is by design.
<P>
<P><h2>MORE INFORMATION</h2>
 
<P>
During each of the operations mentioned in the Symptoms section above, MFC
needs to search for a desired value or object. For example, during de-
serialization, MFC needs to search through all of the currently available
Runtime Classes to match objects in the archive with their proper Runtime
Class.
<P>
As a part of these searches, MFC scans through all of the Extension DLLs in
use by walking a chain of CDynLinkLibrary objects. CDynLinkLibrary objects
attach automatically to a chain during their constructor and are created by
each Extension DLL in turn during initialization. In addition, every module
(EXE or Regular DLL) has its own chain of CDynLinkLibrary objects. In other
words, the chain of Extension DLLs used by an Application is different from
the chain of Extension DLLs used by one Regular DLL which is different from
the chain of Extension DLLs used by another Regular DLL.
<P>
This last point is one of the most common causes of the aforementioned
problems mentioned in the Symptoms section. In order for an Extension DLL
to get wired into a CDynLinkLibrary chain, it must create a CDynLinkLibrary
object in the context of every module that will be using the Extension DLL.
For example, if an Extension DLL is going to be used from Regular DLLs, it
must provide an exported initialization function that creates a
CDynLinkLibrary object. Every Regular DLL that uses the Extension DLL must
call the exported initialization function.
<P>
If an Extension DLL is only going to be used from an MFC application (EXE)
and never from a Regular DLL, then it is sufficient to create the
CDynLinkLibrary object in the Extension DLL's DllMain. This is what the
AppWizard Extension DLL code does. When loading an Extension DLL
implicitly, DllMain loads and executes before the application ever starts.
Any CDynLinkLibrary creations are wired into a default chain that the MFC
DLL reserves for an MFC application. This prevents any need to call the
initialization function from an application. Nevertheless, it is safer and
more recommended that all applications use the initialization function and
that the Extension DLL not create a CDynLinkLibrary object in DllMain. Note
that it is not a good idea to have multiple CDynLinkLibrary objects from
one Extension DLL in any one chain, especially if the Extension DLL will be
dynamically unloaded from memory. Don't call the initialization function
more than once from any one module.
<P>
The implementations of the AfxDbInitModule, AfxOleInitModule, and
AfxNetInitModule functions can be found in the DLLDB.CPP, DLLOLE.CPP, and
DLLNET.CPP files in the \MsDev\Mfc\Src directory, respectively.
<P>
<P><h3>Sample Code</h3>
 
<P>
This sample code assumes that the Regular DLL is implicitly linking to the
Extension DLL. This is accomplished by linking to the Import Library (.LIB)
of the Extension DLL when building the Regular DLL.
<P>
These lines should be in the source of the Extension DLL:
<P>
<PRE>   /////////////////////
   // YourExtDLL.cpp:

   #include "afxdllx.h"    // standard MFC Extension DLL routines

   static AFX_EXTENSION_MODULE NEAR extensionDLL = { NULL, NULL };

   extern "C" int APIENTRY
   DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
   {
       if (dwReason == DLL_PROCESS_ATTACH)
       {
           // Extension DLL one-time initialization.
           if (!AfxInitExtensionModule(extensionDLL, hInstance))
              return 0;
       }
       return 1;   // ok
   }

   // Exported DLL initialization is run in context of application
   // or Regular DLL.
   extern "C" void WINAPI InitYourExtDLL()
   {
       // Create a new CDynLinkLibrary for this app.
       new CDynLinkLibrary(extensionDLL);

       // Add other initialization here.
   }

</PRE>Be sure to export the InitYourExtDLL function. This could be done using
_declspec(dllexport), or in your DLL's .DEF file as follows:
<P>
<PRE>   /////////////////////
   // YourExtDLL.Def:

   LIBRARY      YOUREXTDLL

   CODE         PRELOAD MOVEABLE DISCARDABLE
   DATA         PRELOAD SINGLE

   EXPORTS
       InitYourExtDLL

</PRE>Add a call to the InitInstance member of the CWinApp-derived object
in each Regular DLL using the Extension DLL:
<P>
<PRE>   /////////////////////////
   // YourRegularDLL.cpp:

   class CYourRegularDLL : public CWinApp
   {
   public:
       virtual BOOL InitInstance(); // Initialization
       virtual int ExitInstance();  // Termination

       // Nothing special for the constructor.
       CYourRegularDLL(LPCTSTR pszAppName) : CWinApp(pszAppName) { }
   };

   BOOL CYourRegularDLL::InitInstance()
   {
       // Any DLL initialization goes here.
       TRACE0("YOUR Regular DLL initializing\n");

       // Wire any extension DLLs into CDynLinkLibrary chain.
       InitYourExtDLL();

       return TRUE;
   }

</PRE><h2>REFERENCES</h2>
 
<P>
For information on Regular DLLs, see MFC Technical Note 11.
<P>
For information on Extension DLLs, see MFC Technical Note 33.
<P>
For an example of an Extension DLL with an exported initialization
function, see the DLLHUSK Sample on the Visual C++ CD-ROM in
<PRE>        Samples
            MFC Samples
                Advanced MFC Samples

</PRE>Relevant source code: in the \MsDev\Mfc\Src directory:
<P>
<PRE>    DLLINIT.CPP     Extension DLL code
    DLLMODUL.CPP    Regular DLL code
    DLLDB.CPP       MFC Database Debug DLL (MFCD) code
    DLLOLE.CPP      MFC OLE Debug DLL (MFCO) code
    DLLNET.CPP      MFC Sockets Debug DLL (MFCN) code

</PRE>For more information covering how to use AFX_MANAGE_STATE in your Regular
DLL, and other relevant topics, please see the following articles in the
Microsoft Knowledge Base:
<P>
<PRE>   ARTICLE-ID: <B><A href="../visualc/q140850.htm">Q140850</A></B>
   TITLE     : HOWTO: Converting DLLTRACE to Use MFC in Shared Library

   ARTICLE-ID: <B><A href="../visualc/q150121.htm">Q150121</A></B>
   TITLE     : PRB: MFC Loads Wrong Resource in Extension DLL

   ARTICLE-ID: <B><A href="../visualc/q131946.htm">Q131946</A></B>
   TITLE     : PRB: Bad Pointer from RUNTIME_CLASS with Class from _AFXDLL

   ARTICLE-ID: <B><A href="../visualc/q147315.htm">Q147315</A></B>
   TITLE     : BUG: Access Violation After Unloading Extension DL
</PRE> 
<PRE>Keywords          : MfcDAO MfcDatabase MfcDLL MfcOLE kbcode kbprg
Technology        : kbMfc
Version           : 4.0 4.1 4.2 4.2b 5.0
Platform          : NT WINDOWS</PRE>

	</FONT>
	</TD>
	</TR>
</TABLE>
<P>


<!--DOCBODY_END-->

<!--FOOTER_START-->
<table cellpadding=5 border=0 width="90%">
<tr>
<td>
	<HR WIDTH="90%">

<BLOCKQUOTE>
<FONT FACE="Verdana, Arial, Helvetica" SIZE="1">
<SPAN STYLE="font-family:verdana,arial,helvetica; font-size:8pt">
================================================================================<BR>

</SPAN>
</FONT>
<BR>
<BR>
THE INFORMATION PROVIDED IN THE MICROSOFT KNOWLEDGE BASE IS
PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND.  MICROSOFT DISCLAIMS
ALL WARRANTIES, EITHER EXPRESS OR IMPLIED, INCLUDING THE WARRANTIES
OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  IN NO
EVENT SHALL MICROSOFT CORPORATION OR ITS SUPPLIERS BE LIABLE FOR
ANY DAMAGES WHATSOEVER INCLUDING DIRECT, INDIRECT, INCIDENTAL,
CONSEQUENTIAL, LOSS OF BUSINESS PROFITS OR SPECIAL DAMAGES, EVEN IF
MICROSOFT CORPORATION OR ITS SUPPLIERS HAVE BEEN ADVISED OF THE
POSSIBILITY OF SUCH DAMAGES.  SOME STATES DO NOT ALLOW THE EXCLUSION
OR LIMITATION OF LIABILITY FOR CONSEQUENTIAL OR INCIDENTAL DAMAGES
SO THE FOREGOING LIMITATION MAY NOT APPLY.
</BLOCKQUOTE>
<P>
<center>
	<FONT FACE="Verdana,Arial,Helvetica" SIZE="1">
	Last reviewed:  July 31, 1997</FONT>
	<BR>
	<A href="../cpyright.htm" STYLE="font: bold 7pt Verdana,Arial,Helvetica">&copy; 1998 Microsoft Corporation. All rights reserved. Terms of Use.</A><BR>
	
</center>
</td>
</tr>
</table>

<!--FOOTER_END-->
</FONT>
</BODY>
</HTML>
