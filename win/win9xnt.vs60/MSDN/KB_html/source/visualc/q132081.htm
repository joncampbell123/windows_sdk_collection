

<HTML>
<HEAD>
<TITLE>How to Place Scroll Bars on an Object Derived from CControlBar </TITLE>

<!--STYLE_BEGIN-->
<style>@import url(../../msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="../../msdn_ie3.css">
<!--STYLE_END-->

<META HTTP-EQUIV="CONTENT-Type" CONTENT="text/html; charset=us-ascii">
<META NAME="ms.locale" CONTENT="EN-US">
<META NAME="Category" CONTENT="Support; KB Article">
<META NAME="KBID" CONTENT="Q132081">
<META NAME="KBModify" CONTENT="1997/10/10">
<META NAME="KBCreate" CONTENT="1995/06/27">
<META NAME="Keywords" CONTENT="MfcUI kbcode kbui">
<META NAME="KBArea" CONTENT="Support; KB; visualc">
<META NAME="Description" CONTENT="  When you place scroll bars on an object derived from CControlBar, such as CDialogBar, the window messages must be handled in a special way as described in this article.  MORE INFORMATION  There are three categories of messages for which you can hav...">
<META NAME="Product" CONTENT="Visual C++">
<META NAME="Platform" CONTENT="Windows">
<META NAME="Technology" CONTENT=" ">
<META NAME="Premium" CONTENT="support">

<META NAME="nyms" CONTENT="QAEV,QAYC,QAPN,QAH4,QAW6,QAOE,QAY2,QA7O,QAMN,QAB5,QABO,QBXQ,QAIB,QAM5,QAIA V02180118">
</HEAD>

<BODY BGCOLOR="#FFFFFF" LEFTMARGIN="0" RIGHTMARGIN="0" TOPMARGIN="0">


<!--DOCBODY_START-->
<BR>
<CENTER>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" VALIGN="top" WIDTH="90%">
	<TR>
		<TD VALIGN="top">
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<H1>How to Place Scroll Bars on an Object Derived from CControlBar</H1>
			</FONT>
			<FONT FACE="verdana,arial,helvetica" SIZE="1">
			Last reviewed:  October 10, 1997</FONT><BR>
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<B>Article ID: Q132081</B>
			</FONT>
		</TD>
	</TR>
	<TR>
	<TD>
	<FONT FACE="Verdana, Arial, Helvetica" SIZE=2>



 
1.00 1.50 1.51 1.52 | 1.00 2.00 2.10 4.00 4.10
<PRE>WINDOWS             | WINDOWS NT
</PRE>kbui kbcode
<P>
 
The information in this article applies to:

<UL><LI>The Microsoft Foundation Classes (MFC) included with:
<P>
<P><PRE>    - Microsoft Visual C++ for Windows, versions 1.0, 1.5, 1.51, 1.52
    - Microsoft Visual C++, 32-bit Edition, versions 1.0, 2.0, 2.1, 4.0,
      and 4.1
</UL></PRE> 
<P>
<P><h2>SUMMARY</h2>
 
<P>
When you place scroll bars on an object derived from CControlBar, such as
CDialogBar, the window messages must be handled in a special way as
described in this article.
<P>
<P><h2>MORE INFORMATION</h2>
 
<P>
There are three categories of messages for which you can have handlers:
window messages, control notification messages, and command messages.
<P>
Control notification messages are WM_COMMAND messages sent from controls
and other child windows to their parent windows. For example, an edit
control can send its parent a WM_COMMAND message containing the EN_CHANGE
control notification code. Window messages include the messages with the
WM_ prefix, with the exception of WM_COMMAND. WM_VSCROLL is an example of
a window message sent by a control to its parent. Command messages
include WM_COMMAND messages sent from user-interface objects, such as
menus and toolbar buttons.
<P>
Control notification messages generated by controls in a CControlBar
derived object are routed to the parent view or frame window class of the
CControlBar object. However, window messages from controls are routed to
the object associated with the parent window of the control -- namely, the
CControlBar object itself. Therefore, handlers for controls that send
window messages cannot be placed in the frame or view object.
<P>
One of the controls that sends a window message is a CScrollBar control.
Therefore, when a CScrollBar control is placed on a an object derived from
CControlBar, such as CDialogBar, the window messages it generates cannot
be handled in the parent view or frame window classes, like other messages.
<P>
One way to handle window messages from a CScrollBar on a CDialogBar is to
derive from CDialogBar and include a handler in the derived class. Another
way is to derive from CDialogBar and route the window messages sent to this
object to the parent frame or the view window object.
<P>
<P><h3>Steps Required to Derive a Class from CDialogBar</h3>
 

<OL><P><LI>Create a dialog template. In the Style box, select Child. In the border
   box, select None. Clear the Visible check box and the caption. Leave the
   name IDD_DIALOG1. Create a scroll bar IDC_SCROLLBAR1.

<P><LI>Use Class Wizard to associate the dialog with the generic CWnd class.
   Name the class CMyDlgBar. You need to do this because Class Wizard does
   not allow you to associate the dialog with a CDialogBar class.

<P><LI>Change CMyDlgBar so that it is derived from CDialogBar, not CWnd, by
   changing all references to CWnd in the code to CDialogBar. Don't forget
   the reference in the message map for CMyDlgBar.

<P><LI>Declare a member variable m_MyDlgBar of type CMyDlgBar as the CMainFrame
   class.

<P><LI>Override the Create member function in CMyDlgBar, and associate the
   dialog template with the class:
<P>
   BOOL CMyDlgBar :: Create(CWnd* pParentWnd, UINT nStyle)
   {
<PRE>   // Associate the dialog template with the class:
      return CDialogBar :: Create (pParentWnd,
                                  IDD_DIALOG1,
                                  nStyle,
                                  IDD_DIALOG1);
   }

   Notice that this Create has only two parameters. This is so the Create
   function can only be used for the dialog bar IDD_DIALOG1.

</PRE><P><LI>Call Create for this member in the CMainFrame::OnCreate.
<P>
   m_MyDlgBar.Create(this, CBRS_TOP );
<P>
</OL><h3>How to Handle the Scroll Messages in the Derived Class</h3>
 
<P>
There are two ways to handle the scroll messages in the derived class:

<UL><LI>Handle the processing of messages in the derived class.
<P>
   -or-

<LI>Redirect the message to the parent view or frame window object and
   handle the actual processing in the parent window object.
<P>
</UL>The following sample code shows how to handle the scroll messages using
both methods. The debug build of this program prints a TRACE message in the
debug window in response to messages from a horizontal scroll bar on the
CMyDlgBar IDD_DIALOG1. To run it, build the code, press the F5 function
key, click the scroll bar, and look for the TRACE message in the output
window.
<P>
<P><h3>Sample Code</h3>
 
<P>
The following code shows the modifications made to the code generated
by ClassWizard for the derived class CMyDlgBar.

<OL><P><LI>The handler for the messages for the scroll bar with ID
   IDC_SCROLLBAR1 is in the derived class.
<P>
<PRE>   ///////////////////////////////////////////////////////////
   // mydlgbar.cpp : implementation file
   //
   ...
   void CMyDlgBar::OnHScroll( UINT nSBCode,
                              UINT nPos,
                              CScrollBar* pScrollBar)
   {
    // Add code for processing WM_HSCROLL messages:
    if (pScrollBar != NULL &amp;&amp; pScrollBar-&gt;GetDlgCtrlID() == IDC_SCROLLBAR1)

      {
         TRACE0( "Received message from scroll bar : IDC_SCROLLBAR1\n");
      }

      CDialogBar::OnHScroll(nSBCode, nPos, pScrollBar);
   }

</PRE><P><LI>In this method, the code in OnHScroll shown above is moved to the
   OnHScroll of the parent window object and the handler routes the
   message to the parent Frame or View object.
<P>
<PRE>   ///////////////////////////////////////////////////////////
   // mydlgbar.cpp : implementation file
   //
   ...
   void CMyDlgBar::OnHScroll(UINT nSBCode,
                             UINT nPos,
                             CScrollBar* pScrollBar)
   {
      // Actual code to handle this message is in the parent
      // frame or view object. Send the message to that object.
   #ifdef _WIN32
      GetOwner()-&gt;SendMessage(WM_HSCROLL,
                              (WPARAM)MAKELONG((WORD)nSBCode,(WORD)nPos),
                              (LPARAM)pScrollBar-&gt;m_hWnd);
   #else
      GetOwner()-&gt;SendMessage(WM_HSCROLL,
                              (WPARAM)mSBCode,
                              (LPARAM)MAKELONG(nPos, pScrollBar-&gt;m_hWnd));
   #endif
      CDialogBar::OnHScroll(nSBCode, nPos, pScrollBar);
   }
</PRE>

	</FONT>
	</TD>
	</TR>
</TABLE>
<P>


<!--DOCBODY_END-->

<!--FOOTER_START-->
<table cellpadding=5 border=0 width="90%">
<tr>
<td>
	<HR WIDTH="90%">

<BLOCKQUOTE>
<FONT FACE="Verdana, Arial, Helvetica" SIZE="1">
<SPAN STYLE="font-family:verdana,arial,helvetica; font-size:8pt">
Additional reference words: kbinf 1.00 1.50 2.00 2.10 2.50 2.51 2.52 3.00<BR>
3.10 4.00 4.10<BR>
KBCategory: kbui kbcode<BR>
KBSubcategory: MfcUI<BR>
Keywords          : MfcUI kbcode kbui<BR>
Technology        : kbMfc<BR>
Version           : 1.00 1.50 1.51 1.52 | 1.00 2.00<BR>
Platform          : NT WINDOWS<BR>

</SPAN>
</FONT>
<BR>
<BR>
THE INFORMATION PROVIDED IN THE MICROSOFT KNOWLEDGE BASE IS
PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND.  MICROSOFT DISCLAIMS
ALL WARRANTIES, EITHER EXPRESS OR IMPLIED, INCLUDING THE WARRANTIES
OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  IN NO
EVENT SHALL MICROSOFT CORPORATION OR ITS SUPPLIERS BE LIABLE FOR
ANY DAMAGES WHATSOEVER INCLUDING DIRECT, INDIRECT, INCIDENTAL,
CONSEQUENTIAL, LOSS OF BUSINESS PROFITS OR SPECIAL DAMAGES, EVEN IF
MICROSOFT CORPORATION OR ITS SUPPLIERS HAVE BEEN ADVISED OF THE
POSSIBILITY OF SUCH DAMAGES.  SOME STATES DO NOT ALLOW THE EXCLUSION
OR LIMITATION OF LIABILITY FOR CONSEQUENTIAL OR INCIDENTAL DAMAGES
SO THE FOREGOING LIMITATION MAY NOT APPLY.
</BLOCKQUOTE>
<P>
<center>
	<FONT FACE="Verdana,Arial,Helvetica" SIZE="1">
	Last reviewed:  October 10, 1997</FONT>
	<BR>
	<A href="../cpyright.htm" STYLE="font: bold 7pt Verdana,Arial,Helvetica">&copy; 1998 Microsoft Corporation. All rights reserved. Terms of Use.</A><BR>
	
</center>
</td>
</tr>
</table>

<!--FOOTER_END-->
</FONT>
</BODY>
</HTML>
