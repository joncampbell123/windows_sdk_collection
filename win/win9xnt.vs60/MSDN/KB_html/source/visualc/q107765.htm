

<HTML>
<HEAD>
<TITLE>INFO: Sample Draws a Bitmap in a Foundation Class Dialog Box </TITLE>

<!--STYLE_BEGIN-->
<style>@import url(../../msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="../../msdn_ie3.css">
<!--STYLE_END-->

<META HTTP-EQUIV="CONTENT-Type" CONTENT="text/html; charset=us-ascii">
<META NAME="ms.locale" CONTENT="EN-US">
<META NAME="Category" CONTENT="Support; KB Article">
<META NAME="KBID" CONTENT="Q107765">
<META NAME="KBModify" CONTENT="1997/07/18">
<META NAME="KBCreate" CONTENT="1993/11/29">
<META NAME="Keywords" CONTENT="kb16bitonly MfcUI kbfasttip kbinfo">
<META NAME="KBArea" CONTENT="Support; KB; visualc">
<META NAME="Description" CONTENT=" This is the 16-bit version of this sample. There is an equivalent 32-bit sample available under the name BDLG32.   In a Microsoft Foundation Class (MFC) Libraries application for Windows, it is occasionally useful to be able to display a bitmap larg...">
<META NAME="Product" CONTENT="Visual C++">
<META NAME="Platform" CONTENT="Windows">
<META NAME="Technology" CONTENT=" ">
<META NAME="Premium" CONTENT="support">

<META NAME="nyms" CONTENT="QA01,QAPN,QAB5,QA7O,QAOE,QANX,QAMN,QAB2,QAPF,QABO,QAK3,QA4H,QAIM,QAH4,QBFY V02180118">
</HEAD>

<BODY BGCOLOR="#FFFFFF" LEFTMARGIN="0" RIGHTMARGIN="0" TOPMARGIN="0">


<!--DOCBODY_START-->
<BR>
<CENTER>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" VALIGN="top" WIDTH="90%">
	<TR>
		<TD VALIGN="top">
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<H1>INFO: Sample Draws a Bitmap in a Foundation Class Dialog Box</H1>
			</FONT>
			<FONT FACE="verdana,arial,helvetica" SIZE="1">
			Last reviewed:  July 18, 1997</FONT><BR>
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<B>Article ID: Q107765</B>
			</FONT>
		</TD>
	</TR>
	<TR>
	<TD>
	<FONT FACE="Verdana, Arial, Helvetica" SIZE=2>



 
 
The information in this article applies to:

<UL><LI>The Microsoft Foundation Classes (MFC) included with:
   - Microsoft C/C++ version 7.0
   - Microsoft Visual C++ for Windows, versions 1.0, 1.5, 1.51, 1.52
   - Microsoft Visual C++ 32-bit Edition, versions 1.0, 2.0, 2.1
</UL> 
<P>
This is the 16-bit version of this sample. There is an equivalent 32-bit
sample available under the name BDLG32.
<P>
<P><h2>SUMMARY</h2>
 
<P>
In a Microsoft Foundation Class (MFC) Libraries application for Windows, it
is occasionally useful to be able to display a bitmap larger than a normal
icon in a dialog box.
<P>
You cannot automatically add a bitmap to a dialog box template using a
dialog box editor or App Studio without using a third-party custom control,
such as a VBX picture control. To have a bitmap larger or smaller than an
icon display on a dialog box without such a control, the bitmap must be
painted on the dialog box at run time using some other method. Four
possible methods for doing this are:

<UL><LI>BitBlt() a bitmap onto the dialog box in its OnDraw() handler.
<LI>BitBlt() or StretchBlt() into a "static" frame control.
<LI>BitBlt() or StretchBlt() in OnEraseBkgnd().
<LI>Use a CBitmapButton as a picture control.
<P>
</UL>The sample BDLG demonstrates these four methods for placing a bitmap on a
dialog box. BDLG can be found in the Microsoft Software Library by
searching on the word BDLG, the Q number of this article, or S14421.
<P>
<P><h2>MORE INFORMATION</h2>
 
<P>
The following four methods, implemented in the BDLG sample, demonstrate
some possible ways to display a bitmap in a dialog box using the Microsoft
Foundation Classes.
<P>
<P><h3>Method 1: BitBlt() in OnDraw()</h3>
 
<P>
The first method uses a simple BitBlt(), when the dialog box receives a
WM_PAINT message, to paint a bitmap in a hard-coded location on a dialog
box. This method demonstrates the following:

<UL><LI>Using LoadBitmap().
<LI>Creating a compatible memory device context (DC).
<LI>Saving a handle to an object selected out of a DC between messages.
<LI>Using BitBlt().
<LI>Cleaning up a loaded bitmap and memory DC when finished with them.
<P>
</UL>Because this is a common technique, a basic version of the few steps needed
to draw a bitmap on a dialog box using MFC are listed below. These steps
assume you have already created a C++ class, named CMyDlg, and that it has
been associated with either a dialog box template created in App Studio or
with a dialog editor:

<OL><P><LI>Add a bitmap resource with an ID of IDB_MYBITMAP (or whatever ID you
   want) to your project. With App Studio, you can do this by either
   creating a new bitmap resource and setting the ID, or by choosing
   Resource, Import, and importing an already created bitmap with a .BMP
   extension.

<P><LI>Add a WM_PAINT handler to your CMyDlg class. With Visual C++ 1.0, just
   use Class Wizard to add an OnPaint() handler to your dialog box class.

<P><LI>Now, your OnPaint() function will have to load and use BitBlt() to
   paint the bitmap in your resource onto the dialog box. The code to do
   this is the following:
<P>
<P><PRE>      void CMyDlg::OnPaint()
      {
<PRE></PRE>         CPaintDC dc( this ); // Device context for painting

         CBitmap bmp, *poldbmp;
         CDC memdc;

         // Load the bitmap resource
         bmp.LoadBitmap( IDB_CORPLOGO );

         // Create a compatible memory DC
         memdc.CreateCompatibleDC( &amp;dc );

         // Select the bitmap into the DC
         poldbmp = memdc.SelectObject( &amp;bmp );

         // Copy (BitBlt) bitmap from memory DC to screen DC
         dc.BitBlt( 10, 10, 47, 47, &amp;memdc, 0, 0, SRCCOPY );

         memdc.SelectObject( poldbmp );

         // Do not call CDialog::OnPaint() for painting messages
      }

   After adding this code and adding an OnPaint entry to the message map
   for your CMyDlg class, you should see the bitmap image displayed in the
   dialog box at run time.

   Note that the first four parameters to CDC::BitBlt() depend on your
   program and the size of the bitmap resource. The first two (10, 10)
   position the upper-left corner where the bitmap will be drawn on the
   dialog box's client area. The second two (47, 47) specify the width and
   height of the bitmap area to copy over in logical units. These
   dimensions can be less than the size of the actual bitmap. The sixth and
   seventh parameters specify the upper-left corner of the bitmap in the
   memory DC to start copying from.

   One other thing to note is that the CDC and CPaintDC objects in the code
   above are created on the stack so you do not need to call the Windows
   API functions DeleteDC() and ReleaseDC() on the memory and paint DC
   objects, respectively.

   For more information about bitmaps and device contexts, refer to the
   documentation for the Windows API and MFC versions of BitBlt(),
   SelectObject(), and CreateCompatibleDC(). For a more complete example of
   this, please see the BDLG sample.

</PRE></OL><h3>Method 2: BitBlt() or StretchBlt() in "Static" Frame Control</h3>
 
<P>
The second method uses StretchBlt() and, using techniques similar to those
in the "Paint" dialog box, draws the bitmap in the client area of a
"static" picture frame control.
<P>
The BDLG sample uses Class Wizard to associate a CStatic member variable
with the static control using its "Edit Variables" capability. Besides the
above techniques, it demonstrates calculating the client area of a child
control. Note that subclassing the CStatic member (after using Class Wizard
to associate the control, just change the type in the header from CStatic
to a class you've derived from CStatic) would allow you to have the
subclassed control paint a bitmap in its client area when it itself
received a WM_PAINT.
<P>
<P><h3>Method 3: BitBlt() or StretchBlt() in OnEraseBkgnd()</h3>
 
<P>
The third method StretchBlt's the bitmap onto the background of a dialog
box in the dialog box's WM_ERASEBKGND handler, OnEraseBkgnd(). It also
demonstrates handling WM_CTLCOLOR messages and returning background brushes
from that handler (transparent in this case).
<P>
<P><h3>Method 4: CBitmapButton as Picture Control</h3>
 
<P>
The fourth and last method uses a CBitmapButton class to
CBitmapButton::AutoLoad() a bitmap into a disabled owner-draw button on a
dialog box. It is probably the simplest method of the four, although it
does not allow for much flexibility or changing of what is being painted to
reflect changes in the dialog box.
<P>
Please note the following when creating your resources for using a
CBitmapButton class. When you add the button to your dialog box template,
which you will later be associating with a CBitmapButton, the ID is
relatively unimportant, but the button must be set as owner-draw and the
caption text will be used to load your bitmap. If your button caption text
is "BITB", you should create your bitmap and give it an ID of "BITBU". Your
bitmap ID MUST have the double quotation marks or it will be saved as just
a numeric ID and fail to load when you use CBitmapButton::AutoLoad(). See
the documentation for CBitmapButton for more information.
<P>

	</FONT>
	</TD>
	</TR>
</TABLE>
<P>


<!--DOCBODY_END-->

<!--FOOTER_START-->
<table cellpadding=5 border=0 width="90%">
<tr>
<td>
	<HR WIDTH="90%">

<BLOCKQUOTE>
<FONT FACE="Verdana, Arial, Helvetica" SIZE="1">
<SPAN STYLE="font-family:verdana,arial,helvetica; font-size:8pt">
Additional query words: StretchBlt BDLG32<BR>
Keywords            : kb16bitonly MfcUI kbfasttip kbinfo<BR>
Technology          : kbMfc<BR>
Version             : 1.0 1.5 1.51 1.52 2.0 2.17.0<BR>
Platform            : MS-DOS NT WINDOWS<BR>

</SPAN>
</FONT>
<BR>
<BR>
THE INFORMATION PROVIDED IN THE MICROSOFT KNOWLEDGE BASE IS
PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND.  MICROSOFT DISCLAIMS
ALL WARRANTIES, EITHER EXPRESS OR IMPLIED, INCLUDING THE WARRANTIES
OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  IN NO
EVENT SHALL MICROSOFT CORPORATION OR ITS SUPPLIERS BE LIABLE FOR
ANY DAMAGES WHATSOEVER INCLUDING DIRECT, INDIRECT, INCIDENTAL,
CONSEQUENTIAL, LOSS OF BUSINESS PROFITS OR SPECIAL DAMAGES, EVEN IF
MICROSOFT CORPORATION OR ITS SUPPLIERS HAVE BEEN ADVISED OF THE
POSSIBILITY OF SUCH DAMAGES.  SOME STATES DO NOT ALLOW THE EXCLUSION
OR LIMITATION OF LIABILITY FOR CONSEQUENTIAL OR INCIDENTAL DAMAGES
SO THE FOREGOING LIMITATION MAY NOT APPLY.
</BLOCKQUOTE>
<P>
<center>
	<FONT FACE="Verdana,Arial,Helvetica" SIZE="1">
	Last reviewed:  July 18, 1997</FONT>
	<BR>
	<A href="../cpyright.htm" STYLE="font: bold 7pt Verdana,Arial,Helvetica">&copy; 1998 Microsoft Corporation. All rights reserved. Terms of Use.</A><BR>
	
</center>
</td>
</tr>
</table>

<!--FOOTER_END-->
</FONT>
</BODY>
</HTML>
