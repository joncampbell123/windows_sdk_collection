

<HTML>
<HEAD>
<TITLE>BUG: Operands Reversed in Divide Operation </TITLE>

<!--STYLE_BEGIN-->
<style>@import url(../../msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="../../msdn_ie3.css">
<!--STYLE_END-->

<META HTTP-EQUIV="CONTENT-Type" CONTENT="text/html; charset=us-ascii">
<META NAME="ms.locale" CONTENT="EN-US">
<META NAME="Category" CONTENT="Support; KB Article">
<META NAME="KBID" CONTENT="Q63053 ">
<META NAME="KBModify" CONTENT="1997/07/17">
<META NAME="KBCreate" CONTENT="1990/06/18">
<META NAME="Keywords" CONTENT="kb16bitonly">
<META NAME="KBArea" CONTENT="Support; KB; visualc">
<META NAME="Description" CONTENT="  Under certain situations, the Microsoft C Compiler can generate code that causes the denominator in a division operation to be divided by the numerator instead of the other way around.  Compiling the sample code below with default optimizations dem...">
<META NAME="Product" CONTENT="Visual C++">
<META NAME="Platform" CONTENT="Windows">
<META NAME="Technology" CONTENT=" ">
<META NAME="Premium" CONTENT="support">

<META NAME="nyms" CONTENT="QBFY,QADN,QAGI,QAKN,QAHH,QAKF,QAKP,QAB9,QA4Q,QAY5,QAEF,QAAP,QAIH,QBV8,QAYL V02180118">
</HEAD>

<BODY BGCOLOR="#FFFFFF" LEFTMARGIN="0" RIGHTMARGIN="0" TOPMARGIN="0">


<!--DOCBODY_START-->
<BR>
<CENTER>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" VALIGN="top" WIDTH="90%">
	<TR>
		<TD VALIGN="top">
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<H1>BUG: Operands Reversed in Divide Operation</H1>
			</FONT>
			<FONT FACE="verdana,arial,helvetica" SIZE="1">
			Last reviewed:  July 17, 1997</FONT><BR>
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<B>Article ID: Q63053 </B>
			</FONT>
		</TD>
	</TR>
	<TR>
	<TD>
	<FONT FACE="Verdana, Arial, Helvetica" SIZE=2>



 
6.00 7.00 | 6.00 7.00 | 1.00 1.50
<PRE>MS-DOS    | OS/2      | WINDOWS
</PRE>kbtool kbfasttip kbbuglist
<P>
 
The information in this article applies to:

<UL><LI>The Microsoft C/C++ Compiler (CL.EXE), included with:
<P>
<P><PRE>    - Microsoft C for MS-DOS, versions 6.0, 6.0a, and 6.0ax
    - Microsoft C for OS/2, versions 6.0, and 6.0a
    - Microsoft C/C++ for MS-DOS, version 7.0
    - Microsoft Visual C++ for Windows, versions 1.0 and 1.5
</UL></PRE> 
<P>
<P><h2>SYMPTOMS</h2>
 
<P>
Under certain situations, the Microsoft C Compiler can generate code
that causes the denominator in a division operation to be divided by
the numerator instead of the other way around.
<P>
Compiling the sample code below with default optimizations demonstrates
the problem and causes the following error:
<P>
<PRE>   run-time error M6103: Math
   - floating-point error: divide by 0

</PRE><h2>CAUSE</h2>
 
<P>
The problem apparently occurs only when the denominator contains both
a double value and a function parameter, and the numerator is a global
float. Also, the next statement apparently must contain an expression
utilizing the result of the operation. These prerequisites to the
problem indicate that the problem is directly tied to optimizations
removing common subexpressions.
<P>
<P><h2>STATUS</h2>
 
<P>
Microsoft has confirmed this to be a problem in C version 6.0, C/C++
version 7.0, 8.0, and 8.0c. This problem was corrected in
C version 6.0a, but reappeared in C/C++ version 7.0.
<P>
This is not a problem in the 32-bit compilers included with Visual C++ 32-
bit Edition.
<P>
<P><h2>MORE INFORMATION</h2>
 
<P>
In the sample code, the denominator in the first assignment statement
in set_adc() is divided by the numerator. Therefore, instead of
receiving 26.0/2.56 cast to an int, i gets a value of 0 (zero), or
2.56/26.0 cast to an int.
<P>
The following are several possible workarounds to the problem:

<UL><LI>Disable optimizations.
<LI>Declare the numerator locally or as a double instead of a float.
<LI>Use a global float variable in the denominator instead of parameter.
<LI>Don't use a double value in the denominator.
<LI>Cast the denominator as a float before division.
<LI>Break up assignment statements with a function call.
<LI>Use the /qc compiler option.
<P>
</UL>The section of mixed source and assembly below shows the assembly
instructions generated by default optimizations. The troublesome
instruction [FDIVP  ST(1),ST] is at offset 0023.
<P>
Following the logic below, width is pushed onto the coprocessor stack,
ST. Then it is multiplied by 2.56. Then _f2 is pushed onto the
coprocessor stack, ST, making the above result ST(1). Finally, the
FDIVP instruction takes ST(1), the denominator, and divides it by ST,
the numerator, which is _f2
<P>
The rest is to be expected; __ftol is called to convert the float to
an integer. The result, 0, is moved from the AX register into the
local variable i. Then i is pushed onto the coprocessor stack, ST, and
then the FDIVR instruction divides _f2 by this value causing the
divide by 0 error.
<P>
<PRE>8:          i=(int)(f2/(2.56*width));
9:          f1=f2/i;
0047:0014 9B             WAIT
0047:0015 D94604         FLD       DWord Ptr [width]
0047:0018 9B             WAIT
0047:0019 DC0EB802       FMUL      QWord Ptr [__fpinit+e (02B8)]
0047:001D 9B             WAIT
0047:001E D9064200       FLD       DWord Ptr [_f2 (0042)]
0047:0022 9B             WAIT
0047:0023 DEF9           FDIVP     ST(1),ST                  ; wrong
0047:0025 E8001B         CALL      __ftol (1B28)
0047:0028 8946FE         MOV       Word Ptr [i],AX
0047:002B 9B             WAIT
0047:002C DF46FE         FILD      Word Ptr [i]
0047:002F 9B             WAIT
0047:0030 D83E4200       FDIVR     DWord Ptr [_f2 (0042)]
0047:0034 9B             WAIT
0047:0035 D91ED004       FSTP      DWord Ptr [_f1 (04D0)]
0047:0039 90             NOP
0047:003A 9B             WAIT

</PRE>The following code generated with disabled optimizations shows the
correct method of doing this. Width is pushed onto the coprocessor
stack, ST. Width is then multiplied by 2.56 with the result stored in
ST. The FDIVR instruction then divides _f2 by the above value, and
after conversion, i equals 10 as it is supposed to.
<P>
<PRE>8:          i=(int)(f2/(2.56*width));
0047:0016 9B             WAIT
0047:0017 D94604         FLD       DWord Ptr [width]
0047:001A 9B             WAIT
0047:001B DC0EB802       FMUL      QWord Ptr [__fpinit+e (02B8)]
0047:001F 9B             WAIT
0047:0020 D83E4200       FDIVR     DWord Ptr [_f2 (0042)]   ; right
0047:0024 E8091B         CALL      __ftol (1B30)
0047:0027 8946FE         MOV       Word Ptr [i],AX
9:          f1=f2/i;
0047:002A 9B             WAIT
0047:002B D9064200       FLD       DWord Ptr [_f2 (0042)]
0047:002F 9B             WAIT
0047:0030 DE76FE         FIDIV     Word Ptr [i]
0047:0033 9B             WAIT
0047:0034 D91ED004       FSTP      DWord Ptr [_f1 (04D0)]
0047:0038 90             NOP
0047:0039 9B             WAIT

</PRE><h3>Sample Code</h3>
 
<P>
<PRE>/* Compile options needed: C6   none
*                          C7   /Ot
*                          VC++ /Ot
*/

#include &lt;stdio.h&gt;

</PRE>float f1;
<PRE>float f2=26.0f;   // Works if f2 is declared locally or as double.

void set_adc(float width)
</PRE>{
<PRE>// Works if width declared as local variable instead of parameter.
   int i;
   i=(int)(f2/(2.56*width));
      // Works if used with float constant 2.56f.
      // Works if denominator cast as float.
      // Works if broken up with function call
      //      such as printf("hello");.
   f1=f2/i;
</PRE>}
<P>
<PRE>void main(void)
</PRE>{
<PRE>   set_adc(1.0f);
   printf( "f1 is %f\n", f1 );
</PRE>}
<P>

	</FONT>
	</TD>
	</TR>
</TABLE>
<P>


<!--DOCBODY_END-->

<!--FOOTER_START-->
<table cellpadding=5 border=0 width="90%">
<tr>
<td>
	<HR WIDTH="90%">

<BLOCKQUOTE>
<FONT FACE="Verdana, Arial, Helvetica" SIZE="1">
<SPAN STYLE="font-family:verdana,arial,helvetica; font-size:8pt">
Additional reference words: 6.00 7.00 8.00 8.00c 1.00 1.50<BR>
KBCategory: kbtool kbbuglist<BR>
KBSubcategory: CLIss<BR>
Keywords            : kb16bitonly<BR>

</SPAN>
</FONT>
<BR>
<BR>
THE INFORMATION PROVIDED IN THE MICROSOFT KNOWLEDGE BASE IS
PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND.  MICROSOFT DISCLAIMS
ALL WARRANTIES, EITHER EXPRESS OR IMPLIED, INCLUDING THE WARRANTIES
OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  IN NO
EVENT SHALL MICROSOFT CORPORATION OR ITS SUPPLIERS BE LIABLE FOR
ANY DAMAGES WHATSOEVER INCLUDING DIRECT, INDIRECT, INCIDENTAL,
CONSEQUENTIAL, LOSS OF BUSINESS PROFITS OR SPECIAL DAMAGES, EVEN IF
MICROSOFT CORPORATION OR ITS SUPPLIERS HAVE BEEN ADVISED OF THE
POSSIBILITY OF SUCH DAMAGES.  SOME STATES DO NOT ALLOW THE EXCLUSION
OR LIMITATION OF LIABILITY FOR CONSEQUENTIAL OR INCIDENTAL DAMAGES
SO THE FOREGOING LIMITATION MAY NOT APPLY.
</BLOCKQUOTE>
<P>
<center>
	<FONT FACE="Verdana,Arial,Helvetica" SIZE="1">
	Last reviewed:  July 17, 1997</FONT>
	<BR>
	<A href="../cpyright.htm" STYLE="font: bold 7pt Verdana,Arial,Helvetica">&copy; 1998 Microsoft Corporation. All rights reserved. Terms of Use.</A><BR>
	
</center>
</td>
</tr>
</table>

<!--FOOTER_END-->
</FONT>
</BODY>
</HTML>
