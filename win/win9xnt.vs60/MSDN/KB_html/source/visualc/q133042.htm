

<HTML>
<HEAD>
<TITLE>HOWTO: Pass IDispatch Pointer and Avoid an Application Error </TITLE>

<!--STYLE_BEGIN-->
<style>@import url(../../msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="../../msdn_ie3.css">
<!--STYLE_END-->

<META HTTP-EQUIV="CONTENT-Type" CONTENT="text/html; charset=us-ascii">
<META NAME="ms.locale" CONTENT="EN-US">
<META NAME="Category" CONTENT="Support; KB Article">
<META NAME="KBID" CONTENT="Q133042">
<META NAME="KBModify" CONTENT="1998/02/17">
<META NAME="KBCreate" CONTENT="1995/07/24">
<META NAME="Keywords" CONTENT="MfcOLE">
<META NAME="KBArea" CONTENT="Support; KB; visualc">
<META NAME="Description" CONTENT="  In some cases, you may want an OLE Automation Local-Server to pass its IDispatch pointer to another Local-Server through an automation method. However, the pointer will become invalid after the method in the second server returns, so an Access Viol...">
<META NAME="Product" CONTENT="Visual C++">
<META NAME="Platform" CONTENT="Windows">
<META NAME="Technology" CONTENT=" ">
<META NAME="Premium" CONTENT="support">

<META NAME="nyms" CONTENT="QAO2,QAPN,QAO3,QAD7,QAH7,QAH6,QAGI,QAW6,QAY2,QDKF,QBVW,QAPP,QA9Q,QA2K,QAPF V02180118">
</HEAD>

<BODY BGCOLOR="#FFFFFF" LEFTMARGIN="0" RIGHTMARGIN="0" TOPMARGIN="0">


<!--DOCBODY_START-->
<BR>
<CENTER>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" VALIGN="top" WIDTH="90%">
	<TR>
		<TD VALIGN="top">
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<H1>HOWTO: Pass IDispatch Pointer and Avoid an Application Error</H1>
			</FONT>
			<FONT FACE="verdana,arial,helvetica" SIZE="1">
			Last reviewed:  February 17, 1998</FONT><BR>
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<B>Article ID: Q133042</B>
			</FONT>
		</TD>
	</TR>
	<TR>
	<TD>
	<FONT FACE="Verdana, Arial, Helvetica" SIZE=2>



 
 
The information in this article applies to:

<UL><LI>The Microsoft Foundation Classes (MFC), included with:
   Microsoft Visual C++, 32-bit Edition, versions 2.0, 2.1, 2.2,
   4.0, 4.1, 5.0
</UL> 
<P>
<P><h2>SUMMARY</h2>
 
<P>
In some cases, you may want an OLE Automation Local-Server to pass its
IDispatch pointer to another Local-Server through an automation method.
However, the pointer will become invalid after the method in the second
server returns, so an Access Violation will occur if the second server
tries to use the pointer later.
<P>
To maintain the integrety of the pointer, you need to call AddRef on the
IDispatch pointer within the second server, as described in the following
rule from the OLE SDK documentation:
<P>
<PRE>   If a local copy of an interface pointer is made from an existing global
   interface pointer, the local copy must be independently reference-
   counted. This separate reference count is necessary because the global
   copy can be destroyed while the local copy is in use.

</PRE><h2>MORE INFORMATION</h2>
 
<P>
Here is an example demonstrating the reasoning behind the general rule.
<P>
When the IDispatch pointer from the first Local-Server (server1) is passed
to the second Local-Server (server2), the RPC manager creates a proxy in
the address space of server2. The pointer that server2 actually receives
points to the proxy. This should make sense because the original object
resides in the address space of server1, so server2 cannot actually have a
pointer to it.
<P>
The default life-time of the proxy is the duration of the function or
automation method. In many cases, however, it would be convenient to use
the pointer later. In MFC, you can do this by creating an instance of
COleDispatchDriver (or an instance of an object derived from
COleDispatchDriver) and calling AttachDispatch().
<P>
To affect the life-time of the proxy, server2 must call AddRef for the
automation object it receives. The RPC Manager will intercept this call and
increment the reference count on both the proxy and the object. It is
important to note that AddRef must be called from server2 because the proxy
lives in server2's address space.
<P>
The following sample code demonstrates how to do it. It is assumed that
CServer2Doc is an automation object. The CServerDoc2::SetReturnDispatch
method receives a LPDISPATCH object from server1 and will attach it to
CServer2Doc::m_DDServer1, which is a instance of an object derived from
COleDispatchDriver. Note that m_DDServer1 will be deleted when CServer2Doc
is deleted; Because AttachDispatch is called with the default second
parameter, this will cause the LPDISPATCH object Release to be called.
<P>
Refer to COleDispatchDriver::~COleDispatchDriver and
COleDispatchDriver::AttachDispatch for more information.
<P>
<P><h3>Sample Code</h3>
 
<P>
<PRE>void CServer2Doc::SetReturnDispatch(LPDISPATCH lpDispServer1)
</PRE>{
<PRE>  lpDispServer1-&gt;AddRef();         // AddRef so it can be used later
  m_DDServer1.AttachDispatch(lpDispServer1);
</PRE>}
<P>
<P><h2>REFERENCES</h2>
 

<UL><LI>Visual C++ Books Online Contents\OLE 2.0 SDK\Chapter 6 Component
   Object Interfaces and Functions \Iunknown Interface\Reference Counting
   Rules.

<LI>OLE 2 Programmers Reference Volume One, pages 191-195.

<LI>Inside OLE 2, pages 83-90.
</UL>\8 kbswept50 2/16/98 pjriker
 
<PRE>Keywords          : MfcOLE
Technology        : kbole kbMfc
Version           : Winnet:2.0,2.1,2.2,4.0,4.1,5.0
Platform          : NT WINDOWS
Issue type        : kbhowto</PRE>

	</FONT>
	</TD>
	</TR>
</TABLE>
<P>


<!--DOCBODY_END-->

<!--FOOTER_START-->
<table cellpadding=5 border=0 width="90%">
<tr>
<td>
	<HR WIDTH="90%">

<BLOCKQUOTE>
<FONT FACE="Verdana, Arial, Helvetica" SIZE="1">
<SPAN STYLE="font-family:verdana,arial,helvetica; font-size:8pt">
================================================================================<BR>

</SPAN>
</FONT>
<BR>
<BR>
THE INFORMATION PROVIDED IN THE MICROSOFT KNOWLEDGE BASE IS
PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND.  MICROSOFT DISCLAIMS
ALL WARRANTIES, EITHER EXPRESS OR IMPLIED, INCLUDING THE WARRANTIES
OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  IN NO
EVENT SHALL MICROSOFT CORPORATION OR ITS SUPPLIERS BE LIABLE FOR
ANY DAMAGES WHATSOEVER INCLUDING DIRECT, INDIRECT, INCIDENTAL,
CONSEQUENTIAL, LOSS OF BUSINESS PROFITS OR SPECIAL DAMAGES, EVEN IF
MICROSOFT CORPORATION OR ITS SUPPLIERS HAVE BEEN ADVISED OF THE
POSSIBILITY OF SUCH DAMAGES.  SOME STATES DO NOT ALLOW THE EXCLUSION
OR LIMITATION OF LIABILITY FOR CONSEQUENTIAL OR INCIDENTAL DAMAGES
SO THE FOREGOING LIMITATION MAY NOT APPLY.
</BLOCKQUOTE>
<P>
<center>
	<FONT FACE="Verdana,Arial,Helvetica" SIZE="1">
	Last reviewed:  February 17, 1998</FONT>
	<BR>
	<A href="../cpyright.htm" STYLE="font: bold 7pt Verdana,Arial,Helvetica">&copy; 1998 Microsoft Corporation. All rights reserved. Terms of Use.</A><BR>
	
</center>
</td>
</tr>
</table>

<!--FOOTER_END-->
</FONT>
</BODY>
</HTML>
