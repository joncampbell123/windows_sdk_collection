

<HTML>
<HEAD>
<TITLE>PRB: Brush Permanent Handle Map Doesn't Work on Windows 95 </TITLE>

<!--STYLE_BEGIN-->
<style>@import url(../../msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="../../msdn_ie3.css">
<!--STYLE_END-->

<META HTTP-EQUIV="CONTENT-Type" CONTENT="text/html; charset=us-ascii">
<META NAME="ms.locale" CONTENT="EN-US">
<META NAME="Category" CONTENT="Support; KB Article">
<META NAME="KBID" CONTENT="Q151865">
<META NAME="KBModify" CONTENT="1997/08/07">
<META NAME="KBCreate" CONTENT="1996/05/30">
<META NAME="Keywords" CONTENT="MfcUI kbprb kbprg">
<META NAME="KBArea" CONTENT="Support; KB; visualc">
<META NAME="Description" CONTENT="  Unexpected behavior might occur if an application relies on MFC's permanent brush handle map.  In MFC 2.0 (included with Visual C++, version 1.0), symptoms can include:     Assertion Failure, winhand.cpp - Line 129  In MFC 2.5 (included with Visual...">
<META NAME="Product" CONTENT="Visual C++">
<META NAME="Platform" CONTENT="Windows">
<META NAME="Technology" CONTENT=" ">
<META NAME="Premium" CONTENT="support">

<META NAME="nyms" CONTENT="QAUD,QDL9,QBWQ,QBWO,QBWN,QBWP,QAW6,QAPN,QBFY,QAHB,QAH4,QAEF,QA56,QA55,QAY5 V02180118">
</HEAD>

<BODY BGCOLOR="#FFFFFF" LEFTMARGIN="0" RIGHTMARGIN="0" TOPMARGIN="0">


<!--DOCBODY_START-->
<BR>
<CENTER>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" VALIGN="top" WIDTH="90%">
	<TR>
		<TD VALIGN="top">
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<H1>PRB: Brush Permanent Handle Map Doesn't Work on Windows 95</H1>
			</FONT>
			<FONT FACE="verdana,arial,helvetica" SIZE="1">
			Last reviewed:  August 7, 1997</FONT><BR>
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<B>Article ID: Q151865</B>
			</FONT>
		</TD>
	</TR>
	<TR>
	<TD>
	<FONT FACE="Verdana, Arial, Helvetica" SIZE=2>



 
1.00 1.50 1.51 1.52 1.52b | 2.00 2.10 2.20 4.00 4.10
<PRE>WINDOWS                   | WINDOWS NT
</PRE>kbprg kbprb
<P>
 
The information in this article applies to:

<UL><LI>Microsoft Visual C++ for Windows, versions 1.0, 1.5, 1.51, 1.52, 1.52b,
   1.52c
<LI>Microsoft Visual C++, 32-bit Edition, versions 2.0, 2.1, 2.2, 4.0, 4.1
</UL> 
<P>
<P><h2>SYMPTOMS</h2>
 
<P>
Unexpected behavior might occur if an application relies on MFC's permanent
brush handle map.
<P>
In MFC 2.0 (included with Visual C++, version 1.0), symptoms can include:
<P>
<PRE>   Assertion Failure, winhand.cpp - Line 129

</PRE>In MFC 2.5 (included with Visual C++, version 1.5), symptoms can include:
<P>
<PRE>   Assertion Failure, winhand.cpp - Line 169

</PRE><h2>CAUSE</h2>
 
<P>
Windows 95 has been optimized to prevent individual applications from
burdening the system resources. One of the optimizations is in the area of
brush handles. Windows 95 will not always return a unique handle when a new
brush object is created. Because MFC's permanent handle map mechanism
relies on a one-to-one mapping from HANDLE-&gt; C++ Object, this optimization
will prevent MFC's permanent brush handle map mechanism from working
properly. See the More Information section below for further details.
<P>
<P><h2>RESOLUTION</h2>
 
<P>
Do not rely on the brush permanent handle map when running on Windows 95.
You can still use the return value of any MFC function which might return a
temporary, but you should not rely on the function returning a specific
object that you expected to be in the permanent handle map.
<P>
For example, the code shown below could be re-written as:
<P>
<PRE>   CBrush *pBrush1 = new CBrush (RGB(255,0,0));
   CBrush *pBrush2 = new CBrush (RGB(255,0,0));

   CBrush *pOld = pDC-&gt;SelectObject(pBrush1);
   // Do some stuff in here

   // Don't rely on the return value from SelectObject being pBrush1
   pDC-&gt;SelectObject(pOld);

   // Instead, maintain the pointer to the object yourself
   delete pBrush1;

</PRE>The following functions might return an unexpected object:
<P>
<PRE>   SelectObject
   FromHandle
   FromHandlePermanent
   GetCurrentBrush
   GetHalftoneBrush
   SelectStockObject

</PRE>In MFC versions 2.0 and 2.50, the assertion failures can be ignored
although the behavior mentioned above could still cause problems. If you
cannot ignore the assertion failures if, for instance, they occur far too
often, then you can remove the assertions from the MFC source code and
rebuild the DEBUG version of the MFC libraries. For details on how to
accomplish this behavior, see the README.TXT file in the &lt;MSVC&gt;\MFC\SRC
directory.
<P>
<P><h2>STATUS</h2>
 
<P>
This behavior is by design.
<P>
<P><h2>MORE INFORMATION</h2>
 
<P>
On Windows NT or Windows 3.x, if a successful call is made to create a
brush object, then a unique handle will be returned. This isn't necessarily
true on Windows 95. Consider the following code:
<P>
<PRE>   HANDLE hBrush = ::CreateSolidBrush(RGB(255,0,0));
   HANDLE hBrush2 = ::CreateSolidBrush(RGB(255,0,0));

   // In this case, hBrush and hBrush2 will have different values on
   // Windows NT or Windows 3.x, so the following assert will succeed

   ASSERT(hBrush!=hBrush2);

</PRE>On Windows 95, the above assert will fail. Windows 95 is optimized to
detect when an application is creating a duplicate brush handle so it
doesn't need to create a brand new brush, just maintain internal
information about the brush and return the same handle.
<P>
This presents a problem for MFC's permanent handle map mechanism. The
handle map maintains an entry that maps each GDI handle to the unique
Visual C++ object (derived from CGdiObject) that encapsulates that handle.
This is a one-to-one mapping. If a new Visual C++ object is created that
encapsulates the same handle as the previous object, then the previous
object's entry in the permanent handle map will be replaced. This in itself
is not a problem, but if you rely on the handle map to return the original
Visual C++ object, then your code could run into serious problems. For
example:
<P>
<PRE>   CBrush *pBrush1 = new CBrush (RGB(255,0,0));
   CBrush *pBrush2 = new CBrush (RGB(255,0,0));

   CBrush *pOld = pDC-&gt;SelectObject(pBrush1);
   // Do some stuff in here
   delete pDC-&gt;SelectObject(pOld);
   ASSERT_VALID(pBrush2);
   // On Windows NT or Windows 3.x, the above call to "delete"
   // will delete pBrush1. On Windows 95, the above call to "delete"
   // will delete pBrush2 and the ASSERT_VALID will fail.
</PRE>

	</FONT>
	</TD>
	</TR>
</TABLE>
<P>


<!--DOCBODY_END-->

<!--FOOTER_START-->
<table cellpadding=5 border=0 width="90%">
<tr>
<td>
	<HR WIDTH="90%">

<BLOCKQUOTE>
<FONT FACE="Verdana, Arial, Helvetica" SIZE="1">
<SPAN STYLE="font-family:verdana,arial,helvetica; font-size:8pt">
Additional reference words: 1.00 1.50 1.51 1.52 2.00 2.10 2.20 4.00 4.10<BR>
KBCategory: kbprg kbprb<BR>
KBSubcategory: MfcUI<BR>
Keywords          : MfcUI kbprb kbprg<BR>
Version           : 1.00 1.50 1.51 1.52 1.52b | 2.00<BR>
Platform          : NT WINDOWS<BR>

</SPAN>
</FONT>
<BR>
<BR>
THE INFORMATION PROVIDED IN THE MICROSOFT KNOWLEDGE BASE IS
PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND.  MICROSOFT DISCLAIMS
ALL WARRANTIES, EITHER EXPRESS OR IMPLIED, INCLUDING THE WARRANTIES
OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  IN NO
EVENT SHALL MICROSOFT CORPORATION OR ITS SUPPLIERS BE LIABLE FOR
ANY DAMAGES WHATSOEVER INCLUDING DIRECT, INDIRECT, INCIDENTAL,
CONSEQUENTIAL, LOSS OF BUSINESS PROFITS OR SPECIAL DAMAGES, EVEN IF
MICROSOFT CORPORATION OR ITS SUPPLIERS HAVE BEEN ADVISED OF THE
POSSIBILITY OF SUCH DAMAGES.  SOME STATES DO NOT ALLOW THE EXCLUSION
OR LIMITATION OF LIABILITY FOR CONSEQUENTIAL OR INCIDENTAL DAMAGES
SO THE FOREGOING LIMITATION MAY NOT APPLY.
</BLOCKQUOTE>
<P>
<center>
	<FONT FACE="Verdana,Arial,Helvetica" SIZE="1">
	Last reviewed:  August 7, 1997</FONT>
	<BR>
	<A href="../cpyright.htm" STYLE="font: bold 7pt Verdana,Arial,Helvetica">&copy; 1998 Microsoft Corporation. All rights reserved. Terms of Use.</A><BR>
	
</center>
</td>
</tr>
</table>

<!--FOOTER_END-->
</FONT>
</BODY>
</HTML>
