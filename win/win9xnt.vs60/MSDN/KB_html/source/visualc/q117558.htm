

<HTML>
<HEAD>
<TITLE>Tutorial: Debugging OLE Client-Server Combinations </TITLE>

<!--STYLE_BEGIN-->
<style>@import url(../../msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="../../msdn_ie3.css">
<!--STYLE_END-->

<META HTTP-EQUIV="CONTENT-Type" CONTENT="text/html; charset=us-ascii">
<META NAME="ms.locale" CONTENT="EN-US">
<META NAME="Category" CONTENT="Support; KB Article">
<META NAME="KBID" CONTENT="Q117558">
<META NAME="KBModify" CONTENT="1997/07/22">
<META NAME="KBCreate" CONTENT="1994/06/30">
<META NAME="Keywords" CONTENT="kb16bitonly">
<META NAME="KBArea" CONTENT="Support; KB; visualc">
<META NAME="Description" CONTENT="  When building object linking and embedding (OLE) servers, you may want to debug them in the context of being activated by an OLE container or to debug both the container and the server at the same time. The  Tutorial  in the  MORE INFORMATION  sect...">
<META NAME="Product" CONTENT="Visual C++">
<META NAME="Platform" CONTENT="Windows">
<META NAME="Technology" CONTENT=" ">
<META NAME="Premium" CONTENT="support">

<META NAME="nyms" CONTENT="QA9Q,QBXS,QAVX,QAW6,QAH4,QBWS,QAGI,QAY2,QBJZ,QBWP,QDL9,QBWQ,QBWO,QBWN,QA56 V02180118">
</HEAD>

<BODY BGCOLOR="#FFFFFF" LEFTMARGIN="0" RIGHTMARGIN="0" TOPMARGIN="0">


<!--DOCBODY_START-->
<BR>
<CENTER>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" VALIGN="top" WIDTH="90%">
	<TR>
		<TD VALIGN="top">
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<H1>Tutorial: Debugging OLE Client-Server Combinations</H1>
			</FONT>
			<FONT FACE="verdana,arial,helvetica" SIZE="1">
			Last reviewed:  July 22, 1997</FONT><BR>
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<B>Article ID: Q117558</B>
			</FONT>
		</TD>
	</TR>
	<TR>
	<TD>
	<FONT FACE="Verdana, Arial, Helvetica" SIZE=2>



 
1.50
WINDOWS
kbtool
<P>
 
The information in this article applies to:

<UL><LI>The Visual Workbench Integrated Debugger included with:
   Microsoft Visual C++ for Windows, version 1.5
</UL> 
<P>
<P><h2>SUMMARY</h2>
 
<P>
When building object linking and embedding (OLE) servers, you may want to
debug them in the context of being activated by an OLE container or to
debug both the container and the server at the same time. The "Tutorial" in
the "MORE INFORMATION" section, below, shows you how to debug and set
breakpoints in an OLE server when the main debuggee is an OLE container.
<P>
Because Windows NT does not allow hard-mode debugging, and because you
cannot run CodeView under Windows NT, you cannot perform simultaneous OLE
client-server debugging using Visual C++, version 1.5, on Windows NT.
However, you can still debug clients and servers under Windows NT as single
applications on a standalone basis using the integrated debugger.
<P>
<P><h2>MORE INFORMATION</h2>
 
<P>
This tutorial guides you through a simple debugging session using the
samples that come with Visual C++:
<P>
<P><h3>Tutorial</h3>
 

<OL><P><LI>Build debug versions of the Microsoft Foundation Classes (MFC) samples
   in the following directories:
<P>
<P><PRE>    - \MSVC\MFC\SAMPLES\CONTAIN\STEP2
</PRE><P>
<P><PRE>    - \MSVC\MFC\SAMPLES\SCRIBBLE\STEP7
</PRE>
<P><LI>Run the SCRIBBLE.EXE file, built in step 1, to update the Windows
   registry to point to this executable file.

<P><LI>From File Manager, choose Run from the File menu and type REGEDIT in the
   Command Line field. When REGEDIT comes up, double-click the SCRIB File
   Type entry to verify that the path points to the debug version of
   SCRIBBLE.EXE you just built. If not, modify the path accordingly.

<P><LI>Load the OLE container project into the Visual C++ Workbench. If you are
   debugging an SDI server application, you should set the Program
   Arguments line of the Debug Options dialog box to "/Embedding" or
   "/Automation" so that the debugger can launch the server application as
   though it were launched from a container. Starting the container from
   Program Manager or File Manager now causes the container to use the
   instance of the server started in the debugger.

<P><LI>Choose Debug from the Options menu and enter the full path to the debug
   version of the OLE server in the Additional DLLs field (be sure to
   include the .EXE extension). This tells the debugger to load the
   symbolic debug information for the server.
<P>
   NOTE: This path must exactly match the path to the server entered in the
   Windows system registry. If it does not, attempts to debug the OLE
   server will fail. You can check or modify the path in the registry by
   using the REGEDIT tool provided with Windows.

<P><LI>While in the Visual C++ Debug dialog box, also choose the hard-mode
   button. This is just as important as the path-matching requirement
   mentioned earlier. If you try to debug in soft mode, the OLE lightweight
   remote procedure call (LRPC) mechanism will most likely cause unexpected
   behavior. For example, if you have breakpoints set in the server’s
   initialization code, when the first breakpoint is hit the server will
   stop in the debugger before it is completely "created". The container’s
   call to OleCreate() will continue to run, eventually timing out and
   returning FALSE because the item was not properly created. You will then
   get a Message Box stating "Failed to create object. Make sure the object
   is entered in the system registry." Once you have received this message,
   a copy of the server is left stranded in memory, and subsequent attempts
   to debug it will fail (i.e. breakpoints will be missed). Restarting
   Windows will remove the server from memory and allow you to start a
   fresh debug session.

<P><LI>Open CONTAIN\STEP2’s CONTRVW.CPP file and set a breakpoint on line 168.

<P><LI>Open SCRIBBLE\STEP7’s SCRIBBLE.CPP file and set a breakpoint on line 68.

<P><LI>Press F5 to start the CONTAIN.EXE file. In the CONTAIN main menu, choose
   Insert New Object from the Edit menu.
<P>
</OL>10.From the resulting Object Type list, choose SCRIB File Type and choose
<PRE>   the "OK" button. At this point, the debugger should have stopped at your
   breakpoint in the SCRIBBLE.CPP file. You can now debug the SCRIBBLE
   server.

   NOTE: We could have set the breakpoint anywhere, including within the
   SCRIBBLE class constructors.

</PRE></OL>11.Press F5 again. The SCRIBBLE server continues its initialization, and
<PRE>   then control returns to CONTAIN.EXE. The debugger should stop at the
   breakpoint in the CONTRVW.CPP file.

</PRE>12.Step through CONTRVW’s code, using F8 to see the embedded SCRIBBLE
<PRE>   object become active.

</PRE>13.Press F5 to continue running the SCRIBBLE.EXE file, activated in place
<PRE>   within the CONTAIN.EXE file. If you do not readily see CONTAIN.EXE on
   your screen, you may need to switch focus to CONTAIN.EXE manually. You
   can also arrange Visual C++ and CONTAIN.EXE so that their windows do not
   overlap.

</PRE>14.Close the CONTAIN.EXE file.
<P>
When debugging OLE clients and servers simultaneously, remember that if
both the client and the server(s) were statically linked using the MFC
libraries, there will be at least two copies of MFC code in memory (perhaps
more if you have nested embedded objects supplied by different servers).
Therefore, if you set a breakpoint in MFC library code through its sources
in \MSVC\MFC\SRC, you may get unexpected behavior. For example, if you set
a breakpoint within AfxOleInit() in file \MSVC\MFC\SRC\OLEINIT.CPP, the
debugger may not be able to tell whether you want to break at the
breakpoint under the following conditions:

<UL><LI>When the container’s InitInstance calls AfxOleInit()
<P>
   -or-

<LI>When the server’s InitInstance calls AfxOleInit()
<P>
   -or-

<LI>When the container's and server's InitInstances both call AfxOleInit()
<P>
</UL>Therefore, the breakpoint may not occur in the place that you want.
<P>
To tell the debugger where you want it to break, you must use the context
operator to specify in which module the breakpoint should be set. For the
AfxOleInit example just mentioned, you could use the following expression
to set the breakpoint in the server:
<P>
<PRE>   {,oleinit.cpp,server.exe} AfxOleInit

</PRE>This expression names the source file and module (in memory) where the
debugger inserts the int 3 that sets the breakpoint. If the Integrated
Development Environment (IDE) debugger is used, you need to type this
expression into the Location field in the dialog box you get from choosing
Breakpoints from the Debug menu. (The above breakpoint has AfxOleInit as
the location, which causes a break on the opening brace of AfxOleInit. A
line number can just as well be used in this case.) If Codeview is used,
type the expression into the Location field in the dialog box you get from
choosing Breakpoints from the Data menu.
<P>
15.Set a breakpoint at AfxOleInit in the SCRIBBLE server as described
above.
<P>
16.Restart the CONTAIN.EXE file and observe that this breakpoint is only
hit when the SCRIBBLE.EXE file calls AfxOleInit, not when CONTAIN.EXE calls
AfxOleInit.
<P>
As an alternative, CodeView for Windows allows you to differentiate between
multiple module copies by choosing Open Module from the File menu. Use this
command to select in which module you want to set the breakpoint (CodeView
lists all copies of each of the MFC modules in memory).
<P>
The Visual C++ IDE debugger is somewhat limited in its ability to handle
complex debugging sessions, such as containers calling multiple servers. If
you find you are experiencing problems, try using CodeView instead.
<P>
If you want to use CodeView for Windows as the debugger, load debugging
information for your servers and/or DLLs by running the following command
(without quotes) from the Program Manager or by choosing Run from the File
Manager File menu:
<P>
<PRE>   "CVW &lt;options, if any&gt; [/Loleserver.exe] oleclient.exe"

</PRE>The square brackets indicate that the enclosed parameter can be specified 0
or more times, allowing you to load (/L) symbolic information for several
servers or DLLs (or both). Unless the OLE client, server(s), and DLLs
reside in the current directory (or in the directories listed in the PATH
environment or in the Windows directories), the full path to these files is
needed on the command line above this command.
<P>
<P><h2>REFERENCES</h2>
 
<P>
For more information, please read the "Debugging OLE Applications" section
(pages 136 to 141) in the "Visual C++, version 1.5, OLE 2.0 Classes"
manual.
<P>
For more detailed information on the syntax and use of the context
operator, please refer to chapter 4 of the "Codeview Debugger User's
Guide".
<P>
In addition, Visual C++, version 1.5, supplies a variety of utilities in
the OLE 2.01 Toolkit. These are designed to help you test and debug your
OLE applications. For more information on these tools, please refer to the
"Tools" section of the OLE 2.01 Toolkit Release Notes (open the icon in the
Toolkit program group).
<P>

	</FONT>
	</TD>
	</TR>
</TABLE>
<P>


<!--DOCBODY_END-->

<!--FOOTER_START-->
<table cellpadding=5 border=0 width="90%">
<tr>
<td>
	<HR WIDTH="90%">

<BLOCKQUOTE>
<FONT FACE="Verdana, Arial, Helvetica" SIZE="1">
<SPAN STYLE="font-family:verdana,arial,helvetica; font-size:8pt">
Additional reference words: kbinf 1.50<BR>
KBCategory: kbtool<BR>
KBSubcategory: WBDebug<BR>
Keywords            : kb16bitonly<BR>
Technology          : kbMfc<BR>

</SPAN>
</FONT>
<BR>
<BR>
THE INFORMATION PROVIDED IN THE MICROSOFT KNOWLEDGE BASE IS
PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND.  MICROSOFT DISCLAIMS
ALL WARRANTIES, EITHER EXPRESS OR IMPLIED, INCLUDING THE WARRANTIES
OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  IN NO
EVENT SHALL MICROSOFT CORPORATION OR ITS SUPPLIERS BE LIABLE FOR
ANY DAMAGES WHATSOEVER INCLUDING DIRECT, INDIRECT, INCIDENTAL,
CONSEQUENTIAL, LOSS OF BUSINESS PROFITS OR SPECIAL DAMAGES, EVEN IF
MICROSOFT CORPORATION OR ITS SUPPLIERS HAVE BEEN ADVISED OF THE
POSSIBILITY OF SUCH DAMAGES.  SOME STATES DO NOT ALLOW THE EXCLUSION
OR LIMITATION OF LIABILITY FOR CONSEQUENTIAL OR INCIDENTAL DAMAGES
SO THE FOREGOING LIMITATION MAY NOT APPLY.
</BLOCKQUOTE>
<P>
<center>
	<FONT FACE="Verdana,Arial,Helvetica" SIZE="1">
	Last reviewed:  July 22, 1997</FONT>
	<BR>
	<A href="../cpyright.htm" STYLE="font: bold 7pt Verdana,Arial,Helvetica">&copy; 1998 Microsoft Corporation. All rights reserved. Terms of Use.</A><BR>
	
</center>
</td>
</tr>
</table>

<!--FOOTER_END-->
</FONT>
</BODY>
</HTML>
