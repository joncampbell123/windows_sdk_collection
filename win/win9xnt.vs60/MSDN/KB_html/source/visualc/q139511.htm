

<HTML>
<HEAD>
<TITLE>FIX: Text Data Truncated When Using optimizeBulkAdd </TITLE>

<!--STYLE_BEGIN-->
<style>@import url(../../msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="../../msdn_ie3.css">
<!--STYLE_END-->

<META HTTP-EQUIV="CONTENT-Type" CONTENT="text/html; charset=us-ascii">
<META NAME="ms.locale" CONTENT="EN-US">
<META NAME="Category" CONTENT="Support; KB Article">
<META NAME="KBID" CONTENT="Q139511">
<META NAME="KBModify" CONTENT="1997/09/18">
<META NAME="KBCreate" CONTENT="1995/11/12">
<META NAME="Keywords" CONTENT="MfcDatabase kbbuglist kbfixlist kbprg">
<META NAME="KBArea" CONTENT="Support; KB; visualc">
<META NAME="Description" CONTENT="  When you try to use the optimizeBulkAdd flag with a CRecordset object, text fields may be truncated. For example, if the first insertion in the table inserts a text value in field1 that is four characters long and a second insertion inserts a text ...">
<META NAME="Product" CONTENT="Visual C++">
<META NAME="Platform" CONTENT="Windows">
<META NAME="Technology" CONTENT=" ">
<META NAME="Premium" CONTENT="support">

<META NAME="nyms" CONTENT="QA5V,QAKD,QATX,QAMB,QACI,QA4Q,QAGI,QAUD,QA26,QAR4,QAHE,QA9N,QAY5,QA9E,QA6E V02180118">
</HEAD>

<BODY BGCOLOR="#FFFFFF" LEFTMARGIN="0" RIGHTMARGIN="0" TOPMARGIN="0">


<!--DOCBODY_START-->
<BR>
<CENTER>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" VALIGN="top" WIDTH="90%">
	<TR>
		<TD VALIGN="top">
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<H1>FIX: Text Data Truncated When Using optimizeBulkAdd</H1>
			</FONT>
			<FONT FACE="verdana,arial,helvetica" SIZE="1">
			Last reviewed:  September 18, 1997</FONT><BR>
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<B>Article ID: Q139511</B>
			</FONT>
		</TD>
	</TR>
	<TR>
	<TD>
	<FONT FACE="Verdana, Arial, Helvetica" SIZE=2>



 
1.52a 1.52b
WINDOWS
kbprg kbbuglist kbfixlist
<P>
 
The information in this article applies to:

<UL><LI>The Microsoft Foundation Classes (MFC) included with:
   Microsoft Visual C++ for Windows, versions 1.52a and 1.52b
</UL> 
<P>
<P><h2>SYMPTOMS</h2>
 
<P>
When you try to use the optimizeBulkAdd flag with a CRecordset object, text
fields may be truncated. For example, if the first insertion in the table
inserts a text value in field1 that is four characters long and a second
insertion inserts a text value in field1 that is five characters, the text
in the second insertion will be truncated to four characters, the length of
the text from the first insertion.
<P>
<P><h2>CAUSE</h2>
 
<P>
MFC is incorrectly binding the length of the parameters it uses in the
INSERT INTO statement it constructs for adding a record.
<P>
<P><h2>RESOLUTION</h2>
 
<P>
Use either of these two workarounds:

<UL><LI>As the first record you add, insert a dummy record that contains strings
   with the maximum length you want for the text fields in the recordset.
   Every record after this first insertion will always have text values
   with lengths that are less than or equal to the length of the text
   fields in the dummy record. When you have finished inserting records,
   delete the dummy record.
<P>
   -or-

<LI>Replace the RFX_Text() function calls in your CRecordset's
   DoFieldExchange() with the following RFX_Text2() function, which
   performs the correct binding for the parameters used in the INSERT INTO
   statement used internally by MFC to add a record. In your recordset's
   header file add:
<P>
<PRE>   void RFX_Text2(CFieldExchange* pFX, const char* szName,
                  CString&amp; value, int nMaxLength=255,
                  int nColumnType=SQL_VARCHAR);

   In your recordset's .cpp file add:

   void RFX_Text2(CFieldExchange* pFX, const char* szName,
     CString&amp; value, int nMaxLength /*=255*/ , int nColumnType
                                             /* =SQL_VARCHAR */)
   {
     if (pFX-&gt;m_nOperation != CFieldExchange::NameValue &amp;&amp;
         pFX-&gt;m_nOperation != CFieldExchange::Value &amp;&amp;
         pFX-&gt;m_nOperation != CFieldExchange::BindParam)
     {
        RFX_Text(pFX, szName, value, nMaxLength, nColumnType);
        return;
     }

     ASSERT(AfxIsValidAddress(pFX, sizeof(CFieldExchange)));
     ASSERT(AfxIsValidString(szName));
     ASSERT(AfxIsValidAddress(&amp;value, sizeof(CString)));

     RETCODE nRetCode;
     UINT nField;
     if (!pFX-&gt;IsFieldType(&amp;nField))
        return;

     LONG* plLength = pFX-&gt;m_prs-&gt;GetFieldLength(pFX);
     switch (pFX-&gt;m_nOperation)
     {
       case CFieldExchange::NameValue:
        if (pFX-&gt;m_prs-&gt;IsFieldFlagDirty(nField,pFX-&gt;m_nFieldType))
         {
           *pFX-&gt;m_pstr += pFX-&gt;m_prs-&gt;m_pDatabase-&gt;QuoteName(szName);
           *pFX-&gt;m_pstr += "=";
         }
           // Fall through

       case CFieldExchange::Value:
         if (pFX-&gt;m_prs-&gt;IsFieldFlagDirty(nField, pFX-&gt;m_nFieldType))
         {

            // If user marked column NULL, reflect this in length
          if (pFX-&gt;m_prs-&gt;IsFieldFlagNull(nField, pFX-&gt;m_nFieldType))
             *plLength = SQL_NULL_DATA;
          else
             *plLength = SQL_NTS;

            // If optimizing for bulk add, just set length.
        if (!(pFX-&gt;m_prs-&gt;m_dwOptions &amp; CRecordset::optimizeBulkAdd))
            {
              *pFX-&gt;m_pstr += "?";
              *pFX-&gt;m_pstr += pFX-&gt;m_lpszSeparator;
              pFX-&gt;m_nParamFields++;

              AFX_SQL_SYNC(::SQLSetParam(pFX-&gt;m_hstmt,
                (unsigned short int)pFX-&gt;m_nParamFields,
                SQL_C_CHAR,
                (short int)nColumnType,
                nMaxLength,
                0,
                value.GetBuffer(0),
                plLength));
              value.ReleaseBuffer();

              if (nRetCode != SQL_SUCCESS)
                pFX-&gt;m_prs-&gt;ThrowDBException(nRetCode, pFX-&gt;m_hstmt);
             }
           }
           return;

         case CFieldExchange::BindParam:
           *plLength = SQL_NTS;
           // Preallocate to nMaxLength
           value.GetBufferSetLength(nMaxLength);
           AFX_SQL_SYNC(::SQLSetParam(pFX-&gt;m_hstmt,
            (unsigned short int)nField,
            (short int)SQL_C_CHAR,
            (short int)nColumnType,
            nMaxLength,
            0,
            value.GetBuffer(0),
            plLength));
            value.ReleaseBuffer();

            if (nRetCode != SQL_SUCCESS)
              pFX-&gt;m_prs-&gt;ThrowDBException(nRetCode, pFX-&gt;m_hstmt);
            return;
     }
   }

</PRE></UL><h2>STATUS</h2>
 
<P>
Microsoft has confirmed this to be a bug in the Microsoft products listed
at the beginning of this article. The code has been corrected in Visual C++
version 2.2 and later.
<P>
<P><h2>MORE INFORMATION</h2>
 
<P>
<P><h3>Sample Code to Reproduce Problem</h3>
 
<P>
CMyRecordSet rs;
rs.Open(CRecordset::snapshot, NULL, CRecordset::optimizeBulkAdd);
rs.AddNew();
rs.m_field1="1234";
rs.Update();
rs.AddNew();
rs.m_field1="12345";
rs.Update();
rs.Close();
<P>
The table will look like this:
<P>
<PRE>   field1
   ------
   1234
   1234

</PRE>instead of this:
<P>
<PRE>   field1
   ------
   1234
   12345

</PRE><h2>REFERENCES</h2>
 
<P>
See the following references for more information about the problem and
workaround:

<UL><LI>SQLSetParam() documentation in the ODBC 1.0 Programmer's Reference or
   SQLBindParameter() in the ODBC 2.0 Programmer's Reference.

<LI>For more information about bulk add optimizations in MFC, please see the
   following article in the Microsoft Knowledge Base:
<P>
   ARTICLE-ID: <B><A href="../visualc/q126131.htm">Q126131</A></B>
<PRE>   TITLE     : How to Speed Up Apps that Use Microsoft Access 2.0 ODBC
               Driver

</PRE></UL>Following is the information from the Msetup.hlp file on the Visual C++
compact disc that talks about the optimizeBulkAdd feature:
<P>
<PRE>   The MFC CRecordset class has a new optimization (in both 16- and
   32-bit versions) that improves efficiency when you're adding new
   records in bulk to a table. A new option for the dwOptions parameter
   to the CRecordset::Open member function, optimizeBulkAdd, improves
   performance when you're adding multiple records consecutively
   without calling Requery or Close. Only those fields that are "dirty"
   prior to the first Update call are marked as "dirty" for subsequent
   AddNew/Update calls. If you are using the database classes to take
   advantage of the ::SQLSetPos API function for adding, editing, and
   deleting records, this optimization is unnecessary. If the ODBC Cursor
   Library is loaded or the ODBC driver doesn't support adding, editing,
   and deleting via ::SQLSetPos, this optimization should improve bulk
   add performance. To turn on this optimization, set the dwOptions
   parameter in the Open call for your recordset to:

       appendOnly | optimizeBulkAdd
</PRE>

	</FONT>
	</TD>
	</TR>
</TABLE>
<P>


<!--DOCBODY_END-->

<!--FOOTER_START-->
<table cellpadding=5 border=0 width="90%">
<tr>
<td>
	<HR WIDTH="90%">

<BLOCKQUOTE>
<FONT FACE="Verdana, Arial, Helvetica" SIZE="1">
<SPAN STYLE="font-family:verdana,arial,helvetica; font-size:8pt">
Additional reference words: 1.5 1.50 1.52<BR>
KBCategory: kbprg kbbuglist kbfixlist<BR>
KBSubcategory: MfcDatabase
<P>

Keywords          : MfcDatabase kbbuglist kbfixlist kbprg<BR>
Technology        : kbMfc<BR>
Version           : 1.52a 1.52b<BR>
Platform          : WINDOWS<BR>
Solution Type     : kbfix<BR>

</SPAN>
</FONT>
<BR>
<BR>
THE INFORMATION PROVIDED IN THE MICROSOFT KNOWLEDGE BASE IS
PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND.  MICROSOFT DISCLAIMS
ALL WARRANTIES, EITHER EXPRESS OR IMPLIED, INCLUDING THE WARRANTIES
OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  IN NO
EVENT SHALL MICROSOFT CORPORATION OR ITS SUPPLIERS BE LIABLE FOR
ANY DAMAGES WHATSOEVER INCLUDING DIRECT, INDIRECT, INCIDENTAL,
CONSEQUENTIAL, LOSS OF BUSINESS PROFITS OR SPECIAL DAMAGES, EVEN IF
MICROSOFT CORPORATION OR ITS SUPPLIERS HAVE BEEN ADVISED OF THE
POSSIBILITY OF SUCH DAMAGES.  SOME STATES DO NOT ALLOW THE EXCLUSION
OR LIMITATION OF LIABILITY FOR CONSEQUENTIAL OR INCIDENTAL DAMAGES
SO THE FOREGOING LIMITATION MAY NOT APPLY.
</BLOCKQUOTE>
<P>
<center>
	<FONT FACE="Verdana,Arial,Helvetica" SIZE="1">
	Last reviewed:  September 18, 1997</FONT>
	<BR>
	<A href="../cpyright.htm" STYLE="font: bold 7pt Verdana,Arial,Helvetica">&copy; 1998 Microsoft Corporation. All rights reserved. Terms of Use.</A><BR>
	
</center>
</td>
</tr>
</table>

<!--FOOTER_END-->
</FONT>
</BODY>
</HTML>
