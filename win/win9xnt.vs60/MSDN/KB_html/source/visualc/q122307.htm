

<HTML>
<HEAD>
<TITLE>Tracking Down Memory Leaks with _afxBreakAlloc </TITLE>

<!--STYLE_BEGIN-->
<style>@import url(../../msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="../../msdn_ie3.css">
<!--STYLE_END-->

<META HTTP-EQUIV="CONTENT-Type" CONTENT="text/html; charset=us-ascii">
<META NAME="ms.locale" CONTENT="EN-US">
<META NAME="Category" CONTENT="Support; KB Article">
<META NAME="KBID" CONTENT="Q122307">
<META NAME="KBModify" CONTENT="1997/07/31">
<META NAME="KBCreate" CONTENT="1994/11/01">
<META NAME="Keywords" CONTENT="CvwIss MfcMisc VwbIss WBDebug kbprg kbtshoot">
<META NAME="KBArea" CONTENT="Support; KB; visualc">
<META NAME="Description" CONTENT="  There is currently no documentation for the _afxBreakAlloc symbol defined by MFC. However it can be extremely useful in finding the cause of memory leaks in an application. This article explains how to use it.  Note: In Visual C++ 32-bit Edition, v...">
<META NAME="Product" CONTENT="Visual C++">
<META NAME="Platform" CONTENT="Windows">
<META NAME="Technology" CONTENT=" ">
<META NAME="Premium" CONTENT="support">

<META NAME="nyms" CONTENT="QAH4,QAPN,QAW6,QAKC,QBC6,QBW6,QBFY,QA56,QA55,QAG8,QBC9,QBC8,QAYL,QATL,QATK V02180118">
</HEAD>

<BODY BGCOLOR="#FFFFFF" LEFTMARGIN="0" RIGHTMARGIN="0" TOPMARGIN="0">


<!--DOCBODY_START-->
<BR>
<CENTER>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" VALIGN="top" WIDTH="90%">
	<TR>
		<TD VALIGN="top">
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<H1>Tracking Down Memory Leaks with _afxBreakAlloc</H1>
			</FONT>
			<FONT FACE="verdana,arial,helvetica" SIZE="1">
			Last reviewed:  July 31, 1997</FONT><BR>
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<B>Article ID: Q122307</B>
			</FONT>
		</TD>
	</TR>
	<TR>
	<TD>
	<FONT FACE="Verdana, Arial, Helvetica" SIZE=2>



 
1.00 1.50 | 1.00 2.00
<PRE>WINDOWS   | WINDOWS NT
</PRE>kbprg kbtshoot
<P>
 
The information in this article applies to:

<UL><LI>The Microsoft Foundation Classes (MFC), included with:
<P>
<P><PRE>    - Microsoft Visual C++ for Windows, versions 1.0 and 1.5
    - Microsoft Visual C++, 32-bit Edition, versions 1.0 and 2.0
      on the following platform: x86
</UL></PRE> 
<P>
<P><h2>SUMMARY</h2>
 
<P>
There is currently no documentation for the _afxBreakAlloc symbol defined
by MFC. However it can be extremely useful in finding the cause of memory
leaks in an application. This article explains how to use it.
<P>
Note: In Visual C++ 32-bit Edition, version 4.0, the method described
below is obsolete. For information on diagnosing memory leaks in this
version of Visual C++, refer to the Visual C++ 4.0 Books Online topic
"Diagnostics: Detecting Memory Leaks" in the "Programming with MFC:
Encyclopedia."
<P>
<P><h2>MORE INFORMATION</h2>
 
<P>
The Microsoft Foundation Classes have memory leak detection capabilities.
When you execute a debug build of your application and you have used the
AFX Trace Options Tool to Enable Tracing, MFC will report memory leaks when
an object has been allocated (using operator new) but not deleted before
the application exits. The default output in the debug window will look
similar to this:
<P>
<PRE>   MDI16: Detected memory leaks!
   MDI16: Dumping objects -&gt;
   MDI16: {6} str.cpp(82):non-object block at $24D76B72,5 bytes long
   MDI16: {5} non-object block at $24D76B4E, 6 bytes long
   MDI16: Object dump complete.

</PRE>The number found in the braces ({n}) indicates the allocation number that
has occured. In the first object dump, it is obvious where the allocation
occured. But the second object dump does not give the file and line number
information, so it might be more difficult to track down the leak. However,
MFC has the capability of breaking on a particular allocation number by
using the _afxBreakAlloc symbol.
<P>
The _afxBreakAlloc variable is not available programmatically because it is
defined as a static variable in the MFC source code module AFXMEM.CPP.
However it can be set/modified using the debugger. We can find the point in
our code in which memory allocation number 5 occured by setting
_afxBreakAlloc equal to 5 before we get to that point in the code. To do
so, follow these steps:

<OL><P><LI>Open the file AFXMEM.CPP (by default it is located in the directory
   \MSVC20\MFC\SRC\). Find the function AfxAllocMemoryDebug (in VC 1.x
   the function is named just AllocMemoryDebug). Set a breakpoint on the
   first line of this function (the opening { ).

<P><LI>Run the program until it breaks at this new breakpoint.
   Remove the breakpoint.

<P><LI>Open the Watch Window by selecting Window.Watch.

<P><LI>Type in _afxBreakAlloc and press enter. The watch window should now
   display:
<P>
<P><PRE>      _afxBreakAlloc = -1
</PRE>
<P><LI>Change the -1 to the number of the object leak indicated in the curly
   braces of the object dump. In this example, change the -1 to a 5.

<P><LI>Continue executing the program by pressing the F5 key.
<P>
</OL>When the allocation of the object occurs, your program will break in the
debugger. You can identify which line of code caused the allocation by
looking at the Call Stack (select Debug.Show Call Stack).
<P>

	</FONT>
	</TD>
	</TR>
</TABLE>
<P>


<!--DOCBODY_END-->

<!--FOOTER_START-->
<table cellpadding=5 border=0 width="90%">
<tr>
<td>
	<HR WIDTH="90%">

<BLOCKQUOTE>
<FONT FACE="Verdana, Arial, Helvetica" SIZE="1">
<SPAN STYLE="font-family:verdana,arial,helvetica; font-size:8pt">
Additional reference words: kbinf 1.00 1.50 2.00 2.10 2.50 3.00<BR>
KBCategory: kbprg kbtshoot<BR>
KBSubcategory: MfcMisc VWBIss CvwIss WBDebug<BR>
Keywords          : CvwIss MfcMisc VwbIss WBDebug kbprg kbtshoot<BR>
Technology        : kbMfc<BR>
Version           : 1.00 1.50 | 1.00 2.00<BR>
Platform          : NT WINDOWS<BR>

</SPAN>
</FONT>
<BR>
<BR>
THE INFORMATION PROVIDED IN THE MICROSOFT KNOWLEDGE BASE IS
PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND.  MICROSOFT DISCLAIMS
ALL WARRANTIES, EITHER EXPRESS OR IMPLIED, INCLUDING THE WARRANTIES
OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  IN NO
EVENT SHALL MICROSOFT CORPORATION OR ITS SUPPLIERS BE LIABLE FOR
ANY DAMAGES WHATSOEVER INCLUDING DIRECT, INDIRECT, INCIDENTAL,
CONSEQUENTIAL, LOSS OF BUSINESS PROFITS OR SPECIAL DAMAGES, EVEN IF
MICROSOFT CORPORATION OR ITS SUPPLIERS HAVE BEEN ADVISED OF THE
POSSIBILITY OF SUCH DAMAGES.  SOME STATES DO NOT ALLOW THE EXCLUSION
OR LIMITATION OF LIABILITY FOR CONSEQUENTIAL OR INCIDENTAL DAMAGES
SO THE FOREGOING LIMITATION MAY NOT APPLY.
</BLOCKQUOTE>
<P>
<center>
	<FONT FACE="Verdana,Arial,Helvetica" SIZE="1">
	Last reviewed:  July 31, 1997</FONT>
	<BR>
	<A href="../cpyright.htm" STYLE="font: bold 7pt Verdana,Arial,Helvetica">&copy; 1998 Microsoft Corporation. All rights reserved. Terms of Use.</A><BR>
	
</center>
</td>
</tr>
</table>

<!--FOOTER_END-->
</FONT>
</BODY>
</HTML>
