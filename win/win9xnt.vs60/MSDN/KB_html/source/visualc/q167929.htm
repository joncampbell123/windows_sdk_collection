

<HTML>
<HEAD>
<TITLE>PRB: Memory Leaks Reported When Using Multiple MFC DLLs </TITLE>

<!--STYLE_BEGIN-->
<style>@import url(../../msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="../../msdn_ie3.css">
<!--STYLE_END-->

<META HTTP-EQUIV="CONTENT-Type" CONTENT="text/html; charset=us-ascii">
<META NAME="ms.locale" CONTENT="EN-US">
<META NAME="Category" CONTENT="Support; KB Article">
<META NAME="KBID" CONTENT="Q167929">
<META NAME="KBModify" CONTENT="1997/08/07">
<META NAME="KBCreate" CONTENT="1997/05/02">
<META NAME="Keywords" CONTENT="MfcDLL">
<META NAME="KBArea" CONTENT="Support; KB; visualc">
<META NAME="Description" CONTENT="  When you debug a project that contains MFC regular (USRDLL) DLLs or ActiveX Controls (OCX), you may see memory leaks similar to the following reported in the debugger:     a CDynLinkLibrary object at $00410F70, 64 bytes long    a CDynLinkLibrary ob...">
<META NAME="Product" CONTENT="Visual C++">
<META NAME="Platform" CONTENT="Windows">
<META NAME="Technology" CONTENT=" ">
<META NAME="Premium" CONTENT="support">

<META NAME="nyms" CONTENT="QAGI,QAJQ,QAPN,QALG,QBW6,QDNN,QAIF,QAW6,QAHV,QAY2,QATZ,QATY,QBSO,QBFY,QAO4 V02180118">
</HEAD>

<BODY BGCOLOR="#FFFFFF" LEFTMARGIN="0" RIGHTMARGIN="0" TOPMARGIN="0">


<!--DOCBODY_START-->
<BR>
<CENTER>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" VALIGN="top" WIDTH="90%">
	<TR>
		<TD VALIGN="top">
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<H1>PRB: Memory Leaks Reported When Using Multiple MFC DLLs</H1>
			</FONT>
			<FONT FACE="verdana,arial,helvetica" SIZE="1">
			Last reviewed:  August 7, 1997</FONT><BR>
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<B>Article ID: Q167929</B>
			</FONT>
		</TD>
	</TR>
	<TR>
	<TD>
	<FONT FACE="Verdana, Arial, Helvetica" SIZE=2>



 
 
The information in this article applies to:

<UL><LI>The Microsoft Foundation Classes (MFC) included with:
   - Microsoft Visual C++, 32-bit Editions, versions 4.0, 4.1, 4.2, 5.0
</UL> 
<P>
<P><h2>SYMPTOMS</h2>
 
<P>
When you debug a project that contains MFC regular (USRDLL) DLLs or ActiveX
Controls (OCX), you may see memory leaks similar to the following reported
in the debugger:
<P>
<PRE>   a CDynLinkLibrary object at $00410F70, 64 bytes long
   a CDynLinkLibrary object at $00410F70, 64 bytes long
   {38} client block at 0x00410D80, subtype 0, 64 bytes long.
   a CDynLinkLibrary object at $00410D80, 64 bytes long
   a CDynLinkLibrary object at $00410D80, 64 bytes long
   {36} client block at 0x00410C60, subtype 0, 64 bytes long.
   a CDynLinkLibrary object at $00410C60, 64 bytes long
   a CDynLinkLibrary object at $00410C60, 64 bytes long

</PRE><h2>CAUSE</h2>
 
<P>
These memory leaks are reported when multiple versions of the MFC DLL are
loaded in the same process. Since MFC extension (AFXDLL) DLLs require the
exact same MFC DLL as the call application, this problem can only occur
when using MFC regular (USRDLL) DLLs or ActiveX Controls (OCX) that use the
shared version of MFC.
<P>
The most common case is mixing ANSI (MFC4xd.DLL) and UNICODE (MFC4xxUd.DLL)
versions of MFC in the same process. This can also occur when mixing
MFC42d.DLL and MFC40d.DLL.
<P>
<P><h2>RESOLUTION</h2>
 
<P>
These memory leak notifications are false, and can be ignored. Since
neither copy of MFC knows about the other ones, it's not easy to stop these
false leaks from being reported. However, it is possible to separate the
false leaks from the potential real leaks. This can be done by overriding
CWinApp::ExitInstance() in both the EXE and DLL and placing TRACE()
statements in them:
<P>
<PRE>   int CTestDllApp::ExitInstance()
   {
      TRACE(_T("ExitInstance() for regular DLL: TESTDLL\n"));

      return CWinApp::ExitInstance();
   }

</PRE>Only the memory leaks that are detected after the last
CWinApp::ExitInstance() is called are true memory leaks.
<P>
<P><h2>STATUS</h2>
 
<P>
This behavior is by design.
<P>
<P><h2>MORE INFORMATION</h2>
 
<P>
Consider the following application/DLLs:
<P>
<PRE>     -------------               --------------
     =           =               =            =
     =   MFC     =    Calls      =    MFC     =
     =   APP     = ------------&gt; =   USRDLL   =
     =           =               =            =
     =           =               =            =
     -------------               --------------
           |                           |
           |                           |
           | Calls                     | Calls
           |                           |
           \/                         \/
     -------------               --------------
     =           =               =            =
     =           =               =            =
     =   MFC40d  =               =   MFC40Ud  =
     =    DLL    =               =    DLL     =
     =           =               =            =
     -------------               --------------
                \                 /
                 \               /
                  \ Calls       / Calls
                   \           /
                   \/         \/
                   -------------
                   =           =
                   =           =
                   =  MSVCR40d =
                   =   (CRT)   =
                   =           =
                   -------------

</PRE>The MFC Application that is built with the ANSI (MFC40d.DLL) version of MFC
calls the MFC USRDLL, which is built with the UNICODE (MFC40Ud.DLL) version
of MFC. Both MFC versions use the same C run-time (CRT) DLL, MSVCR40d.DLL.
Since MFC USRDLLs are "black-boxes", there should be no problems with
calling a UNICODE MFC USRDLL from an ANSI MFC Application.
<P>
However, since the UNICODE (MFC40ud.DLL) and ANSI (MFC40d.DLL) MFC DLLs
both use the same CRT DLL, false memory leaks are reported on all the
objects allocated in the MFC USRDLL. This occurs because MFC relies on the
CRT DLL to allocate and track all memory. It does not separate the memory
allocations from the different versions of MFC. When one of the MFC DLLs
unloads, it calls the CRT to do a memory dump, assuming everything left in
the heap is a memory leak. However, this assumption is incorrect since
there are two multiple copies of MFC in memory.
<P>
(c) Microsoft Corporation 1997, All Rights Reserved.
Contributions by Kelly Marie Ward, Microsoft Corporation
 
<PRE>Keywords          : MfcDLL
Technology        : kbMfc
Version           : 4.0 4.1 4.2 5.0
Platform          : NT WINDOWS
Issue type        : kbprb</PRE>

	</FONT>
	</TD>
	</TR>
</TABLE>
<P>


<!--DOCBODY_END-->

<!--FOOTER_START-->
<table cellpadding=5 border=0 width="90%">
<tr>
<td>
	<HR WIDTH="90%">

<BLOCKQUOTE>
<FONT FACE="Verdana, Arial, Helvetica" SIZE="1">
<SPAN STYLE="font-family:verdana,arial,helvetica; font-size:8pt">
================================================================================<BR>

</SPAN>
</FONT>
<BR>
<BR>
THE INFORMATION PROVIDED IN THE MICROSOFT KNOWLEDGE BASE IS
PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND.  MICROSOFT DISCLAIMS
ALL WARRANTIES, EITHER EXPRESS OR IMPLIED, INCLUDING THE WARRANTIES
OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  IN NO
EVENT SHALL MICROSOFT CORPORATION OR ITS SUPPLIERS BE LIABLE FOR
ANY DAMAGES WHATSOEVER INCLUDING DIRECT, INDIRECT, INCIDENTAL,
CONSEQUENTIAL, LOSS OF BUSINESS PROFITS OR SPECIAL DAMAGES, EVEN IF
MICROSOFT CORPORATION OR ITS SUPPLIERS HAVE BEEN ADVISED OF THE
POSSIBILITY OF SUCH DAMAGES.  SOME STATES DO NOT ALLOW THE EXCLUSION
OR LIMITATION OF LIABILITY FOR CONSEQUENTIAL OR INCIDENTAL DAMAGES
SO THE FOREGOING LIMITATION MAY NOT APPLY.
</BLOCKQUOTE>
<P>
<center>
	<FONT FACE="Verdana,Arial,Helvetica" SIZE="1">
	Last reviewed:  August 7, 1997</FONT>
	<BR>
	<A href="../cpyright.htm" STYLE="font: bold 7pt Verdana,Arial,Helvetica">&copy; 1998 Microsoft Corporation. All rights reserved. Terms of Use.</A><BR>
	
</center>
</td>
</tr>
</table>

<!--FOOTER_END-->
</FONT>
</BODY>
</HTML>
