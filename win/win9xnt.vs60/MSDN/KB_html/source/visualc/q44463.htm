

<HTML>
<HEAD>
<TITLE>INFO: Difference Between Arrays and Pointers in C </TITLE>

<!--STYLE_BEGIN-->
<style>@import url(../../msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="../../msdn_ie3.css">
<!--STYLE_END-->

<META HTTP-EQUIV="CONTENT-Type" CONTENT="text/html; charset=us-ascii">
<META NAME="ms.locale" CONTENT="EN-US">
<META NAME="Category" CONTENT="Support; KB Article">
<META NAME="KBID" CONTENT="Q44463 ">
<META NAME="KBModify" CONTENT="1997/09/02">
<META NAME="KBCreate" CONTENT="1989/05/16">
<META NAME="Keywords" CONTENT="CLngIss kbfasttip">
<META NAME="KBArea" CONTENT="Support; KB; visualc">
<META NAME="Description" CONTENT="  The text below presents an example of a common programming mistake, that is, confusing an array and a pointer declaration:     Consider an application divided into several modules. In one    module, declare an array as follows:        signed char b...">
<META NAME="Product" CONTENT="Visual C++">
<META NAME="Platform" CONTENT="Windows">
<META NAME="Technology" CONTENT=" ">
<META NAME="Premium" CONTENT="support">

<META NAME="nyms" CONTENT="QAH4,QBQU,QBFY,QAJQ,QAO3,QAO2,QAC2,QAY4,QACI,QACJ,QAJG,QALG,QAEF,QAR5,QBW6 V02180118">
</HEAD>

<BODY BGCOLOR="#FFFFFF" LEFTMARGIN="0" RIGHTMARGIN="0" TOPMARGIN="0">


<!--DOCBODY_START-->
<BR>
<CENTER>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" VALIGN="top" WIDTH="90%">
	<TR>
		<TD VALIGN="top">
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<H1>INFO: Difference Between Arrays and Pointers in C</H1>
			</FONT>
			<FONT FACE="verdana,arial,helvetica" SIZE="1">
			Last reviewed:  September 2, 1997</FONT><BR>
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<B>Article ID: Q44463 </B>
			</FONT>
		</TD>
	</TR>
	<TR>
	<TD>
	<FONT FACE="Verdana, Arial, Helvetica" SIZE=2>



<P><h3> </h3>
 
The information in this article applies to:

<UL><LI>Microsoft C for MS-DOS, versions 6.0, 6.0a, 6.0ax
<LI>Microsoft C/C++ for MS-DOS, version 7.0
<LI>Microsoft Visual C++ for Windows, versions 1.0, 1.5, 1.51, 1.52
<LI>Microsoft Visual C++ 32-bit Edition, versions 1.0, 2.0, 2.1, 4.0, 5.0
</UL> 
<P>
<P><h2>SUMMARY</h2>
 
<P>
The text below presents an example of a common programming mistake, that
is, confusing an array and a pointer declaration:
<P>
<PRE>   Consider an application divided into several modules. In one
   module, declare an array as follows:

      signed char buffer[100];

   In another module, declare the following variables to access the
   array:

      extern signed char *buffer;           // FAILS
      extern signed char buffer[];          // WORKS

   If you view the code in the CodeView debugger, it indicates that
   the "*buffer" declaration produces a different address than the
   "buffer[]" declaration does.

</PRE><h2>MORE INFORMATION</h2>
 
<P>
The following declarations are NOT the same:
<P>
<PRE>   char *pc;
   char ac[20];

</PRE>The first declaration allocates memory for a pointer; the second
allocates memory for 20 characters.
<P>
A picture of pc and ac in memory might appear as follows:
<P>
<PRE>    pc  +--------+
        |   ???  |
        +--------+

    ac  +-----+-----+-----+-----+     +-----+
        |  ?  |  ?  |  ?  |  ?  | ... |  ?  |
        +-----+-----+-----+-----+     +-----+

</PRE>Neither are the following the same:
<P>
<PRE>   extern char *pc;
   extern char ac[];

</PRE>The first declaration indicates that another module allocated either two or
four bytes for a pointer to char named pc while the second indicates that
another module allocated an array (of some unspecified length) named ac.
<P>
The steps required to address pc[3] and ac[3] are different. The one
similarity is that the expression "ac" is a constant pointer to char that
points to &amp;ac[0].
<P>
To evaluate pc[3], load the value of the pointer pc from memory and add 3.
Then load the character stored ad this location (pc + 3) into a register.
Assuming the small memory model, the appropriate MASM code might look like
the following:
<P>
<PRE>   MOV     BX, pc          ; move *CONTENTS* of pc into BX
                           ; BX contains 1234
   MOV     AL, [BX + 3]    ; move byte at pc + 3 (1237) into AL
                           ; ==&gt; AL contains 'd'

</PRE>An appropriate diagram might appear as follows, provided that pc has been
set to point to an array at location 1234 and that the first four positions
of the array contain the string "abcd":
<P>
<PRE>address:   1000                  1234  1235  1236  1237
    pc  +--------+---&gt;&gt;&gt;&gt;&gt;------v-----v-----v-----v-----+
        |  1234  |          *pc |  a  |  b  |  c  |  d  | ...
        +--------+              +-----+-----+-----+-----+
                                 pc[0] pc[1] pc[2] pc[3]
                                 *pc   *(pc+1) and so on

</PRE>NOTE: If you use pc without first initializing it properly causes your
application to access random memory which can cause undesired behavior. To
initialize the pointer, include a line of code such as "pc = malloc(5);" or
"pc = ac;".
<P>
Because ac is a constant, it can be stored in the final MOV instruction,
which eliminates two MOV instructions. The MASM code might look like the
following:
<P>
<PRE>   MOV     AL, [offset ac + 3]     ; move byte at ac + 3 into AL
                                   ; offset ac is 1100, so move
                                   ; byte at 1103 into AL
                                   ; ==&gt; AL contains 'd'

</PRE>The corresponding picture might appear as follows:
<P>
<PRE>address: 1100  1101  1102  1103        1119
    ac  +-----+-----+-----+-----+     +-----+
        |  a  |  b  |  c  |  d  | ... |  \0 |
        +-----+-----+-----+-----+     +-----+
        ac[0] ac[1] ac[2] ac[3]       ac[19]
        *ac   *(ac+1)  and so on

</PRE>NOTE: If you first initialize pc to point to ac (by including the line "pc
= ac;" in your application), then the end result of the two statements is
identical. To see this in the picture, set pc to contain the address of ac,
1100. However, the instructions used to generate these effects are quite
different.
<P>
If you declare ac as follows, the compiler generates code to perform
pointer-type addressing rather than array-type addressing:
<P>
<PRE>   extern char *ac;  // WRONG!

</PRE>The compiler uses the first few bytes of the array as an address (rather
than as characters) and accesses the memory stored at that (unintended)
location.
<P>

	</FONT>
	</TD>
	</TR>
</TABLE>
<P>


<!--DOCBODY_END-->

<!--FOOTER_START-->
<table cellpadding=5 border=0 width="90%">
<tr>
<td>
	<HR WIDTH="90%">

<BLOCKQUOTE>
<FONT FACE="Verdana, Arial, Helvetica" SIZE="1">
<SPAN STYLE="font-family:verdana,arial,helvetica; font-size:8pt">
Additional query words: 8.00<BR>
Keywords          : CLngIss kbfasttip<BR>
Version           : MS-DOS:6.0,6.00a,6.00ax,7.0; WINDOWS:1.0,1.5,1.51,1.52;  WINDOWS NT:1.0,2.0,2.1,4.0,5.0<BR>
Platform          : MS-DOS NT WINDOWS<BR>
Issue type        : kbinfo<BR>

</SPAN>
</FONT>
<BR>
<BR>
THE INFORMATION PROVIDED IN THE MICROSOFT KNOWLEDGE BASE IS
PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND.  MICROSOFT DISCLAIMS
ALL WARRANTIES, EITHER EXPRESS OR IMPLIED, INCLUDING THE WARRANTIES
OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  IN NO
EVENT SHALL MICROSOFT CORPORATION OR ITS SUPPLIERS BE LIABLE FOR
ANY DAMAGES WHATSOEVER INCLUDING DIRECT, INDIRECT, INCIDENTAL,
CONSEQUENTIAL, LOSS OF BUSINESS PROFITS OR SPECIAL DAMAGES, EVEN IF
MICROSOFT CORPORATION OR ITS SUPPLIERS HAVE BEEN ADVISED OF THE
POSSIBILITY OF SUCH DAMAGES.  SOME STATES DO NOT ALLOW THE EXCLUSION
OR LIMITATION OF LIABILITY FOR CONSEQUENTIAL OR INCIDENTAL DAMAGES
SO THE FOREGOING LIMITATION MAY NOT APPLY.
</BLOCKQUOTE>
<P>
<center>
	<FONT FACE="Verdana,Arial,Helvetica" SIZE="1">
	Last reviewed:  September 2, 1997</FONT>
	<BR>
	<A href="../cpyright.htm" STYLE="font: bold 7pt Verdana,Arial,Helvetica">&copy; 1998 Microsoft Corporation. All rights reserved. Terms of Use.</A><BR>
	
</center>
</td>
</tr>
</table>

<!--FOOTER_END-->
</FONT>
</BODY>
</HTML>
