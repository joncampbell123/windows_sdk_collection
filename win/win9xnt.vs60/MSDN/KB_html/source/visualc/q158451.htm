

<HTML>
<HEAD>
<TITLE>How To Call Automation Methods with Variable Argument Lists </TITLE>

<!--STYLE_BEGIN-->
<style>@import url(../../msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="../../msdn_ie3.css">
<!--STYLE_END-->

<META HTTP-EQUIV="CONTENT-Type" CONTENT="text/html; charset=us-ascii">
<META NAME="ms.locale" CONTENT="EN-US">
<META NAME="Category" CONTENT="Support; KB Article">
<META NAME="KBID" CONTENT="Q158451">
<META NAME="KBModify" CONTENT="1997/07/10">
<META NAME="KBCreate" CONTENT="1996/10/30">
<META NAME="Keywords" CONTENT="MfcOLE kbhowto kbole">
<META NAME="KBArea" CONTENT="Support; KB; visualc">
<META NAME="Description" CONTENT="  OLE Automation allows you to create methods on your server that can take a variable-length list of arguments. This is a simple procedure in Visual Basic. However, there are special considerations when you call such a method from a client written in...">
<META NAME="Product" CONTENT="Visual C++">
<META NAME="Platform" CONTENT="Windows">
<META NAME="Technology" CONTENT=" ">
<META NAME="Premium" CONTENT="support">

<META NAME="nyms" CONTENT="QAD7,QAHE,QAH7,QAH6,QBS0,QAPN,QAGI,QAY5,QA2K,QAB9,QBV8,QAG1,QBFY,QAYL,QAIF V02180118">
</HEAD>

<BODY BGCOLOR="#FFFFFF" LEFTMARGIN="0" RIGHTMARGIN="0" TOPMARGIN="0">


<!--DOCBODY_START-->
<BR>
<CENTER>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" VALIGN="top" WIDTH="90%">
	<TR>
		<TD VALIGN="top">
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<H1>How To Call Automation Methods with Variable Argument Lists</H1>
			</FONT>
			<FONT FACE="verdana,arial,helvetica" SIZE="1">
			Last reviewed:  July 10, 1997</FONT><BR>
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<B>Article ID: Q158451</B>
			</FONT>
		</TD>
	</TR>
	<TR>
	<TD>
	<FONT FACE="Verdana, Arial, Helvetica" SIZE=2>



 
4.00 4.10 4.20
WINDOWS NT
kbole kbhowto
<P>
 
The information in this article applies to:
<P>
<PRE>  - The Microsoft Foundation Classes (MFC), included with:
    Microsoft Visual C++, 32-bit Edition, versions 4.0, 4.1, 4.2
</PRE> 
<P>
<P><h2>SUMMARY</h2>
 
<P>
OLE Automation allows you to create methods on your server that can take a
variable-length list of arguments. This is a simple procedure in Visual
Basic. However, there are special considerations when you call such a
method from a client written in C/C++.
<P>
<P><h2>MORE INFORMATION</h2>
 
<P>
<P><h3>Visual Basic</h3>
 
<P>
You can create a method on your OLE Automation server that takes a variable-
length list of arguments, such as the following:
<P>
<PRE>   Function MyFunc1(ByVal p1 As Long, ParamArray p2()) As String

   myfunc1 = "String returned"
   End Function

</PRE>The ParamArray parameter p2 allows the caller of this function to pass any
number of parameters in addition to the required parameter, p1. Visual
Basic retrieves additional parameters by locating the array of VARIANTS
contained in the variable p2. The type information generated by Visual
Basic for the MyFunc1 function will look like this:
<P>
<PRE>   [id(0x60030020), vararg]
   HRESULT _stdcall MyFunc1(
                   [in] long p1,
                   [in, out] SAFEARRAY(VARIANT)* p2,
                   [retval] BSTR* );

</PRE>The vararg attribute in the type information for the MyFunc1 function tells
callers that it accepts a variable-length list of arguments for this
function. The [in, out] SAFEARRAY(VARIANT)* p2 parameter tells callers that
a SAFEARRAY pointer, representing an array of variants, must be passed to
this function. The array of variants is the list of optional parameters
that will be passed into this function.
<P>
If your Automation client is a Visual Basic client, then the call is made
by passing however many parameters the caller wishes to pass beyond the one
required parameter. The following is an example of a call to MyFunc1 in
Visual Basic:
<P>
<PRE>   MyObj.MyFunc1(x,y,z,"Some String",q);

</PRE>In this example, x is passed as the required parameter to MyFunc1. All
other parameters are packaged into an array of variants internally by
Visual Basic. This array is then passed to the automation method.
<P>
<P><h3>C or C++</h3>
 
<P>
If you are calling this method from a C or C++ client, more work is
necessary to package the call. If you are calling this function from an MFC
client application and you use ClassWizard to generate a wrapper class for
the automation object that contains MyFunc1, ClassWizard will not generate
a wrapper function for MyFunc1 or any function that takes a variable-length
list of arguments. This behavior occurs because the MFC implementation of
COleDispatchDriver, which is responsible for packaging and invoking
automation calls, does not understand how to package the SAFEARRAY type.
This is not a bug, but rather an MFC limitation. Therefore, if you use
ClassWizard to generate a wrapper class for an automation object that
contains a method with a variable-length list of parameters, you have to
write the wrapper to invoke that function.
<P>
The following Visual C++ function shows how to invoke the MyFunc1
automation method:
<P>
<PRE>   CString _Class1::InvokeMyFunc1(long p1,VARIANT *pVar,int cElems)
   {
       //pVar is an array of variants.
       //cElems is the number of variants in pVar.
       //p1 is a required long parameter.
       HRESULT hr;

       VARIANT returnval;
       EXCEPINFO Excepinfo;
       unsigned int uArgErr;
       DISPPARAMS dp;

       VariantInit(&amp;returnval);

       //Create the rgvarg member of the DISPPARAMS struct.
       //Make it big enough to hold the number of VARIANTS in the
       //pVar array + an extra variant to hold the required parameter.
        dp.rgvarg = new VARIANTARG[cElems+1];

       //Because the variable length parameter list is the last argument
       //to the function, it gets copied to dp.rgvarg first.
       memcpy(dp.rgvarg,pVar,sizeof(VARIANT)*cElems);

       //Add the required parameter (p1) to the array.
       dp.rgvarg[cElems].vt = VT_I4;
       dp.rgvarg[cElems].lVal = p1;

       //Set cArgs to the total number of arguments passed.
       dp.cArgs = cElems+1;
       dp.cNamedArgs = 0;

       //Make the call.
       hr = m_lpDispatch-&gt;Invoke(0x6003001C,
                           IID_NULL,
                           LOCALE_SYSTEM_DEFAULT,
                           DISPATCH_METHOD,
                           &amp;dp,
                           &amp;returnval,
                           &amp;Excepinfo,&amp;uArgErr);
       //Delete the memory you allocated above for dp.rgvarg.
        delete[] dp.rgvarg;

       //Return the string as a Cstring.
       CString strRet(returnval.bstrVal);
       VariantClear(&amp;returnval);
       return strRet;
   }

</PRE>Although the type information for the MyFunc1 function specifies that a
SAFEARRAY* be passed in, a SAFEARRAY was not created and passed to the
invoke call by the caller. The caller passes an array of variants along
with the one required parameter and the total count of all arguments in the
DISPARAMS structure. The implementation of Invoke in the server will create
a SAFEARRAY, package the passed-in array of variants into the SAFEARRAY,
and then pass the SAFEARRAY pointer to the server's method. Therefore, the
responsibility for creating the SAFEARRAY to pass to MyFunc1 does not fall
on the caller. The caller needs to package all of the extra parameters it
wishes to pass in a flat array (contained in the DISPARAMS struct) and
invoke the method.
<P>

	</FONT>
	</TD>
	</TR>
</TABLE>
<P>


<!--DOCBODY_END-->

<!--FOOTER_START-->
<table cellpadding=5 border=0 width="90%">
<tr>
<td>
	<HR WIDTH="90%">

<BLOCKQUOTE>
<FONT FACE="Verdana, Arial, Helvetica" SIZE="1">
<SPAN STYLE="font-family:verdana,arial,helvetica; font-size:8pt">
KBCategory: kbole kbhowto<BR>
KBSubcategory: MfcOLE<BR>
Additional reference words: 4.00 4.10 4.20 kbdsi ParamArray<BR>
Keywords            : MfcOLE kbhowto kbole<BR>
Technology          : kbMfc<BR>
Version             : 4.00 4.10 4.20<BR>
Platform            : NT WINDOWS<BR>

</SPAN>
</FONT>
<BR>
<BR>
THE INFORMATION PROVIDED IN THE MICROSOFT KNOWLEDGE BASE IS
PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND.  MICROSOFT DISCLAIMS
ALL WARRANTIES, EITHER EXPRESS OR IMPLIED, INCLUDING THE WARRANTIES
OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  IN NO
EVENT SHALL MICROSOFT CORPORATION OR ITS SUPPLIERS BE LIABLE FOR
ANY DAMAGES WHATSOEVER INCLUDING DIRECT, INDIRECT, INCIDENTAL,
CONSEQUENTIAL, LOSS OF BUSINESS PROFITS OR SPECIAL DAMAGES, EVEN IF
MICROSOFT CORPORATION OR ITS SUPPLIERS HAVE BEEN ADVISED OF THE
POSSIBILITY OF SUCH DAMAGES.  SOME STATES DO NOT ALLOW THE EXCLUSION
OR LIMITATION OF LIABILITY FOR CONSEQUENTIAL OR INCIDENTAL DAMAGES
SO THE FOREGOING LIMITATION MAY NOT APPLY.
</BLOCKQUOTE>
<P>
<center>
	<FONT FACE="Verdana,Arial,Helvetica" SIZE="1">
	Last reviewed:  July 10, 1997</FONT>
	<BR>
	<A href="../cpyright.htm" STYLE="font: bold 7pt Verdana,Arial,Helvetica">&copy; 1998 Microsoft Corporation. All rights reserved. Terms of Use.</A><BR>
	
</center>
</td>
</tr>
</table>

<!--FOOTER_END-->
</FONT>
</BODY>
</HTML>
