

<HTML>
<HEAD>
<TITLE>FIX: CFile Exception: badSeek, OS error information = -1 </TITLE>

<!--STYLE_BEGIN-->
<style>@import url(../../msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="../../msdn_ie3.css">
<!--STYLE_END-->

<META HTTP-EQUIV="CONTENT-Type" CONTENT="text/html; charset=us-ascii">
<META NAME="ms.locale" CONTENT="EN-US">
<META NAME="Category" CONTENT="Support; KB Article">
<META NAME="KBID" CONTENT="Q128831">
<META NAME="KBModify" CONTENT="1997/09/18">
<META NAME="KBCreate" CONTENT="1995/04/11">
<META NAME="Keywords" CONTENT="MfcDatabase kbbuglist kbfixlist kbprg">
<META NAME="KBArea" CONTENT="Support; KB; visualc">
<META NAME="Description" CONTENT="  When calling IsFieldDirty() twice, directly or indirectly, the following exception occurs:     CFile exception: badSeek, OS error information = -1.  This simplified example demonstrates how to see the error:     CSomeRecordset rs;    rs.Open();    ...">
<META NAME="Product" CONTENT="Visual C++">
<META NAME="Platform" CONTENT="Windows">
<META NAME="Technology" CONTENT=" ">
<META NAME="Premium" CONTENT="support">

<META NAME="nyms" CONTENT="QAGI,QAY5,QAXB,QAH4,QAEF,QACI,QBV8,QAB9,QA9N,QAC1,QBCT,QAR4,QAGC,QAGB,QAAP V02180118">
</HEAD>

<BODY BGCOLOR="#FFFFFF" LEFTMARGIN="0" RIGHTMARGIN="0" TOPMARGIN="0">


<!--DOCBODY_START-->
<BR>
<CENTER>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" VALIGN="top" WIDTH="90%">
	<TR>
		<TD VALIGN="top">
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<H1>FIX: CFile Exception: badSeek, OS error information = -1</H1>
			</FONT>
			<FONT FACE="verdana,arial,helvetica" SIZE="1">
			Last reviewed:  September 18, 1997</FONT><BR>
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<B>Article ID: Q128831</B>
			</FONT>
		</TD>
	</TR>
	<TR>
	<TD>
	<FONT FACE="Verdana, Arial, Helvetica" SIZE=2>



 
2.00 2.10
WINDOWS NT
kbprg kbfixlist kbbuglist
<P>
 
The information in this article applies to:

<UL><LI>The  Microsoft Foundation Classes (MFC), included with:
   Microsoft Visual C++, 32-bit Edition, versions 2.0 and 2.1
</UL> 
<P>
<P><h2>SYMPTOMS</h2>
 
<P>
When calling IsFieldDirty() twice, directly or indirectly, the following
exception occurs:
<P>
<PRE>   CFile exception: badSeek, OS error information = -1.

</PRE>This simplified example demonstrates how to see the error:
<P>
<PRE>   CSomeRecordset rs;
   rs.Open();
   rs.Edit();
   rs.IsFieldDirty(NULL);
   rs.m_field1="somevalue";
   rs.Update();
   rs.Close();

</PRE>IsFieldDirty() is called twice -- once explicitly and then indirectly in
the Update() call.
<P>
<P><h2>CAUSE</h2>
 
<P>
The problem lies in the MarkForUpdate() function. Here is the code shown in
\MSVC20\MFC\SRC\DBCORE.CPP:
<P>
<PRE>void CRecordset::MarkForUpdate()
</PRE>{
<PRE>   ASSERT_VALID(this);
   ASSERT(m_hstmt != SQL_NULL_HSTMT);

   // Must have already stored field values in memfile
   ASSERT(m_pmemfile != NULL);

   CFieldExchange fx(CFieldExchange::MarkForUpdate, this);
   m_pmemfile-&gt;SeekToBegin();

   ASSERT(m_par != NULL);
   delete m_par;
   m_par = NULL;
   m_par = new CArchive(m_pmemfile, CArchive::load);
   fx.m_par = m_par;

   DoFieldExchange(&amp;fx);
</PRE>}
<P>
The SeekToBegin() call is made while the CArchive object pointed to by
m_par is still attached to the file. The CArchive doesn't know that the
memfile's file pointer has been moved by the SeekToBegin() call. When the
archive is deleted, its Flush() member function is called. In that
function, the archive attempts to move the file pointer back from where it
thinks the current file position is to the beginning of the file. Because
the current file position is already at the beginning of the file, a bad
seek CFileException is thrown.
<P>
<P><h2>RESOLUTION</h2>
 
<P>
The solution is to move the SeekToBegin() function to a position following
the delete of the CArchive that is attached to the file.
<P>
To do this, copy four functions (Update(),UpdateInsertDelete(),
IsFieldDirty(), and MarkForUpdate()) from DBCORE.CPP to your CRecordset
.CPP file. The Update() function is virtual so by copying these functions
to your recordset class, you will guarantee that your new (instead of old)
MarkForUpdate() function is called.
<P>
The only change you need to make to the code is to the MarkForUpdate()
function. Place the code that deletes the archive before the call to
SeekToBegin() as shown here:
<P>
<PRE>void CSomeRecordset::MarkForUpdate()
</PRE>{
<PRE>   ASSERT_VALID(this);
   ASSERT(m_hstmt != SQL_NULL_HSTMT);

   // Must have already stored field values in memfile
   ASSERT(m_pmemfile != NULL);

   ASSERT(m_par != NULL);
   delete m_par;
   m_par = NULL;

   CFieldExchange fx(CFieldExchange::MarkForUpdate, this);
   m_pmemfile-&gt;SeekToBegin();

   m_par = new CArchive(m_pmemfile, CArchive::load);
   fx.m_par = m_par;

   DoFieldExchange(&amp;fx);
</PRE>}
<P>
Again, copy the Update(), UpdateInsertDelete(), and IsFieldDirty()
functions from the code in DBCORE.CPP to functions of the same name in your
new CRecordset-derived class.
<P>
<P><h2>STATUS</h2>
 
<P>
Microsoft has confirmed this to be a bug in the Microsoft products listed
at the beginning of this article. This problem was corrected in Microsoft
Visual C++, 32-bit Edition, version 2.2
<P>

	</FONT>
	</TD>
	</TR>
</TABLE>
<P>


<!--DOCBODY_END-->

<!--FOOTER_START-->
<table cellpadding=5 border=0 width="90%">
<tr>
<td>
	<HR WIDTH="90%">

<BLOCKQUOTE>
<FONT FACE="Verdana, Arial, Helvetica" SIZE="1">
<SPAN STYLE="font-family:verdana,arial,helvetica; font-size:8pt">
Additional reference words: 2.00 2.10 3.0 3.1 3.00 3.10<BR>
KBCategory: kbprg kbfixlist kbbuglist<BR>
KBSubcategory: MfcDatabase<BR>
Keywords          : MfcDatabase kbbuglist kbfixlist kbprg<BR>
Technology        : kbMfc<BR>
Version           : 2.00 2.10<BR>
Platform          : NT WINDOWS<BR>
Solution Type     : kbfix<BR>

</SPAN>
</FONT>
<BR>
<BR>
THE INFORMATION PROVIDED IN THE MICROSOFT KNOWLEDGE BASE IS
PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND.  MICROSOFT DISCLAIMS
ALL WARRANTIES, EITHER EXPRESS OR IMPLIED, INCLUDING THE WARRANTIES
OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  IN NO
EVENT SHALL MICROSOFT CORPORATION OR ITS SUPPLIERS BE LIABLE FOR
ANY DAMAGES WHATSOEVER INCLUDING DIRECT, INDIRECT, INCIDENTAL,
CONSEQUENTIAL, LOSS OF BUSINESS PROFITS OR SPECIAL DAMAGES, EVEN IF
MICROSOFT CORPORATION OR ITS SUPPLIERS HAVE BEEN ADVISED OF THE
POSSIBILITY OF SUCH DAMAGES.  SOME STATES DO NOT ALLOW THE EXCLUSION
OR LIMITATION OF LIABILITY FOR CONSEQUENTIAL OR INCIDENTAL DAMAGES
SO THE FOREGOING LIMITATION MAY NOT APPLY.
</BLOCKQUOTE>
<P>
<center>
	<FONT FACE="Verdana,Arial,Helvetica" SIZE="1">
	Last reviewed:  September 18, 1997</FONT>
	<BR>
	<A href="../cpyright.htm" STYLE="font: bold 7pt Verdana,Arial,Helvetica">&copy; 1998 Microsoft Corporation. All rights reserved. Terms of Use.</A><BR>
	
</center>
</td>
</tr>
</table>

<!--FOOTER_END-->
</FONT>
</BODY>
</HTML>
