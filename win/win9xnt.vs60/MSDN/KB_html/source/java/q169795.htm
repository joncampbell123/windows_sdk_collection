

<HTML>
<HEAD>
<TITLE>HOWTO: OleDate: Conversion Between DATE and java.util.Date </TITLE>

<!--STYLE_BEGIN-->
<style>@import url(../../msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="../../msdn_ie3.css">
<!--STYLE_END-->

<META HTTP-EQUIV="CONTENT-Type" CONTENT="text/html; charset=us-ascii">
<META NAME="ms.locale" CONTENT="EN-US">
<META NAME="Category" CONTENT="Support; KB Article">
<META NAME="KBID" CONTENT="Q169795">
<META NAME="KBModify" CONTENT="1998/03/20">
<META NAME="KBCreate" CONTENT="1997/06/09">
<META NAME="Keywords" CONTENT="kbcode JCOM JVM">
<META NAME="KBArea" CONTENT="Support; KB; java">
<META NAME="Description" CONTENT="  OLE data type DATE is used in OLE to specify a date. It is typedefed as double in Visual C++. You can expose properties of type DATE from an automation object. When you create a wrapper class for the OLE object in Java using JavaTlb, DATE types are...">
<META NAME="Product" CONTENT="java">
<META NAME="Platform" CONTENT="Windows">
<META NAME="Technology" CONTENT=" ">
<META NAME="Security" CONTENT="PUBLIC ">
<META NAME="Premium" CONTENT="support">

<META NAME="nyms" CONTENT="QACE,QAHH,QA4Q,QAH4,QAGJ,QAFO,QAPN,QAY2,QAKC,QBXF,QAEQ,QAI4,QAYV,QAW6,QAKD V02180118">
</HEAD>

<BODY BGCOLOR="#FFFFFF" LEFTMARGIN="0" RIGHTMARGIN="0" TOPMARGIN="0">


<!--DOCBODY_START-->
<BR>
<CENTER>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" VALIGN="top" WIDTH="90%">
	<TR>
		<TD VALIGN="top">
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<H1>HOWTO: OleDate: Conversion Between DATE and java.util.Date</H1>
			</FONT>
			<FONT FACE="verdana,arial,helvetica" SIZE="1">
			Last reviewed:  March 20, 1998</FONT><BR>
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<B>Article ID: Q169795</B>
			</FONT>
		</TD>
	</TR>
	<TR>
	<TD>
	<FONT FACE="Verdana, Arial, Helvetica" SIZE=2>



 
 
The information in this article applies to:

<UL><LI>Microsoft Win32 Virtual Machine for Java
<LI>Microsoft Visual J++, versions 1.0, 1.1
</UL> 
<P>
<P><h2>SUMMARY</h2>
 
<P>
OLE data type DATE is used in OLE to specify a date. It is typedefed as
double in Visual C++. You can expose properties of type DATE from an
automation object. When you create a wrapper class for the OLE object in
Java using JavaTlb, DATE types are mapped to double. Java has a class that
is used for specifying dates. It is lang.util.Date. However, these two
types are not the same and there is no conversion function between them in
Java. You can use the code in the MORE INFORMATION section to convert them.
<P>
<P><h2>MORE INFORMATION</h2>
 
<P>
The following code is copied from the Microsoft Foundation Classes included
with Visual C++ version 4.21 and modified to work with Java and
lang.util.Date. Copy the code to a file named OleDate.java and add it to
your project. Include the following line to all your source files that use
OleDate:
<P>
<PRE>   import OleDate;

</PRE>NOTE: The file name has to have the correct capitalization.
<P>
<P><h3>Sample Code</h3>
 
<P>
<PRE>   // OleDate.java
   //
   // Written by Sridhar S Madhugiri
   // of Microsoft Technical Support, Developer Support
   // Copyright (c) 1997 Microsoft Corporation. All rights reserved.
   //
   // this class extends Date to convert support Conversion from/to
   // OLE Data type DATE
   //
   // OleData type DATE is actually represented as a double.
   //
   // To convert from DATE to Date call the setDate(double) member.
   // This function does not do a lot of error checking about valid ranges.
   // It converts the value passed in to year, month, date, hour,
   // minute, second and calls the Date functions to set the values in
   // the object.
   //
   // To convert from Date to DATE call toDouble() member. This returns
   // a double that has the date value in the correct format.
   //


   import java.util.Date;
   import java.lang.Math;

   public class OleDate extends java.util.Date
   {
      public OleDate()
      {
         super();
      }

      public OleDate(int year, int month, int date)
      {
         super(year, month, date);
      }

      public OleDate(int year, int month, int date,
         int hrs, int min, int sec)
      {
         super(year, month, date, hrs, min, sec);
      }

      public OleDate(long date)
      {
         super(date);
      }

      public OleDate(String s)
      {
         super(s);
      }

      public OleDate(double date)
      {
         super();
         setDate(date);
      }

      // Source code copied from MFC 4.21 and modified

      // Half a second, expressed in days
      static double HALF_SECOND = (1.0/172800.0);

      public void setDate(double dtSrc)
      {
         // source code copied from MFC 4.21 and modified

         long nDays;         // Number of days since Dec. 30, 1899
         long nDaysAbsolute; // Number of days since 1/1/0
         long nSecsInDay;    // Time in seconds since midnight
         long nMinutesInDay; // Minutes in day

         long n400Years;     // Number of 400 year increments since 1/1/0
         long n400Century;   // Century within 400 year block (0,1,2 or 3)
         long n4Years;       // Number of 4 year increments since 1/1/0
         long n4Day;         // Day within 4 year block
                             //  (0 is 1/1/yr1, 1460 is 12/31/yr4)
         long n4Yr;          // Year within 4 year block (0,1,2 or 3)
         boolean bLeap4 = true; // TRUE if 4 year block includes leap year

         // values in terms of year month date.
         int tm_sec;
         int tm_min;
         int tm_hour;
         int tm_mday;
         int tm_mon;
         int tm_year;
         int tm_wday;
         int tm_yday;

         double dblDate = dtSrc; // temporary serial date

         // If a valid date, then this conversion should not overflow
         nDays = (long)dblDate;

         // Round to the second
         dblDate += ((dtSrc &gt; 0.0) ? HALF_SECOND : -HALF_SECOND);

         // Add days from 1/1/0 to 12/30/1899
         nDaysAbsolute = (long)dblDate + 693959L;

         dblDate = Math.abs(dblDate);
         nSecsInDay = (long)((dblDate - Math.floor(dblDate)) * 86400.);

         // Leap years every 4 yrs except centuries not multiples of 400.
         n400Years = (long)(nDaysAbsolute / 146097L);

         // Set nDaysAbsolute to day within 400-year block
         nDaysAbsolute %= 146097L;

         // -1 because first century has extra day
         n400Century = (long)((nDaysAbsolute - 1) / 36524L);

         // Non-leap century
         if (n400Century != 0)
         {
            // Set nDaysAbsolute to day within century
            nDaysAbsolute = (nDaysAbsolute - 1) % 36524L;

            // +1 because 1st 4 year increment has 1460 days
            n4Years = (long)((nDaysAbsolute + 1) / 1461L);

            if (n4Years != 0)
               n4Day = (long)((nDaysAbsolute + 1) % 1461L);
            else
            {
               bLeap4 = false;
               n4Day = (long)nDaysAbsolute;
            }
         }
         else
         {
            // Leap century - not special case!
            n4Years = (long)(nDaysAbsolute / 1461L);
            n4Day = (long)(nDaysAbsolute % 1461L);
         }

         if (bLeap4)
         {
            // -1 because first year has 366 days
            n4Yr = (n4Day - 1) / 365;

            if (n4Yr != 0)
               n4Day = (n4Day - 1) % 365;
         }
         else
         {
            n4Yr = n4Day / 365;
            n4Day %= 365;
         }

         tm_year = (int)(n400Years * 400 + n400Century * 100 +
            n4Years * 4 + n4Yr);

         // Handle leap year: before, on, and after Feb. 29.
         if (n4Yr == 0 &amp;&amp; bLeap4 &amp;&amp; n4Day == 59)
         {
            /* Feb. 29 */
            tm_mon = 2;
            tm_mday = 29;
         }
         else
         {
            if (n4Yr == 0 &amp;&amp; bLeap4 &amp;&amp; n4Day &gt;= 59)
               --n4Day;

            // Make n4DaY a 1-based day of non-leap year and compute
            //  month/day for everything but Feb. 29.
            ++n4Day;

            // Month number always &gt;= n/32, so save some loop time */
            for (tm_mon = (int)((n4Day &gt;&gt; 5) + 1);
               n4Day &gt; rgMonthDays[tm_mon]; tm_mon++);

            tm_mday = (int)(n4Day - rgMonthDays[tm_mon-1]);
         }

         if (nSecsInDay == 0)
            tm_hour = tm_min = tm_sec = 0;
         else
         {
            tm_sec = (int)(nSecsInDay % 60L);
            nMinutesInDay = nSecsInDay / 60L;
            tm_min = (int)(nMinutesInDay % 60);
            tm_hour = (int)(nMinutesInDay / 60);
         }

         setYear(tm_year - 1900);
         setMonth(tm_mon - 1);
         setDate(tm_mday);
         setHours(tm_hour);
         setMinutes(tm_min);
         setSeconds(tm_sec);

      }

      // source code copied from MFC 4.21 and modified
      static int rgMonthDays[] =
         {0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 365};

      public double toDouble()
      {
         // source code copied from MFC 4.21 and modified.

         int wYear = getYear() + 1900;
         int wMonth = getMonth() + 1;
         int wDay = getDate();
         int wHour = getHours();
         int wMinute = getMinutes();
         int wSecond = getSeconds();


         //  Check for leap year and set the number of days in the month
         boolean bLeapYear = ((wYear &amp; 3) == 0) &amp;&amp;
            ((wYear % 100) != 0 || (wYear % 400) == 0);

         int nDaysInMonth =
            rgMonthDays[wMonth] - rgMonthDays[wMonth-1] +
            ((bLeapYear &amp;&amp; wDay == 29 &amp;&amp; wMonth == 2) ? 1 : 0);

         // Cache the date in days and time in fractional days
         long nDate;
         double dblTime;

         //It is a valid date; make Jan 1, 1AD be 1
         nDate = wYear*365L + wYear/4 - wYear/100 + wYear/400 +
            rgMonthDays[wMonth-1] + wDay;

         //  If leap year and it's before March, subtract 1:
         if (wMonth &lt;= 2 &amp;&amp; bLeapYear)
            --nDate;

         //  Offset so that 12/30/1899 is 0
         nDate -= 693959L;

         dblTime = (((long)wHour * 3600L) +  // hrs in seconds
            ((long)wMinute * 60L) +  // mins in seconds
            ((long)wSecond)) / 86400.;

         double dtDest = (double) nDate +
            ((nDate &gt;= 0) ? dblTime : -dblTime);

         return dtDest;
      }
   }

</PRE>The class OleDate has two public member functions that convert between DATE
and java.util.Date.
<P>
<PRE>   public void setDate(double date)

</PRE>takes valid OLE DATE values and sets the Date object with the values
specified in DATE.
<P>
<PRE>   public double toDouble()

</PRE>returns a double that contains the value in the object, converted to OLE
DATE type.
<P>
The following code illustrates how to use these functions.
<P>
m_autoObject is a valid Automation object. The automation object exposes a
Property named "today" of type DATE.
<P>
<PRE>   ...
   import OleDate;
   class testoledate
   {
      ...
      public void testDate
      {
         OleDate date = new OleDate(m_autoObject.gettoday());
    date.setDate(date.getDate() + 1);
    m_autoObject.puttoday(date.toDouble());

      }
      ...
   }

</PRE>Once you run the code above, the automation objects property will be set to
the next day.
<P>
<P><h2>REFERENCES</h2>
 
<P>
Win32 SDK Documentation
<P>
MFC source file OleVar.cpp
<P>
For the latest Knowledge Base articles and other support information on
Visual J++ and the SDK for Java, see the following page on the Microsoft
Technical Support site:
<P>
<PRE>   <B><A href="http://support.microsoft.com/support/visualj/">http://support.microsoft.com/support/visualj/</A></B>
   <B><A href="http://support.microsoft.com/support/java/">http://support.microsoft.com/support/java/</A></B>

</PRE>(c) Microsoft Corporation 1997, All Rights Reserved.
Contributions by Sridhar S. Madhugiri, Microsoft Corporation
 
<PRE>Keywords          : kbcode JCOM JVM
Technology        : kbole kbInetDev
Version           : 1.0 1.1
Platform          : WINDOWS
Issue type        : kbhowto</PRE>

	</FONT>
	</TD>
	</TR>
</TABLE>
<P>


<!--DOCBODY_END-->

<!--FOOTER_START-->
<table cellpadding=5 border=0 width="90%">
<tr>
<td>
	<HR WIDTH="90%">

<BLOCKQUOTE>
<FONT FACE="Verdana, Arial, Helvetica" SIZE="1">
<SPAN STYLE="font-family:verdana,arial,helvetica; font-size:8pt">
================================================================================<BR>

</SPAN>
</FONT>
<BR>
<BR>
THE INFORMATION PROVIDED IN THE MICROSOFT KNOWLEDGE BASE IS
PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND.  MICROSOFT DISCLAIMS
ALL WARRANTIES, EITHER EXPRESS OR IMPLIED, INCLUDING THE WARRANTIES
OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  IN NO
EVENT SHALL MICROSOFT CORPORATION OR ITS SUPPLIERS BE LIABLE FOR
ANY DAMAGES WHATSOEVER INCLUDING DIRECT, INDIRECT, INCIDENTAL,
CONSEQUENTIAL, LOSS OF BUSINESS PROFITS OR SPECIAL DAMAGES, EVEN IF
MICROSOFT CORPORATION OR ITS SUPPLIERS HAVE BEEN ADVISED OF THE
POSSIBILITY OF SUCH DAMAGES.  SOME STATES DO NOT ALLOW THE EXCLUSION
OR LIMITATION OF LIABILITY FOR CONSEQUENTIAL OR INCIDENTAL DAMAGES
SO THE FOREGOING LIMITATION MAY NOT APPLY.
</BLOCKQUOTE>
<P>
<center>
	<FONT FACE="Verdana,Arial,Helvetica" SIZE="1">
	Last reviewed:  March 20, 1998</FONT>
	<BR>
	<A href="../cpyright.htm" STYLE="font: bold 7pt Verdana,Arial,Helvetica">&copy; 1998 Microsoft Corporation. All rights reserved. Terms of Use.</A><BR>
	
</center>
</td>
</tr>
</table>

<!--FOOTER_END-->
</FONT>
</BODY>
</HTML>
