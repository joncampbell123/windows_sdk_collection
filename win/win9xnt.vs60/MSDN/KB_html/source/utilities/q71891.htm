

<HTML>
<HEAD>
<TITLE>Dictionary Hashing Algorithm Used by the LIB Utility </TITLE>

<!--STYLE_BEGIN-->
<style>@import url(../../msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="../../msdn_ie3.css">
<!--STYLE_END-->

<META HTTP-EQUIV="CONTENT-Type" CONTENT="text/html; charset=us-ascii">
<META NAME="ms.locale" CONTENT="EN-US">
<META NAME="Category" CONTENT="Support; KB Article">
<META NAME="KBID" CONTENT="Q71891 ">
<META NAME="KBModify" CONTENT="1997/07/17">
<META NAME="KBCreate" CONTENT="1991/05/08">
<META NAME="Keywords" CONTENT="kb16bitonly">
<META NAME="KBArea" CONTENT="Support; KB; utilities">
<META NAME="Description" CONTENT="  The last part of each library produced by the Microsoft Library Manager (LIB) contains a dictionary that holds all the public symbols in the library. The hashing algorithm mentioned on page 63 of the  Microsoft C Developer's Toolkit Reference  is u...">
<META NAME="Product" CONTENT="Programming Utilities">
<META NAME="Platform" CONTENT="Windows">
<META NAME="Technology" CONTENT=" ">
<META NAME="Premium" CONTENT="support">

<META NAME="nyms" CONTENT="QATJ,QA28,QBWA,QBFY,QAUI,QA4Q,QAOP,QA1L,QAWN,QBHQ,QAH4,QBXV,QAI4,QADF V02180118">
</HEAD>

<BODY BGCOLOR="#FFFFFF" LEFTMARGIN="0" RIGHTMARGIN="0" TOPMARGIN="0">


<!--DOCBODY_START-->
<BR>
<CENTER>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" VALIGN="top" WIDTH="90%">
	<TR>
		<TD VALIGN="top">
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<H1>Dictionary Hashing Algorithm Used by the LIB Utility</H1>
			</FONT>
			<FONT FACE="verdana,arial,helvetica" SIZE="1">
			Last reviewed:  July 17, 1997</FONT><BR>
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<B>Article ID: Q71891 </B>
			</FONT>
		</TD>
	</TR>
	<TR>
	<TD>
	<FONT FACE="Verdana, Arial, Helvetica" SIZE=2>



 
3.10 3.11 3.17 3.18 3.20 3.20.010 | 3.10 3.11 3.17 3.20
<PRE>MS-DOS                            | OS/2
</PRE>kbtool kbcode
<P>
 
The information in this article applies to:

<UL><LI>Microsoft LIB for MS-DOS, versions 3.1, 3.11, 3.17, 3.18, 3.2,
   3.20.010, 3.31, and 3.4
<LI>Microsoft LIB for OS/2, versions 3.1, 3.11, 3.17, 3.2
</UL> 
<P>
<P><h2>SUMMARY</h2>
 
<P>
The last part of each library produced by the Microsoft Library
Manager (LIB) contains a dictionary that holds all the public symbols
in the library. The hashing algorithm mentioned on page 63 of the
"Microsoft C Developer's Toolkit Reference" is used to place data in
the dictionary. The code required to implement the hashing algorithm
is shown at the end of this article.
<P>
<P><h2>MORE INFORMATION</h2>
 
<P>
The library dictionary is divided into pages that are 512 bytes long.
Each page starts with a 37-byte bucket table, which contains 37
separate offsets to the symbols in the rest of the page. The values in
the buckets are multiplied by 2 to get the actual offset (since 1 byte
can contain only 256 different values).
<P>
The hashing algorithm analyzes a symbol's name and produces two
indexes (page index and bucket index) and two deltas (page index delta
and bucket index delta). Using the offset contained in the bucket at
bucket index in the page at page index, you must compare the symbol at
that location with the one you are looking for.
<P>
If (due to symbol collision) you have not found the correct symbol,
add the bucket index delta to the current bucket index, modulo 37, and
try again. Continue until all the buckets in the current page are
tried. Then, add the page index delta to the current page, modulo by
the page count, and try all the buckets in that page starting at
bucket index. Continue this process until all of the possible page and
offset combinations have been tried.
<P>
For more information on the actual format of the symbols in the
dictionary, and information on the format for the rest of the library,
see the "Microsoft C Developer's Toolkit Reference."
<P>
<P><h3>Sample Code</h3>
 
<P>
<PRE>/* This code illustrates the hashing algorithm used by LIB */

/* Compile options needed: none
*/

#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;malloc.h&gt;
#include &lt;stdlib.h&gt;

#define XOR ^
#define MODULO %

char *symbol;        /* Symbol to find (or to place) */
int dictlength;      /* Dictionary length in pages   */
int buckets;         /* Number of buckets on one page */

char *pb;            /* A pointer to the beginning of the symbol */
char *pe;            /* A pointer to the end of the symbol */
int slength;         /* Length of the symbol's name */

int page_index;         /* Page Index */
int page_index_delta;   /* Page Index Delta */
int bucket_index;       /* Bucket Index */
int bucket_index_delta; /* Bucket Index Delta */

</PRE>unsigned c;
<P>
<PRE>void hash(void)
</PRE>{
<PRE>   page_index = 0;
   page_index_delta = 0;
   bucket_index = 0;
   bucket_index_delta = 0;

   while( slength--)
   {
      c = *(pb++) | 32;        /* Convert character to lower case */
      page_index = (page_index&lt;&lt;2) XOR c;                 /* Hash */
      bucket_index_delta = (bucket_index_delta&gt;&gt;2) XOR c; /* Hash */
      c = *(pe--) | 32;
      bucket_index = (bucket_index&gt;&gt;2) XOR c;             /* Hash */
      page_index_delta = (page_index_delta&lt;&lt;2) XOR c;     /* Hash */
   }
   /* Calculate page index  */
   page_index = page_index MODULO dictlength;

   /* Calculate page index delta */
   if( (page_index_delta = page_index_delta MODULO dictlength) == 0)
      page_index_delta = 1;

   /* Calculate bucket offset */
      bucket_index = bucket_index MODULO buckets;

   /* Calculate bucket offset delta */
   if( (bucket_index_delta = bucket_index_delta MODULO buckets) == 0)
      bucket_index_delta = 1;
</PRE>}
<P>
<PRE>void main(void)
</PRE>{
<PRE>   int i;
   dictlength = 3;
   buckets = 37;
   if ( (symbol = (char *) malloc( sizeof(char) * 4 )) == NULL )
      exit(1);

   strcpy( symbol, "one");

   for( i = 0; i &lt; 2; i++ )
   {
      slength = strlen(symbol);
      pb = symbol;
      pe = symbol + slength ;
      hash();
      printf("\npage_index:  %2d   page_index_delta:  %d",
      page_index, page_index_delta);
      printf("\nbucket_index: %2d   bucket_index_delta: %d",
      bucket_index, bucket_index_delta);
      strcpy( symbol, "two");
   }
</PRE>}
<P>

	</FONT>
	</TD>
	</TR>
</TABLE>
<P>


<!--DOCBODY_END-->

<!--FOOTER_START-->
<table cellpadding=5 border=0 width="90%">
<tr>
<td>
	<HR WIDTH="90%">

<BLOCKQUOTE>
<FONT FACE="Verdana, Arial, Helvetica" SIZE="1">
<SPAN STYLE="font-family:verdana,arial,helvetica; font-size:8pt">
Additional reference words: kbinf 3.10 3.20<BR>
KBCategory: kbtool kbcode<BR>
KBSubcategory: LibIss<BR>
Keywords            : kb16bitonly<BR>

</SPAN>
</FONT>
<BR>
<BR>
THE INFORMATION PROVIDED IN THE MICROSOFT KNOWLEDGE BASE IS
PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND.  MICROSOFT DISCLAIMS
ALL WARRANTIES, EITHER EXPRESS OR IMPLIED, INCLUDING THE WARRANTIES
OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  IN NO
EVENT SHALL MICROSOFT CORPORATION OR ITS SUPPLIERS BE LIABLE FOR
ANY DAMAGES WHATSOEVER INCLUDING DIRECT, INDIRECT, INCIDENTAL,
CONSEQUENTIAL, LOSS OF BUSINESS PROFITS OR SPECIAL DAMAGES, EVEN IF
MICROSOFT CORPORATION OR ITS SUPPLIERS HAVE BEEN ADVISED OF THE
POSSIBILITY OF SUCH DAMAGES.  SOME STATES DO NOT ALLOW THE EXCLUSION
OR LIMITATION OF LIABILITY FOR CONSEQUENTIAL OR INCIDENTAL DAMAGES
SO THE FOREGOING LIMITATION MAY NOT APPLY.
</BLOCKQUOTE>
<P>
<center>
	<FONT FACE="Verdana,Arial,Helvetica" SIZE="1">
	Last reviewed:  July 17, 1997</FONT>
	<BR>
	<A href="../cpyright.htm" STYLE="font: bold 7pt Verdana,Arial,Helvetica">&copy; 1998 Microsoft Corporation. All rights reserved. Terms of Use.</A><BR>
	
</center>
</td>
</tr>
</table>

<!--FOOTER_END-->
</FONT>
</BODY>
</HTML>
