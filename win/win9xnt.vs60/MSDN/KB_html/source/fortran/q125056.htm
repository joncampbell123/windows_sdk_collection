

<HTML>
<HEAD>
<TITLE>INFO: Precision and Accuracy in Floating-Point Calculations </TITLE>

<!--STYLE_BEGIN-->
<style>@import url(../../msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="../../msdn_ie3.css">
<!--STYLE_END-->

<META HTTP-EQUIV="CONTENT-Type" CONTENT="text/html; charset=us-ascii">
<META NAME="ms.locale" CONTENT="EN-US">
<META NAME="Category" CONTENT="Support; KB Article">
<META NAME="KBID" CONTENT="Q125056">
<META NAME="KBModify" CONTENT="1997/10/03">
<META NAME="KBCreate" CONTENT="1995/01/19">
<META NAME="Keywords" CONTENT="CLngIss FORTLngIss kbcode">
<META NAME="KBArea" CONTENT="Support; KB; fortran">
<META NAME="Description" CONTENT="  There are many situations in which precision, rounding, and accuracy in floating-point calculations can work to generate results that are surprising to the programmer. There are four general rules that should be followed:  1. In a calculation invol...">
<META NAME="Product" CONTENT="Fortran">
<META NAME="Platform" CONTENT="Windows">
<META NAME="Technology" CONTENT=" ">
<META NAME="Premium" CONTENT="support">

<META NAME="nyms" CONTENT="QBE6,QBE7,QAGN,QAOX,QAHH,QAKJ,QAPF,QAJQ,QAKC,QAKD,QBFY,QAAP,QAYV,QAML,QAFO V02180118">
</HEAD>

<BODY BGCOLOR="#FFFFFF" LEFTMARGIN="0" RIGHTMARGIN="0" TOPMARGIN="0">


<!--DOCBODY_START-->
<BR>
<CENTER>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" VALIGN="top" WIDTH="90%">
	<TR>
		<TD VALIGN="top">
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<H1>INFO: Precision and Accuracy in Floating-Point Calculations</H1>
			</FONT>
			<FONT FACE="verdana,arial,helvetica" SIZE="1">
			Last reviewed:  October 3, 1997</FONT><BR>
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<B>Article ID: Q125056</B>
			</FONT>
		</TD>
	</TR>
	<TR>
	<TD>
	<FONT FACE="Verdana, Arial, Helvetica" SIZE=2>



 
 
The information in this article applies to:

<UL><LI>Microsoft FORTRAN PowerStation for MS-DOS, versions 1.0, 1.0a
<LI>Microsoft FORTRAN PowerStation 32 for Windows NT, version 1.0
<LI>Microsoft Visual C++ for Windows, versions 1.0, 1.5, 1.51
<LI>Microsoft Visual C++ 32-bit Edition, versions 1.0, 2.0, 4.0, 5.0
</UL> 
<P>
<P><h2>SUMMARY</h2>
 
<P>
There are many situations in which precision, rounding, and accuracy in
floating-point calculations can work to generate results that are
surprising to the programmer. There are four general rules that should be
followed:

<OL><P><LI>In a calculation involving both single and double precision, the result
   will not usually be any more accurate than single precision. If double
   precision is required, be certain all terms in the calculation,
   including constants, are specified in double precision.

<P><LI>Never assume that a simple numeric value is accurately represented in
   the computer. Most floating-point values can't be precisely represented
   as a finite binary value. For example .1 is .0001100110011... in binary
   (it repeats forever), so it can't be represented with complete accuracy
   on a computer using binary arithmetic, which includes all PCs.

<P><LI>Never assume that the result is accurate to the last decimal place.
   There are always small differences between the "true" answer and what
   can be calculated with the finite precision of any floating point
   processing unit.

<P><LI>Never compare two floating-point values to see if they are equal or not-
   equal. This is a corollary to rule 3. There are almost always going to
   be small differences between numbers that "should" be equal. Instead,
   always check to see if the numbers are nearly equal. In other words,
   check to see if the difference between them is very small or
   insignificant.
<P>
</OL><h2>MORE INFORMATION</h2>
 
<P>
In general, the rules described above apply to all languages, including C,
C++, and assembler. The samples below demonstrate some of the rules using
FORTRAN PowerStation. All of the samples were compiled using FORTRAN
PowerStation 32 without any options, except for the last one, which is
written in C.
<P>
Please refer to the FORTRAN manual(s) supplied with Microsoft FORTRAN for a
description of numeric constants, and article <B><A href="../visualc/q36068.htm">Q36068</A></B> for a description of
the internal representation of floating-point values.
<P>
<P><h3>SAMPLE 1</h3>
 
<P>
The first sample demonstrates two things:

<UL><LI>That FORTRAN constants are single precision by default (C constants are
   double precision by default).
<LI>Calculations that contain any single precision terms are not much more
   accurate than calculations in which all terms are single precision.
<P>
</UL>After being initialized with 1.1 (a single precision constant), y is as
inaccurate as a single precision variable.
<P>
<PRE>   x = 1.100000000000000  y = 1.100000023841858

</PRE></OL>The result of multiplying a single precision value by an accurate double
precision value is nearly as bad as multiplying two single precision
values. Both calculations have thousands of times as much error as
multiplying two double precision values.
<P>
<PRE>   true = 1.320000000000000 (multiplying 2 double precision values)
   y    = 1.320000052452087 (multiplying a double and a single)
   z    = 1.320000081062318 (multiplying 2 single precision values)

</PRE><h3>Sample Code</h3>
 
<P>
C Compile options: none
<P>
<PRE>       real*8 x,y,z
       x = 1.1D0
       y = 1.1
       print *, 'x =',x, 'y =', y
       y = 1.2 * x
       z = 1.2 * 1.1
       print *, x, y, z
       end

</PRE><h3>SAMPLE 2</h3>
 
<P>
Sample 2 uses the quadratic equation. It demonstrates that even double
precision calculations are not perfect, and that the result of a
calculation should be tested before it is depended on if small errors can
have drastic results. The input to the square root function in sample 2 is
only very slightly negative, but it is still invalid. If the double
precision calculations did not have slight errors, the result would be:
<P>
<PRE>   Root =   -1.1500000000

</PRE>Instead, it generates the following error:
<P>
<PRE>   run-time error M6201: MATH
   - sqrt: DOMAIN error

</PRE><h3>Sample Code</h3>
 
<P>
C Compile options: none
<P>
<PRE>       real*8 a,b,c,x,y
       a=1.0D0
       b=2.3D0
       c=1.322D0
       x = b**2
       y = 4*a*c
       print *,x,y,x-y
       print "(' Root =',F16.10)",(-b+dsqrt(x-y))/(2*a)
       end

</PRE><h3>SAMPLE 3</h3>
 
<P>
Sample 3 demonstrates that due to optimizations that occur even if
optimization is not turned on, values may temporarily retain a higher
precision than expected, and that it is very unwise to test two floating-
point values for equality.
<P>
In this example, two values are both equal and not equal. At the first IF,
the value of Z is still on the coprocessor's stack and has the same
precision as Y. Therefore X does not equal Y and the first message is
printed out. At the time of the second IF, Z had to be loaded from memory
and therefore had the same precision and value as X, and the second message
also is printed.
<P>
<P><h3>Sample Code</h3>
 
<P>
C Compile options: none
<P>
<PRE>       real*8 y
       y=27.1024D0
       x=27.1024
       z=y
       if (x.ne.z) then
         print *,'X does not equal Z'
       end if
       if (x.eq.z) then
         print *,'X equals Z'
       end if
       end

</PRE><h3>SAMPLE 4</h3>
 
<P>
The first part of sample code 4 calculates the smallest possible difference
between two numbers close to 1.0. It does this by adding a single bit to
the binary representation of 1.0.
<P>
<PRE>   x   = 1.00000000000000000  (one bit more than 1.0)
   y   = 1.00000000000000000  (exactly 1.0)
   x-y =  .00000000000000022  (smallest possible difference)

</PRE>Some versions of FORTRAN round the numbers when displaying them so that the
inherent numerical imprecision is not so obvious. This is why x and y look
the same when displayed.
<P>
The second part of sample code 4 calculates the smallest possible
difference between 2 numbers close to 10.0. Again, it does this by adding a
single bit to the binary representation of 10.0. Notice that the difference
between numbers near 10 is larger than the difference near 1. This
demonstrates the general principle that the larger the absolute value of a
number, the less precisely it can be stored in a given number of bits.
<P>
<PRE>   x   = 10.00000000000000000  (one bit more than 10.0)
   y   = 10.00000000000000000  (exactly 10.0)
   x-y =   .00000000000000178

</PRE>The binary representation of these numbers is also displayed to show that
they do differ by only one bit.
<P>
<PRE>   x = 4024000000000001 Hex
   y = 4024000000000000 Hex

</PRE>The last part of sample code 4 shows that simple nonrepeating decimal
values often can be represented in binary only by a repeating fraction. In
this case x=1.05, which requires a repeating factor CCCCCCCC....(Hex) in
the mantissa. In FORTRAN, the last digit "C" is rounded up to "D" in order
to maintain the highest possible accuracy:
<P>
<PRE>   x = 3FF0CCCCCCCCCCCD (Hex representation of 1.05D0)

</PRE>Even after rounding, the result is not perfectly accurate. There is some
error after the least significant digit, which we can see by removing the
first digit.
<P>
<PRE>   x-1 = .05000000000000004

</PRE><h3>Sample Code</h3>
 
<P>
C Compile options: none
<P>
<PRE>       IMPLICIT real*8 (A-Z)
       integer*4 i(2)
       real*8 x,y
       equivalence (i(1),x)

       x=1.
       y=x
       i(1)=i(1)+1
       print "(1x,'x  =',F20.17,'  y=',f20.17)", x,y
       print "(1x,'x-y=',F20.17)", x-y
       print *

       x=10.
       y=x
       i(1)=i(1)+1
       print "(1x,'x  =',F20.17,'  y=',f20.17)", x,y
       print "(1x,'x-y=',F20.17)", x-y
       print *
       print "(1x,'x  =',Z16,' Hex  y=',Z16,' Hex')", x,y
       print *

       x=1.05D0
       print "(1x,'x  =',F20.17)", x
       print "(1x,'x  =',Z16,' Hex')", x
       x=x-1
       print "(1x,'x-1=',F20.17)", x
       print *

       end

</PRE><h3>SAMPLE 5</h3>
 
<P>
In C, floating constants are doubles by default. Use an "f" to indicate a
float value, as in "89.95f".
<P>
<P><h3>Sample Code</h3>
 
<P>
<PRE>   /* Compile options needed: none
   */

   #include &lt;stdio.h&gt;

   void main()
   {
      float floatvar;
      double doublevar;

   /* Print double constant. */
      printf("89.95 = %f\n", 89.95);      // 89.95 = 89.950000

   /* Printf float constant */
      printf("89.95 = %f\n", 89.95F);     // 89.95 = 89.949997

   /*** Use double constant. ***/
      floatvar = 89.95;
      doublevar = 89.95;

      printf("89.95 = %f\n", floatvar);   // 89.95 = 89.949997
      printf("89.95 = %lf\n", doublevar); // 89.95 = 89.950000

   /*** Use float constant. ***/
      floatvar = 89.95f;
      doublevar = 89.95f;

      printf("89.95 = %f\n", floatvar);   // 89.95 = 89.949997
      printf("89.95 = %lf\n", doublevar); // 89.95 = 89.949997
   }
</PRE> 
<PRE>Keywords          : CLngIss FORTLngIss kbcode
Version           : MS-DOS:1.0,1.00a,1.5,1.51;WINNT:1.0,2.0,4.0,5.0;
Platform          : MS-DOS NT WINDOWS
Issue type        : kbinfo</PRE>

	</FONT>
	</TD>
	</TR>
</TABLE>
<P>


<!--DOCBODY_END-->

<!--FOOTER_START-->
<table cellpadding=5 border=0 width="90%">
<tr>
<td>
	<HR WIDTH="90%">

<BLOCKQUOTE>
<FONT FACE="Verdana, Arial, Helvetica" SIZE="1">
<SPAN STYLE="font-family:verdana,arial,helvetica; font-size:8pt">
================================================================================<BR>

</SPAN>
</FONT>
<BR>
<BR>
THE INFORMATION PROVIDED IN THE MICROSOFT KNOWLEDGE BASE IS
PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND.  MICROSOFT DISCLAIMS
ALL WARRANTIES, EITHER EXPRESS OR IMPLIED, INCLUDING THE WARRANTIES
OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  IN NO
EVENT SHALL MICROSOFT CORPORATION OR ITS SUPPLIERS BE LIABLE FOR
ANY DAMAGES WHATSOEVER INCLUDING DIRECT, INDIRECT, INCIDENTAL,
CONSEQUENTIAL, LOSS OF BUSINESS PROFITS OR SPECIAL DAMAGES, EVEN IF
MICROSOFT CORPORATION OR ITS SUPPLIERS HAVE BEEN ADVISED OF THE
POSSIBILITY OF SUCH DAMAGES.  SOME STATES DO NOT ALLOW THE EXCLUSION
OR LIMITATION OF LIABILITY FOR CONSEQUENTIAL OR INCIDENTAL DAMAGES
SO THE FOREGOING LIMITATION MAY NOT APPLY.
</BLOCKQUOTE>
<P>
<center>
	<FONT FACE="Verdana,Arial,Helvetica" SIZE="1">
	Last reviewed:  October 3, 1997</FONT>
	<BR>
	<A href="../cpyright.htm" STYLE="font: bold 7pt Verdana,Arial,Helvetica">&copy; 1998 Microsoft Corporation. All rights reserved. Terms of Use.</A><BR>
	
</center>
</td>
</tr>
</table>

<!--FOOTER_END-->
</FONT>
</BODY>
</HTML>
