

<HTML>
<HEAD>
<TITLE>BUG: StretchDIBits() Prints Wrong Part of DIB with PSCRIPT.DRV </TITLE>

<!--STYLE_BEGIN-->
<style>@import url(../../msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="../../msdn_ie3.css">
<!--STYLE_END-->

<META HTTP-EQUIV="CONTENT-Type" CONTENT="text/html; charset=us-ascii">
<META NAME="ms.locale" CONTENT="EN-US">
<META NAME="Category" CONTENT="Support; KB Article">
<META NAME="KBID" CONTENT="Q100354">
<META NAME="KBModify" CONTENT="1997/07/23">
<META NAME="KBCreate" CONTENT="1993/06/20">
<META NAME="Keywords" CONTENT="GdiPrn kb16bitonly kbbuglist kbprg kbprint kbtool">
<META NAME="KBArea" CONTENT="Support; KB; win16sdk">
<META NAME="Description" CONTENT="  When using StretchDIBits() to print a section of a device-independent bitmap (DIB) with the Windows version 3.1 PostScript printer driver, in some cases the wrong part of the DIB is printed. When printing the entire DIB, StretchDIBits() works corre...">
<META NAME="Product" CONTENT="Win16 SDK">
<META NAME="Platform" CONTENT="Windows">
<META NAME="Technology" CONTENT=" ">
<META NAME="Premium" CONTENT="support">

<META NAME="nyms" CONTENT="QAH2,QAOX,QDL9,QBWO,QBWN,QAO3,QAO2,QADF,QAKC,QA4Q,QAK4,QBWQ,QBC6,QALG,QAAP V02180118">
</HEAD>

<BODY BGCOLOR="#FFFFFF" LEFTMARGIN="0" RIGHTMARGIN="0" TOPMARGIN="0">


<!--DOCBODY_START-->
<BR>
<CENTER>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" VALIGN="top" WIDTH="90%">
	<TR>
		<TD VALIGN="top">
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<H1>BUG: StretchDIBits() Prints Wrong Part of DIB with PSCRIPT.DRV</H1>
			</FONT>
			<FONT FACE="verdana,arial,helvetica" SIZE="1">
			Last reviewed:  July 23, 1997</FONT><BR>
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<B>Article ID: Q100354</B>
			</FONT>
		</TD>
	</TR>
	<TR>
	<TD>
	<FONT FACE="Verdana, Arial, Helvetica" SIZE=2>



 
3.10
WINDOWS
kbtool kbprint kbprg kbbuglist
<P>
 
The information in this article applies to:

<UL><LI>Microsoft Windows Software Development Kit (SDK) version 3.1
</UL> 
<P>
<P><h2>SYMPTOMS</h2>
 
<P>
When using StretchDIBits() to print a section of a device-independent
bitmap (DIB) with the Windows version 3.1 PostScript printer driver,
in some cases the wrong part of the DIB is printed. When printing the
entire DIB, StretchDIBits() works correctly.
<P>
<P><h2>STATUS</h2>
 
<P>
Microsoft has confirmed this to be a bug in version 3.5 of the PostScript
printer driver (PSCRIPT.DRV) that shipped with Windows 3.1. The problem
also occurs with version 3.55 of the PostScript driver that is currently
available in the Windows Driver Library (WDL).
<P>
<P><h2>MORE INFORMATION</h2>
 
<P>
Below is the function prototype for StretchDIBits():
<P>
<PRE>int StretchDIBits(hdc, XDest, YDest, cxDest, cyDest, XSrc, YSrc, cxSrc,
                  cySrc, lpvBits, lpbmi, fuColorUse, fdwRop)
HDC hdc;                      // Handle of device context
int XDest;                    // X-coordinate of destination rectangle
int YDest;                    // Y-coordinate of destination rectangle
int cxDest;                   // Width of destination rectangle
int cyDest;                   // Height of destination rectangle
int XSrc;                     // X-coordinate of source rectangle
int YSrc;                     // Y-coordinate of source rectangle
int cxSrc;                    // Width of source rectangle
int cySrc;                    // Height of source rectangle
const void FAR* lpvBits;      // Address of buffer with DIB bits
LPBITMAPINFO lpbmi;           // Address of structure with bitmap data
UINT fuColorUse;              // RGB or palette indices
DWORD fdwRop;                 // Raster operation

</PRE>To print the entire DIB, set both XSrc and YSrc to 0 (zero). This
starting location of (0,0) corresponds to the bottom-left corner of
the DIB. If you do not want to print the bottom portion of the DIB,
change the starting location. Typically, you increase YSrc to the
desired value and leave XSrc at 0 (as well as adjusting cySrc
appropriately) so that the starting location is at the beginning of a
scan line in the DIB. If the value of YSrc is such that the distance
from the beginning of the DIB to (XSrc, YSrc) crosses a 64K segment
boundary, the wrong part of the DIB will be printed.
<P>
To print the top section of the DIB, the printer driver must adjust
lpvBits, the pointer to the DIB bits. Unfortunately, the segment
portion of the huge pointer to the DIB bits is not incremented
correctly; only the offset portion is incremented. Because the pointer
to the DIB bits is not adjusted correctly, it points to the wrong
section of the DIB bits and the wrong part of the DIB is printed.
<P>
Until the printer driver is fixed, application developers should
themselves adjust the pointer to the DIB bits. The values of the
biHeight and biSizeImage fields in the BITMAPINFOHEADER also must be
adjusted accordingly. All the necessary code to calculate the new
value for lpvBits can be obtained from the sample program DIBVIEW or
WINCAP.
<P>
For example:
<P>
<PRE> // PaletteSize() and WIDTHBYTES can be found in either DIBVIEW or WINCAP

 LPBITMAPINFOHEADER lpDIBHdr;  // Pointer to BITMAPINFO struct
                               // casted to LPBITMAPINFOHEADER
 LPSTR lpDIBBits;              // Pointer to DIB bits
 char _huge *lpTempDIBBits;    // IMPORTANT - must be a huge pointer
 DWORD  dwPalSize;             // Number of bytes in DIB color table
 DWORD  dwNumBytes;            // Number of bytes from beginning of DIB
                               // bits to (0, YSrc)
 DWORD  dwSize;                // Number of bytes from beginning of DIB
                               // to (0, YSrc)
 DWORD  dwSaveHeight;          // Save original DIB biHeight
 DWORD  dwSaveSizeImage;       // Save original DIB biSizeImage
...

 // Number of bytes in the DIB's color table.
 dwPalSize = PaletteSize((LPSTR)lpDIBHdr);

 // WIDTHBYTES calculates the number of bytes in one scan line.
 // dwNumBytes is the number of bytes from the beginning of the DIB
 // bits to the location (0, YSrc) in the DIB.
 dwNumBytes = YSrc * WIDTHBYTES(lpDIBHdr-&gt;biWidth * lpDIBHdr-&gt;biBitCount);

 // dwSize is the number of bytes from the beginning of the DIB to
 // the location (0, YSrc) in the DIB.
 dwSize = dwNumBytes + dwPalSize + (DWORD)sizeof(BITMAPINFOHEADER);

 if (dwSize &gt;= 65536)
 {
    // Carefully adjust the pointer to the DIB bits.
    // Important Note: Due to problems with versions 6.0 and 7.0
    // of the Microsoft C Compiler, manipulating the pointer in one
    // statement may result in the segment portion of the huge pointer
    // being adjusted incorrectly or not at all.
    lpTempDIBBits = (char huge *)lpDIBBits;
    lpTempDIBBits = lpTempDIBBits + dwNumBytes;
    dwSaveHeight =  lpDIBHdr-&gt;biHeight;
    dwSaveSizeImage =  lpDIBHdr-&gt;biSizeImage;
    lpDIBHdr-&gt;biHeight -=YSrc;
    lpDIBHdr-&gt;biSizeImage= WIDTHBYTES(lpDIBHdr-&gt;biWidth *
                                      lpDIBHdr-&gt;biBitCount) *
                                      lpDIBHdr-&gt;biHeight;
    Ysrc = 0;
 }

 if (!StretchDIBits (hDC,                           // DestDC
                     XDest,
                     YDest,
                     DestWidth,
                     DestHeight,
                     XSrc,
                     YSrc,
                     SrcWidth,
                     SrcHeight,
                     lpTempDIBBits,                 // DIB bits
                     (LPBITMAPINFO) lpDIBHdr,
                     DIB_RGB_COLORS,                // wUsage
                     SRCCOPY))                      // dwROP
    dwError |= ERR_PRN_STRETCHDIBITS;

 if (dwSize &gt;= 65536)
 {
    lpDIBHdr-&gt;biHeight = dwSaveHeight;
    lpDIBHdr-&gt;biSizeImage = dwSaveSizeImage;
 }

</PRE>For additional information on WINCAP, please see the following article in
the Microsoft Knowledge Base:
<P>
<PRE>   ARTICLE-ID: <B><A href="../win16sdk/q97193.htm">Q97193</A></B>
   TITLE     : SAMPLE: WINCAP Captures Screens Using DIB API

</PRE>DIBVIEW can be found in the SAMPLES directory of version 3.1 of the
Windows Software Development Kit (SDK) and Visual C++ for Windows.
<P>
This is not an issue with Windows 95.
<P>

	</FONT>
	</TD>
	</TR>
</TABLE>
<P>


<!--DOCBODY_END-->

<!--FOOTER_START-->
<table cellpadding=5 border=0 width="90%">
<tr>
<td>
	<HR WIDTH="90%">

<BLOCKQUOTE>
<FONT FACE="Verdana, Arial, Helvetica" SIZE="1">
<SPAN STYLE="font-family:verdana,arial,helvetica; font-size:8pt">
Additional reference words: 3.10 buglist3.10<BR>
KBCategory: kbtool kbprint kbprg kbbuglist<BR>
KBSubcategory: GdiPrn<BR>
Keywords            : GdiPrn kb16bitonly kbbuglist kbprg kbprint kbtool<BR>
Version             : 3.10<BR>
Platform            : WINDOWS<BR>

</SPAN>
</FONT>
<BR>
<BR>
THE INFORMATION PROVIDED IN THE MICROSOFT KNOWLEDGE BASE IS
PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND.  MICROSOFT DISCLAIMS
ALL WARRANTIES, EITHER EXPRESS OR IMPLIED, INCLUDING THE WARRANTIES
OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  IN NO
EVENT SHALL MICROSOFT CORPORATION OR ITS SUPPLIERS BE LIABLE FOR
ANY DAMAGES WHATSOEVER INCLUDING DIRECT, INDIRECT, INCIDENTAL,
CONSEQUENTIAL, LOSS OF BUSINESS PROFITS OR SPECIAL DAMAGES, EVEN IF
MICROSOFT CORPORATION OR ITS SUPPLIERS HAVE BEEN ADVISED OF THE
POSSIBILITY OF SUCH DAMAGES.  SOME STATES DO NOT ALLOW THE EXCLUSION
OR LIMITATION OF LIABILITY FOR CONSEQUENTIAL OR INCIDENTAL DAMAGES
SO THE FOREGOING LIMITATION MAY NOT APPLY.
</BLOCKQUOTE>
<P>
<center>
	<FONT FACE="Verdana,Arial,Helvetica" SIZE="1">
	Last reviewed:  July 23, 1997</FONT>
	<BR>
	<A href="../cpyright.htm" STYLE="font: bold 7pt Verdana,Arial,Helvetica">&copy; 1998 Microsoft Corporation. All rights reserved. Terms of Use.</A><BR>
	
</center>
</td>
</tr>
</table>

<!--FOOTER_END-->
</FONT>
</BODY>
</HTML>
