

<HTML>
<HEAD>
<TITLE>SAMPLE: Infinite Loop When Moving Through Dialog Box Control </TITLE>

<!--STYLE_BEGIN-->
<style>@import url(../../msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="../../msdn_ie3.css">
<!--STYLE_END-->

<META HTTP-EQUIV="CONTENT-Type" CONTENT="text/html; charset=us-ascii">
<META NAME="ms.locale" CONTENT="EN-US">
<META NAME="Category" CONTENT="Support; KB Article">
<META NAME="KBID" CONTENT="Q92905 ">
<META NAME="KBModify" CONTENT="1996/02/15">
<META NAME="KBCreate" CONTENT="1992/11/17">
<META NAME="Keywords" CONTENT="kbprg kbfile">
<META NAME="KBArea" CONTENT="Support; KB; win16sdk">
<META NAME="Description" CONTENT="  An application enters an infinite loop when you use the TAB or arrow keys to navigate through dialog box controls. The problem occurs only when the dialog box has another dialog box as a child. When you use the TAB key, the problem occurs only when...">
<META NAME="Product" CONTENT="Win16 SDK">
<META NAME="Platform" CONTENT="Windows">
<META NAME="Technology" CONTENT=" ">
<META NAME="Premium" CONTENT="support">

<META NAME="nyms" CONTENT="QA01,QA7O,QAB5,QAOE,QAMN,QAML,QADO,QANX,QAEV,QAH6,QAK3,QAIB,QAZB,QAKP,QBSO V02180118">
</HEAD>

<BODY BGCOLOR="#FFFFFF" LEFTMARGIN="0" RIGHTMARGIN="0" TOPMARGIN="0">


<!--DOCBODY_START-->
<BR>
<CENTER>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" VALIGN="top" WIDTH="90%">
	<TR>
		<TD VALIGN="top">
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<H1>SAMPLE: Infinite Loop When Moving Through Dialog Box Control</H1>
			</FONT>
			<FONT FACE="verdana,arial,helvetica" SIZE="1">
			Last reviewed:  February 15, 1996</FONT><BR>
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<B>Article ID: Q92905 </B>
			</FONT>
		</TD>
	</TR>
	<TR>
	<TD>
	<FONT FACE="Verdana, Arial, Helvetica" SIZE=2>



 
The information in this article applies to:

<UL><LI>Microsoft Windows Software Development Kit (SDK) for Windows
   version 3.1
</UL> 
<P>
<P><h2>SUMMARY</h2>
 
<P>
An application enters an infinite loop when you use the TAB or arrow keys
to navigate through dialog box controls. The problem occurs only when the
dialog box has another dialog box as a child. When you use the TAB key, the
problem occurs only when the child dialog box has the WS_MAXIMIZEBOX or
WS_TABSTOPS style.
<P>
This article describes the problem in detail together with two possible
solutions. A sample is also provided that demonstrates the problem and one
of the workarounds.
<P>
<P><h2>SYMPTOMS</h2>
 
<P>
<P><h3>Problem 1</h3>
 
<P>
When arrow keys are used to maneuver through a dialog box's last control
(the last control in the parent dialog box), the focus is passed to the
next child (in this case, the child dialog box) and the application goes
into an infinite loop.
<P>
<P><h3>Problem 2</h3>
 
<P>
When the TAB key is used to maneuver through the dialog box's last control,
the focus is then passed to the next child (again the child dialog box) and
the application goes into an infinite loop.
<P>
The infinite loop is clearly visible when spying on the child dialog box
window. The child dialog box window continually receives WM_GETDLGCODE
messages.
<P>
<P><h2>CAUSE</h2>
 
<P>
The dialog box manager confuses the child dialog box window with a child
control.
<P>
When maneuvering through controls in a dialog box, the dialog box
manager looks through its children and checks for the next child to pass
focus to. In order to do that, the dialog box manager sets the focus to
the child control and generates messages to complete the process.
<P>
<P><h3>Using the Arrow Keys to Navigate Through Controls</h3>
 
<P>
WS_GROUP defines the start of a group within a dialog box. All controls
defined between two WS_GROUP styles are members of a group. Arrow keys can
then be used to navigate between members of a group.
<P>
Normally a dialog box does not have WS_GROUP for a style; therefore, the
child dialog box does not have a WS_GROUP but a previous control does have
one. Based on the definition of a group, the child dialog box is considered
a member of the last group by the dialog box manager. When the arrow key is
used on the last control, the dialog box manager checks for the next child
control in that group to pass the focus to, in this case the child dialog
box window. The dialog box manager then tries to set focus to the window
and generates necessary messages to complete the process. These generated
messages are meaningful to a control but not to a window. One of these
generated messages is WM_GETDLGCODE, which causes the infinite loop.
<P>
<P><h3>Using the TAB Key to Navigate Through Controls</h3>
 
<P>
WS_TABSTOPS defines which control has a tab stop. When you tab through
controls, the dialog box manager looks for the next child that has the
WS_TABSTOPS style and changes the focus to that child.
<P>
Normally a dialog box does not use WS_TABSTOPS for a style. It is quite
normal, however, to use WS_MAXIMIZEBOX for a dialog box style. The child
dialog box in this case has WS_MAXIMIZEBOX. The values for WS_TABSTOPS and
WS_MAXIMIZEBOX are the same in WINDOWS.H. Because the dialog box manager
expects a child control and not another window, the WS_MAXIMIZEBOX is
interpreted as WS_TABSTOPS. So, when you tab on the last control of the
parent dialog box, the dialog box manager tries to set the focus to the
next child with WS_TABSTOPS, in this case the child dialog box. Then the
dialog box manager generates the necessary messages to complete the
process. These generated messages are meaningful to a control but not to a
window. One of these messages is WM_GETDLGCODE, which causes the infinite
loop.
<P>
<P><h2>RESOLUTION</h2>
 
<P>
Workarounds are described in the MORE INFORMATION section below.
<P>
<P><h2>MORE INFORMATION</h2>
 

<UL><LI>Do not include the WS_MAXIMIZEBOX style for the child dialog box to
   resolve the TAB key problem, and add WS_GROUP to the child dialog box to
   resolve the arrow key problem.

<LI>Subclass the last control and handle the change of focus in the dialog
   box. This method is outlined below:
<P>
   1. Subclass the last control in the parent dialog box.
<P>
   2. In the subclass procedure for the control, process the WM_GETDLGCODE
<P><PRE>      message by:
</PRE><P>
<P><PRE>      a. Passing the WM_GETDLGCODE to the button window procedure.
      b. Or'ing the return value of (a.) with DLGC_WANTMESSAGE and
<PRE></PRE>         returning it.

      The following is sample code demonstrating the WM_GETDLGCODE message:

         lpButtonProcOrg is a pointer to the button window
         procedure. This is a global and was set before setting
         the pointer to the subclass procedure for the button.
         To do this call:

                  lpButtonProgOrg = (FARPROC)
                  GetWindowLong(GetDlgItem(hCancelBtn,GWL_WNDPROC);
                  :
                  :

           case WM_GETDLGCODE:
             lRet = CallWindowProc(lpButtonProcOrg,hWnd,iMessage,
                                   wParam,lParam);
             if (lParam)
               {
               lpmsg= (LPMSG) lParam;
               if (lpmsg-&gt;message == WM_KEYDOWN)
                {
                if ( (lpmsg-&gt;wParam == VK_TAB)   ||
                     (lpmsg-&gt;wParam == VK_DOWN)  ||
                     (lpmsg-&gt;wParam == VK_UP)    ||
                     (lpmsg-&gt;wParam == VK_RIGHT) ||
                     (lpmsg-&gt;wParam == VK_LEFT) )
                  lRet |= DLGC_WANTMESSAGE;
                }
               }
             return (lRet);

      For more information on WM_GETDLGCODE, please see the following
      article in the Microsoft Knowledge Base:

         ARTICLE-ID: <B><A href="../win16sdk/q83302.htm">Q83302</A></B>
         TITLE     : Using the WM_GETDLGCODE Message

   3. In the subclass procedure, process the WM_KEYDOWN message by:

      a. Set the focus to the first control.
      b. If the first control is not a push button, then the process is
         complete; otherwise, the dark border needs to be removed from
         whichever button that has it, and placed on the first button, as
         follows:

         1) First send a WM_GETDLGCODE.

         2) If the return value is DLGC_DEFPUSHBUTTON, then send a
            BM_SETSTYLE message to the button that has the dark border,
            with BS_PUSHBUTTON for wParam. This will cause the dark border
            to be removed.

         3) Now the dark border needs to be placed on the button that has
            the focus (that is, the first button). To do this, send
            BM_SETSTYLE to the first button, with BS_DEFPUSHBUTTON for
            wParam.

      Sample Code Demonstrating the WM_KEYDOWN Message
      ------------------------------------------------

         case WM_KEYDOWN:

            // Check for keys that need this processing such as the
            // TAB and arrow keys.
            if ( (wParam == VK_TAB)   ||
                 (wParam == VK_DOWN)  || (wParam == VK_UP) ||
                 (wParam == VK_RIGHT) || (wParam == VK_LEFT) )
               {
               // Set the focus to the first control, Button #1
               // in this case.
               hwndBtn1 = GetDlgItem(hParentDlg,IDBUTTON1);
               SetFocus(hwndBtn1);

               // Loop through all the controls and remove the
               // dark border that the previous default push
               // button has.
               hwndCtrls = GetWindow(hParentDlg, GW_CHILD);
               while (hwndCtrls)
                   {
                   wRet = (WORD)(DWORD)SendMessage(hwndCtrls,
                                           WM_GETDLGCODE, 0, 0L);

                  if (wRet &amp; DLGC_DEFPUSHBUTTON)
                    SendMessage(hwndCtrls, BM_SETSTYLE,
                               (WPARAM)BS_PUSHBUTTON, TRUE);

                  hwndCtrls = GetWindow(hwndCtrls, GW_HWNDNEXT);
                  }

              // Give the hwndBtn1 button the default push button
              // border.
               SendMessage(hwndBtn1,  BM_SETSTYLE,
                           (WPARAM)BS_DEFPUSHBUTTON, TRUE);

               return(0L);
               }

            break;

</PRE></UL>DLGTAB is a file in the Microsoft Software Library that demonstrates both
the TAB and ARROW key problems, together with the second method of
resolving the problem, which is listed above.
<P>
Download DLGTAB.EXE, a self-extracting file, from the Microsoft Software
Library (MSL) on the following services:

<UL><LI>Microsoft Download Service (MSDL)
<P><PRE>      Dial (206) 936-6735 to connect to MSDL
      Download <A href="http://support.microsoft.com/download/support/mslfiles/dlgtab.exe">DLGTAB.EXE</A> <I>(size: 32946 bytes)</I> 
</PRE>
<LI>Internet (anonymous FTP)
<P><PRE>      ftp ftp.microsoft.com
      Change to the \SOFTLIB\MSLFILES directory
      Get <A href="http://support.microsoft.com/download/support/mslfiles/dlgtab.exe">DLGTAB.EXE</A> <I>(size: 32946 bytes)</I> 
</PRE><P>
</UL>To get the dialog boxes, from the File menu, choose Dialog Tab. Two dialog
boxes will be displayed: one is the Parent dialog box and the other is the
Child dialog box.
<P>
There are two option buttons in the Parent dialog box: one demonstrates the
problem and the other the solution. When the Demo Problem option button is
selected, the sample demonstrates the problem. When the Fix Problem option
button is selected, the sample demonstrates the workaround. The default
button is the workaround for the problem.
<P>

	</FONT>
	</TD>
	</TR>
</TABLE>
<P>


<!--DOCBODY_END-->

<!--FOOTER_START-->
<table cellpadding=5 border=0 width="90%">
<tr>
<td>
	<HR WIDTH="90%">

<BLOCKQUOTE>
<FONT FACE="Verdana, Arial, Helvetica" SIZE="1">
<SPAN STYLE="font-family:verdana,arial,helvetica; font-size:8pt">
Additional reference words: 3.10 softlib DLGTAB.EXE<BR>
KBCategory: kbprg kbfile<BR>
KBSubcategory: UsrDlgs<BR>

</SPAN>
</FONT>
<BR>
<BR>
THE INFORMATION PROVIDED IN THE MICROSOFT KNOWLEDGE BASE IS
PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND.  MICROSOFT DISCLAIMS
ALL WARRANTIES, EITHER EXPRESS OR IMPLIED, INCLUDING THE WARRANTIES
OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  IN NO
EVENT SHALL MICROSOFT CORPORATION OR ITS SUPPLIERS BE LIABLE FOR
ANY DAMAGES WHATSOEVER INCLUDING DIRECT, INDIRECT, INCIDENTAL,
CONSEQUENTIAL, LOSS OF BUSINESS PROFITS OR SPECIAL DAMAGES, EVEN IF
MICROSOFT CORPORATION OR ITS SUPPLIERS HAVE BEEN ADVISED OF THE
POSSIBILITY OF SUCH DAMAGES.  SOME STATES DO NOT ALLOW THE EXCLUSION
OR LIMITATION OF LIABILITY FOR CONSEQUENTIAL OR INCIDENTAL DAMAGES
SO THE FOREGOING LIMITATION MAY NOT APPLY.
</BLOCKQUOTE>
<P>
<center>
	<FONT FACE="Verdana,Arial,Helvetica" SIZE="1">
	Last reviewed:  February 15, 1996</FONT>
	<BR>
	<A href="../cpyright.htm" STYLE="font: bold 7pt Verdana,Arial,Helvetica">&copy; 1998 Microsoft Corporation. All rights reserved. Terms of Use.</A><BR>
	
</center>
</td>
</tr>
</table>

<!--FOOTER_END-->
</FONT>
</BODY>
</HTML>
