

<HTML>
<HEAD>
<TITLE>How to Move Data Between Large Overlapping Buffers </TITLE>

<!--STYLE_BEGIN-->
<style>@import url(../../msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="../../msdn_ie3.css">
<!--STYLE_END-->

<META HTTP-EQUIV="CONTENT-Type" CONTENT="text/html; charset=us-ascii">
<META NAME="ms.locale" CONTENT="EN-US">
<META NAME="Category" CONTENT="Support; KB Article">
<META NAME="KBID" CONTENT="Q117743">
<META NAME="KBModify" CONTENT="1997/07/23">
<META NAME="KBCreate" CONTENT="1994/07/06">
<META NAME="Keywords" CONTENT="kb16bitonly">
<META NAME="KBArea" CONTENT="Support; KB; win16sdk">
<META NAME="Description" CONTENT="  Programmers often need to move large amounts of data between buffers in their applications. The Microsoft Windows version 3.1 API and the Microsoft C Run Time library provide several functions to let you copy and move data between buffers. However,...">
<META NAME="Product" CONTENT="Win16 SDK">
<META NAME="Platform" CONTENT="Windows">
<META NAME="Technology" CONTENT=" ">
<META NAME="Premium" CONTENT="support">

<META NAME="nyms" CONTENT="QA9N,QAGX,QAYV,QAU3,QAMR,QAK6,QAFH,QANJ,QAEF,QDL9,QBWO,QBWN,QAW9,QASB,QACI V02180118">
</HEAD>

<BODY BGCOLOR="#FFFFFF" LEFTMARGIN="0" RIGHTMARGIN="0" TOPMARGIN="0">


<!--DOCBODY_START-->
<BR>
<CENTER>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" VALIGN="top" WIDTH="90%">
	<TR>
		<TD VALIGN="top">
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<H1>How to Move Data Between Large Overlapping Buffers</H1>
			</FONT>
			<FONT FACE="verdana,arial,helvetica" SIZE="1">
			Last reviewed:  July 23, 1997</FONT><BR>
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<B>Article ID: Q117743</B>
			</FONT>
		</TD>
	</TR>
	<TR>
	<TD>
	<FONT FACE="Verdana, Arial, Helvetica" SIZE=2>



 
3.10
WINDOWS
kbprg
<P>
 
The information in this article applies to:

<UL><LI>Microsoft Windows Software Development Kit (SDK) for Windows,
   version 3.1
</UL> 
<P>
<P><h2>SUMMARY</h2>
 
<P>
Programmers often need to move large amounts of data between buffers in
their applications. The Microsoft Windows version 3.1 API and the Microsoft
C Run Time library provide several functions to let you copy and move data
between buffers. However, none of these functions guarantees that data
larger than 64K can be moved safely between buffers that overlap. This
article lists a C function based on the hmemcpy() Windows version 3.1
function to accomplish this job.
<P>
<P><h2>MORE INFORMATION</h2>
 
<P>
For example, the functions hmemcpy() and MemoryWrite() handle buffers
greater than 64K, but do not guarantee that data can be safely moved
between overlapping buffers. The function _fmemmove() guarantees that data
can be safely moved between overlapping buffers, but does not handle more
than 64K.
<P>
Below is a C function that provides that functionality. It recognizes and
covers the four cases that arise while moving data. The four cases are:

<UL><LI>The source and the destination are identical.
<P>
   -or-

<LI>The source and the destination do not overlap.
<P>
   -or-

<LI>The source and the destination overlap and the source starts at a
   location before the destination in the address space.
<P>
   -or-

<LI>The source and the destination overlap and the source starts at a
   location after the destination in the address space.
<P>
</UL>Cases 1 and 2 are easy to handle, as seen in the sample code below. In
cases 3 and 4, the address space must be divided into smaller units so that
the data can be moved in small chunks, thus better ensuring the integrity
of the data. In the best case, cases 3 and 4 require only two calls to
hmemcpy(). In the worst case, cases 3 and 4 require "len" number of calls
to hmemcpy(), where len is the number of bytes to move.
<P>
The interface to SafeCopy() is identical to that of hmemcpy().
<P>
<PRE>   void SafeCopy(void _huge *d, void _huge *s, long len)
   {
        register long i;
        long safesize, times;

        // There are four cases to consider
        // case 1: source and destination are the same
        // case 2: source and destination do not overlap
        // case 3: source starts at a location before destination in
        //         linear memory
        // case 4: source starts at a location after destination in
        //         linear memory

        // detect case 1 and handle it
        if (d == s)
             return;

        // determine the amount of overlap
        if (d &gt; s)     // get the absolute difference
             safesize = ((unsigned long)d - (unsigned long)s);
        else
             safesize = ((unsigned long)s - (unsigned long)d);

        // detect case 2
        if (safesize &gt;= len)
        {
             hmemcpy(d, s, len);  // no overlap
             return;
        }

        times = len/safesize;

        // detect case 3 and handle it
        if ((s &lt; d) &amp;&amp; ((unsigned long)s+len-1) &gt;(unsigned long)d)
        {
             // copy bytes from the end of source to the end of
             // destination in safesize quantum.
             for (i = 1; i &lt;= times; i++)
                  hmemcpy((void _huge *)((unsigned long) d+len-i*safesize),
                          (void _huge *)((unsigned long)s+len-i*safesize),
                           safesize);

             // copy the bytes remaining to be copied after
             // times*safesize bytes have been copied.
             if (times*safesize &lt; len)
                  hmemcpy(d, s, len - times*safesize);

        }
        else // this is case 4. handle it
        {
             // ASSERT (s &gt; d) &amp;&amp; ((d+len-1) &gt; s))

             // copy bytes from the beginning of source to the
             // beginning of destination in safesize quantum
             for (i = 0; i &lt; times; i++)
                  hmemcpy((void _huge *)((unsigned long)d+i*safesize),
                          (void _huge *)((unsigned long)s+i*safesize),
                          safesize);

             // copy the bytes remaining to be copied after
             // times*safesize bytes have been copied.
             if (times*safesize &lt; len)
                  hmemcpy((void _huge*)((unsigned long)d+times*safesize),
                          (void _huge*)((unsigned long)s+times*safesize),
                          len - times*safesize);
        }

        return;
   }
</PRE>

	</FONT>
	</TD>
	</TR>
</TABLE>
<P>


<!--DOCBODY_END-->

<!--FOOTER_START-->
<table cellpadding=5 border=0 width="90%">
<tr>
<td>
	<HR WIDTH="90%">

<BLOCKQUOTE>
<FONT FACE="Verdana, Arial, Helvetica" SIZE="1">
<SPAN STYLE="font-family:verdana,arial,helvetica; font-size:8pt">
Additional reference words: 3.10<BR>
KBCategory: kbprg<BR>
KBSubcategory: KrMm<BR>
Keywords            : kb16bitonly<BR>

</SPAN>
</FONT>
<BR>
<BR>
THE INFORMATION PROVIDED IN THE MICROSOFT KNOWLEDGE BASE IS
PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND.  MICROSOFT DISCLAIMS
ALL WARRANTIES, EITHER EXPRESS OR IMPLIED, INCLUDING THE WARRANTIES
OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  IN NO
EVENT SHALL MICROSOFT CORPORATION OR ITS SUPPLIERS BE LIABLE FOR
ANY DAMAGES WHATSOEVER INCLUDING DIRECT, INDIRECT, INCIDENTAL,
CONSEQUENTIAL, LOSS OF BUSINESS PROFITS OR SPECIAL DAMAGES, EVEN IF
MICROSOFT CORPORATION OR ITS SUPPLIERS HAVE BEEN ADVISED OF THE
POSSIBILITY OF SUCH DAMAGES.  SOME STATES DO NOT ALLOW THE EXCLUSION
OR LIMITATION OF LIABILITY FOR CONSEQUENTIAL OR INCIDENTAL DAMAGES
SO THE FOREGOING LIMITATION MAY NOT APPLY.
</BLOCKQUOTE>
<P>
<center>
	<FONT FACE="Verdana,Arial,Helvetica" SIZE="1">
	Last reviewed:  July 23, 1997</FONT>
	<BR>
	<A href="../cpyright.htm" STYLE="font: bold 7pt Verdana,Arial,Helvetica">&copy; 1998 Microsoft Corporation. All rights reserved. Terms of Use.</A><BR>
	
</center>
</td>
</tr>
</table>

<!--FOOTER_END-->
</FONT>
</BODY>
</HTML>
