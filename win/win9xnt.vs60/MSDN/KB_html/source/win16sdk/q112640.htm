

<HTML>
<HEAD>
<TITLE>SAMPLE: Paging Down in an Owner-Draw Variable List Box </TITLE>

<!--STYLE_BEGIN-->
<style>@import url(../../msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="../../msdn_ie3.css">
<!--STYLE_END-->

<META HTTP-EQUIV="CONTENT-Type" CONTENT="text/html; charset=us-ascii">
<META NAME="ms.locale" CONTENT="EN-US">
<META NAME="Category" CONTENT="Support; KB Article">
<META NAME="KBID" CONTENT="Q112640">
<META NAME="KBModify" CONTENT="1997/07/23">
<META NAME="KBCreate" CONTENT="1994/03/15">
<META NAME="Keywords" CONTENT="kb16bitonly UsrCtl kbfile kbprg">
<META NAME="KBArea" CONTENT="Support; KB; win16sdk">
<META NAME="Description" CONTENT="  Using the Microsoft Windows 3.1 SDK, when page down is used in an owner- draw variable list box, the selection is changed to the last visible item in the list box (as it should). However, at this point no subsequent page downs will work.  To addres...">
<META NAME="Product" CONTENT="Win16 SDK">
<META NAME="Platform" CONTENT="Windows">
<META NAME="Technology" CONTENT=" ">
<META NAME="Premium" CONTENT="support">

<META NAME="nyms" CONTENT="QBVR,QAML,QAE1,QAUD,QBXQ,QAH4,QANY,QAYL,QADO,QATJ V02180118">
</HEAD>

<BODY BGCOLOR="#FFFFFF" LEFTMARGIN="0" RIGHTMARGIN="0" TOPMARGIN="0">


<!--DOCBODY_START-->
<BR>
<CENTER>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" VALIGN="top" WIDTH="90%">
	<TR>
		<TD VALIGN="top">
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<H1>SAMPLE: Paging Down in an Owner-Draw Variable List Box</H1>
			</FONT>
			<FONT FACE="verdana,arial,helvetica" SIZE="1">
			Last reviewed:  July 23, 1997</FONT><BR>
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<B>Article ID: Q112640</B>
			</FONT>
		</TD>
	</TR>
	<TR>
	<TD>
	<FONT FACE="Verdana, Arial, Helvetica" SIZE=2>



 
3.10
WINDOWS
kbprg kbfile
<P>
 
The information in this article applies to:

<UL><LI>Microsoft Windows Software Development Kit (SDK) for Windows
   versions 3.1
</UL> 
<P>
<P><h2>SUMMARY</h2>
 
<P>
Using the Microsoft Windows 3.1 SDK, when page down is used in an owner-
draw variable list box, the selection is changed to the last visible item
in the list box (as it should). However, at this point no subsequent page
downs will work.
<P>
To address the page-down problem, the owner-draw variable list box is
subclassed. In the subclass procedure, WM_KEYDOWN is processed. When wParam
is VK_NEXT, the PAGE DOWN key was pressed, and the actual paging down is
implemented. The ODVARLB sample shows how to work around this problem.
<P>
ODVARLB can be downloaded as a self-extracting file from the Microsoft
Software Library (MSL) on the following services:

<UL><LI>Microsoft Download Service (MSDL)
<P><PRE>      Dial (206) 936-6735 to connect to MSDL
      Download <A href="http://support.microsoft.com/download/support/mslfiles/odvarlb.exe">ODVARLB.EXE</A> <I>(size: 31920 bytes)</I> 
</PRE>
<LI>Internet (anonymous FTP)
<P><PRE>      ftp ftp.microsoft.com
      Change to the \SOFTLIB\MSLFILES directory
      Get <A href="http://support.microsoft.com/download/support/mslfiles/odvarlb.exe">ODVARLB.EXE</A> <I>(size: 31920 bytes)</I> 
</PRE><P>
</UL>NOTE: This is not a problem with Win32-based applications.
<P>
<P><h2>MORE INFORMATION</h2>
 
<P>
The steps required for implementing the page down are as follows:

<OL><P><LI>Find out how many items exist in the list box. LB_GETCOUNT message can
   be used to get this information:
<P>
<P><PRE>      // Get maximum number of items in the list box.
      iMaxItems = SendMessage(hWnd,LB_GETCOUNT,0,0L);
</PRE>
<P><LI>Find out which item now has the selection; this item will be moved to
   the top of the list box on a page down. This can be done by sending an
   LB_GETCURSEL to the list box:
<P>
<P><PRE>      // Get the index for the item which is to be at the top.
<PRE></PRE>      iTopIdx    = SendMessage(hWnd,LB_GETCURSEL,0,0L);

</PRE><P><LI>If the item that has the focus now is the last item in the list then we
   cannot page down further, so just return.
<P>
<P><PRE>      // If the focus is already on the last item, we have reached
      // the end of the list so just return.
      if (iTopIdx != (iMaxItems -1))
<PRE></PRE>          // Continue we have more work to do.

</PRE><P><LI>Otherwise, get the height of the list box by calling GetClientRect():
<P>
<P><PRE>      // Get the client area rectangle of the list box.
       GetClientRect(hWnd, &amp;rc);
</PRE>
<P><LI>Then find out how many items will fit in the list box; because this is
   an owner-draw variable list box, some more elaborate calculation is
   necessary. To do this cleanly, a WM_MEASUREITEM message is sent to the
   parent of the list box and WM_MEASUREITEM code calculates the height for
   each of the items one by one. Then the height of each item is
   accumulated and is compared with the list box's height until the last
   item in the current page is located.
<P>
<P><PRE>      // Get the index for the last visible item in the list
      // box based on the new top item.
      iBottomIdx = GetLBIndex(hWnd,iTopIdx,iMaxItems,rc.bottom);
</PRE><P>
   The GetLBIndex() function finds the last item that should be visible
   after the page down is completed. Below is the code for GetLBIndex:
<P>
<P><PRE>     int GetLBIndex(HWND hLB,int iTopIdx,UINT iMaxLBItems, int lbHeight)
     {
<PRE></PRE>         MEASUREITEMSTRUCT mis;
         int ItmHeights = 0;          // Keeps track of total item heights.

         // Set up the measure item structures fields.
         mis.CtlType = ODT_LISTBOX;
         mis.itemID  = iTopIdx;

         while (mis.itemID &lt;= (iMaxLBItems - 1))
            {
            // Get the items measurement, height in particular.
            SendMessage(GetParent(hLB),WM_MEASUREITEM,
                        0, (LPARAM)(LPMEASUREITEMSTRUCT)&amp;mis);

            // Add it to our total height.
            ItmHeights += mis.itemHeight;

            // If the total item height is still less than
            // the list box:
            if (ItmHeights &lt;= lbHeight)
             // Unless we have reached the end of out list.
              if (mis.itemID == (iMaxLBItems - 1))
            // In this case, return the index to the last item in the list.
                 return (mis.itemID);
              else
             // Check the next item, we want to cycle through again.
                 ++mis.itemID ;
            else
             // We have found the last item to be displayed in the list box
             // so return it.
              return (--mis.itemID);
            }
         return (iTopIdx);
     }

</PRE><P><LI>When the height of the list box is less than or equal to the height of
   an item, the list box displays only one item or part of an item. In this
   situation some special-case handling is required. When the user presses
   the PAGE DOWN key, the next item in the list becomes visible. Below is
   the code used to adjust the top and bottom index for this special case:
<P>
<P><PRE>      // Special case: When the height of the list box is less than or
      // equal to the height of an item, the list box displays only one
      // item or part of an item at a time. So, when paging down we need
      // to display the next item in the list.
      if (iBottomIdx &lt;= iTopIdx)
<PRE></PRE>         iBottomIdx = ++iTopIdx;

</PRE><P><LI>Now the item in step 2 (or 6, iTopIdx) is placed at the top of the list
   and the selection (highlighted) is given to the last item, which is the
   item obtained in step 5 (or 6, iBottomIdx). The scroll bar thumb
   position is automatically updated.
<P>
<P><PRE>      // Move the item that had the focus to the top, then set the
      // selection to the last visible item in the list box.
      SendMessage(hWnd,LB_SETCURSEL,(WPARAM) iBottomIdx, 0L);
      SendMessage(hWnd,LB_SETTOPINDEX,(WPARAM) iTopIdx, 0L);
</PRE><P>
   NOTE: Just doing this will cause flashing so the painting is turned off
   in the list box until the page down process is complete. Then the entire
   list box is invalidated and the list box window is updated to reflect
   the changes.
<P>
<P><PRE>      // Turn off all painting to prevent flashing.
      SendMessage(hWnd, WM_SETREDRAW, (WPARAM) FALSE,0L);
</PRE><P>
<P><PRE>      // Move the item that had the focus to the top, then set the
      // focus to the last visible item in the list box.
      SendMessage(hWnd,LB_SETCURSEL,(WPARAM) iBottomIdx, 0L);
      SendMessage(hWnd,LB_SETTOPINDEX,(WPARAM) iTopIdx, 0L);
</PRE><P>
<P><PRE>      // We are done, so turn on painting. Invalidate the list box window
      // for painting and then update the list window.
      SendMessage(hWnd, WM_SETREDRAW, (WPARAM) TRUE,0L);
      InvalidateRect(hWnd,NULL,TRUE);
      UpdateWindow(hWnd);
</PRE><P>
   However, adding the WM_SETREDRAW messages to eliminate flashing prevents
   the scroll bar from being updated. To address this problem, the scroll
   bar position is retrieved via GetScrollPos() and then reset and painted
   via SetScrollPos().
<P>
<P><PRE>      pos = GetScrollPos(hWnd,SB_VERT);
      SetScrollPos(hWnd,SB_VERT,pos,TRUE);
</PRE><P>
   The code for this workaround is the ODLB.C file. All the necessary code
   for this workaround is actually contained in two functions,
<P>
<P><PRE>      SbListSubProc() - The subclass procedure for the list box.
<PRE></PRE>      GetLBIndex()    - Finds the last visible item in the list box
                        after paging down.

</PRE></OL>To see the demonstration, select the list box menu item and then page down!
<P>
The font on the list box can also be changed using the Change Font menu
option. Changing the font demonstrates how the code works with a different
number of visible items in the list box.
<P>

	</FONT>
	</TD>
	</TR>
</TABLE>
<P>


<!--DOCBODY_END-->

<!--FOOTER_START-->
<table cellpadding=5 border=0 width="90%">
<tr>
<td>
	<HR WIDTH="90%">

<BLOCKQUOTE>
<FONT FACE="Verdana, Arial, Helvetica" SIZE="1">
<SPAN STYLE="font-family:verdana,arial,helvetica; font-size:8pt">
Additional reference words: 3.10 softlib owner draw listbox softlib<BR>
ODVARLB.EXE<BR>
KBCategory: kbprg kbfile<BR>
KBSubcategory: UsrCtl<BR>
Keywords            : kb16bitonly UsrCtl kbfile kbprg<BR>
Version             : 3.10<BR>
Platform            : WINDOWS<BR>

</SPAN>
</FONT>
<BR>
<BR>
THE INFORMATION PROVIDED IN THE MICROSOFT KNOWLEDGE BASE IS
PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND.  MICROSOFT DISCLAIMS
ALL WARRANTIES, EITHER EXPRESS OR IMPLIED, INCLUDING THE WARRANTIES
OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  IN NO
EVENT SHALL MICROSOFT CORPORATION OR ITS SUPPLIERS BE LIABLE FOR
ANY DAMAGES WHATSOEVER INCLUDING DIRECT, INDIRECT, INCIDENTAL,
CONSEQUENTIAL, LOSS OF BUSINESS PROFITS OR SPECIAL DAMAGES, EVEN IF
MICROSOFT CORPORATION OR ITS SUPPLIERS HAVE BEEN ADVISED OF THE
POSSIBILITY OF SUCH DAMAGES.  SOME STATES DO NOT ALLOW THE EXCLUSION
OR LIMITATION OF LIABILITY FOR CONSEQUENTIAL OR INCIDENTAL DAMAGES
SO THE FOREGOING LIMITATION MAY NOT APPLY.
</BLOCKQUOTE>
<P>
<center>
	<FONT FACE="Verdana,Arial,Helvetica" SIZE="1">
	Last reviewed:  July 23, 1997</FONT>
	<BR>
	<A href="../cpyright.htm" STYLE="font: bold 7pt Verdana,Arial,Helvetica">&copy; 1998 Microsoft Corporation. All rights reserved. Terms of Use.</A><BR>
	
</center>
</td>
</tr>
</table>

<!--FOOTER_END-->
</FONT>
</BODY>
</HTML>
