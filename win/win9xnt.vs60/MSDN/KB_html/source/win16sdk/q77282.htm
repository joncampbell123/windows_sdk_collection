

<HTML>
<HEAD>
<TITLE>SAMPLE: Changing Color Bitmaps to Monochrome </TITLE>

<!--STYLE_BEGIN-->
<style>@import url(../../msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="../../msdn_ie3.css">
<!--STYLE_END-->

<META HTTP-EQUIV="CONTENT-Type" CONTENT="text/html; charset=us-ascii">
<META NAME="ms.locale" CONTENT="EN-US">
<META NAME="Category" CONTENT="Support; KB Article">
<META NAME="KBID" CONTENT="Q77282 ">
<META NAME="KBModify" CONTENT="1996/02/15">
<META NAME="KBCreate" CONTENT="1991/10/13">
<META NAME="Keywords" CONTENT="kbprg kbfile">
<META NAME="KBArea" CONTENT="Support; KB; win16sdk">
<META NAME="Description" CONTENT="  It is often desirable to convert a color bitmap into a monochrome bitmap so that it can be used to dynamically create a cursor (or icon). The procedure is relatively simple and is described in this article.  BIT2MONO is a sample application in the ...">
<META NAME="Product" CONTENT="Win16 SDK">
<META NAME="Platform" CONTENT="Windows">
<META NAME="Technology" CONTENT=" ">
<META NAME="Premium" CONTENT="support">

<META NAME="nyms" CONTENT="QAUD,QAPG,QAG9,QAXX,QAI4,QAGI,QALW,QAPF,QAY4,QAH4,QAB2,QDL9,QBWO,QBWN,QAO2 V02180118">
</HEAD>

<BODY BGCOLOR="#FFFFFF" LEFTMARGIN="0" RIGHTMARGIN="0" TOPMARGIN="0">


<!--DOCBODY_START-->
<BR>
<CENTER>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" VALIGN="top" WIDTH="90%">
	<TR>
		<TD VALIGN="top">
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<H1>SAMPLE: Changing Color Bitmaps to Monochrome</H1>
			</FONT>
			<FONT FACE="verdana,arial,helvetica" SIZE="1">
			Last reviewed:  February 15, 1996</FONT><BR>
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<B>Article ID: Q77282 </B>
			</FONT>
		</TD>
	</TR>
	<TR>
	<TD>
	<FONT FACE="Verdana, Arial, Helvetica" SIZE=2>



 
The information in this article applies to:

<UL><LI>Microsoft Windows Software Development Kit (SDK) for Windows
   versions 3.1 and 3.0
</UL> 
<P>
<P><h2>SUMMARY</h2>
 
<P>
It is often desirable to convert a color bitmap into a monochrome
bitmap so that it can be used to dynamically create a cursor (or
icon). The procedure is relatively simple and is described in this
article.
<P>
BIT2MONO is a sample application in the Microsoft Software Library that
demonstrates converting a color bitmap to a monochrome bitmap. It also
demonstrates the effect of changing the background and text color on a
monochrome bitmap.
<P>
Download BIT2MONO.EXE, a self-extracting file, from the Microsoft Software
Library (MSL) on the following services:

<UL><LI>Microsoft Download Service (MSDL)
<P><PRE>      Dial (206) 936-6735 to connect to MSDL
      Download <A href="http://support.microsoft.com/download/support/mslfiles/bit2mono.exe">BIT2MONO.EXE</A> <I>(size: 24015 bytes)</I> 
</PRE>
<LI>Internet (anonymous FTP)
<P><PRE>      ftp ftp.microsoft.com
      Change to the \SOFTLIB\MSLFILES directory
      Get <A href="http://support.microsoft.com/download/support/mslfiles/bit2mono.exe">BIT2MONO.EXE</A> <I>(size: 24015 bytes)</I> 
</PRE><P>
</UL><h2>MORE INFORMATION</h2>
 
<P>
Converting a color bitmap to a monochrome bitmap basically involves
three steps:

<OL><P><LI>Select the color bitmap into a compatible memory DC (display
   context).

<P><LI>Use GetDIBits to retrieve the bitmap information and create a color
   DIB (device independent bitmap).

<P><LI>Use SetDIBits to move the color DIB into a monochrome bitmap,
   performing the "smart" conversion from color to monochrome.
<P>
</OL>The resulting monochrome bitmap has the same bitmap "pattern," in a
monochrome format.
<P>
The following code sample demonstrates this process:
<P>
<PRE>     hbmLoaded = LoadBitmap(hInst, "mybitmap");

     // convert color bitmap to monochrome
     hbmMono = ColorDDBToMonoDDB(hbmLoaded, 0, 0, NULL);

     DeleteDC(hDCMem);
     ReleaseDC(hWnd, hDC);


</PRE></OL>The DibNumColors, PaletteSize, and ColorDDBToMonoDDB functions are
listed below. They are based on code found in the SHOWDIB example
provided with the Windows Software Development Kit (SDK).
<P>
<PRE>#define WIDTHBYTES(bits)  (((bits) + 31) / 32 * 4)

</PRE>WORD DibNumColors (pv)
VOID FAR * pv;
{
<PRE>    int                bits;
    LPBITMAPINFOHEADER lpbi;
    LPBITMAPCOREHEADER lpbc;

    lpbi = ((LPBITMAPINFOHEADER)pv);
    lpbc = ((LPBITMAPCOREHEADER)pv);

    // With the BITMAPINFO format headers, the size of the palette is
    // in biClrUsed. In the BITMAPCORE-style headers, it depends on
    // the bits per pixel (2 raised to the power of bits/pixel).

    if (lpbi-&gt;biSize != sizeof(BITMAPCOREHEADER))
    {
        if (lpbi-&gt;biClrUsed != 0)
            return (WORD)lpbi-&gt;biClrUsed;
        bits = lpbi-&gt;biBitCount;
    }
    else
        bits = lpbc-&gt;bcBitCount;

    switch (bits)
       {
        case 1:
            return 2;
        case 4:
            return 16;
        case 8:
            return 256;
        default:
            // A 24 bit DIB has no color table
            return 0;
        }
}


</PRE>WORD PaletteSize(pv)
VOID FAR * pv;
{
<PRE>    LPBITMAPINFOHEADER lpbi;
    WORD               NumColors;

    lpbi      = (LPBITMAPINFOHEADER)pv;
    NumColors = DibNumColors(lpbi);

    if (lpbi-&gt;biSize == sizeof(BITMAPCOREHEADER))
        return NumColors * sizeof(RGBTRIPLE);
    else
        return NumColors * sizeof(RGBQUAD);
}


</PRE>HBITMAP ColorDDBToMonoDDB(hbm, biStyle, biBits, hpal)
<P>
<PRE>HBITMAP      hbm;
DWORD        biStyle;
WORD         biBits;
HPALETTE     hpal;
{
    BITMAP               bm;
    BITMAPINFOHEADER     bi;
    BITMAPINFOHEADER FAR *lpbi;
    DWORD                dwLen;
    HANDLE               hdib;
    HANDLE               h;
    HDC                  hdc;
    HBITMAP              hbmMono;

    if (!hbm)
        return NULL;

    if (hpal == NULL)
        hpal = GetStockObject(DEFAULT_PALETTE);

    GetObject(hbm, sizeof(bm), (LPSTR)&amp;bm);

    if (biBits == 0)
        biBits = bm.bmPlanes * bm.bmBitsPixel;

    bi.biSize          = sizeof(BITMAPINFOHEADER);
    bi.biWidth         = bm.bmWidth;
    bi.biHeight        = bm.bmHeight;
    bi.biPlanes        = 1;
    bi.biBitCount      = biBits;
    bi.biCompression   = biStyle;
    bi.biSizeImage     = 0;
    bi.biXPelsPerMeter = 0;
    bi.biYPelsPerMeter = 0;
    bi.biClrUsed       = 0;
    bi.biClrImportant  = 0;

    dwLen = bi.biSize + PaletteSize(&amp;bi);

    hdc = GetDC(NULL);
    hpal = SelectPalette(hdc, hpal, FALSE);
    RealizePalette(hdc);

    hdib = GlobalAlloc(GHND, dwLen);

    if (!hdib)
        {
        SelectPalette(hdc, hpal, FALSE);
        ReleaseDC(NULL, hdc);
        return NULL;
        }

    lpbi = (VOID FAR *)GlobalLock(hdib);

    *lpbi = bi;

    // Call GetDIBits with a NULL lpBits parameter; it will calculate
    // the biSizeImage field.
    GetDIBits(hdc, hbm, 0, (WORD)bi.biHeight,
        NULL, (LPBITMAPINFO)lpbi, DIB_RGB_COLORS);

    bi = *lpbi;
    GlobalUnlock(hdib);

    // If the driver did not fill in the biSizeImage field,
    // calculate it.
    if (bi.biSizeImage == 0)
        {
        bi.biSizeImage = WIDTHBYTES((DWORD)bm.bmWidth * biBits)
            * bm.bmHeight;
        if (biStyle != BI_RGB)
            bi.biSizeImage = (bi.biSizeImage * 3) / 2;
        }

    // Reallocate the buffer big enough to hold all the bits.
    dwLen = bi.biSize + PaletteSize(&amp;bi) + bi.biSizeImage;
    if ((h = GlobalReAlloc(hdib, dwLen, 0)))
        hdib = h;
    else
        {
        GlobalFree(hdib);
        hdib = NULL;

        SelectPalette(hdc, hpal, FALSE);
        ReleaseDC(NULL, hdc);
        return hdib;
        }

    // Call GetDIBits with a NON-NULL lpBits parameter, to actually
    // get the bits this time.
    lpbi = (VOID FAR *)GlobalLock(hdib);

    if (GetDIBits(hdc, hbm, 0, (WORD)bi.biHeight,
             (LPSTR)lpbi + (WORD)lpbi-&gt;biSize + PaletteSize(lpbi),
             (LPBITMAPINFO)lpbi, DIB_RGB_COLORS) == 0)
         {
         GlobalUnlock(hdib);
         hdib = NULL;
         SelectPalette(hdc, hpal, FALSE);
         ReleaseDC(NULL, hdc);
         return NULL;
         }

    // Finally, create a monochrome DDB, and put the DIB into it.
    // SetDIBits does smart color conversion.
    hbmMono = CreateBitmap((WORD)lpbi-&gt;biWidth, (WORD)lpbi-&gt;biHeight,
                           1, 1, NULL);
    SetDIBits(hdc, hbmMono, 0, lpbi-&gt;biHeight,
              (LPSTR)lpbi + lpbi-&gt;biSize + PaletteSize(lpbi),
              (LPBITMAPINFO)lpbi, DIB_RGB_COLORS);

    bi = *lpbi;
    GlobalUnlock(hdib);
    GlobalFree(hdib);

    SelectPalette(hdc, hpal, FALSE);
    ReleaseDC(NULL, hdc);
    return hbmMono;
</PRE>}
<P>
<P>
An application can create a cursor from the monochrome bitmap produced
by ColorDDBToMonoDDB. The application can use the bitmap as either the
ANDbitPlane or the XORbitPlane parameter to CreateCursor. The
following code demonstrates this procedure:
<P>
<PRE>    // Get only the bitmap's bits, and load into a BYTE array of
    // correct size.

    // In this example, the bitmap created happens to have the
    // dimensions needed for a cursor or icon. This may not always be
    // the case. It may be necessary to "stretch" or "compress" the
    // bitmap to the correct size, using StretchDIBits or StretchBlt
    // (depending at what point the change in size is done).

    xsize = GetSystemMetrics(SM_CXCURSOR);
    ysize = GetSystemMetrics(SM_CYCURSOR);
    GetObject(hbmMono, sizeof(BITMAP), (LPSTR)&amp;bm);
    GetBitmapBits(hbmMono, (bm.bmWidthBytes * bm.bmHeight),
                     (LPSTR)XORbitPlane);

    // The call above uses bm.bmWidthBytes instead of planes and
    // bitsPixel because the former takes into account the fact that
    // some drivers might pad scan lines for speed reasons.

    hBitCursor = CreateCursor(ghInstance, 0, 0, xsize, ysize,
                                           ANDbitPlane, XORbitPlane);


</PRE>The above procedure also applies to the CreateIcon function.
<P>
The following two notes should be considered when an application uses
this procedure:

<UL><LI>It is always wise to call GetSystemMetrics to determine the
   appropriate size of cursors or icons for the installed display.
   This removes the assumption that the size is always 32 x 32, and
   allows the application to create the cursor or icon appropriately.

<LI>Monochrome merely means one drawing color (in addition to the
   background color). The system uses the current background and text
   colors chosen for the application (or defaults to the system-wide
   choices). An application can use SetBkColor, SetBkMode, and
   SetTextColor to modify the choice of colors in each display context
   (DC) if desired.
<P></UL>

	</FONT>
	</TD>
	</TR>
</TABLE>
<P>


<!--DOCBODY_END-->

<!--FOOTER_START-->
<table cellpadding=5 border=0 width="90%">
<tr>
<td>
	<HR WIDTH="90%">

<BLOCKQUOTE>
<FONT FACE="Verdana, Arial, Helvetica" SIZE="1">
<SPAN STYLE="font-family:verdana,arial,helvetica; font-size:8pt">
Additional reference words: 3.00 3.10 softlib BIT2MONO.EXE<BR>
KBCategory: kbprg kbfile<BR>
KBSubcategory: GdiBmp<BR>

</SPAN>
</FONT>
<BR>
<BR>
THE INFORMATION PROVIDED IN THE MICROSOFT KNOWLEDGE BASE IS
PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND.  MICROSOFT DISCLAIMS
ALL WARRANTIES, EITHER EXPRESS OR IMPLIED, INCLUDING THE WARRANTIES
OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  IN NO
EVENT SHALL MICROSOFT CORPORATION OR ITS SUPPLIERS BE LIABLE FOR
ANY DAMAGES WHATSOEVER INCLUDING DIRECT, INDIRECT, INCIDENTAL,
CONSEQUENTIAL, LOSS OF BUSINESS PROFITS OR SPECIAL DAMAGES, EVEN IF
MICROSOFT CORPORATION OR ITS SUPPLIERS HAVE BEEN ADVISED OF THE
POSSIBILITY OF SUCH DAMAGES.  SOME STATES DO NOT ALLOW THE EXCLUSION
OR LIMITATION OF LIABILITY FOR CONSEQUENTIAL OR INCIDENTAL DAMAGES
SO THE FOREGOING LIMITATION MAY NOT APPLY.
</BLOCKQUOTE>
<P>
<center>
	<FONT FACE="Verdana,Arial,Helvetica" SIZE="1">
	Last reviewed:  February 15, 1996</FONT>
	<BR>
	<A href="../cpyright.htm" STYLE="font: bold 7pt Verdana,Arial,Helvetica">&copy; 1998 Microsoft Corporation. All rights reserved. Terms of Use.</A><BR>
	
</center>
</td>
</tr>
</table>

<!--FOOTER_END-->
</FONT>
</BODY>
</HTML>
