

<HTML>
<HEAD>
<TITLE>HOWTO: Use GetChunk and AppendChunk Methods of RDO Object </TITLE>

<!--STYLE_BEGIN-->
<style>@import url(../../msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="../../msdn_ie3.css">
<!--STYLE_END-->

<META HTTP-EQUIV="CONTENT-Type" CONTENT="text/html; charset=us-ascii">
<META NAME="ms.locale" CONTENT="EN-US">
<META NAME="Category" CONTENT="Support; KB Article">
<META NAME="KBID" CONTENT="Q153238">
<META NAME="KBModify" CONTENT="1997/05/19">
<META NAME="KBCreate" CONTENT="1996/07/02">
<META NAME="Keywords" CONTENT="APrgData kbusage vb432 vb4win kbhowto">
<META NAME="KBArea" CONTENT="Support; KB; vbwin">
<META NAME="Description" CONTENT="  This article describes how to use the GetChunk and AppendChunk methods of an RDO column object. Included is the code for a working example of how to implement this behavior.  The GetChunk and AppendChunk methods work with the LongVarChar and LongVa...">
<META NAME="Product" CONTENT="Visual Basic for Windows">
<META NAME="Platform" CONTENT="Windows">
<META NAME="Technology" CONTENT=" ">
<META NAME="Premium" CONTENT="support">

<META NAME="nyms" CONTENT="QAH4,QBS0,QAE1,QBR4,QAPN,QDMN,QATX,QANF,QABA,QA2O,QBVV,QA2Q,QABM,QACI,QAXB V02180118">
</HEAD>

<BODY BGCOLOR="#FFFFFF" LEFTMARGIN="0" RIGHTMARGIN="0" TOPMARGIN="0">


<!--DOCBODY_START-->
<BR>
<CENTER>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" VALIGN="top" WIDTH="90%">
	<TR>
		<TD VALIGN="top">
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<H1>HOWTO: Use GetChunk and AppendChunk Methods of RDO Object</H1>
			</FONT>
			<FONT FACE="verdana,arial,helvetica" SIZE="1">
			Last reviewed:  May 19, 1997</FONT><BR>
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<B>Article ID: Q153238</B>
			</FONT>
		</TD>
	</TR>
	<TR>
	<TD>
	<FONT FACE="Verdana, Arial, Helvetica" SIZE=2>



 
 
The information in this article applies to:

<UL><LI>Enterprise Edition of Microsoft Visual Basic, 32-bit only,
   for Windows, version 4.0
</UL> 
<P>
<P><h2>SUMMARY</h2>
 
<P>
This article describes how to use the GetChunk and AppendChunk methods of
an RDO column object. Included is the code for a working example of how to
implement this behavior.
<P>
The GetChunk and AppendChunk methods work with the LongVarChar and
LongVarBinary column types, also known as TEXT and IMAGE columns, in
Microsoft SQL Server. To identify these column types in RDO, use the
&lt;Column Object&gt;.Type property that will return the constants rdLongVarChar
or rdLongVarBinary, or use the &lt;Column object&gt;.ChunkRequired property to
determine if you need to use the Get/AppendChunk methods to access the
column. Each of these column types is commonly referred to as Binary Large
Objects (BLOBs), so the term BLOB will be used for the remainder of this
article.
<P>
Following are some suggestions for using BLOBs with RDO:

<UL><LI>Using BLOB columns in a SQL table will cause performance degradation at
   your server and add an extra layer of complexity in your application
   code that you can avoid. If you are storing files such as Paintbrush
   (.bmp), Microsoft Word (.doc), or just text (.txt) files, it is more
   efficient to store these files in your file system than in your table.
   You can do this by storing the UNC path for the file in a column of your
   table, then letting your Visual Basic code read the path and handle the
   file appropriately.

<LI>When selecting a result set containing BLOB columns, you should place
   the BLOB columns at the end of the select list. If you usually use the
   "Select * from table" syntax, you should change this to "Select char1,
   text1, image1 from table" to explicitly reference each column and place
   the BLOB columns at the end.

<LI>When editing a BLOB column using the AppendChunk method, you should
   select at least one other editable non-BLOB column in your result set
   and edit the non-BLOB column as well as the BLOB column. If you do not
   edit the non-BLOB column, RDO will not raise an error but the data may
   not be saved back to the base table.

<LI>You cannot bind a BLOB value to a parameter marker because the
   AppendChunk method is not available on the rdoParameter object. If you
   want to pass a BLOB as an input parameter to a stored procedure, you
   will have to utilize the ODBC handle from RDO to process this through
   ODBC API calls. Fortunately, the ability to do this will be implemented
   in all future versions of RDO following version 1.0x.

<LI>If you are trying to display a bitmap image in a Picture control that
   is stored in a LongVarBinary column, keep in mind that the Picture
   control in Visual Basic does not have the capability of taking in a
   stream of bits via Visual Basic Applications (VBA) code. The only way
   to place a picture into the Picture control through code, or get the
   bits back out of a Picture control through code, is to use a file on
   the disk. You can also use the RDC and bind the Picture box to the BLOB
   column. This works well for reads (displaying the Picture), but updates
   are unstable in Visual Basic 4.0 due to problems in Visual Basic's
   binding manager. To perform updates, you should use code, rather than
   the RDC.
<P>
</UL>With the ODBC cursor library, it is not possible to use the GetChunk or
AppendChunk methods on a resultset returned from a stored procedure. This
is because the BLOB data does not come across the pipe with the rest of the
resultset. RDO has to go back and use the SQLGetData or SQLPutData ODBC AP
functions on the column when you request it with the RDO GetChunk or
AppendChunk methods. When a stored procedure creates a result set that is
returned to your application, RDO can use the data in the result set, but
it cannot go back to the base tables and columns and perform the
SQLGetData/SQLP tData because all it knows is that the SQL Statement was
something like "{call myproc(...)}", and there is no way for the cursor
library to know how to ask for the BLOB data because there is no base table
or column expressed there.
<P>
With server side cursors, it is possible to get at your BLOB data. The
server-side cursor knows the content of the stored procedure and can thus
get at the base table. A limitation of this is that you can't create a
server-side cursor based on a stored procedure that has anything besides
just one single select statement in it (a SQL Server restriction), so it is
pretty limiting and doubtful that you would be able to use this as your
primary technique.
<P>
The fact that users want to update their BLOB column demands that they
expose their base tables and create the cursor by using a standard select
statement from that base table. This would be true even if you were coding
directly to ODBC (not an RDO thing), as well as dbLibary (a proprietary SQL
Server API). If you use Jet, you can't update cursors based on stored
procedures at all because they always become read-only.
<P>
<P><h2>MORE INFORMATION</h2>
 
<P>
The following example is divided into three separate procedures,
Command1_Click, ColumnToFile, and FileToColumn. ColumnToFile and
FileToColumn are two self-contained procedures that you should be able to
paste directly into your code if you are moving BLOB data back and forth
from your table to files on disk. Each of the procedures accept parameters
that can be provided by your application. Command1_Click contains the
example code that makes the connection to your database, creates the table
CHUNKTABLE if it does not exist, and calls ColumnToFile and FileToColumn
procedures with the proper parameters.

<OL><P><LI>Start a new project in Visual Basic. Form1 is created by default.

<P><LI>Add a Command button, Command1, to Form1.

<P><LI>Paste the following code into the General Declarations section of Form1:
<P>
<PRE>   Private Sub Command1_Click()
     MousePointer = vbHourglass
     Dim cn As rdoConnection
     Dim rs As rdoResultset, TempRs As rdoResultset
     Dim cnstr As String, sqlstr As String
     cnstr = "Driver={SQL Server};Server=myserver;Database=pubs; _
     Uid=sa;Pwd="
     sqlstr = "Select int1, char1, text1, image1 from chunktable"

     rdoEnvironments(0).CursorDriver = rdUseServer
     Set cn = rdoEnvironments(0).OpenConnection( _
       "", rdDriverNoPrompt, False, cnstr)
     On Error Resume Next
     If cn.rdoTables("chunktable").Updatable Then
       'table exists
     End If
     If Err &gt; 0 Then
       On Error GoTo 0
       Debug.Print "Creating new table..."
       cn.Execute "Create table chunktable(int1 int identity, " &amp; _
                  "char1 char(30), text1 text, image1 image)"
       cn.Execute "create unique index int1index on chunktable(int1)"
     End If
     On Error GoTo 0
     Set rs = cn.OpenResultset(Name:=sqlstr, _
       Type:=rdOpenDynamic, _
       LockType:=rdConcurRowver)
     If rs.EOF Then
       rs.AddNew
       rs("char1") = Now
       rs.Update
       rs.Requery
     End If
     Dim currec As Integer
     currec = rs("int1")
     rs.Edit
     FileToColumn rs.rdoColumns("text1"), App.Path &amp; "\README.TXT", 102400
     FileToColumn rs.rdoColumns("image1"), App.Path &amp; "\SETUP.BMP", 102400
     rs("char1") = Now  'need to update at least one non-BLOB column
     rs.Update

     'this code gets the columnsize of each column
     Dim text1_len As Long, image1_len As Long
     If rs("text1").ColumnSize = -1 Then
       'the function Datalength is SQL Server specific
       'so you may have to change this for your database
       sqlstr = "Select Datalength(text1) As text1_len, " &amp; _
                "Datalength(image1) As image1_len from chunktable " &amp; _
                "Where int1=" &amp; currec
       Set TempRs = cn.OpenResultset(Name:=sqlstr, _
         Type:=rdOpenStatic, _
         LockType:=rdConcurReadOnly)
       text1_len = TempRs("text1_len")
       image1_len = TempRs("image1_len")
       TempRs.Close
     Else
       text1_len = rs("text1").ColumnSize
       image1_len = rs("image1").ColumnSize
     End If

     ColumnToFile rs.rdoColumns("text1"), App.Path &amp; "\text1.txt",  _
       102400, text1_len
     ColumnToFile rs.rdoColumns("image1"), App.Path &amp; "\image1.bmp",  _
       102400, image1_len
     MousePointer = vbNormal
   End Sub

   Sub ColumnToFile(Col As rdoColumn, ByVal DiskFile As String, _
     BlockSize As Long, ColSize As Long)
     Dim NumBlocks As Integer
     Dim LeftOver As Long
     Dim byteData() As Byte   'Byte array for LongVarBinary
     Dim strData As String    'String for LongVarChar
     Dim DestFileNum As Integer, i As Integer

     ' Remove any existing destination file
     If Len(Dir$(DiskFile)) &gt; 0 Then
       Kill DiskFile
     End If

     DestFileNum = FreeFile
     Open DiskFile For Binary As DestFileNum

     NumBlocks = ColSize \ BlockSize
     LeftOver = ColSize Mod BlockSize
     Select Case Col.Type
       Case rdTypeLONGVARBINARY
         byteData() = Col.GetChunk(LeftOver)
         Put DestFileNum, , byteData()
         For i = 1 To NumBlocks
           byteData() = Col.GetChunk(BlockSize)
           Put DestFileNum, , byteData()
         Next i
       Case rdTypeLONGVARCHAR
         For i = 1 To NumBlocks
           strData = String(BlockSize, 32)
           strData = Col.GetChunk(BlockSize)
           Put DestFileNum, , strData
         Next i
         strData = String(LeftOver, 32)
         strData = Col.GetChunk(LeftOver)
         Put DestFileNum, , strData
       Case Else
         MsgBox "Not a ChunkRequired column."
     End Select
     Close DestFileNum
   End Sub

   Sub FileToColumn(Col As rdoColumn, DiskFile As String, _
   BlockSize As Long)
     'moves a disk file to a ChunkRequired column in the table
     'A Byte array is used to avoid a UNICODE string
     Dim byteData() As Byte   'Byte array for LongVarBinary
     Dim strData As String    'String for LongVarChar
     Dim NumBlocks As Integer
     Dim filelength As Long
     Dim LeftOver As Long
     Dim SourceFile As Integer
     Dim i As Integer
     SourceFile = FreeFile
     Open DiskFile For Binary Access Read As SourceFile
     filelength = LOF(SourceFile) ' Get the length of the file
     If filelength = 0 Then
       Close SourceFile
       MsgBox DiskFile &amp; " empty or not found."
     Else
       ' Calculate number of blocks to read and left over bytes
       NumBlocks = filelength \ BlockSize
       LeftOver = filelength Mod BlockSize
       Col.AppendChunk Null

       Select Case Col.Type
         Case rdTypeLONGVARCHAR
           ' Read the 'left over' amount of LONGVARCHAR data
           strData = String(LeftOver, " ")
           Get SourceFile, , strData
           Col.AppendChunk strData
           strData = String(BlockSize, " ")
           For i = 1 To NumBlocks
             Get SourceFile, , strData
             Col.AppendChunk strData
           Next i
           Close SourceFile
         Case rdTypeLONGVARBINARY
           ' Read the left over amount of LONGVARBINARY data
           ReDim byteData(LeftOver)
           Get SourceFile, , byteData()
           Col.AppendChunk byteData()
           ReDim byteData(BlockSize)
           For i = 1 To NumBlocks
             Get SourceFile, , byteData()
             Col.AppendChunk byteData()
           Next i
           Close SourceFile
         Case Else
           MsgBox "not a chunkrequired column."
       End Select
     End If
   End Sub

</PRE><P><LI>You will need to change the Server, Database, UID, and PWD values in the
   cnstr variable in order to connect to your database.

<P><LI>The code in the Command1_Click event expects to find two files named
   README.TXT and SETUP.BMP in the current directory. These files are
   usually found in the Windows directory. You can either move these files
   to your current directory or change the path to match another bitmap and
   text file on your hard drive.

<P><LI>Press the F5 key to start the program.

<P><LI>Click the Command1 button to execute the RDO code. The code will
   automatically create a table named chunktable, if it does not already
   exist, and move the text and bitmap files into and out of the BLOB
   columns.
<P>
</OL><h2>REFERENCES</h2>
 
<P>
Hitchhiker's Guide to Visual Basic and SQL Server, Microsoft Press.
ISBN: 1-55615-906-4.
<P>
For additional information, please see the following article in the
Microsoft Knowledge Base:
<P>
<PRE>   ARTICLE-ID: <B><A href="../vbwin/q152715.htm">Q152715</A></B>
   TITLE     : RDO 1.0b Release Now Available
 

	</FONT>
	</TD>
	</TR>
</TABLE>
<P>


<!--DOCBODY_END-->

<!--FOOTER_START-->
<table cellpadding=5 border=0 width="90%">
<tr>
<td>
	<HR WIDTH="90%">

<BLOCKQUOTE>
<FONT FACE="Verdana, Arial, Helvetica" SIZE="1">
<SPAN STYLE="font-family:verdana,arial,helvetica; font-size:8pt">
Keywords            : APrgData kbusage vb432 vb4win kbhowto<BR>
Version             : 4.0<BR>
Platform            : NT WINDOWS<BR>

</SPAN>
</FONT>
<BR>
<BR>
THE INFORMATION PROVIDED IN THE MICROSOFT KNOWLEDGE BASE IS
PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND.  MICROSOFT DISCLAIMS
ALL WARRANTIES, EITHER EXPRESS OR IMPLIED, INCLUDING THE WARRANTIES
OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  IN NO
EVENT SHALL MICROSOFT CORPORATION OR ITS SUPPLIERS BE LIABLE FOR
ANY DAMAGES WHATSOEVER INCLUDING DIRECT, INDIRECT, INCIDENTAL,
CONSEQUENTIAL, LOSS OF BUSINESS PROFITS OR SPECIAL DAMAGES, EVEN IF
MICROSOFT CORPORATION OR ITS SUPPLIERS HAVE BEEN ADVISED OF THE
POSSIBILITY OF SUCH DAMAGES.  SOME STATES DO NOT ALLOW THE EXCLUSION
OR LIMITATION OF LIABILITY FOR CONSEQUENTIAL OR INCIDENTAL DAMAGES
SO THE FOREGOING LIMITATION MAY NOT APPLY.
</BLOCKQUOTE>
<P>
<center>
	<FONT FACE="Verdana,Arial,Helvetica" SIZE="1">
	Last reviewed:  May 19, 1997</FONT>
	<BR>
	<A href="../cpyright.htm" STYLE="font: bold 7pt Verdana,Arial,Helvetica">&copy; 1998 Microsoft Corporation. All rights reserved. Terms of Use.</A><BR>
	
</center>
</td>
</tr>
</table>

<!--FOOTER_END-->
</FONT>
</BODY>
</HTML>
