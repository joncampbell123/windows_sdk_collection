

<HTML>
<HEAD>
<TITLE>Using For Each to Loop Through Arrays Is Not Recommended </TITLE>

<!--STYLE_BEGIN-->
<style>@import url(../../msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="../../msdn_ie3.css">
<!--STYLE_END-->

<META HTTP-EQUIV="CONTENT-Type" CONTENT="text/html; charset=us-ascii">
<META NAME="ms.locale" CONTENT="EN-US">
<META NAME="Category" CONTENT="Support; KB Article">
<META NAME="KBID" CONTENT="Q129931">
<META NAME="KBModify" CONTENT="1996/02/21">
<META NAME="KBCreate" CONTENT="1995/05/08">
<META NAME="Keywords" CONTENT="kbprg kbcode">
<META NAME="KBArea" CONTENT="Support; KB; vbwin">
<META NAME="Description" CONTENT="  The For Each statement can be used on variant type arrays and collections that contain generic object, variant, or OLE automation variables.  You can also use the For Each statement with an array that is not a variant type, but the result is a subs...">
<META NAME="Product" CONTENT="Visual Basic for Windows">
<META NAME="Platform" CONTENT="Windows">
<META NAME="Technology" CONTENT=" ">
<META NAME="Premium" CONTENT="support">

<META NAME="nyms" CONTENT="QAPN,QBS0,QANF,QBXS,QAW6,QAH4,QAB9,QAFQ,QBJZ,QACJ,QA4Q,QATX,QAG1,QAY5,QAZB V02180118">
</HEAD>

<BODY BGCOLOR="#FFFFFF" LEFTMARGIN="0" RIGHTMARGIN="0" TOPMARGIN="0">


<!--DOCBODY_START-->
<BR>
<CENTER>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" VALIGN="top" WIDTH="90%">
	<TR>
		<TD VALIGN="top">
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<H1>Using For Each to Loop Through Arrays Is Not Recommended</H1>
			</FONT>
			<FONT FACE="verdana,arial,helvetica" SIZE="1">
			Last reviewed:  February 21, 1996</FONT><BR>
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<B>Article ID: Q129931</B>
			</FONT>
		</TD>
	</TR>
	<TR>
	<TD>
	<FONT FACE="Verdana, Arial, Helvetica" SIZE=2>



 
The information in this article applies to:

<UL><LI>Standard, Professional, and Enterprise Editions of Microsoft
   Visual Basic, 16-bit and 32-bit, for Windows, version 4.0
</UL> 
<P>
<P><h2>SUMMARY</h2>
 
<P>
The For Each statement can be used on variant type arrays and collections
that contain generic object, variant, or OLE automation variables.
<P>
You can also use the For Each statement with an array that is not a variant
type, but the result is a substantial decrease in performance. This article
shows by example how to use the For Each statement to loop through
collections and demonstrates the decrease in performance that occurs when
you use the For Each statement to loop through arrays.
<P>
MORE INFORMATION
 
<P>
Although it is possible to use For Each on an array, there is rarely a
reason to do so. You pay a substantial performance penalty on For Each
statements. The For Each statement is advantageous in situations where the
number of elements is unknown, but the number of elements in an array is
almost always known. The only exceptions are arrays created by Visual
Basic, such as ParamArray arguments (using the ParamArray keyword in a
procedure creates arrays based on an indefinite number of arguments) and
possibly control arrays.
<P>
For Each deals with objects rather than variables. A For Each on an array
essentially does this:
<P>
<PRE>   Dim MyArray(i to j) as Variant
   Dim VArray As Variant
   For i = LBound(MyArray) to UBound(MyArray)
      Set VArray = MyArray(i)
      ' Do something with VArray
   Next

</PRE>Usually, For Each is used on arrays or collections of objects or variants.
However, if you are working on an array of strings (Dim MyArray(i to j) as
String in the above example) Visual Basic converts each string element
to a variant object internally in order to use Set on it. That is, Visual
Basic performs the equivalent of:
<P>
<PRE>   Set VArray = CVar(MyArray(i))

</PRE>Therefore, there is additional overhead when using For Each on arrays.
<P>
<P><h3>Steps to Demonstrate For Each versus For Next</h3>
 

<OL><P><LI>Start a new project in Visual Basic. Form1 is created by default.

<P><LI>Add the following code to the Form1_Click event Procedure:
<P>
<PRE>   Private Sub Form_Click()
      ForEach
   End Sub

</PRE><P><LI>From the Insert Menu, choose Module to add Module1 to the project.

<P><LI>Add the following code to the general declarations section of Module1:
<P>
   #if Win32 Then
<P><PRE>      Declare Function GetTickCount Lib "kernel32" () As Long
</PRE>   #Else
<P><PRE>      Declare Function GetTickCount Lib "User" () As Long
</PRE>   #End If
<P>
   Public Sub ForEach()
<P><PRE>      Dim MyArrayS(1 To 3000) As String
      Dim MyArrayI(1 To 3000) As Integer
      Dim MyArrayO(1 To 3000) As Object
      Dim MyArrayV(1 To 3000) As Variant
      Dim obj As Object
      Dim j As Integer
      Dim CurrElement, TheName, v
      Dim Date1 As Long, Date2 As Long, Date3 As Long
      Dim MyInt As New Collection
      Dim MyClasses As New Collection
</PRE><P>
<P><PRE>      Date1 = GetTickCount()
      For i = 1 To 3000
<PRE></PRE>         MyArrayS(i) = "dummy"
      Next
      Date2 = GetTickCount()
      For Each CurrElement In MyArrayS
         CurrElement = "dummy"
      Next
      Date3 = GetTickCount()
      Form1.Print "For i on String Array    " &amp; CStr(Date2 - Date1)
      Form1.Print "For Each on String Array " &amp; CStr(Date3 - Date2)

      Date1 = GetTickCount()
      For i = 1 To 3000
         MyArrayI(i) = 1
      Next
      Date2 = GetTickCount()
      For Each CurrElement In MyArrayI
         CurrElement = 1
      Next
      Date3 = GetTickCount()
      Form1.Print "For i on Integer Array    " &amp; CStr(Date2 - Date1)
      Form1.Print "For Each on Integer Array " &amp; CStr(Date3 - Date2)

      Date1 = GetTickCount()
      For i = 1 To 3000
         Set MyArrayO(i) = obj
      Next
      Date2 = GetTickCount()
      For Each CurrElement In MyArrayO
         Set CurrElement = obj
      Next
      Date3 = GetTickCount()
      Form1.Print "For i on Object Array    " &amp; CStr(Date2 - Date1)
      Form1.Print "For Each on Object Array " &amp; CStr(Date3 - Date2)

      Date1 = GetTickCount()
      For i = 1 To 3000
         MyArrayV(i) = v
      Next
      Date2 = GetTickCount()
      For Each CurrElement In MyArrayV
         CurrElement = v
      Next
      Date3 = GetTickCount()
      Form1.Print "For i on Variant Array    " &amp; CStr(Date2 - Date1)
      Form1.Print "For Each on Variant Array " &amp; CStr(Date3 - Date2)

      For i = 1 To 500
         MyInt.Add Item:=j, Key:=CStr(i)
      Next
      Date1 = GetTickCount()
      For i = 1 To 500
         j = MyInt.Item(i)
      Next
      Date2 = GetTickCount()
      For Each CurrElement In MyInt
         j = CurrElement
      Next
      Date3 = GetTickCount()

      Form1.Print "For i on Integer Collection    " &amp; CStr(Date2 - Date1)
      Form1.Print "For Each on Integer Collection " &amp; CStr(Date3 - Date2)

      For i = 1 To 500
         Dim Inst As New Class1
         TheName = "Mike" &amp; CStr(i)
         Inst.InstanceName = TheName
         MyClasses.Add Item:=Inst, Key:=CStr(i)
         Set Inst = Nothing
      Next
      Date1 = GetTickCount()
      For i = 1 To 500
         Set a = MyClasses.Item(i)
      Next
      Date2 = GetTickCount()
      For Each CurrElement In MyClasses
         Set a = CurrElement
      Next
      Date3 = GetTickCount()

      Form1.Print "For i on Object Collection    " &amp; CStr(Date2 - Date1)
      Form1.Print "For Each on Object Collection " &amp; CStr(Date3 - Date2)
   End Sub

</PRE><P><LI>From the Insert Menu, choose Class Module to add Class1 to the project.

<P><LI>Add the following code to the general declarations section of Class1:
<P>
   Public InstanceName

<P><LI>Run the program.
<P>
</OL>In general, the results illustrate why you should use the For...Next
statement on arrays and use the For Each...Next statement on collections.
<P>

	</FONT>
	</TD>
	</TR>
</TABLE>
<P>


<!--DOCBODY_END-->

<!--FOOTER_START-->
<table cellpadding=5 border=0 width="90%">
<tr>
<td>
	<HR WIDTH="90%">

<BLOCKQUOTE>
<FONT FACE="Verdana, Arial, Helvetica" SIZE="1">
<SPAN STYLE="font-family:verdana,arial,helvetica; font-size:8pt">
Additional reference words: 4.00 optimum optimal speedier faster quicker<BR>
vb4win better best vb4all<BR>
KBCategory: kbprg kbcode<BR>
KBSubcategory: PrgOptTips<BR>

</SPAN>
</FONT>
<BR>
<BR>
THE INFORMATION PROVIDED IN THE MICROSOFT KNOWLEDGE BASE IS
PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND.  MICROSOFT DISCLAIMS
ALL WARRANTIES, EITHER EXPRESS OR IMPLIED, INCLUDING THE WARRANTIES
OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  IN NO
EVENT SHALL MICROSOFT CORPORATION OR ITS SUPPLIERS BE LIABLE FOR
ANY DAMAGES WHATSOEVER INCLUDING DIRECT, INDIRECT, INCIDENTAL,
CONSEQUENTIAL, LOSS OF BUSINESS PROFITS OR SPECIAL DAMAGES, EVEN IF
MICROSOFT CORPORATION OR ITS SUPPLIERS HAVE BEEN ADVISED OF THE
POSSIBILITY OF SUCH DAMAGES.  SOME STATES DO NOT ALLOW THE EXCLUSION
OR LIMITATION OF LIABILITY FOR CONSEQUENTIAL OR INCIDENTAL DAMAGES
SO THE FOREGOING LIMITATION MAY NOT APPLY.
</BLOCKQUOTE>
<P>
<center>
	<FONT FACE="Verdana,Arial,Helvetica" SIZE="1">
	Last reviewed:  February 21, 1996</FONT>
	<BR>
	<A href="../cpyright.htm" STYLE="font: bold 7pt Verdana,Arial,Helvetica">&copy; 1998 Microsoft Corporation. All rights reserved. Terms of Use.</A><BR>
	
</center>
</td>
</tr>
</table>

<!--FOOTER_END-->
</FONT>
</BODY>
</HTML>
