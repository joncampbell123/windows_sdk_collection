

<HTML>
<HEAD>
<TITLE>How to Control the Placement of Desktop Windows </TITLE>

<!--STYLE_BEGIN-->
<style>@import url(../../msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="../../msdn_ie3.css">
<!--STYLE_END-->

<META HTTP-EQUIV="CONTENT-Type" CONTENT="text/html; charset=us-ascii">
<META NAME="ms.locale" CONTENT="EN-US">
<META NAME="Category" CONTENT="Support; KB Article">
<META NAME="KBID" CONTENT="Q113702">
<META NAME="KBModify" CONTENT="1997/03/18">
<META NAME="KBCreate" CONTENT="1994/04/12">
<META NAME="Keywords" CONTENT="">
<META NAME="KBArea" CONTENT="Support; KB; vbwin">
<META NAME="Description" CONTENT="  There are situations where you'd like your program to have control over windows that do not belong to the program itself. For example, when a Visual Basic program performs OLE automation with Microsoft Word for Windows, you might want to place the ...">
<META NAME="Product" CONTENT="Visual Basic for Windows">
<META NAME="Platform" CONTENT="Windows">
<META NAME="Technology" CONTENT=" ">
<META NAME="Premium" CONTENT="support">

<META NAME="nyms" CONTENT="QA4Q,QBS0,QAW9,QAH4,QAVX,QAG8,QDL9,QBWQ,QBWO,QBWN,QAY5,QBXT,QA5V,QAIB,QAB9 V02180118">
</HEAD>

<BODY BGCOLOR="#FFFFFF" LEFTMARGIN="0" RIGHTMARGIN="0" TOPMARGIN="0">


<!--DOCBODY_START-->
<BR>
<CENTER>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" VALIGN="top" WIDTH="90%">
	<TR>
		<TD VALIGN="top">
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<H1>How to Control the Placement of Desktop Windows</H1>
			</FONT>
			<FONT FACE="verdana,arial,helvetica" SIZE="1">
			Last reviewed:  March 18, 1997</FONT><BR>
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<B>Article ID: Q113702</B>
			</FONT>
		</TD>
	</TR>
	<TR>
	<TD>
	<FONT FACE="Verdana, Arial, Helvetica" SIZE=2>



 
3.00
WINDOWS
kbui kbprg kbcode
<P>
 
The information in this article applies to:
<P>
- Professional Edition of Microsoft Visual Basic for Windows, version 3.0
 
<P>
<P><h2>SUMMARY</h2>
 
<P>
There are situations where you'd like your program to have control over
windows that do not belong to the program itself. For example, when a
Visual Basic program performs OLE automation with Microsoft Word for
Windows, you might want to place the Word window next to the current
position of the program's window -- so that the two windows are tiled side
by side.
<P>
This article demonstrates how to use the Windows API SetWindowPlacement
function in a tiling algorithm.
<P>
<P><h2>MORE INFORMATION</h2>
 
<P>
The example code in this article obtains the handles of three standard
applications (CALC.EXE, WRITE.EXE, and NOTEPAD.EXE) by using the FindWindow
function. Then it tiles the application windows horizontally or vertically,
along with the Visual Basic program's form. The handles are obtained after
using the Visual Basic Shell function to launch the applications.
<P>
After obtaining the handles, the example code calls the Windows API
SetWindowPlacement function to size and position the top-level window. For
illustration, an algorithm that tiles the windows either horizontally or
vertically is called using an array of window handles.
<P>
<P><h3>Possible Enhancement</h3>
 
<P>
You could enhance the example in this article by applying a technique
described in another Microsoft Knowledge Base article to obtain the handles
of already running applications. For information about this technique
please see the following article in the Microsoft Knowledge Base:
<P>
ARTICLE-ID: <B><A href="../vbwin/q78001.htm">Q78001</A></B>
<PRE>TITLE     : How to Get Windows Master List (Task List) Using Visual Basic

</PRE><h3>Step-by-Step Example</h3>
 
<P>
Here are the steps necessary to construct the example:

<OL><P><LI>Start a new project in Visual Basic. Form1 is created by default.

<P><LI>Add a command button (Command1) to the form, and change its Caption
   property to Tile.

<P><LI>Add a code module (Module1) to the project by choosing New Module
   from the File menu (ALT, F, M).

<P><LI>Add the following code to the general declarations section of Module1:
<P>
   Type POINTAPI
<P><PRE>      x As Integer
      y As Integer
</PRE>   End Type
<P>
   Type RECT
<P><PRE>      left As Integer
      top As Integer
      right As Integer
      bottom As Integer
</PRE>   End Type
<P>
   Type WINDOWPLACEMENT
<P><PRE>      length As Integer
      flags As Integer
      showCmd As Integer
      ptMinPosition As POINTAPI
      ptMaxPosition As POINTAPI
      rcNormalPosition As RECT
</PRE>   End Type
<P>
   Global lpwndplOld As WINDOWPLACEMENT
   Global lpwndplNew As WINDOWPLACEMENT
<P>
<PRE>   ' Enter each of the following Declare statements as one, single line:
   Declare Function FindWindow Lib "User" (ByVal lpClassName As Any,
      ByVal lpWindowName As Any) As Integer
   Declare Function GetWindowPlacement Lib "User" (ByVal hwnd As
      Integer, lpwndpl As WINDOWPLACEMENT) As Integer
   Declare Function SetWindowPlacement Lib "User" (ByVal hwnd As
      Integer, lpwndpl As WINDOWPLACEMENT) As Integer

   Global Const SW_SHOWNORMAL = 1
   Global hWnds() As Integer

</PRE><P><LI>Add the following code to Module1:
<P>
<PRE>   ' Enter the following Function statement as one, single line:
   Function Tile (hWndArr() As Integer, cardinal As Integer,
      HorV As Integer)

      Dim ordinal As Integer
      On Error GoTo handler

      Select Case HorV

      Case 1

      For ordinal = 1 To cardinal

      ' Optionally, check old placement of window:
      ' ****************************************************
      ' Note that the debug statements induce a slight delay
      ' Enter each Debug.Print statement as one, single line:
      '
      ' lpwndplOld.length = Len(lpwndplOld)
      ' ret% = GetWindowPlacement(hWndArr(ordinal), lpwndplOld)
      ' Debug.Print
      ' Debug.Print "ordinal= "; ordinal
      ' Enter the following two lines as one, single line:
      ' Debug.Print " Old window placement values for handle = ";
      '    Hex$(hWndArr(ordinal))
      ' Debug.Print "lpwndplOld.length= "; lpwndplOld.length
      ' Debug.Print "lpwndplOld.flags= "; lpwndplOld.flags
      ' Debug.Print "lpwndplOld.showCmd= "; lpwndplOld.showCmd
      '
      ' Debug.Print "lpwndplOld.ptMinPosition.x= ";
      '    lpwndplOld.ptMinPosition.x
      ' Debug.Print "lpwndplOld.ptMinPosition.y= ";
      '    lpwndplOld.ptMinPosition.y
      '
      ' Debug.Print "lpwndplOld.ptMaxPosition.x= ";
      '    lpwndplOld.ptMaxPosition.x
      ' Debug.Print "lpwndplOld.ptMaxPosition.y= ";
      '    lpwndplOld.ptMaxPosition.y
      '
      ' Debug.Print "lpwndplOld.rcNormalPosition.left= ";
      '    lpwndplOld.rcNormalPosition.left
      ' Debug.Print "lpwndplOld.rcNormalPosition.top= ";
      '    lpwndplOld.rcNormalPosition.top
      ' Debug.Print "lpwndplOld.rcNormalPosition.right= ";
      '    lpwndplOld.rcNormalPosition.right
      ' Debug.Print "lpwndplOld.rcNormalPosition.bottom= ";
      '    lpwndplOld.rcNormalPosition.bottom
      '**************************************************************

         lpwndplNew.length = Len(lpwndplNew)
         lpwndplNew.flags = 0
         lpwndplNew.showCmd = SW_SHOWNORMAL

         l = 0

         ' Enter the following two lines as one, single line:
         t = (ordinal - 1) *
            (screen.Height / screen.TwipsPerPixelY) \ cardinal

         r = (screen.Width / screen.TwipsPerPixelX)
         b = ordinal * (screen.Height / screen.TwipsPerPixelY) \ cardinal

         lpwndplNew.rcNormalPosition.left = l
         lpwndplNew.rcNormalPosition.top = t
         lpwndplNew.rcNormalPosition.right = r
         lpwndplNew.rcNormalPosition.bottom = b

         ret% = SetWindowPlacement(hWndArr(ordinal), lpwndplNew)

      Next ordinal

      Case 2

      For ordinal = 1 To cardinal

         lpwndplNew.length = Len(lpwndplNew)
         lpwndplNew.flags = 0
         lpwndplNew.showCmd = SW_SHOWNORMAL

         ' Enter the following two lines as one, single line:
         l = (ordinal - 1) *
            (screen.Width / screen.TwipsPerPixelX) \ cardinal

         t = 0
         r = ordinal * (screen.Width / screen.TwipsPerPixelX) \ cardinal
         b = (screen.Height / screen.TwipsPerPixelY)
         lpwndplNew.rcNormalPosition.left = l
         lpwndplNew.rcNormalPosition.top = t
         lpwndplNew.rcNormalPosition.right = r
         lpwndplNew.rcNormalPosition.bottom = b

         ret% = SetWindowPlacement(hWndArr(ordinal), lpwndplNew)

      Next ordinal
      End Select
      Tile = True
      Exit Function

      handler:
      MsgBox Error$
      Tile = False
      Exit Function

   End Function

</PRE><P><LI>Add the following code to Command1_Click event procedure:
<P>
<PRE>   Sub Command1_Click ()
      Dim orientation As Integer, handlecount As Integer, i As Integer

      ret% = Shell("notepad", 7)
      If FindWindow("NOTEPAD", 0&amp;) Then
         handlecount = handlecount + 1
         ReDim Preserve hWnds(1 To handlecount)
         hWnds(handlecount) = FindWindow("NOTEPAD", 0&amp;)
      End If

      ret% = Shell("write", 7)
      If FindWindow("MSWRITE_MENU", 0&amp;) Then
         handlecount = handlecount + 1
         ReDim Preserve hWnds(1 To handlecount)
         hWnds(handlecount) = FindWindow("MSWRITE_MENU", 0&amp;)
      End If

      handlecount = handlecount + 1
      ReDim Preserve hWnds(1 To handlecount)
      hWnds(handlecount) = Me.hWnd ' the handle of Form1

      ret% = Shell("calc", 7)
      If FindWindow("SCICALC", 0&amp;) Then
         handlecount = handlecount + 1
         ReDim Preserve hWnds(1 To handlecount)
         hWnds(handlecount) = FindWindow("SCICALC", 0&amp;)
      End If

      'orientation = 1 ' horizontal
      orientation = 2 ' vertical

      ret% = Tile(hWnds(), handlecount, orientation)

   End Sub

</PRE><P><LI>Save the project and run the program by pressing the F5 key.

<P><LI>Click the Tile button, and observe the vertical tiling of the windows.
   Then stop the program, and close the three applications (CALC.EXE,
   WRITE.EXE, and NOTEPAD.EXE). Remove the single quotation mark from
   "orientation = 1" line. Then add a single quotation mark to the
   "orientation = 2" line. Run the program again, and observe the
   horizontal tiling.
<P></OL>

	</FONT>
	</TD>
	</TR>
</TABLE>
<P>


<!--DOCBODY_END-->

<!--FOOTER_START-->
<table cellpadding=5 border=0 width="90%">
<tr>
<td>
	<HR WIDTH="90%">

<BLOCKQUOTE>
<FONT FACE="Verdana, Arial, Helvetica" SIZE="1">
<SPAN STYLE="font-family:verdana,arial,helvetica; font-size:8pt">
Additional reference words: 3.00<BR>
KBCategory: kbui kbprg kbcode<BR>
KBSubcategory: APrgWindow<BR>

</SPAN>
</FONT>
<BR>
<BR>
THE INFORMATION PROVIDED IN THE MICROSOFT KNOWLEDGE BASE IS
PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND.  MICROSOFT DISCLAIMS
ALL WARRANTIES, EITHER EXPRESS OR IMPLIED, INCLUDING THE WARRANTIES
OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  IN NO
EVENT SHALL MICROSOFT CORPORATION OR ITS SUPPLIERS BE LIABLE FOR
ANY DAMAGES WHATSOEVER INCLUDING DIRECT, INDIRECT, INCIDENTAL,
CONSEQUENTIAL, LOSS OF BUSINESS PROFITS OR SPECIAL DAMAGES, EVEN IF
MICROSOFT CORPORATION OR ITS SUPPLIERS HAVE BEEN ADVISED OF THE
POSSIBILITY OF SUCH DAMAGES.  SOME STATES DO NOT ALLOW THE EXCLUSION
OR LIMITATION OF LIABILITY FOR CONSEQUENTIAL OR INCIDENTAL DAMAGES
SO THE FOREGOING LIMITATION MAY NOT APPLY.
</BLOCKQUOTE>
<P>
<center>
	<FONT FACE="Verdana,Arial,Helvetica" SIZE="1">
	Last reviewed:  March 18, 1997</FONT>
	<BR>
	<A href="../cpyright.htm" STYLE="font: bold 7pt Verdana,Arial,Helvetica">&copy; 1998 Microsoft Corporation. All rights reserved. Terms of Use.</A><BR>
	
</center>
</td>
</tr>
</table>

<!--FOOTER_END-->
</FONT>
</BODY>
</HTML>
