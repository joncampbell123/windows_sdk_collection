

<HTML>
<HEAD>
<TITLE>How to Parse a Delimited String Using InStr and Mid </TITLE>

<!--STYLE_BEGIN-->
<style>@import url(../../msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="../../msdn_ie3.css">
<!--STYLE_END-->

<META HTTP-EQUIV="CONTENT-Type" CONTENT="text/html; charset=us-ascii">
<META NAME="ms.locale" CONTENT="EN-US">
<META NAME="Category" CONTENT="Support; KB Article">
<META NAME="KBID" CONTENT="Q126939">
<META NAME="KBModify" CONTENT="1995/06/21">
<META NAME="KBCreate" CONTENT="1995/03/07">
<META NAME="Keywords" CONTENT="kbprg kbcode">
<META NAME="KBArea" CONTENT="Support; KB; vbwin">
<META NAME="Description" CONTENT="  Visual Basic programmers are sometimes presented with data in a delimited string. This article shows by example how to use the InStr and Mid functions to find and extract the parts of a string between delimiters.  MORE INFORMATION  Programmers can ...">
<META NAME="Product" CONTENT="Visual Basic for Windows">
<META NAME="Platform" CONTENT="Windows">
<META NAME="Technology" CONTENT=" ">
<META NAME="Premium" CONTENT="support">

<META NAME="nyms" CONTENT="QATX,QBS0,QAY5,QANF,QACI,QA3P,QAUD,QAB9,QBV8,QAIJ,QA4Q,QAIV,QAYV,QAJP,QAFF V02180118">
</HEAD>

<BODY BGCOLOR="#FFFFFF" LEFTMARGIN="0" RIGHTMARGIN="0" TOPMARGIN="0">


<!--DOCBODY_START-->
<BR>
<CENTER>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" VALIGN="top" WIDTH="90%">
	<TR>
		<TD VALIGN="top">
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<H1>How to Parse a Delimited String Using InStr and Mid</H1>
			</FONT>
			<FONT FACE="verdana,arial,helvetica" SIZE="1">
			Last reviewed:  June 21, 1995</FONT><BR>
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<B>Article ID: Q126939</B>
			</FONT>
		</TD>
	</TR>
	<TR>
	<TD>
	<FONT FACE="Verdana, Arial, Helvetica" SIZE=2>



 
The information in this article applies to:
<P>
- Standard and Professional Editions of Microsoft Visual Basic for
<PRE>  Windows, version 2.0 and 3.0
</PRE> 
<P>
<P><h2>SUMMARY</h2>
 
<P>
Visual Basic programmers are sometimes presented with data in a delimited
string. This article shows by example how to use the InStr and Mid
functions to find and extract the parts of a string between delimiters.
<P>
<P><h2>MORE INFORMATION</h2>
 
<P>
Programmers can use the InStr function to search through a string for a sub
string, starting at a specified position. When parsing a delimited string,
use the InStr function to find each occurance of the delimiter in the
string. Do this in a loop using the position of a previously found
delimiter as the starting point for each subsequent search with InStr.
<P>
When the positions of two delimiters within the string have been found, the
Mid function can be used to extract the piece of the string between them.
<P>
The example program below provides a generic function that parses a string
with a given delimiter and returns the pieces in a dynamic array.
<P>
<P><h3>Step-by-Step Example</h3>
 

<OL><P><LI>Start a new project in Visual Basic. Form1 is created by default.

<P><LI>Put the following ParseString function in the General Declarations
   section of Form1:
<P>
<PRE>   ' Enter the following Function statement as one, single line:
   Function ParseString (SubStrs() As String, ByVal SrcStr As String,
      Byval Delimiter As String) As Integer

      ' Dimension variables:
      ReDim SubStrs(0) As String
      Dim CurPos As Long
      Dim NextPos As Long
      Dim DelLen As Integer
      Dim nCount As Integer
      Dim TStr As String

      ' Add delimiters to start and end of string to make loop simpler:
      SrcStr = Delimiter &amp; SrcStr &amp; Delimiter
      ' Calculate the delimiter length only once:
      DelLen = Len(Delimiter)
      ' Initialize the count and position:
      nCount = 0
      CurPos = 1
      NextPos = InStr(CurPos + DelLen, SrcStr, Delimiter)

      ' Loop searching for delimiters:
      Do Until NextPos = 0
         ' Extract a sub-string:
         TStr = Mid$(SrcStr, CurPos + DelLen, NextPos - CurPos - DelLen)
         ' Increment the sub string counter:
         nCount = nCount + 1
         ' Add room for the new sub-string in the array:
         ReDim Preserve SubStrs(nCount) As String
         ' Put the sub-string in the array:
         SubStrs(nCount) = TStr
         ' Position to the last found delimiter:
         CurPos = NextPos
         ' Find the next delimiter:
         NextPos = InStr(CurPos + DelLen, SrcStr, Delimiter)
      Loop

      ' Return the number of sub-strings found:
      ParseString = nCount

   End Function

</PRE><P><LI>Add a command button (Command1) to Form1 and put the following code in
   the Command1 Click event:
<P>
<PRE>   Sub Command1_Click ()
      Dim DataString As String
      Redim SubStr(0) As String
      Dim SubStrCount As Integer
      Dim i As Integer

      ' Create a comma-delimited string:
      DataString = "One,Two,Three,Four"
      Print "Delimited String: " &amp; DataString

      ' Parse the string into sub-strings:
      SubStrCount = ParseString(SubStr(), DataString, ",")

      ' Display the sub-strings:
      For i = 1 to SubStrCount
         Print "Sub-String " &amp; i &amp; ": " &amp; SubStr(i)
      Next
   End Sub

</PRE><P><LI>Save the Project and press F5 to run the application.
<P>
</OL>The delimited string should be displayed on the form as well as each
sub-string extracted from it.
<P>
NOTE: The ParseString routine returns an empty string if it finds two
consecutive delimiters.
<P>

	</FONT>
	</TD>
	</TR>
</TABLE>
<P>


<!--DOCBODY_END-->

<!--FOOTER_START-->
<table cellpadding=5 border=0 width="90%">
<tr>
<td>
	<HR WIDTH="90%">

<BLOCKQUOTE>
<FONT FACE="Verdana, Arial, Helvetica" SIZE="1">
<SPAN STYLE="font-family:verdana,arial,helvetica; font-size:8pt">
Additional reference words: 2.00 3.00<BR>
KBCategory: kbprg kbcode<BR>
KBSubcategory: PrgOther<BR>

</SPAN>
</FONT>
<BR>
<BR>
THE INFORMATION PROVIDED IN THE MICROSOFT KNOWLEDGE BASE IS
PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND.  MICROSOFT DISCLAIMS
ALL WARRANTIES, EITHER EXPRESS OR IMPLIED, INCLUDING THE WARRANTIES
OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  IN NO
EVENT SHALL MICROSOFT CORPORATION OR ITS SUPPLIERS BE LIABLE FOR
ANY DAMAGES WHATSOEVER INCLUDING DIRECT, INDIRECT, INCIDENTAL,
CONSEQUENTIAL, LOSS OF BUSINESS PROFITS OR SPECIAL DAMAGES, EVEN IF
MICROSOFT CORPORATION OR ITS SUPPLIERS HAVE BEEN ADVISED OF THE
POSSIBILITY OF SUCH DAMAGES.  SOME STATES DO NOT ALLOW THE EXCLUSION
OR LIMITATION OF LIABILITY FOR CONSEQUENTIAL OR INCIDENTAL DAMAGES
SO THE FOREGOING LIMITATION MAY NOT APPLY.
</BLOCKQUOTE>
<P>
<center>
	<FONT FACE="Verdana,Arial,Helvetica" SIZE="1">
	Last reviewed:  June 21, 1995</FONT>
	<BR>
	<A href="../cpyright.htm" STYLE="font: bold 7pt Verdana,Arial,Helvetica">&copy; 1998 Microsoft Corporation. All rights reserved. Terms of Use.</A><BR>
	
</center>
</td>
</tr>
</table>

<!--FOOTER_END-->
</FONT>
</BODY>
</HTML>
