

<HTML>
<HEAD>
<TITLE>VB3 Printing Multiline Text Box Using Windows API Functions </TITLE>

<!--STYLE_BEGIN-->
<style>@import url(../../msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="../../msdn_ie3.css">
<!--STYLE_END-->

<META HTTP-EQUIV="CONTENT-Type" CONTENT="text/html; charset=us-ascii">
<META NAME="ms.locale" CONTENT="EN-US">
<META NAME="Category" CONTENT="Support; KB Article">
<META NAME="KBID" CONTENT="Q80867 ">
<META NAME="KBModify" CONTENT="1997/08/18">
<META NAME="KBCreate" CONTENT="1992/02/18">
<META NAME="Keywords" CONTENT="APrgWindow PrgCtrlsStd kbcode kbprg kbcode kbprg kbtlc">
<META NAME="KBArea" CONTENT="Support; KB; vbwin">
<META NAME="Description" CONTENT="  Printing the Text property of a multiline text box while maintaining the line structure requires attention to word wrapping, carriage returns, and line feeds. The programmer can either track the number of characters and lines in code or use Windows...">
<META NAME="Product" CONTENT="Visual Basic for Windows">
<META NAME="Platform" CONTENT="Windows">
<META NAME="Technology" CONTENT=" ">
<META NAME="Premium" CONTENT="support">

<META NAME="nyms" CONTENT="QBV4,QBT6,QAHP,QBXT,QA5V,QAIB,QAH4,QAUD,QAOX,QANE,QAMB,QAY5,QBS0,QATX,QAB9 V02180118">
</HEAD>

<BODY BGCOLOR="#FFFFFF" LEFTMARGIN="0" RIGHTMARGIN="0" TOPMARGIN="0">


<!--DOCBODY_START-->
<BR>
<CENTER>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" VALIGN="top" WIDTH="90%">
	<TR>
		<TD VALIGN="top">
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<H1>VB3 Printing Multiline Text Box Using Windows API Functions</H1>
			</FONT>
			<FONT FACE="verdana,arial,helvetica" SIZE="1">
			Last reviewed:  August 18, 1997</FONT><BR>
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<B>Article ID: Q80867 </B>
			</FONT>
		</TD>
	</TR>
	<TR>
	<TD>
	<FONT FACE="Verdana, Arial, Helvetica" SIZE=2>



 
<P>
 
The information in this article applies to:

<UL><LI>Standard and Professional Editions of Microsoft Visual Basic for
   Windows, versions 2.0 and 3.0
</UL> 
<P>
<P><h2>SUMMARY</h2>
 
<P>
Printing the Text property of a multiline text box while maintaining the
line structure requires attention to word wrapping, carriage returns, and
line feeds. The programmer can either track the number of characters and
lines in code or use Windows API functions to manipulate the Text property.
This article demonstrates these techniques in a Visual Basic example.
<P>
<P><h2>MORE INFORMATION</h2>
 
<P>
The example below demonstrates how to use the API function SendMessage() to
track the number of lines in a multiline text box and to select and print
the lines the way they appear, with line breaks or word wrapping intact.
This code will work without modification even if the form and controls are
resized at run time. The actual position of word wrapping will change.
<P>
For more information about API functions relating to text boxes, query on
the following words in the Microsoft Knowledge Base:
<P>
<PRE>   ("API") and ("text") and ("box") and ("manipulate")

</PRE><h3>Step-by-Step Example</h3>
 

<OL><P><LI>Create a form (Form1) and place a label (Label1), text box (Text1), and
   command button (Command1) on it.

<P><LI>Set the following properties at design time:
<P>
<PRE>   Control    Property      Setting
   --------------------------------------------------------
   Text box   TabIndex      0 (zero, or first in tab order)
   Text box   MultiLine     True
   Label      AutoSize      True
   Label      Name          aGetLineCount

</PRE><P><LI>Add the following code to the (general) (declarations) section of the
   form:
<P>
   NOTE: If you copy-and-paste the code directly from here to Visual Basic,
   try to make sure that before you paste, you remove all carriage returns
   from code strings that must appear on one line.
<P>
<PRE>   ' Enter the following Declare statement on one, single line:
   Declare Function SendMessage% Lib "user" (ByVal hWnd%, ByVal wMsg%,
      ByVal wParam%, ByVal lParam As Any)
   Dim Buffer As String
   Dim resizing As Integer
   Const EM_GETLINE = &amp;H400 + 20
   Const EM_GETLINECOUNT = &amp;H400 + 10
   Const MAX_CHAR_PER_LINE = 80  ' Scale this to size of text box.

</PRE><P><LI>Add the following code to the Form_Load procedure:
<P>
<PRE>   Sub Form_Load ()
      ' Size form relative to screen dimensions.
      ' Could define all in move command but recursive definition causes
      ' extra paints.
      form1.width = screen.width * .8
      form1.height = screen.height * .6
      ' Enter the following form1.Move method on one, single line:
      form1.Move screen.width\2-form1.width\2,
         screen.height\2-form1.height\2
   End Sub

</PRE><P><LI>Add the following code to the Form_Resize procedure:
<P>
<PRE>   Sub Form_Resize ()
      resizing = -1      ' Global  flag for fGetLineCount function call.
      ' Dynamically scale and position the controls in the form.
      ' This code also is executed on first show of form.
      Text1.Move 0, 0, form1.width, form1.height \ 2
      Text1.SelStart = Text1.SelStart
' Enter the following two lines as one, single line:
      command1.Move form1.width\2-command1.width\2,
         form1.height-form1.height\4
      ' Enter the following two lines as one, single line:
      aGetLineCount.Move form1.width \ 2 - command1.width \ 2,
         Text1.height
      X% = fGetLineCount() ' Update to reflect change in text-box size.
      resizing = 0
   End Sub

</PRE><P><LI>Add the following code to the Command1_Click event:
<P>
<PRE>   Sub Command1_Click ()
      '* Pop up an inputbox$ to allow user to specify which line
      '* in the text box to print or print all lines.
      '* Also check bounds so that a valid line number is printed.
      OK = 0                     ' Zero the Do Loop flag.
      NL$ = Chr$(13) + Chr$(10)
      prompt$ = "Which line would you like to print?"
      prompt1$ = prompt$ + NL$ + "Enter -1 for all"
      prompt2$ = "Too many lines" + NL$ + "Try again!" + NL$ + prompt1$
      prompt$ = prompt1$
      Do
         response$ = InputBox$(prompt$, "Printing", "-1")
         If response$ = "" Then Exit Sub  ' If user hits cancel, then exit.
         If Val(response$) &gt; fGetLineCount&amp;() Then
            prompt$ = prompt2$
         Else
            OK = -1        ' Line chosen is in valid range, so exit DO.
         End If
      Loop Until OK
      If Val(response$) = -1 Then  ' Print all lines...
         ndx&amp; = fGetLineCount&amp;()
         For N&amp; = 1 To ndx&amp;
            Buffer = fGetLine(N&amp; - 1)
            printer.Print Buffer       ' ...or print to the screen.
         Next N&amp;
      Else                         ' Print a line...
         Buffer = fGetLine(Val(response$) - 1)
         printer.Print Buffer       ' ...or print to the screen.
      End If
      printer.enddoc
   End Sub

</PRE><P><LI>Add the following code to the (general) (declarations) section of the
   form's code:
<P>
   Function fGetLine$ (LineNumber As Long)
<P><PRE>     ' This function fills the buffer with a line of text
     ' specified by LineNumber from the text-box control.
     ' The first line starts at zero.
      byteLo% = MAX_CHAR_PER_LINE And (255)  '[changed 5/15/92]
      byteHi% = Int(MAX_CHAR_PER_LINE / 256) '[changed 5/15/92]
      Buffer$ = chr$(byteLo%) + chr$(byteHi%)+Space$(MAX_CHAR_PER_LINE-2)
      ' [Above line changed 5/15/92 to correct problem.]
      x% = SendMessage(text1.hwnd, EM_GETLINE, LineNumber, Buffer$)
      fGetLine$ = Left$(Buffer$,X%)
</PRE>   End Function
<P>
   Function fGetLineCount&amp; ()
<P><PRE>      ' This function will return the number of lines
      ' currently in the text-box control.
      ' Setfocus method illegal while in resize event,
      ' so use global flag to see if called from there
      ' (or use setfocus before this function call in general case).
      lcount% = SendMessage(text1.hwnd, EM_GETLINECOUNT, 0&amp;, 0&amp;)
      aGetLineCount.caption = "GetLineCount = " + Str$(lcount%)
      fGetLineCount&amp; = lcount%
</PRE>   End Function

<P><LI>Add the following code to the Text1_Change event:
<P>
<PRE>   Sub Text1_Change ()
      X% = fGetLineCount() '* Update label to reflect current line
   End Sub

</PRE><P><LI>Save the project. Then run the application (press F5).
<P>
</OL>10.Type text in the text box, and either let it wrap or use the
<PRE>   ENTER key to arrange lines.

</PRE></OL>11.Choose the Command1 button or TAB and press ENTER.
<P>
12.Choose the default (which prints all lines) or enter the line
<PRE>   you want. Choose OK. If you choose Cancel, nothing will print.

</PRE>13.Resize the form and repeat steps 10 through 12 above. The text will
<PRE>   appear on the printed page as you see it in the text box when you press
   the Command1 button.

</PRE>NOTE: This example can be modified to send the contents of the text box to
a file or a form instead of to the printer object.
<P>
<P><h2>REFERENCES</h2>
 
<P>
Please see the "Microsoft Windows Programmer's Reference Book and Online
Resource" (Visual Basic Add-on Kit #1-55615-413-5).
<P>

	</FONT>
	</TD>
	</TR>
</TABLE>
<P>


<!--DOCBODY_END-->

<!--FOOTER_START-->
<table cellpadding=5 border=0 width="90%">
<tr>
<td>
	<HR WIDTH="90%">

<BLOCKQUOTE>
<FONT FACE="Verdana, Arial, Helvetica" SIZE="1">
<SPAN STYLE="font-family:verdana,arial,helvetica; font-size:8pt">
Additional query words: textbox<BR>
Keywords          : APrgWindow PrgCtrlsStd kbcode kbprg kbcode kbprg kbtlc<BR>
Version           : 2.0 3.0<BR>
Platform          : WINDOWS<BR>
Issue type        : kbhowto<BR>
Solution Type     : kbcode<BR>

</SPAN>
</FONT>
<BR>
<BR>
THE INFORMATION PROVIDED IN THE MICROSOFT KNOWLEDGE BASE IS
PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND.  MICROSOFT DISCLAIMS
ALL WARRANTIES, EITHER EXPRESS OR IMPLIED, INCLUDING THE WARRANTIES
OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  IN NO
EVENT SHALL MICROSOFT CORPORATION OR ITS SUPPLIERS BE LIABLE FOR
ANY DAMAGES WHATSOEVER INCLUDING DIRECT, INDIRECT, INCIDENTAL,
CONSEQUENTIAL, LOSS OF BUSINESS PROFITS OR SPECIAL DAMAGES, EVEN IF
MICROSOFT CORPORATION OR ITS SUPPLIERS HAVE BEEN ADVISED OF THE
POSSIBILITY OF SUCH DAMAGES.  SOME STATES DO NOT ALLOW THE EXCLUSION
OR LIMITATION OF LIABILITY FOR CONSEQUENTIAL OR INCIDENTAL DAMAGES
SO THE FOREGOING LIMITATION MAY NOT APPLY.
</BLOCKQUOTE>
<P>
<center>
	<FONT FACE="Verdana,Arial,Helvetica" SIZE="1">
	Last reviewed:  August 18, 1997</FONT>
	<BR>
	<A href="../cpyright.htm" STYLE="font: bold 7pt Verdana,Arial,Helvetica">&copy; 1998 Microsoft Corporation. All rights reserved. Terms of Use.</A><BR>
	
</center>
</td>
</tr>
</table>

<!--FOOTER_END-->
</FONT>
</BODY>
</HTML>
