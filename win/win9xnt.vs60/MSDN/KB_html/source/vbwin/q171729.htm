

<HTML>
<HEAD>
<TITLE>HOWTO: Do Generic Callbacks Using a Helper DLL </TITLE>

<!--STYLE_BEGIN-->
<style>@import url(../../msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="../../msdn_ie3.css">
<!--STYLE_END-->

<META HTTP-EQUIV="CONTENT-Type" CONTENT="text/html; charset=us-ascii">
<META NAME="ms.locale" CONTENT="EN-US">
<META NAME="Category" CONTENT="Support; KB Article">
<META NAME="KBID" CONTENT="Q171729">
<META NAME="KBModify" CONTENT="1997/08/04">
<META NAME="KBCreate" CONTENT="1997/07/22">
<META NAME="Keywords" CONTENT="vb5all VBKBDLL VBKBVBA kbhowto">
<META NAME="KBArea" CONTENT="Support; KB; vbwin">
<META NAME="Description" CONTENT="  The new AddressOF operator allows you to pass the Address of a Visual Basic procedure to a DLL for the purposes of providing a Callback function. However, Visual Basic does not let you make the callback directly from within BASIC code. This article...">
<META NAME="Product" CONTENT="Visual Basic for Windows">
<META NAME="Platform" CONTENT="Windows">
<META NAME="Technology" CONTENT=" ">
<META NAME="Premium" CONTENT="support">

<META NAME="nyms" CONTENT="QAY5,QAUD,QAB9,QBV8,QAR5,QAH4,QAMA,QA5F,QDJF,QA7R,QBS0,QAH6,QAP2,QAPN,QATX V02180118">
</HEAD>

<BODY BGCOLOR="#FFFFFF" LEFTMARGIN="0" RIGHTMARGIN="0" TOPMARGIN="0">


<!--DOCBODY_START-->
<BR>
<CENTER>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" VALIGN="top" WIDTH="90%">
	<TR>
		<TD VALIGN="top">
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<H1>HOWTO: Do Generic Callbacks Using a Helper DLL</H1>
			</FONT>
			<FONT FACE="verdana,arial,helvetica" SIZE="1">
			Last reviewed:  August 4, 1997</FONT><BR>
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<B>Article ID: Q171729</B>
			</FONT>
		</TD>
	</TR>
	<TR>
	<TD>
	<FONT FACE="Verdana, Arial, Helvetica" SIZE=2>



 
 
The information in this article applies to:

<UL><LI>Microsoft Visual Basic Control Creation, Learning, Professional, and
   Enterprise Editions for Windows, version 5.0
</UL> 
<P>
<P><h2>SUMMARY</h2>
 
<P>
The new AddressOF operator allows you to pass the Address of a Visual Basic
procedure to a DLL for the purposes of providing a Callback function.
However, Visual Basic does not let you make the callback directly from
within BASIC code. This article provides a helper DLL that makes generic
callback functionality available to BASIC.
<P>
<P><h2>MORE INFORMATION</h2>
 
<P>
The usual way to use the callback mechanism is to write separate DLL
functions for each BASIC function prototype. This article details two
Visual C++ functions that provide a generic callback mechanism for any
BASIC function prototype. The functions work by manipulating the stack,
thus passing the parameters directly to the called function.
<P>
WARNING: ANY USE BY YOU OF THE CODE PROVIDED IN THIS ARTICLE IS AT YOUR OWN
RISK. Microsoft provides this code "as is" without warranty of any kind,
either express or implied, including but not limited to the implied
warranties of merchantability and/or fitness for a particular purpose.
<P>
<P><h3>Visual C++ Code</h3>
 
<P>
The following code was compiled using Microsoft Visual C++ 4.0 but should
work with other compilers. This is in a standard DLL project with multi-
threaded DLL libraries. The calling convention has no prolog code. If
you're unsure, have the compiler generate an .ASM file, examine the output,
and choose a different calling convention. You can ignore epilog code
because it will never get executed.
<P>
NOTE: This code is specific to the INTEL platform only.
<P>
<P><h3>Callback.DEF</h3>
 
<P>
<PRE>   LIBRARY   VB5Callback

   EXPORTS
      Callback
      Callback2

</PRE><h3>Callback.CPP</h3>
 
<P>
<PRE>   __declspec(naked) void Callback()
   {

   /* For procedures with return values of 8 bytes or less */

   /* Get address to be called and fix-up return address */

      _asm  pop   eax;        // save return address
      _asm  pop   ecx;        // get address to JMP to
      _asm  push  eax;        // restore return address
      _asm  jmp   ecx;        // Jump to callback function....
   }

   __declspec(naked) void Callback2()
   {

   /* For procedures with return values of more than 8 bytes */

   /* Get address to be called and fix-up return address */

      _asm  pop   eax;        // save return address
      _asm  pop   edx;        // save parameter 0
      _asm  pop   ecx;        // get address to JMP to
      _asm  push  edx;        // restore parameter 0
      _asm  push  eax;        // restore return address
      _asm  jmp   ecx;        // Jump to callback function....
   }


</PRE><h3>Visual Basic Code</h3>
 
<P>
The function prototypes in BASIC are achieved by using the DECLARE
statement because the BASIC compiler does no type checking on the DLL
functions. The first argument needs to be a LONG with which to pass the
address of the function to be called. Subsequent arguments and the function
return type should match the callback function exactly.
<P>
<P><h3>Sample Callback Function Declarations:</h3>
 
<P>
The callback functions must reside in a standard .BAS module. They cannot
reside in a Form or Class module:
<P>
<PRE>   Sub Message()
   Function Calc(ByVal X As Long, Y As Long) As Long
   Function StrPrt(ByVal S As String) As String
   Function RetVariant() As Variant

</PRE><h3>Sample Declare Statements</h3>
 
<P>
The declare statements can be anywhere. If in a Form or Class module, they
need to be declared using Private Declare ...:
<P>
<PRE>   Declare Sub CallMessage Lib "Callback.dll" Alias "Callback" _
       (ByVal Addr As Long)
   Declare Function CallCalc Lib "Callback.dll" Alias "Callback" _
       (ByVal Addr As Long, ByVal X As Long, Y As Long) As Long
   Declare Function CallStrPrt Lib "Callback.dll" Alias "Callback" _
       (ByVal Addr As Long, ByVal S As String) As String
   Declare Function CallRetVariant Lib "Callback.dll" Alias "Callback2" _
       (ByVal Addr As Long) As Variant

</PRE>The use of "Callback" or "Callback2" depends on the function return type as
explained in the Return Type table (below).
<P>
<P><h3>Sample Usage</h3>
 
<P>
The callback functions can be called from anywhere in scope of the
prototype Declare statement:
<P>
<PRE>   CallMessage AddressOf Message
   iResult = CallCalc(AddressOf Calc, 6, iNum)
   S$ = CallStrPrt(AddressOf StrPrt, "The moon is rising over Toledo")
   Debug.Print CallRetVariant(AddressOf RetVariant)

</PRE><h3>Return-type Table</h3>
 
<P>
The following table indicates which return types should use Callback and
which should use Callback2 in their Declare statements.
<P>
Two versions of the function are required. The first is for Sub routines
and all Function prototypes whose return type occupies 8 bytes or less,
including all object types and String. The second is for Function
prototypes whose return argument is greater than 8 bytes, namely all
Variants and those User-Defined Types whose length is greater than 8 bytes.
<P>
The reason for this dichotomy is that Visual Basic can't return these large
data types in a register. It passes the address of a pre-allocated
structure as an implicit parameter on the stack, which the second callback
function takes into account.
<P>
<PRE>   Return Type                            DLL Function
   ----------------------------           --------------------
   All Sub routines                       Callback
   Byte                                   Callback
   Integer                                Callback
   Boolean                                Callback
   Long                                   Callback
   Single                                 Callback
   Double                                 Callback
   Currency                               Callback
   Date                                   Callback
   String                                 Callback
   Variant                                           Callback2
   Any object type                        Callback
   User-defined type (8-bytes or less)    Callback
   User-defined Type (more than 8 bytes)             Callback2

</PRE>If you're unsure about which function to use with your user-defined type,
you may have to try both functions and see which one works. The example
below illustrates Types requiring both Callback and Callback2:
<P>
<PRE>   Type Size8          ' functions returning this type require Callback
     A As Long         ' 4 bytes
     B As String       ' 4-byte pointer - note String discussion below
   End Type

   Type Size12         ' functions returning this type require Callback2
     A As Long         ' 4 bytes
     B As Double       ' 8 bytes
   End Type

</PRE><h3>A Note About Strings</h3>
 
<P>
Because BASIC is calling a DLL, it will convert string parameters from
UNICODE to ANSI when calling, and back to UNICODE when returning. If the
function returns a String, it undergoes the ANSI to UNICODE conversion
process also. The callback function receives the converted (ANSI) string,
which can present problems. This also applies to Strings in User-Defined
types. There are several ways to deal with this problem:

<OL><P><LI>Use the StrConv() function in the callback function to do the
   appropriate conversions upon entry and exit.

<P><LI>Use Byte arrays. These don't undergo conversion.

<P><LI>Use Variant. These don't undergo conversion and can be used as function
   return, whereas Byte arrays cannot.
<P>
</OL>It is recommended that you use a Variant to pass strings as the most simple
and flexible option.
<P>
NOTE: You don't have to use the Callback2 function unless you return a
Variant or large User-Defined Type as the function result. Using Variants
and User-defined types as function arguments has no bearing on which DLL
function to use in your Declare statement.
<P>
<P><h3>Other Notes</h3>
 
<P>
In many cases, you can get similar functionality completely in BASIC by
using a SELECT CASE statement to call multiple implementations of the same
prototype, or by using callback objects. The main area where the all-BASIC
solution won't apply is using components that require calling back into
your code and that need to call a function rather than an object.
(c) Microsoft Corporation 1997, All Rights Reserved.
Contributions by Malcolm Stewart, Microsoft Corporation
(c) Microsoft Corporation 1997, All Rights Reserved.
Contributions by Richard Ault, Microsoft Corporation
 
<PRE>Keywords          : vb5all VBKBDLL VBKBVBA kbhowto
Version           : 5.0
Platform          : WINDOWS</PRE>

	</FONT>
	</TD>
	</TR>
</TABLE>
<P>


<!--DOCBODY_END-->

<!--FOOTER_START-->
<table cellpadding=5 border=0 width="90%">
<tr>
<td>
	<HR WIDTH="90%">

<BLOCKQUOTE>
<FONT FACE="Verdana, Arial, Helvetica" SIZE="1">
<SPAN STYLE="font-family:verdana,arial,helvetica; font-size:8pt">
================================================================================<BR>

</SPAN>
</FONT>
<BR>
<BR>
THE INFORMATION PROVIDED IN THE MICROSOFT KNOWLEDGE BASE IS
PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND.  MICROSOFT DISCLAIMS
ALL WARRANTIES, EITHER EXPRESS OR IMPLIED, INCLUDING THE WARRANTIES
OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  IN NO
EVENT SHALL MICROSOFT CORPORATION OR ITS SUPPLIERS BE LIABLE FOR
ANY DAMAGES WHATSOEVER INCLUDING DIRECT, INDIRECT, INCIDENTAL,
CONSEQUENTIAL, LOSS OF BUSINESS PROFITS OR SPECIAL DAMAGES, EVEN IF
MICROSOFT CORPORATION OR ITS SUPPLIERS HAVE BEEN ADVISED OF THE
POSSIBILITY OF SUCH DAMAGES.  SOME STATES DO NOT ALLOW THE EXCLUSION
OR LIMITATION OF LIABILITY FOR CONSEQUENTIAL OR INCIDENTAL DAMAGES
SO THE FOREGOING LIMITATION MAY NOT APPLY.
</BLOCKQUOTE>
<P>
<center>
	<FONT FACE="Verdana,Arial,Helvetica" SIZE="1">
	Last reviewed:  August 4, 1997</FONT>
	<BR>
	<A href="../cpyright.htm" STYLE="font: bold 7pt Verdana,Arial,Helvetica">&copy; 1998 Microsoft Corporation. All rights reserved. Terms of Use.</A><BR>
	
</center>
</td>
</tr>
</table>

<!--FOOTER_END-->
</FONT>
</BODY>
</HTML>
