

<HTML>
<HEAD>
<TITLE>How to Create Nested Queries in Visual Basic 3.0 Prof Edition </TITLE>

<!--STYLE_BEGIN-->
<style>@import url(../../msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="../../msdn_ie3.css">
<!--STYLE_END-->

<META HTTP-EQUIV="CONTENT-Type" CONTENT="text/html; charset=us-ascii">
<META NAME="ms.locale" CONTENT="EN-US">
<META NAME="Category" CONTENT="Support; KB Article">
<META NAME="KBID" CONTENT="Q113335">
<META NAME="KBModify" CONTENT="1995/07/20">
<META NAME="KBCreate" CONTENT="1994/03/31">
<META NAME="Keywords" CONTENT="kbprg kbcode">
<META NAME="KBArea" CONTENT="Support; KB; vbwin">
<META NAME="Description" CONTENT="  Subqueries are Select statements that are embedded within an outer query. The Microsoft Access engine in Visual Basic version 3.0 and in Microsoft Access version 1.1 cannot handle subqueries directly.  Here's an example of a subquery:     UPDATE Or...">
<META NAME="Product" CONTENT="Visual Basic for Windows">
<META NAME="Platform" CONTENT="Windows">
<META NAME="Technology" CONTENT=" ">
<META NAME="Premium" CONTENT="support">

<META NAME="nyms" CONTENT="QAMB,QBS0,QAN0,QBXT,QA5V,QAIB,QAOX,QAH4,QA2R,QA1S,QBXS,QA2Q,QAZV,QAY2,QAUD V02180118">
</HEAD>

<BODY BGCOLOR="#FFFFFF" LEFTMARGIN="0" RIGHTMARGIN="0" TOPMARGIN="0">


<!--DOCBODY_START-->
<BR>
<CENTER>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" VALIGN="top" WIDTH="90%">
	<TR>
		<TD VALIGN="top">
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<H1>How to Create Nested Queries in Visual Basic 3.0 Prof Edition</H1>
			</FONT>
			<FONT FACE="verdana,arial,helvetica" SIZE="1">
			Last reviewed:  July 20, 1995</FONT><BR>
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<B>Article ID: Q113335</B>
			</FONT>
		</TD>
	</TR>
	<TR>
	<TD>
	<FONT FACE="Verdana, Arial, Helvetica" SIZE=2>



 
The information in this article applies to:
<P>
- Professional Edition of Microsoft Visual Basic for Windows,
<PRE>  version 3.0
</PRE> 
<P>
<P><h2>SUMMARY</h2>
 
<P>
Subqueries are Select statements that are embedded within an outer query.
The Microsoft Access engine in Visual Basic version 3.0 and in Microsoft
Access version 1.1 cannot handle subqueries directly.
<P>
Here's an example of a subquery:
<P>
<PRE>   UPDATE Orders SET Orders.ItemCount = (SELECT COUNT(*) WHERE
      Orders.OrderNum = Item.OrderNum)

</PRE>This particular query could be handled with the intrinsic Microsoft Access
engine's DCount function:
<P>
<PRE>   UPDATE Orders SET Orders.ItemCount =
      DCount('*'','Orders','Orders.OrderNum = Item.OrderNum')

</PRE>However, there are many cases when an intrinsic function is not available
but the need for a subquery remains. In these cases, the database
programmer can use nested queries to accomplish the same task.
<P>
<P><h2>MORE INFORMATION</h2>
 
<P>
NOTE: The following queries are based on the sample database (BIBLIO.MDB)
that comes with Visual Basic version 3.0. BIBLIO.MDB contains entries on
actual reference works dealing with database programming.
<P>
For example, subqueries are useful when you need to find all the books that
were published the same year as the book, "The database experts' guide to
SQL." You could do this in two steps. First, find out what year that the
book was published:
<P>
<PRE>   SELECT DISTINCTROW [year published] from titles
      WHERE titles.title = 'The database experts'' guide to SQL'
      WITH OWNERACCESS OPTION;

</PRE>Then take the result (1988) and build a second query based on this result:
<P>
<PRE>   SELECT DISTINCTROW  title,[year published] from titles
      WHERE titles.[year published] = 1988
      WITH OWNERACCESS OPTION;

</PRE>Microsoft SQL Server syntax would support the combination of these two
queries into one query with a subquery:
<P>
<PRE>   SELECT  DISTINCT title,[year published]
      From titles
      WHERE titles.[year published] =
      (Select  [year published] from titles
      WHERE titles.title = 'The database experts'' guide to SQL' )

</PRE>However, the Microsoft Access engine cannot parse this directly, so the
alternative is to create a QueryDef in a Microsoft Access-format database;
then reference this querydef in a succeeding query. This nesting can be of
multiple levels. However, all the nested queries must be resolved in order
to return the result from the outer or topmost query. Therefore, you may
find that at some multiple level of nesting, performance will become
unacceptable or the engine's internal workspace capacity will be exceeded.
<P>
NOTE: Even if the data sources are not Microsoft Access databases (.MDB
files), the performance gains from making the data sources into attached
tables in a .MDB database as well as the added benefit of being able to
create and store querydefs, makes the use of even a data-free .MDB file a
compelling choice. The .MDB file could be used to hold only the TableDefs
of attached tables and QueryDefs, whether permanently stored or created on
the fly during the execution of your program. For additional information,
please see the following article in the Microsoft Knowledge Base:
<P>
ARTICLE-ID: <B><A href="../vbwin/q108423.htm">Q108423</A></B>
<PRE>TITLE     : How to Attach an External Database Table to a VB 3.0 Database

</PRE><h3>Visual Basic Code -- Example One</h3>
 
<P>
Here's an illustration of the Visual Basic solution to the limitation on
subqueries. The following shows the code that can handle the specific
example referenced above by using a nested query. The goal is to obtain all
the books published the same year as the book "The database experts' guide
to SQL."
<P>
Dim db As database, ds As Dynaset, qd As QueryDef
Set db = OpenDatabase("C:\VB\BIBLIO.MDB")
<P>
<PRE>' Formulate subquery. Enter all three lines as one, single line of code:
</PRE>subq$ = "SELECT DISTINCTROW  [year published] from titles
<PRE>   where titles.title = 'The database experts'' guide to SQL'
   WITH OWNERACCESS OPTION;"

' NOTE: Because the book title contains an embedded single quotation mark
' or apostrophe, note the use of doubled apostrophes in the book title
' string literal to avoid confusing the SQL parser.

' For testing purposes, delete any existing QueryDef, and change the
' first run db.DeleteQueryDef ("Year Book Was Published") into a comment.
' Next, create a QueryDef in the BIBLIO.MDB:
</PRE>Set qd = db.CreateQueryDef("Year Book Was Published", subq$)
<P>
<PRE>' Now, the following SQL statement will obtain the desired results.
' Enter the following five lines as one, single line in Visual Basic:
</PRE>Set ds = db.CreateDynaset("SELECT DISTINCTROW
<PRE>   title,titles.[year published]
   from titles , [Year Book Was Published] where titles.[year published] =
   [Year Book Was Published].[year published]
   WITH OWNERACCESS OPTION;")

</PRE>Notice that the column or field name returned by the QueryDef, [year
published], is available as a valid field reference in the Where clause of
the outer query. If the column names are aliased, using the &lt;columnname&gt; As
&lt;aliasname&gt; syntax, then the aliasname must be used by the outer query when
referring to columns returned by the query, as in Example Two.
<P>
<P><h3>Visual Basic Code -- Example Two</h3>
 
<P>
Dim db As database, ds As Dynaset, qd As QueryDef
<P>
Set db = OpenDatabase("E:\PROGDIR\VB3\BIBLIO.MDB")
<P>
<PRE>' Enter the following four lines as one, single line:
</PRE>s$ = "select authors.au_id as temp1,authors.author as temp2,
<PRE>   titles.title as temp3, titles.pubID as temp4 from authors,titles,
   authors inner join titles on authors.au_ID=titles.au_ID
   order by authors.author"

' For testing purposes, delete any existing QueryDef. Turn the following
' into a comment line on the first run:
</PRE>db.DeleteQueryDef ("Nested")
<P>
Set qd = db.CreateQueryDef("Nested", s$)
<P>
<PRE>' Now build a query based on the columns in the inner nested QueryDef.
' Enter the following two lines as one, single line of code:
</PRE>Set ds = db.CreateDynaset("select temp1, temp2, temp3, publishers.name from
<PRE>   publishers, Nested where publishers.pubid=temp4 order by temp2")

</PRE><h3>Same Queries Without the Use of Aliases</h3>
 
<P>
The same queries without the use of aliases would be as follows. Note that
you need to enter each query as one, single line:
<P>
<PRE>' Enter the following three lines as one, single line:
</PRE>s$ = "select authors.au_id ,authors.author , titles.title , titles.pubID
<PRE>   from authors,titles, authors inner join titles on
   authors.au_ID=titles.au_ID order by authors.author"

' For testing purposes, delete any existing QueryDef. Turn the following
' into a comment line on the first run:
</PRE>db.DeleteQueryDef ("Nested")
<P>
Set qd = db.CreateQueryDef("Nested", s$)
<P>
<PRE>' Now build a query based on the columns in the inner nested QueryDef.
' Enter the following three lines as one, single line of code:
</PRE>Set ds = db.CreateDynaset("select authors.au_id,authors.author,
<PRE>   titles.title,publishers.name from publishers,
   Nested where publishers.pubid=titles.pubid order by authors.author")

</PRE><h3>Getting the Results of a Non-Existence Query</h3>
 
<P>
A more challenging application is to get the results of a non-existence
query. For example, if you needed to find out all the publishers who have
no books in the database that were published in the year 1988, some form of
subquery would be needed. Therefore, you could do it using nested queries
in the Microsoft Access engine in Visual Basic version 3.0 and Microsoft
Access version 1.1.
<P>
The first QueryDef is built on the following SQL statement:
<P>
<PRE>   SELECT DISTINCTROW titles.title, titles.[year published],titles.pubid
      FROM titles
      WHERE titles.[year published]= 1988
      WITH OWNERACCESS OPTION;

</PRE>This returns those book titles, along with their associated pubid field,
that were published in 1988. Next, the following outer join (Left Join in
Microsoft Access syntax), allows you to look for non-existence, in the form
of Nulls in the result set:
<P>
<PRE>   SELECT DISTINCTROW publishers.pubid, publishers.name
      FROM publishers, [titles in 1988],
      publishers LEFT JOIN [titles in 1988]
      ON publishers.pubid = [titles in 1988].pubid
      WHERE [titles in 1988].pubid Is Null
      WITH OWNERACCESS OPTION;

</PRE><h3>Visual Basic Code -- Example Three</h3>
 
<P>
NOTE: Place the command button Command1 in the lower left corner of the
form to allow room for the printing to the form.
<P>
<PRE>Sub Command1_Click ()
</PRE>Dim db As database
Dim ds As Dynaset
Dim qd As QueryDef
Dim NL$, Tabb$, subq$, query$
<P>
NL$ = Chr$(13) &amp; Chr$(10)
Tabb$ = Chr$(9) &amp; Chr$(9)
<P>
Set db = OpenDatabase("E:\PROGDIR\VB3\BIBLIO.MDB")
<P>
<PRE>' Formulate the query that selects titles published in 1988.
' Enter the following three lines as one, single line of code:
</PRE>subq$ = "SELECT DISTINCTROW titles.title, titles.[year
<PRE>   published],titles.pubid FROM titles
   WHERE titles.[year published]= 1988 WITH OWNERACCESS OPTION;"

' For testing purposes, delete any existing QueryDef. Turn the following
' line into a comment on the first run:
</PRE>db.DeleteQueryDef ("titles in 1988")
<P>
<PRE>' Next, create the inner query:
</PRE>Set qd = db.CreateQueryDef("titles in 1988", subq$)
<P>
<PRE>' Print to the form the contents of the sub query for a sanity check:
</PRE>Me.WindowState = 2  ' Maximize form for more room
Set ds = qd.CreateDynaset()
Print " Name : "; ds.Name
While Not ds.EOF
<PRE>   For i = 0 To ds.Fields.Count - 1
      Print ds(i); Tabb$;
   Next i
   Print
   ds.MoveNext
</PRE>Wend
<P>
Print NL$, NL$
<P>
<PRE>' Now formulate a query based on the previous query.
' Enter the following four lines as one, single line of code:
</PRE>query$ = "SELECT DISTINCTROW publishers.pubid, publishers.name FROM
<PRE>   publishers, [titles in 1988], publishers LEFT JOIN [titles in 1988]
   ON publishers.pubid = [titles in 1988].pubid WHERE [titles
   in 1988].pubid Is Null WITH OWNERACCESS OPTION;"

' For testing purposes, delete any existing QueryDef. But turn the
' following into a comment on the first run:
</PRE>db.DeleteQueryDef ("publishers who have no titles in 1988")
<P>
Set qd = db.CreateQueryDef("publishers who have no titles in 1988", query$)
Set ds = qd.CreateDynaset()
<P>
<PRE>' Print to the form the contents of the outer query:
</PRE>Print " Name : "; ds.Name
While Not ds.EOF
<PRE>   For i = 0 To ds.Fields.Count - 1
      Print ds(i); Tabb$;
   Next i
   Print
   ds.MoveNext
</PRE>Wend
<P>
Print NL$, NL$
<P>
<PRE>' Or print the contents of a Dynaset directly based on the subquery:
</PRE>Set ds = db.CreateDynaset(query$)
<P>
<PRE>' Enter the following two lines as one, single line of code:
</PRE>Print "The results of a direct CreateDynaset with SQL referencing the
QueryDef [titles in 1988]"
<P>
Print " Name : "; ds.Name
While Not ds.EOF
<PRE>   For i = 0 To ds.Fields.Count - 1
      Print ds(i); Tabb$;
   Next i
   Print
   ds.MoveNext
</PRE>Wend
<P>
ds.Close
qd.Close
db.Close
<PRE>End Sub
</PRE>

	</FONT>
	</TD>
	</TR>
</TABLE>
<P>


<!--DOCBODY_END-->

<!--FOOTER_START-->
<table cellpadding=5 border=0 width="90%">
<tr>
<td>
	<HR WIDTH="90%">

<BLOCKQUOTE>
<FONT FACE="Verdana, Arial, Helvetica" SIZE="1">
<SPAN STYLE="font-family:verdana,arial,helvetica; font-size:8pt">
Additional reference words: 3.00<BR>
KBCategory: kbprg kbcode<BR>
KBSubcategory: APrgDataOther<BR>

</SPAN>
</FONT>
<BR>
<BR>
THE INFORMATION PROVIDED IN THE MICROSOFT KNOWLEDGE BASE IS
PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND.  MICROSOFT DISCLAIMS
ALL WARRANTIES, EITHER EXPRESS OR IMPLIED, INCLUDING THE WARRANTIES
OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  IN NO
EVENT SHALL MICROSOFT CORPORATION OR ITS SUPPLIERS BE LIABLE FOR
ANY DAMAGES WHATSOEVER INCLUDING DIRECT, INDIRECT, INCIDENTAL,
CONSEQUENTIAL, LOSS OF BUSINESS PROFITS OR SPECIAL DAMAGES, EVEN IF
MICROSOFT CORPORATION OR ITS SUPPLIERS HAVE BEEN ADVISED OF THE
POSSIBILITY OF SUCH DAMAGES.  SOME STATES DO NOT ALLOW THE EXCLUSION
OR LIMITATION OF LIABILITY FOR CONSEQUENTIAL OR INCIDENTAL DAMAGES
SO THE FOREGOING LIMITATION MAY NOT APPLY.
</BLOCKQUOTE>
<P>
<center>
	<FONT FACE="Verdana,Arial,Helvetica" SIZE="1">
	Last reviewed:  July 20, 1995</FONT>
	<BR>
	<A href="../cpyright.htm" STYLE="font: bold 7pt Verdana,Arial,Helvetica">&copy; 1998 Microsoft Corporation. All rights reserved. Terms of Use.</A><BR>
	
</center>
</td>
</tr>
</table>

<!--FOOTER_END-->
</FONT>
</BODY>
</HTML>
