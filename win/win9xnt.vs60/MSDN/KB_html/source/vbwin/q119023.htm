

<HTML>
<HEAD>
<TITLE>PRB: VB ODBC Error "Connection is busy with results..." </TITLE>

<!--STYLE_BEGIN-->
<style>@import url(../../msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="../../msdn_ie3.css">
<!--STYLE_END-->

<META HTTP-EQUIV="CONTENT-Type" CONTENT="text/html; charset=us-ascii">
<META NAME="ms.locale" CONTENT="EN-US">
<META NAME="Category" CONTENT="Support; KB Article">
<META NAME="KBID" CONTENT="Q119023">
<META NAME="KBModify" CONTENT="1996/03/29">
<META NAME="KBCreate" CONTENT="1994/08/04">
<META NAME="Keywords" CONTENT="kbinterop kbprg kbprb">
<META NAME="KBArea" CONTENT="Support; KB; vbwin">
<META NAME="Description" CONTENT="  When accessing an SQL Server database as an ODBC data source in Visual Basic versions 3.0 or 4.0 with the Microsoft Access version 2.0 Compatibility Layer installed, error message 3146 may occur:      ODBC-call failed.  [Microsoft][ODBC SQL Server ...">
<META NAME="Product" CONTENT="Visual Basic for Windows">
<META NAME="Platform" CONTENT="Windows">
<META NAME="Technology" CONTENT=" ">
<META NAME="Premium" CONTENT="support">

<META NAME="nyms" CONTENT="QBS0,QBXS,QAPN,QAL3,QAI5,QABM,QA1S,QA9E,QAB4,QBG2,QAAP,QAZV,QDN9,QBW7,QAW6 V02180118">
</HEAD>

<BODY BGCOLOR="#FFFFFF" LEFTMARGIN="0" RIGHTMARGIN="0" TOPMARGIN="0">


<!--DOCBODY_START-->
<BR>
<CENTER>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" VALIGN="top" WIDTH="90%">
	<TR>
		<TD VALIGN="top">
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<H1>PRB: VB ODBC Error "Connection is busy with results..."</H1>
			</FONT>
			<FONT FACE="verdana,arial,helvetica" SIZE="1">
			Last reviewed:  March 29, 1996</FONT><BR>
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<B>Article ID: Q119023</B>
			</FONT>
		</TD>
	</TR>
	<TR>
	<TD>
	<FONT FACE="Verdana, Arial, Helvetica" SIZE=2>



 
The information in this article applies to:

<UL><LI>Professional and Enterprise Editions of Microsoft
   Visual Basic, 16-bit and 32-bit, for Windows, version 4.0
<LI>Professional Edition of Microsoft Visual Basic for Windows,
   version 3.0
<LI>Microsoft Jet 2.0/Visual Basic 3.0 Compatibility Layer
</UL> 
<P>
<P><h2>SUMMARY</h2>
 
<P>
When accessing an SQL Server database as an ODBC data source in Visual
Basic versions 3.0 or 4.0 with the Microsoft Access version 2.0
Compatibility Layer installed, error message 3146 may occur:
<P>
<PRE>    ODBC-call failed.  [Microsoft][ODBC SQL Server Driver]Connection is
    busy with results for another hstmt [#0]

</PRE>This error is the result of the SQL Server ODBC driver. The driver can only
handle one active statement at a time. The statement remains active until
all the rows are fetched.
<P>
<P><h2>MORE INFORMATION</h2>
 
<P>
This problem occurs because of a change in the behavior of the Microsoft
Access engine between versions 1.1 and 2.0. In Visual Basic version 3.0, as
shipped with the database engine in Microsoft Access version 1.1, when the
DB_SQLPASSTHROUGH flag was used with CreateSnapshot, CreateDynaset, or as a
setting for the Options property of the data control, the engine fully
populated all result sets before the next Visual Basic statement could be
executed.
<P>
A fully populated result set means that all the rows or records in the
result set have been visited and fetched to the client machine. This was
accomplished by doing the equivalent of a &lt;your data access
object&gt;.MoveLast implicitly before the method (CreateDynaset,
CreateSnapshot, &lt;your data control&gt;.Refresh or the creation of the form
with the data control) returned.
<P>
Using the Compatibility Layer and the database engine in Microsoft Access
version 2.0, this automatic forcing of a fully populated result set no
longer occurs. This design decision was made because fully populating
result sets can be expensive in terms of performance. It was decided to
allow the programmer the control over whether the result set is fully
populated. This gives the programmer the flexibility of choosing whether to
fully populate the result set and when, either by slow navigation
or in an explicit &lt;your data access object&gt;.MoveLast at a point after the
initial object creation.
<P>
This error occurs when there are pending results on a statement handle that
is then used to execute another query. This causes a problem when the ODBC
data source is a SQL Server (Microsoft or Sybase) because, owing to the
architectural design, there can be only one active statement per connection
on an SQL Server.
<P>
Therefore the SQL Server ODBC driver (SQLSRVR.DLL) cannot allow multiple
active HSTMTs on a single connection handle or HDBC. An active statement is
defined as a statement that has pending results; that is, the whole result
set has not been read from the server.
<P>
When a result set is created with the DB_SQLPASSTHROUGH flag, an HSTMT,
which is an ODBC statement handle, is tied up waiting on the pending fetch
of the entire result set. If there are pending results on a connection when
the next query is executed, the error occurs.
<P>
When the DB_SQLPASSTHROUGH flag is NOT used, the connection manager
component of the engine creates additional connections for each of the
statements, because these statements may be pending throughout the life of
the data access object (DAO). In the case of dynasets or data controls
(which are wrappers for a database object and a dynaset), because these
represent updateable result sets, a two-way connection must be maintained.
<P>
NOTE: These connections (HDBCs) can be recycled by the connection manager
as they go idle. The time they are maintained is a function of activity and
the ConnectionTimeout setting in the [ODBC] section of the VB.INI or &lt;your
exename&gt;.INI file. See the following articles in the Microsoft Knowledge
Base for more information:
<P>
<PRE>   ARTICLE-ID: <B><A href="../vbwin/q110227.htm">Q110227</A></B>
   TITLE     : PRB: ODBC Database Remains Open After a Close Method Used

   ARTICLE-ID: <B><A href="../vbwin/q115237.htm">Q115237</A></B>
   TITLE     : How to Use Temporary Tables in SQL Server from Visual Basic
               3.0

</PRE><h2>WORKAROUND</h2>
 
<P>
The solution for the changed behavior of the Microsoft Access 2.0 engine is
to add an explicit &lt;your data access object&gt;.MoveLast after each query
executed using DB_SQLPASSTHROUGH thereby forcing full population of the
result set. This will be no slower than the original Visual Basic version
3.0 performance and possibly faster, and it will prevent the error from
occurring.
<P>
For Microsoft Access version 1.1 compatibility, placing an extra
(redundant) &lt;your data access object&gt;.MoveLast after the creation of the
DAO will not cost any more, because the result set is already fully
populated automatically.
<P>
<P><h2>CODE EXAMPLE</h2>
 
<P>
Use the following code to demonstrate and work around the problem (NOTE:
all statements must be complete on one line):
<P>
<PRE>   Dim db As database, sn As snapshot, sn2 As snapshot
   Dim sql As String

   Set db = OpenDatabase("", 0, 0,
    "odbc;dsn=texas;uid=sa;pwd=;database=library;")

   sql = "select * from adultwide where member_no &lt; 2001"
   Set sn = db.CreateSnapshot(sql, 64)

   ' Uncomment the next line to work around the problem.
   ' sn.MoveLast

   sql = "select * from adultwide where member_no &lt; 2001"
   Set sn2 = db.CreateSnapshot(sql)
   ' This second CreateSnapshot causes the error:
   '  ODBC--call failed. [Microsoft][ODBC SQL Server Driver]Connection
   '  is busy with results for another hstmt (#0).

</PRE>Use the following code to trap the error:
<P>
<PRE>   Dim db As database, sn As snapshot, sn2 As snapshot
   Dim sql As String

   On Error GoTo handle

   Set db = OpenDatabase("", 0,
   0,"odbc;dsn=texas;uid=sa;pwd=;database=library;"
   )

   sql = "select * from adultwide where member_no &lt; 2001"
   Set sn = db.CreateSnapshot(sql, 64)

   sql = "select * from adultwide where member_no &lt; 2001"
   Set sn2 = db.CreateSnapshot(sql)

   Exit Sub
   handle:
   ' This local error handler could call a central global handler
   ' and use a global object pointer (Global glbsn As snapshot) to
   ' track any pending snapshots; for example:
   '   Set sn = db.CreateSnapshot(sql, 64)
   '   Set glbsn=sn
   ' Then in the handler, do =&gt; glbsn.MoveLast

   sn.MoveLast
   Resume
</PRE>

	</FONT>
	</TD>
	</TR>
</TABLE>
<P>


<!--DOCBODY_END-->

<!--FOOTER_START-->
<table cellpadding=5 border=0 width="90%">
<tr>
<td>
	<HR WIDTH="90%">

<BLOCKQUOTE>
<FONT FACE="Verdana, Arial, Helvetica" SIZE="1">
<SPAN STYLE="font-family:verdana,arial,helvetica; font-size:8pt">
Additional reference words: 3.00 4.00 vb4all vb4win<BR>
KBCategory: kbinterop kbprg kbprb<BR>
KBSubcategory: APrgDataODBC<BR>

</SPAN>
</FONT>
<BR>
<BR>
THE INFORMATION PROVIDED IN THE MICROSOFT KNOWLEDGE BASE IS
PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND.  MICROSOFT DISCLAIMS
ALL WARRANTIES, EITHER EXPRESS OR IMPLIED, INCLUDING THE WARRANTIES
OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  IN NO
EVENT SHALL MICROSOFT CORPORATION OR ITS SUPPLIERS BE LIABLE FOR
ANY DAMAGES WHATSOEVER INCLUDING DIRECT, INDIRECT, INCIDENTAL,
CONSEQUENTIAL, LOSS OF BUSINESS PROFITS OR SPECIAL DAMAGES, EVEN IF
MICROSOFT CORPORATION OR ITS SUPPLIERS HAVE BEEN ADVISED OF THE
POSSIBILITY OF SUCH DAMAGES.  SOME STATES DO NOT ALLOW THE EXCLUSION
OR LIMITATION OF LIABILITY FOR CONSEQUENTIAL OR INCIDENTAL DAMAGES
SO THE FOREGOING LIMITATION MAY NOT APPLY.
</BLOCKQUOTE>
<P>
<center>
	<FONT FACE="Verdana,Arial,Helvetica" SIZE="1">
	Last reviewed:  March 29, 1996</FONT>
	<BR>
	<A href="../cpyright.htm" STYLE="font: bold 7pt Verdana,Arial,Helvetica">&copy; 1998 Microsoft Corporation. All rights reserved. Terms of Use.</A><BR>
	
</center>
</td>
</tr>
</table>

<!--FOOTER_END-->
</FONT>
</BODY>
</HTML>
