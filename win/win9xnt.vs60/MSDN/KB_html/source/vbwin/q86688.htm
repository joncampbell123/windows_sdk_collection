

<HTML>
<HEAD>
<TITLE>Example to Evaluate Basic Numeric Expressions </TITLE>

<!--STYLE_BEGIN-->
<style>@import url(../../msdn_ie4.css);</style>
	<link disabled rel="stylesheet" href="../../msdn_ie3.css">
<!--STYLE_END-->

<META HTTP-EQUIV="CONTENT-Type" CONTENT="text/html; charset=us-ascii">
<META NAME="ms.locale" CONTENT="EN-US">
<META NAME="Category" CONTENT="Support; KB Article">
<META NAME="KBID" CONTENT="Q86688 ">
<META NAME="KBModify" CONTENT="1995/06/21">
<META NAME="KBCreate" CONTENT="1992/07/14">
<META NAME="Keywords" CONTENT="kbprg kbcode">
<META NAME="KBArea" CONTENT="Support; KB; vbwin">
<META NAME="Description" CONTENT="  This article contains an example program that evaluates a numeric expression contained in a string, mimicking the operators, built-in functions, and order of evaluation used by Microsoft Basic language products. This article also explains the opera...">
<META NAME="Product" CONTENT="Visual Basic for Windows">
<META NAME="Platform" CONTENT="Windows">
<META NAME="Technology" CONTENT=" ">
<META NAME="Premium" CONTENT="support">

<META NAME="nyms" CONTENT="QAGI,QAGX,QBFY,QAIF,QAB9,QBVV,QAKM,QAY5,QBS0,QABH,QAHH,QATX,QBV8,QAOE,QANF V02180118">
</HEAD>

<BODY BGCOLOR="#FFFFFF" LEFTMARGIN="0" RIGHTMARGIN="0" TOPMARGIN="0">


<!--DOCBODY_START-->
<BR>
<CENTER>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" VALIGN="top" WIDTH="90%">
	<TR>
		<TD VALIGN="top">
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<H1>Example to Evaluate Basic Numeric Expressions</H1>
			</FONT>
			<FONT FACE="verdana,arial,helvetica" SIZE="1">
			Last reviewed:  June 21, 1995</FONT><BR>
			<FONT FACE="verdana,arial,helvetica" SIZE="2">
			<B>Article ID: Q86688 </B>
			</FONT>
		</TD>
	</TR>
	<TR>
	<TD>
	<FONT FACE="Verdana, Arial, Helvetica" SIZE=2>



 
The information in this article applies to:

<UL><LI>Microsoft Visual Basic programming system for Windows, versions
   1.0, 2.0, and 3.0
<LI>The Standard and Professional Editions of Microsoft Visual Basic for
   MS-DOS, version 1.0
</UL> 
<P>
<P><h2>SUMMARY</h2>
 
<P>
This article contains an example program that evaluates a numeric
expression contained in a string, mimicking the operators,
built-in functions, and order of evaluation used by Microsoft Basic
language products. This article also explains the operator
precedence rules in detail.
<P>
<P><h2>MORE INFORMATION</h2>
 
<P>
The example program listed below recognizes the following operators
and subexpressions, listed by precedence from highest to lowest:
<P>
<PRE>   - Constants, function calls, parentheses
   - Exponentiation ^
   - Unary minus -
   - Multiplication and division *, /
   - Integer division \
   - Integer modulus MOD
   - Addition and subtraction +, -
   - Relational operators =, &lt;&gt;, &lt;, &gt;, &lt;=, &gt;=
   - NOT
   - AND
   - OR
   - XOR
   - EQV
   - IMP

</PRE>The precedence of unary minus "-" and operator "NOT" indicate the
highest possible precedence of their operand. Unary minus and "NOT"
may occur in an expression of any precedence. The following
expressions illustrate the precedence rules for unary minus and "NOT".
<P>
<PRE>   Expression        Value
   ----------        -----

    -1  ^  2          -1
   -(1  ^  2)         -1
   (-1) ^  2           1
     2  ^ -2          .25
    NOT  0  = 1       -1
    NOT (0  = 1)      -1
   (NOT  0) = 1        0
    NOT  0  AND 1      1
   (NOT  0) AND 1      1
    NOT (0  AND 1)    -1

</PRE>The example program listed below accepts number constants written as
decimal numbers with an optional fraction. For example, it accepts
"123" and "123.4". It is possible to modify the program to recognize
hexadecimal, scientific notation, or other formats.
<P>
This example program also recognizes the following functions: ABS,
ATN, COS, EXP, FIX, INT, LOG, RND, SNG, SIN, SQR, and TAN.
<P>
<P><h3>Steps to Create Example Program</h3>
 

<OL><P><LI>Run Visual Basic, or from the File menu, choose New Project (press
   ALT, F, N) if Visual Basic is already running. Form1 will be created
   by default.

<P><LI>Add a text box (Text1) and a command button (Command1) to Form1.

<P><LI>Set the Text property for Text1 to the null string (empty).

<P><LI>Enter the following code in the Command1 Click event procedure:
<P>
<PRE>   Sub Command1_Click ()
       Dim n As Double

       If e_eval(Text1.Text, n) Then
         MsgBox Format$(n)
       End If
   End Sub

</PRE><P><LI>Add the following code in the general Declarations section of Form1:
<P>
<PRE>' To run this program in Visual Basic for MS-DOS, change the
' following Dim statements to DIM SHARED.
'
Dim e_input As String     ' Expression input string.
Dim e_tok As String       ' Current token kind.
</PRE></OL>Dim e_spelling As String  ' Current token spelling.
<PRE>Dim e_error As Integer    ' Tells if syntax error occurred.

' e_eval
'   Evaluate a string containing an infix numeric expression.
'   If successful, return true and place result in &lt;value&gt;.
'   This is the top-level function in the expression evaluator.
</PRE>Function e_eval (ByVal s As String, value As Double) As Integer
<PRE>   ' Initialize.
   e_error = 0
   e_input = s
   Call e_nxt

   ' Evaluate.
   value = e_prs(1)

   ' Check for unrecognized input.
   If e_tok &lt;&gt; "" And Not e_error Then
      MsgBox "syntax error, token = '" + e_spelling + "'"
   e_error = -1
   End If

   e_eval = Not e_error
</PRE>End Function
<P>
<PRE>' e_prs
'   Parse an expression, allowing operators of a specified
'   precedence or higher. The lowest precedence is 1.
'   This function gets tokens with e_nxt and recursively
'   applies operator precedence rules.
</PRE>Function e_prs (p As Integer) As Double
<PRE>   Dim n As Double    ' Return value.
   Dim fun As String  ' Function name.

   ' Parse expression that begins with a token (precedence 12).
   If e_tok = "num" Then
      ' number.
      n = Val(e_spelling)
      Call e_nxt
   ElseIf e_tok = "-" Then
      ' unary minus.
      Call e_nxt
      n = -e_prs(11)    ' Operand precedence 11.
   ElseIf e_tok = "not" Then
      ' logical NOT.
      Call e_nxt
      n = Not e_prs(6)  ' Operand precedence 6.
   ElseIf e_tok = "(" Then
      ' parentheses.
      Call e_nxt
      n = e_prs(1)
      Call e_match(")")
   ElseIf e_tok = "id" Then
      ' Function call.
      fun = e_spelling
      Call e_nxt
      Call e_match("(")
      n = e_prs(1)
      Call e_match(")")
      n = e_function(fun, n)
   Else
      If Not e_error Then
         MsgBox "syntax error, token = '" + e_spelling + "'"
         e_error = -1
      End If
   End If

   ' Parse binary operators.
</PRE>Do While Not e_error
<PRE>  If 0 Then  ' To allow ElseIf .
  ElseIf p &lt;= 11 And e_tok  = "^"  Then Call e_nxt: n = n ^   e_prs(12)
  ElseIf p &lt;= 10 And e_tok  = "*"  Then Call e_nxt: n = n *   e_prs(11)
  ElseIf p &lt;= 10 And e_tok = "/"   Then Call e_nxt: n = n /   e_prs(11)
  ElseIf p &lt;= 9  And e_tok = "\"   Then Call e_nxt: n = n \   e_prs(10)
  ElseIf p &lt;= 8  And e_tok = "mod" Then Call e_nxt: n = n Mod e_prs(9)
  ElseIf p &lt;= 7  And e_tok = "+"   Then Call e_nxt: n = n +    e_prs(8)
  ElseIf p &lt;= 7  And e_tok = "-"   Then Call e_nxt: n = n -    e_prs(8)
  ElseIf p &lt;= 6  And e_tok = "="   Then Call e_nxt: n = n =    e_prs(7)
  ElseIf p &lt;= 6  And e_tok = "&lt;"   Then Call e_nxt: n = n &lt;    e_prs(7)
  ElseIf p &lt;= 6  And e_tok = "&gt;"   Then Call e_nxt: n = n &gt;    e_prs(7)
  ElseIf p &lt;= 6  And e_tok = "&lt;&gt;"  Then Call e_nxt: n = n &lt;&gt;   e_prs(7)
  ElseIf p &lt;= 6  And e_tok = "&lt;="  Then Call e_nxt: n = n &lt;=   e_prs(7)
  ElseIf p &lt;= 6  And e_tok = "&gt;="  Then Call e_nxt: n = n &gt;=   e_prs(7)
  ElseIf p &lt;= 5  And e_tok = "and" Then Call e_nxt: n = n And  e_prs(6)
  ElseIf p &lt;= 4  And e_tok = "or"  Then Call e_nxt: n = n Or   e_prs(5)
  ElseIf p &lt;= 3  And e_tok = "xor" Then Call e_nxt: n = n Xor  e_prs(4)
  ElseIf p &lt;= 2  And e_tok = "eqv" Then Call e_nxt: n = n Eqv  e_prs(3)
  ElseIf p &lt;= 1  And e_tok = "imp" Then Call e_nxt: n = n Imp  e_prs(2)
  Else
       Exit Do
  End If
 Loop

   e_prs = n
</PRE>End Function
<P>
<PRE>' e_function.
'   Evaluate a function. This is a helper function to simplify
'   e_prs.
</PRE>Function e_function (fun As String, arg As Double) As Double
<PRE>   Dim n As Double

   Select Case LCase$(fun)
   Case "abs": n = Abs(arg)
   Case "atn": n = Atn(arg)
   Case "cos": n = Cos(arg)
   Case "exp": n = Exp(arg)
   Case "fix": n = Fix(arg)
   Case "int": n = Int(arg)
   Case "log": n = Log(arg)
   Case "rnd": n = Rnd(arg)
   Case "sgn": n = Sgn(arg)
   Case "sin": n = Sin(arg)
   Case "sqr": n = Sqr(arg)
   Case "tan": n = Tan(arg)
   Case Else
      If Not e_error Then
         MsgBox "undefined function '" + fun + "'"
         e_error = -1
      End If
   End Select

   e_function = n
</PRE>End Function
<P>
<PRE>' e_nxt
'   Get the next token into e_tok and e_spelling and remove the
'   token from e_input.
'   This function groups the input into "words" like numbers,
'   operators and function names.
Sub e_nxt ()
   Dim is_keyword As Integer
   Dim c As String  ' Current input character.

   e_tok = ""
   e_spelling = ""

   ' Skip whitespace.
   Do
      c = Left$(e_input, 1)
      e_input = Mid$(e_input, 2)
   Loop While c = " " Or c = Chr$(9) Or c = Chr$(13) Or c = Chr$(10)

   Select Case LCase$(c)

   ' Number constant. Modify this to support hexadecimal, etc.
   Case "0" To "9", "."
      e_tok = "num"
      Do
         e_spelling = e_spelling + c
         c = Left$(e_input, 1)
         e_input = Mid$(e_input, 2)
      Loop While (c &gt;= "0" And c &lt;= "9") Or c = "."
      e_input = c + e_input

   ' Identifier or keyword.
   Case "a" To "z", "_"
      e_tok = "id"
      Do
         e_spelling = e_spelling + c
         c = LCase$(Left$(e_input, 1))
         e_input = Mid$(e_input, 2)
         is_id% = (c &gt;= "a" And c &lt;= "z")
         is_id% = is_id% Or c = "_" Or (c &gt;= "0" And c &lt;= "9")
      Loop While is_id%
      e_input = c + e_input

      ' Check for keyword.
      is_keyword = -1
      Select Case LCase$(e_spelling)
         Case "and"
         Case "eqv"
         Case "imp"
         Case "mod"
         Case "not"
         Case "or"
         Case "xor"
         Case Else: is_keyword = 0
      End Select
      If is_keyword Then
         e_tok = LCase$(e_spelling)
      End If

   ' Check for &lt;=, &gt;=, &lt;&gt;.
   Case "&lt;", "&gt;"
      e_tok = c
      c = Left$(e_input, 1)
      If c = "=" Or c = "&gt;" Then
         e_tok = e_tok + c
         e_input = Mid$(e_input, 2)
      End If

   ' Single character token.
   Case Else
      e_tok = c
   End Select

    If e_spelling = "" Then
       e_spelling = e_tok
   End If
End Sub

' e_match
'   Check the current token and skip past it.
'   This function helps with syntax checking.
Sub e_match (token As String)
   If Not e_error And e_tok &lt;&gt; token Then
      MsgBox "expected " + token + ", got '" + e_spelling + "'"
      e_error = -1
   End If
   Call e_nxt
End Sub

</PRE><P><LI>Press F5 to run the program. Type an expression into Text1 such
   as "1+2*3^4". Click Command1.
<P>
</OL>The program displays the result, 163 in this case.
<P>

	</FONT>
	</TD>
	</TR>
</TABLE>
<P>


<!--DOCBODY_END-->

<!--FOOTER_START-->
<table cellpadding=5 border=0 width="90%">
<tr>
<td>
	<HR WIDTH="90%">

<BLOCKQUOTE>
<FONT FACE="Verdana, Arial, Helvetica" SIZE="1">
<SPAN STYLE="font-family:verdana,arial,helvetica; font-size:8pt">
Additional reference words: 1.00 2.00 3.00<BR>
KBCategory: kbprg kbcode<BR>
KBSubcategory: PrgCtrlsStd<BR>

</SPAN>
</FONT>
<BR>
<BR>
THE INFORMATION PROVIDED IN THE MICROSOFT KNOWLEDGE BASE IS
PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND.  MICROSOFT DISCLAIMS
ALL WARRANTIES, EITHER EXPRESS OR IMPLIED, INCLUDING THE WARRANTIES
OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  IN NO
EVENT SHALL MICROSOFT CORPORATION OR ITS SUPPLIERS BE LIABLE FOR
ANY DAMAGES WHATSOEVER INCLUDING DIRECT, INDIRECT, INCIDENTAL,
CONSEQUENTIAL, LOSS OF BUSINESS PROFITS OR SPECIAL DAMAGES, EVEN IF
MICROSOFT CORPORATION OR ITS SUPPLIERS HAVE BEEN ADVISED OF THE
POSSIBILITY OF SUCH DAMAGES.  SOME STATES DO NOT ALLOW THE EXCLUSION
OR LIMITATION OF LIABILITY FOR CONSEQUENTIAL OR INCIDENTAL DAMAGES
SO THE FOREGOING LIMITATION MAY NOT APPLY.
</BLOCKQUOTE>
<P>
<center>
	<FONT FACE="Verdana,Arial,Helvetica" SIZE="1">
	Last reviewed:  June 21, 1995</FONT>
	<BR>
	<A href="../cpyright.htm" STYLE="font: bold 7pt Verdana,Arial,Helvetica">&copy; 1998 Microsoft Corporation. All rights reserved. Terms of Use.</A><BR>
	
</center>
</td>
</tr>
</table>

<!--FOOTER_END-->
</FONT>
</BODY>
</HTML>
