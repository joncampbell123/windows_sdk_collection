;--------------------------------------
; HARDWARE OPTION CLASSES WE UNDERSTAND
;--------------------------------------

[Options]
    ;
    Computer            = cpt
    Video               = vio
    Pointer             = ptr
    Keyboard            = kbd
    Layout              = lay
    Language            = lng
    Printer             = prn
    Scsi                = scs
    Tape                = tap
    Sound               = snd
    Driver              = drv
    NetAdapter          = nad
    NetDriver           = ndr
    NetTransport        = nxp
    NetService          = nsv
    Network             = nwk
    NetProvider         = npr


[OemOptionFiles]
    OemFiles = {} ? $(!LIBHANDLE) FindFileInstances $(!STF_WINDOWSSYSPATH)"\oem"$(Abb)"*.inf"

;-----------------------------------------------------------------------
;
; ROUTINE:      ReturnOemOptions
;
; DESCRIPTION:  This routine finds out if an OEM file representing
;               the option exists in the windows sytem directory
;               and returns the options represented in the INF.
;
; INPUTS:       $0: Language to use
;               $1: Option Type (Computer|Video|...)
;
; OUTPUTS:      $R0: STATUS:   STATUS_SUCCESSFUL |
;                              STATUS_FAILED
;
;               $R1: OemOptionList: This is of form:
;                                   { {Oemfile1, Option1List, Option1TextList},
;                                     {Oemfile2, Option2List, Option2TextList},
;                                     ...
;                                   }
;
;
;------------------------------------------------------------------------

[ReturnOemOptions]
    ;
    ; Initialize
    ;
    set Status         = STATUS_FAILED
    set OemOptionList  = {}

    set Abb = #(Options, $($1), 1)
    read-syms OemOptionFiles
    detect OemOptionFiles

    ForListDo $(OemFiles)
        set OemFileName = $(!STF_WINDOWSSYSPATH)"\"$($)
        set Found = FALSE
        shell "", GetOptionsFromINF $($0) $($1) $(OemFileName)
        ifstr(i) $($R0) == STATUS_SUCCESSFUL
            ForListDo $(OemOptionList)
                ifstr(i) *($($), 2) == $($R1)
                    set Found = TRUE
                endif
            EndForListDo
            ifstr(i) $(Found) == FALSE
                set OemOptionList = >($(OemOptionList), {$($), $($R1), $($R2)})
            endif
        endif
    EndForListDo
    set Status = STATUS_SUCCESSFUL

finish_GetCurrentOemOptions = +
    Return $(Status) $(OemOptionList)



;-----------------------------------------------------------------------
;
; ROUTINE:      GetOptionsFromINF
;
; DESCRIPTION:  This routine checks to see if the specified file exists
;               and if it is of the right type and gets option info from
;               the INF.
;
; INPUTS:       $0:  Language To use
;               $1:  OptionType
;               $2:  OptionFileName
;
; OUTPUTS:      $R0: STATUS:   STATUS_SUCCESSFUL  |
;                              STATUS_INFNOTFOUND |
;                              STATUS_FAILED
;
;               $R1: OptionList
;               $R2: OPtionTextList
;
;------------------------------------------------------------------------

[GetOptionsFromINF]

    ;
    ; Initialize
    ;

    set Status         = STATUS_FAILED
    set OptionList     = {}
    set OptionTextList = {}


    set FileToCheck = $($2)
    install Install-SeeIfFileIsPresent
    ifstr(i) $(STATUS) != "YES"
        set Status = STATUS_INFNOTFOUND
        goto finish_GetOptionsFromINF
    endif

    ;
    ; Check that the INF represents the option we are looking for
    ;
    shell $($2) Identify
    ifstr(i) $($R0) == "STATUS_SUCCESSFUL"
        ifstr(i) $($R1) == $($1)
            shell $($2) ReturnOptions $($0) $(!STF_BUSTYPE)
            ifstr(i) $($R0) == STATUS_SUCCESSFUL
                 set  OptionList     = $($R1)
                 set  OptionTextList = $($R2)
                 set  Status         = STATUS_SUCCESSFUL
                 goto finish_GetOptionsFromINF
            endif
        endif
    endif

finish_GetOptionsFromINF = +
    Return $(Status) $(OptionList) $(OptionTextList)


;-----------------------------------------------------------------------
;
; ROUTINE:      GetNewOEMOption
;
; DESCRIPTION:  This routine prompts the user for a new OEM file, presents
;               the options supported and if the user chooses one of these
;               copies over the INF to the windows system directory.
;
; INPUTS:       $0:  Language to use
;               $1:  OemOptionList
;               $2:  OptionType
;               $3:  OptDisketteSource
;
; OUTPUTS:      $R0: STATUS:   STATUS_SUCCESSFUL |
;                              STATUS_USERCANCEL |
;                              STATUS_FAILED     |
;
;               $R1: NewOemOptionList
;               $R2: OemOptionChosen
;               $R3: OemOptionChosenText
;               $R4: OEMINFSource
;
;------------------------------------------------------------------------

[GetNewOEMOption]
    ;
    set Status            = STATUS_FAILED

    set Option            = $($2)
    set OptDisketteSrc    = $($3)
    set OptDiskette       = #(OptionDiskettes$($0), $($2), 1)
    set InfName1          = "OEMSETUP.INF"
    set InfName2          = "OEMSETNT.INF"

    set Abb = #(Options, $(Option), 1)

    set NewOemOptionList  = $($1)
    set OptionChosen      = ""
    set OptionChosenText  = ""

    ;
    ; Prompt the user for the diskette containing the INF
    ;

ask_dodiskette = +
    ;
    ;  Reset the INF name to the standard default
    ;
    set InfName = $(InfName1)

    shell "" DoDiskette $($0) $(OptDiskette) $(OptDisketteSrc)
    set Status = STATUS_FAILED

    ifstr(i) $($R0) == STATUS_USERCANCEL
        set Status = STATUS_USERCANCEL
        goto finish_GetOEMOption
    else-ifstr(i) $($R0) == STATUS_FAILED
        goto finish_GetOEMOption
    endif

    set OptDisketteSrc = $($R1)

    ;
    ; Check that the Diskette contains an INF we are looking for
    ;
ask_inf_retry = +
    FlushInf $(InfName)
    LibraryProcedure FileToCheck, $(!LIBHANDLE), AppendBackSlash $(OptDisketteSrc)
    set FileToCheck = $(FileToCheck)$(InfName)
    install Install-SeeIfFileIsPresent
    set OemSetupFilePath = $(FileToCheck)
    set NfError = 1

    ifstr(i) $(STATUS) == YES
        set NfError = 2
        ;
        ; Check that the INF represents the option we are looking for
        ;
        shell $(OemSetupFilePath) Identify
        ifstr(i) $($R0) == "STATUS_SUCCESSFUL"
            ifstr(i) $($R1) == $(Option)
                shell $(OemSetupFilePath) ReturnOptions $($0) $(!STF_BUSTYPE)
                ifstr(i) $($R0) == STATUS_SUCCESSFUL
                     set OemList     = $($R1)
                     set OemTextList = $($R2)
                     goto asksingleselection
                endif
            endif
        endif
    endif
    ;
    ;  The file isn't in NT format; try the alternate name.
    ;
    ifstr(i) $(InfName) == $(InfName1)
        Set InfName = $(InfName2)
        goto ask_inf_retry
    endif

    read-syms NonFatalError$(NfError)$($0)
    shell "subroutn.inf" SetupMessage $($0) "NONFATAL" $(NonFatal)
    goto ask_dodiskette

    ;
    ; Present the OEM options to the user. Let the user select.  If
    ; the user selects to cancel, don't change anything, just return
    ;

asksingleselection = +
    shell "" DoSingleOption $(OemList) $(OemTextList) $(OptDiskette)
    ifstr(i) $($R0) == STATUS_FAILED
        set Status = STATUS_FAILED
        goto finish_GetOEMOption
    else-ifstr(i) $($R0) == STATUS_USERCANCEL
        set Status = STATUS_USERCANCEL
        goto finish_GetOEMOption
    endif

    set OptionChosen     = $($R1)
    set OptionChosenText = $($R2)

    ;
    ; Determine the file name to use to copy over.  First see if the INF
    ; is a duplicate
    ;

    set Duplicate = FALSE
    ForListDo $($1)
        ifstr(i) *($($), 2) == $(OemList)
            set OemFileName = *($($), 1)
            set Duplicate = TRUE
            FlushInf $(OemFileName)
            goto copyinf
        endif
    EndForListDo

    ;
    ; Not a duplicate, we need to copy it under a unique name.
    ;

    set Num = 0
nextinf = +
    ifint $(Num) < 99
        set OemFileName = "oem"$(Abb)$(Num)".inf"
        set FileToCheck = $(!STF_WINDOWSSYSPATH)"\"$(OemFileName)
        install Install-SeeIfFileIsPresent
        ifstr(i) $(STATUS) == "YES"
            set-add Num = $(Num) 1
            goto nextinf
        else
            goto copyinf
        endif
    endif
    goto finish_GetOEMOption

copyinf = +
    ;
    ; copy the INF over to the windows system directory
    ;
    set OemSrc = $(OemSetupFilePath)
    set OemDst = $(!STF_WINDOWSSYSPATH)"\"$(OemFileName)
    install Install-OemINF


    ;
    ; form the new oem option list
    ;
    ifstr(i) $(Duplicate) == TRUE
    else
        set NewOemOptionList = >($(NewOemOptionList), {$(OemFileName), $(OemList), $(OemTextList)})
    endif
    set Status = STATUS_SUCCESSFUL

finish_GetOEMOption = +
    FlushInf $(InfName)
    Return $(Status) $(NewOemOptionList) $(OptionChosen) $(OptionChosenText) $(OptDisketteSrc)

;-----------------------------------------------------------------------
;
; ROUTINE:      GetNewOEMMultiOption
;
; DESCRIPTION:  This routine prompts the user for a new OEM file, presents
;               the options supported and if the user chooses one of these
;               copies over the INF to the windows system directory.
;
; INPUTS:       $0:  Language to use
;               $1:  OemOptionList
;               $2:  OptionTypeList;   e.g.,  { NetService, NetTransport }
;               $3:  OptDisketteSource
;
; OUTPUTS:      $R0: STATUS:   STATUS_SUCCESSFUL |
;                              STATUS_USERCANCEL |
;                              STATUS_FAILED     |
;
;               $R1: NewOemOptionList
;               $R2: OemOptionChosen
;               $R3: OemOptionChosenText
;               $R4: OEMINFSource
;
;------------------------------------------------------------------------

[GetNewOEMMultiOption]

    Debug-Output $(STF_CONTEXTINFNAME)": GetNewOEMMultiOption called"

    set Status            = STATUS_FAILED

    set OptionType        = ""
    set OptionTypeList    = $($2)
    set OptDisketteSrc    = $($3)
    set InfName1          = "OEMSETUP.INF"
    set InfName2          = "OEMSETNT.INF"

    read-syms OptionDisketteMulti$($0)

    Set TypeNames = ^(Options,0)
    Set TypeAbbs  = ^(Options,1)

    set NewOemOptionList  = $($1)
    set OptionChosen      = ""
    set OptionChosenText  = ""

    ;
    ; Prompt the user for the diskette containing the INF
    ;

m_ask_dodiskette = +
    Debug-Output $(STF_CONTEXTINFNAME)": GetNewOEMMultiOption shelling DoDiskette"

    ;
    ;  Reset the INF name to the standard default
    ;
    set InfName = $(InfName1)

    shell "" DoDiskette $($0) $(OptDiskette) $(OptDisketteSrc)
    set Status = STATUS_FAILED

    ifstr(i) $($R0) == STATUS_USERCANCEL
        set Status = STATUS_USERCANCEL
        goto m_finish_GetOEMOption
    else-ifstr(i) $($R0) == STATUS_FAILED
        goto m_finish_GetOEMOption
    endif

    set OptDisketteSrc = $($R1)

    ;
    ; Check that the Diskette contains an INF we are looking for
    ;

m_ask_inf_retry = +
    FlushInf $(InfName)
    LibraryProcedure FileToCheck, $(!LIBHANDLE), AppendBackSlash $(OptDisketteSrc)
    set FileToCheck = $(FileToCheck)$(InfName)
    install Install-SeeIfFileIsPresent
    set OemSetupFilePath = $(FileToCheck)
    set NfError = 1

    ifstr(i) $(STATUS) == YES
        set NfError = 2
        ;
        ; Check that the INF represents the option we are looking for
        ;
        shell $(OemSetupFilePath) Identify
        ifstr(i) $($R0) == "STATUS_SUCCESSFUL"
            ifcontains(i) $($R1) in $(OptionTypeList)
                Set OptionType = $($R1)
                shell $(OemSetupFilePath) ReturnOptions $($0) $(!STF_BUSTYPE)
                ifstr(i) $($R0) == STATUS_SUCCESSFUL
                     set OemList     = $($R1)
                     set OemTextList = $($R2)
                     goto m_asksingleselection
                endif
            endif
        endif
    endif
    ;
    ;  The file wasn't found or isn't in NT format; try the alternate name.
    ;
    ifstr(i) $(InfName) == $(InfName1)
        Set InfName = $(InfName2)
        goto m_ask_inf_retry
    endif

    read-syms NonFatalError$(NfError)$($0)
    shell "subroutn.inf" SetupMessage $($0) "NONFATAL" $(NonFatal)
    goto m_ask_dodiskette

    ;
    ; Present the OEM options to the user. Let the user select.  If
    ; the user selects to cancel, don't change anything, just return
    ;

m_asksingleselection = +
    shell "" DoSingleOption $(OemList) $(OemTextList) $(OptDiskette)
    ifstr(i) $($R0) == STATUS_FAILED
        set Status = STATUS_FAILED
        goto m_finish_GetOEMOption
    else-ifstr(i) $($R0) == STATUS_USERCANCEL
        set Status = STATUS_USERCANCEL
        goto m_finish_GetOEMOption
    endif

    set OptionChosen     = $($R1)
    set OptionChosenText = $($R2)

    ;
    ; Determine the file name to use to copy over.  First see if the INF
    ; is a duplicate
    ;

    set Duplicate = FALSE
    ForListDo $($1)
        ifstr(i) *($($), 2) == $(OemList)
            set OemFileName = *($($), 1)
            set Duplicate = TRUE
            FlushInf $(OemFileName)
            goto m_copyinf
        endif
    EndForListDo

    ;
    ; Not a duplicate, we need to copy it under a unique name.
    ;

    set Num = 0
    Set Abb = *($(TypeAbbs),~($(TypeNames),$(OptionType)))

m_nextinf = +
    ifint $(Num) < 99
        set OemFileName = "oem"$(Abb)$(Num)".inf"
        Debug-Output "OTHER.INF: Checking winsyspath for "$(OemFileName)

        set FileToCheck = $(!STF_WINDOWSSYSPATH)"\"$(OemFileName)
        install Install-SeeIfFileIsPresent
        ifstr(i) $(STATUS) == "YES"
            set-add Num = $(Num) 1
            goto m_nextinf
        else
            goto m_copyinf
        endif
    endif
    goto m_finish_GetOEMOption

m_copyinf = +
    ;
    ; copy the INF over to the windows system directory
    ;
    set OemSrc = $(OemSetupFilePath)
    set OemDst = $(!STF_WINDOWSSYSPATH)"\"$(OemFileName)
    install Install-OemINF
    ;
    ; form the new oem option list
    ;
    ifstr(i) $(Duplicate) == TRUE
    else
        set NewOemOptionList = >($(NewOemOptionList), {$(OemFileName), $(OemList), $(OemTextList)})
    endif
    set Status = STATUS_SUCCESSFUL

m_finish_GetOEMOption = +
    FlushInf $(InfName)
    Return $(Status) $(NewOemOptionList) $(OptionChosen) $(OptionChosenText) $(OptDisketteSrc)

;-----------------------------------------------------------------------
;
; ROUTINE:      DoDiskette
;
; DESCRIPTION:  This routine prompts the OEM for the source of the OEM
;               Diskette
;
; INPUTS:       $0:  Language
;               $1:  OemDiskette
;               $2:  OemDisketteSrc
;
; OUTPUTS:      $R0: STATUS:   STATUS_SUCCESSFUL |
;                              STATUS_USERCANCEL |
;                              STATUS_FAILED
;
;               $R1: Diskette Src
;
;------------------------------------------------------------------------


[DoDiskette]
    ;
    ;
    set Status         = STATUS_FAILED
    set OemDiskette    = $($1)
    set OemDisketteSrc = $($2)

    Debug-Output $(STF_CONTEXTINFNAME)": DoDiskette called"

    read-syms DisketteDlg$($0)
    ui start "Diskette"
    ifstr(i) $(DLGEVENT) == "CONTINUE"
        set OemDisketteSrc = $(EditTextOut)
        ui pop 1
        set Status = STATUS_SUCCESSFUL
        goto finish_dodiskette
    else-ifstr(i) $(DLGEVENT) == "BACK"
        ui pop 1
        set Status = STATUS_USERCANCEL
        goto finish_dodiskette
    else
        ui pop 1
        goto finish_dodiskette
    endif

finish_dodiskette = +
    Return $(Status) $(OemDisketteSrc)

;-----------------------------------------------------------------------
;
; ROUTINE:      DoSingleOption
;
; DESCRIPTION:  This routine presents the OEM Options to the user to
;               get a selectiom
;
; INPUTS:       $0:  OptionList
;               $1:  OptionTextList
;               $2:  OptionTypeText
;
; OUTPUTS:      $R0: STATUS:   STATUS_SUCCESSFUL |
;                              STATUS_USERCANCEL |
;                              STATUS_FAILED
;
;               $R1: OptionChosen
;               $R2: OptionChosenText
;
;------------------------------------------------------------------------


[DoSingleOption]

    set Status              = STATUS_FAILED
    set OemOptionChosen     = ""
    set OemOptionChosenText = ""
    set OemOptionList       = $($0)
    set OemOptionTextList   = $($1)
    set OemOptionTypeText   = $($2)

    read-syms OemSingleOptionDlg$(!STF_LANGUAGE)
    ui start "Diskette"
    ifstr(i) $(DLGEVENT) == "CONTINUE"

        ui pop 1
        ifstr(i) $(ListItemsOut) == ""
            set Status = STATUS_USERCANCEL
        else
            set OemOptionChosenText = $(ListItemsOut)
            set OemOptionChosen = *($($0), ~($(ListItemsIn), $(ListItemsOut)))
            set Status = STATUS_SUCCESSFUL
        endif

        goto finish_dosingleoption

    else-ifstr(i) $(DLGEVENT) == "BACK"
        ui pop 1
        set Status = STATUS_USERCANCEL
        goto finish_dosingleoption
    else
        ui pop 1
        set Status = STATUS_FAILED
        goto finish_dosingleoption

    endif

finish_dosingleoption = +
    Return $(Status) $(OemOptionChosen) $(OemOptionChosenText)





[Install-SeeIfFileIsPresent]
LibraryProcedure STATUS,$(!LIBHANDLE), CheckFileExistance $(FileToCheck)
exit




[Install-OemINF]
LibraryProcedure STATUS,$(!LIBHANDLE), CopySingleFile $(OemSrc) $(OemDst)
exit



