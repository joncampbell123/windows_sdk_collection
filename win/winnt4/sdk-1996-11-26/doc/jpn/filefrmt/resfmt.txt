Win32 バイナリ リソース形式
					Floyd Rogers 著
 
 
はじめに
 
本書は Microsoft Developer Support で編集、リリースしたものです。ここ
では Win32 のリソースのバイナリ形式について解説します。この文書のリリ
ースは、今後、本文中の各形式を変更しないことを保証するものではありま
せん。ここに記載する情報に関する質問や補足については、CompuServe 
MSWIN32 フォーラム セクション 4 にお送りください。
                    --Steve Firebaugh
                          Microsoft Developer Support
 
 
1.　概要
    1.1  Windows 16 (Win 3.0/3.1) と Windows 32 との比較
    1.2  Unicode 文字列
    1.3  DWORD 整列
2.  一般情報
    2.1  新しい定義文
    2.1.1  新しいボタン定義文
        2.1.1.1  AUTO3STATE
        2.1.1.2  AUTOCHECKBOX
        2.1.1.3  AUTORADIOBUTTON
        2.1.1.4  PUSHBOX
        2.1.1.5  STATE3 (3STATE)
        2.1.1.6  USERBUTTON
    2.1.2  EXSTYLE 定義文
    2.1.3  CHARACTERISTICS 定義文
    2.1.4  VERSION 定義文
    2.1.5  LANGUAGE 定義文
    2.1.6  MESSAGETABLE 定義文
    2.1.7  Unicode 文字列の追加構文
3.  リソース ヘッダー形式
    3.1  DataSize
    3.2  HeaderSize
    3.3  型
    3.4  名前
    3.5  追加リソース ヘッダー情報
        3.5.1  DataVersion
        3.5.2  MemoryFlags
        3.5.3  LanguageId
        3.5.4  バージョンと特性
    3.6  16 ビットと 32 ビットのリソース ファイルの区別
    3.7  ファイルの整列
4.  リソース データ形式
    4.1  バージョン リソース
    4.2  アイコン リソース
    4.3  メニュー リソース
    4.4  ダイアログ ボックス リソース
    4.5  マウス カーソル リソース
    4.6  ビットマップ リソース
    4.7  フォント リソースとフォント ディレクトリ リソース
    4.8  文字列テーブル リソース
    4.9  アクセラレータ テーブル リソース
    4.10  ユーザー定義のリソースと RCDATA
    4.11  名前テーブル リソースとエラー テーブル リソース
    4.12  バージョン リソース
    4.13  メッセージ テーブル リソース
5.  改版履歴



1.  概要

本書では、 Windows 32 API (Windows NT 3.1 と Win32s) におけるリソース 
バイナリ ファイル (.res) の形式の構造について詳述してあります。この構
造は、既存の Windows 16 (Win 3.0/3.1)の構造と似ていますが、ここでは 
Unicode 文字列、バージョン ヘッダーおよび DWORD 整列のような重要な追加
機能がサポートされます。これらの変更をサポートするには、リソース コン
パイラで書かれたファイル形式を、Windows 16 で使っていたものから変更す
る必要があります。

1.1  Windows 3.0/3.1 と Windows 32 との比較

Windows 16 リソース ファイルには、1 つ以上のバイナリ リソースが格納さ
れています。各リソースの前には、型、名前、フラグ、サイズを含む可変長の
構造体が置かれます。型フィールドと名前フィールドは、型または名前を識別
するための文字列、もしくはリソースの序数 ID を指定するための WORD 値の
いずれかです。 フラグ フィールドは、リソースをメモリに読み込む方法をシ
ステムに指定するためのものです。サイズは、リソースのサイズをバイトで指
定するためのものです。したがって、ファイル内の次のリソースがサイズに
よって指されます。

Windows 32 (NT と Win32s) のリソース ファイルでは、この構造が保持され
ていますが、追加の値を数個付けることによってヘッダー情報を拡張してい
ます。また、メニュー、ダイアログなどの規定リソースの中には数個のフィー
ルドが追加されたものもあり、すべてのフィールドを規定リソースの範囲内で 
WORD または DWORD 境界に合わせてあります。さらに、データ構造に対して 
16 ビット文字の Unicode を新たにサポートしています。

Windows 32 のリソース ファイルには相違点がもう 1 つありますが、重要で
はありません。これは、リソース ファイルの構造に直接影響を及ぼすものと
いうより、リソース ファイルの処理の方法、dll または exe の実行可能な
イメージへのリソース ファイルの組み込み方の違いです。Windows NT では 
COFF 形式オブジェクトを使い、しかも Windows 32 exe 形式が Windows 16 
の形式と非常に異なっているので、SDK ではリソース ファイルを COFF オブ
ジェクトに変換するための CVTRES というユーティリティが提供されます。こ
のオブジェクトは、生成される実行可能なイメージに、リンカによって直接組
み込まれるので、Windows 16 のときのように、リソースを更新するためにリ
ソース コンパイラの第 2 パスを何回も実行する必要はありません。ただし、
イメージの再リンクは必要です。

しかし、Windows 32 API では、プログラムが実行可能なイメージ内のすべて
のリソースを列挙したり、イメージ内の個々のリソースを更新したりできるよ
うにする 1 組の API を提供しています。

1.2  Unicode 文字列

リソースファイル内のすべての文字列は、今回 Unicode 形式で格納されます。
この形式では、文字はすべて 16 ビットの (WORD) 値で表されます。先頭の 
128 文字は、Windows ANSI の文字セットの 128 文字と同じです。ただし、
個々の文字は、8 ビットではなく、16 ビットで表現されます。160　から 254 
までの位置の文字は、標準 Windows 文字セット内の文字と似ています。(128 
から 159 までの文字は、正しくない Unicode コードポイントであることに
注意してください。) 文字列は、単一の NULL ではなく Unicode_NULL 記号で
終了します。リソース コンパイラ は Windows API で提供された 
MultiByteToWideChar 機能を呼び出すことによって、すべての通常の ASCII 
文字列を Unicode に変換します。すべてのエスケープ文字は、直接格納され、
リソース用の有効な Unicode 文字とみなされます。これらの文字列は、アプ
リケーションによって (たとえば、LoadString API を呼び出すことによって)、
後で ASCII として読み込まれたとき、ローダーによってユーザーが意識する
ことなく Unicode から 元の ASCII に変換されます。

ただし、RCDATA 定義文中の文字列だけは、この規則が当てはまりません。こ
れらの疑似文字列は、実際の文字列ではなく、単にバイトの集合に対して便利
な表記法であるにすぎません。 ユーザーは RCDATA 定義文によって、データ
上に構造体をオーバーレイさせ、データを一定のオフセットに位置させること
ができます。疑似文字列が自動的に Unicode 文字列に変更されると、構造体
内のオフセットが誤って変更され、アプリケーションをブレークしてしまいます。
したがって、これらの疑似文字列は、ASCII バイトとして残しておく必要があ
ります。 RCDATA 定義文中で Unicode 文字列を指定するには、L 付きの二重
引用符で明示的に囲まれた文字列を使ってください。

1.3  DWORD 整列

Windows 32 でリソース バイナリ ファイルを読み込みやすくするには、
ファイル内のオブジェクトをすべて DWORD 整列にする必要があります。これ
には、データ エントリだけでなく、ヘッダーに対しても行います。通常は、
リソース データ構造体のフィールドの順序を変更する必要はありませんが、
フィールド間に多少の埋め込みを行う必要があります。

この規則に当てはまらないのは、フォント構造体とfontdir 構造体だけです。
というのは、これらの 2 つの構造体は他のファイルから直接コピーされ、RC 
によって使われることはないからです。

2.  一般情報

リソース コンパイラ (RC) は、リソース スクリプト ファイル (.RC) を解
析し、ほかのすべてのリソース データ ファイル (.ICO、.CUR、.BMP、.FNTなど) 
を取り込みながら、リソース ファイルを作成します。リソース ファイルには、
実行可能なイメージ内にリソース テーブルを構築するのに必要な情報がすべ
て格納されています。リソース ファイルの主な目的は、必ずしもリソースの
再コンパイルを必要とせずにエディット - コンパイル - リンクのサイクルの
時間を短縮するためです。

現在、規定のリソースの型は、1 ダースほど存在します。これらには、メ
ニュー、ダイアログ、アクセラレータ、文字列、アイコン、マウス カーソル、
ビットマップ、フォント、およびバージョンがあります。これらのリソースは、
アプリケーション ウィンドウの構成を定義するために、Windows システムで
使われます。リソース スクリプトによって、アプリケーションの作成者は、
これらの機能を簡単に編集できる書式で表すことができます。型のこれ以外の
範囲は、アプリケーションに固有のデータをアプリケーションで使うために
予約されています。リソース コンパイラでは、このユーザー定義のデータを 
16 ビット形式から 32 ビット形式には修正しません。

Windows 32 の実行可能なイメージ ファイルは、セグメント化されたイメージ
ではありません。16 ビットの実行可能なイメージ ファイルでは、個々のリ
ソースは、イメージ ファイル内の別々のセグメントに格納されていました。 
Windows 32 のイメージ ファイルでは、すべてのリソースは、単一のオブジェ
クトまたはセクションに格納されます。Windows 32 のイメージ ファイルでは、
16 ビットのイメージ ファイルのときのようなリニア検索する必要のある
テーブルではなく、特定のリソースを高速に探索できるバイナリ ソートされ
たリソース テーブルも提供されます。この Windows 32 イメージ ファイル
形式は、Windows 16 形式より複雑であり、直接更新することは困難なので、
Windows 32 API ではリソース データを直接修正する手段を提供しています。

リソース ファイルを COFF オブジェクトに変換するための CVTRES 変換ユー
ティリティによって、リソース テーブルが作成されます。このテーブルには、
型、名前、および言語の順にインデックスの付けられた 3 つのディレクトリ
があります。 型ディレクトリおよび名前ディレクトリは、2 つの部分、すな
わち、型または名前が文字列によって表されるリソース専用の部分、および
序数の WORD 値によって表される部分によって構成されます。リソースの型と
名前の識別子として文字列を使うと、序数の識別子のときに比べかなり多くの
領域を占有するので、お勧めしません。

リソースの型と名前の識別に使う文字列も含め、リソース ファイル内の文字
列はすべて Unicode なので、LoadBitmap などに現在渡されているプログラム
内の対応する文字列も Unicode でなければなりません。ただし、アプリケー
ションが、ASCII セットでなく API の Unicode セットを使用中のときに限り
ます。Unicode にするには、winnt.h で提供されている TEXT マクロを使うと
簡単です。

第 3 のレベル、すなわち言語によって、アプリケーションの開発者は複数の
言語をサポートする単一の実行可能なイメージを販売できます。たとえば、
フランス語、カナダ フランス語、およびベルギー フランス語を提供する 1 
つのイメージを 1 つのイメージ ファイルに格納することなども簡単にでき
ます。Unicode 規格でサポートされるすべての言語をサポートしたまま、アプ
リケーションを販売することもできます。この場合、イメージが非常に大きく
なってしまいますが、システムにはイメージ内のリソースを修正する機能があ
るので、セットアップ プログラムにより、特定のユーザーごとにアプリケー
ションのイメージ ファイルをカスタマイズし、不要な言語サポートを削除す
ることでイメージ ファイル内の空間を節約できます。

2.1  新しい定義文

Windows 32 のリソース コンパイラで処理される新しい定義文がいくつか追加
されました。

2.1.1  新しいボタン定義文

これらの定義文は該当するボタン スタイルと対応しており、アプリケーション
の開発者は PUSHBUTTON 定義文、DEFPUSHBUTTON 定義文など同様に、自由に
表現することができます。

これらはすべて、構文が PUSHBUTTON などと同一です。

2.1.1.1  AUTO3STATE

AUTO3STATE ボタンを宣言できます。

2.1.1.2  AUTOCHECKBOX

AUTOCHECKBOX ボタンを宣言できます。

2.1.1.3  AUTORADIOBUTTON

AUTORADIOBUTTON ボタンを宣言できます。

2.1.1.5  PUSHBOX

PUSHBOX ボタンを宣言できます。

2.1.1.6  STATE3

3STATE ボタンを宣言できます。構文上の都合で、3 は最後に付けます。

2.1.1.7  USERBUTTON

ユーザー定義の USERBUTTON ボタンを宣言できます。

2.1.2  EXSTYLE 定義文

この定義文により、アプリケーションの開発者は、ダイアログまたはコント
ロール ウィンドウの拡張 (WS_EX_xxx) スタイルの 1 つを指定できます。
要求に応じて、以下の 3 つの方法に分けられます。

まず DIALOG 定義文の直後に指定することによって、CAPTION 定義文または 
STYLE 定義文のように、ダイアログ ウィンドウに適用することができます。

     EXSTYLE <flags>
     
さらに、メモリ フラグの付いた DIALOG 定義文で指定することもできます。

     FOOBAR DIALOG [MemFlags...] [EXSTYLE=<flags>] x, y, dx, dy
     

また、CONTROL 定義文、PUSHBUTTON 定義文、LTEXT 定義文のような個々の
定義文の終わりで指定することもできます。

     AUTOCHECKBOX "autocheckbox", id, x, y, dx, dy
     [styleflags][exstyleflags]

2.1.3  CHARACTERISTICS 定義文

この定義文により、アプリケーション開発者はリソース ファイルの読み書き
を行うツールに役立つリソース情報を指定できます。システムにとって重要
ではないので、イメージ ファイルには格納されません。

     CHARACTERISTICS <ユーザー定義の DWORD 値>
     
2.1.4  VERSION 定義文

この定義文は、リソース ファイルの読み書きを行うツールに対してアプリ
ケーションでリソース ファイル内の特定のリソースのバージョン番号を指定
できるようにするためのものです。システムにとって重要ではないので、
イメージ ファイルには格納されません。

     VERSION <ユーザー定義の DWORD 値>
     
2.1.5  LANGUAGE 定義文

LANGUAGE 定義文は、リソース ファイルまたはリソース ファイルの一部を書
き込むときに使う言語を指定するためのものです。 ICON、CURSOR、および 
BITMAP のような単一行の定義文を指定できるリソース スクリプト ファイル
であればどこでも指定できます。LANGUAGE 定義文で指定する言語の適用範囲
は、スクリプト ファイル内のこの定義文から次の LANGUAGE 定義文まで、
またはファイルの終わりまでです。

     LANGUAGE <メジャー番号>,<マイナー番号>

ここで、<メジャー番号> は、言語の ID を表し、<マイナー番号> は、 2 次
言語識別子を表します。winnt.h 内で指定された値を使ってください。

MENU、DIALOG、STRINGTABLE、ACCELERATOR、および RCDATA リソースでは、
LANGUAGE 定義文は、CAPTION、STYLE などのような他の省略可能な定義文と
一緒に BEGIN 定義文の前に指定することもできます。本定義文をここで指定
したとき、定義文の範囲は定義中のリソースに限定されます。

2.1.6  MESSAGETABLE 定義文

MESSAGETABLE 定義文は、メッセージ テーブルを対象に含めるのに使います。
メッセージ テーブルは、特殊な目的をもった文字列テーブルであり、エラー 
メッセージまたは情報メッセージを格納するのに使います。形式情報を格納
する場合もあります。形式は、以下のとおりです。

     <名前 ID> MESSAGETABLE <ファイル名>
     
2.1.7  Unicode 文字列の追加構文

リソース スクリプト内の引用符の付いた文字列は、L または l 文字が前
に付いていない限り、現在のコード ページ内で、ASCII 文字列として処理さ
れます。
例：
     L"This is a Unicode string"

この構文と一緒に文字列の Unicode を宣言すると、次の 2 つの効果があり
ます。RCDATA 定義文では、コンパイラによって文字列が ASCII ではなく 
Unicode として格納されます。さらに、この構文を使用するとき、常に文字
列内に埋め込まれたエスケープが Unicode コードポイント エスケープになり、
この結果 16 ビットの Unicode 文字列になります。
例：

     L"This is the first line,\x2028and this is the second"

ここで、0x2028 の Unicode 文字は、行区切り記号です。この方法で、任意
の Unicode 文字を、任意のリソース スクリプト文字列内に埋め込むことが
できます。

3.  リソース ヘッダー形式

ファイル全体の一般的な形式は、互いに連結された多くのリソース ファイル 
エントリにすぎません。各リソースには、ダイアログまたは文字列テーブルの
ような、単一のリソースについての情報が格納されています。

各エントリは、リソース ヘッダーとリソース データによって構成されます。
DWORD 整列されたリソース ヘッダーは、ヘッダー サイズとリソース データ 
サイズからなる 2 つの DWORD、リソースの型、リソース名、および追加リソー
ス情報の 4 つの要素によって構成されます。リソース データは、リソース 
ヘッダーの後に置かれます。このデータは、個々の型のリソースに固有のも
のです。

3.1  DataSize

このフィールドでは、ヘッダーの後に置かれるデータのサイズを指定します。
ただし、このサイズにはリソース ファイル内のこのリソースと次のリソース
の間のファイル埋め込みは含まれません。

3.2  HeaderSize

HeaderSize フィールドでは、後に続くリソース ヘッダー構造体のサイズを
指定します。

3.3  Type

型フィールドは、型名を指定するための数、または NULL で終わる Unicode 
文字列のいずれかです。この変数のような型は、名前フィールドまたは序数
フィールドとして知られており、ID を指定できるリソース ファイルで使用
されます。

名前フィールドまたは序数フィールドでは、先頭の WORD で数値フィールド
なのか、文字列フィールドなのかを識別します。先頭の WORD が 無効な 
Unicode 文字、0xffff であると、次の WORD 情報は型番号になります。
0xffff でなければ、このフィールドでは Unicode 文字列で指定します。

型フィールドが数のとき、この数で標準のリソースの型またはユーザー定義
のリソースの型を指定します。すべての標準 の Windows リソースの型には、
以下で示した数が割り当てられています。この数のリストは、RC を作るのに
使うヘッダー ファイルから取ったもので、種々のリソースの型番号で構成さ
れています。

    /* 定義済みのリソースの型 */
    #define    RT_NEWRESOURCE      0x2000
    #define    RT_ERROR            0x7fff
    #define    RT_CURSOR           1
    #define    RT_BITMAP           2
    #define    RT_ICON             3
    #define    RT_MENU             4
    #define    RT_DIALOG           5
    #define    RT_STRING           6
    #define    RT_FONTDIR          7
    #define    RT_FONT             8
    #define    RT_ACCELERATORS     9
    #define    RT_RCDATA           10
    #define    RT_MESSAGETABLE     11
    #define    RT_GROUP_CURSOR     12
    #define    RT_GROUP_ICON       14
    #define    RT_VERSION          16
    #define    RT_NEWBITMAP        (RT_BITMAP|RT_NEWRESOURCE)
    #define    RT_NEWMENU          (RT_MENU|RT_NEWRESOURCE)
    #define    RT_NEWDIALOG        (RT_DIALOG|RT_NEWRESOURCE)
    
型フィールドが文字列のとき、型は、ユーザー定義の型になります。

3.4  Names

名前により特定のリソースを識別します。型と同様に、名前は数または文字
列のいずれかです。数および文字列は、型フィールドのときと同じ方法で
区別されます。

DWORD 整列のとき、型フィールドと名前フィールドの間に埋め込みは不要です。
というのも、これらのフィールドには WORD データしかなく、名前フィールド
は常に正しく整列されるからです。しかし、ヘッダーの未使用の部分を DWORD 
境界に整列させるためには、名前フィールドの後に 1 WORD の埋め込みが必要
なこともあります。

3.5  追加ヘッダー情報

追加情報には、サイズおよび言語 ID などの特定のリソース データに関する
詳細が格納されています。ヘッダーの構造および追加情報は、以下のとおり
です。

struct tagResource {
  DWORD  DataSize;           // ヘッダーのないデータのサイズ
  DWORD  HeaderSize;         // 追加ヘッダーの長さ
  [Ordinal or name TYPE]     // 型の識別子。ID または文字列
  [Ordinal or name NAME]     // 名前の識別子。ID または文字列
  DWORD  DataVersion;        // 定義済みのリソース データ バージョン
  WORD   MemoryFlags;        // リソース状態
  WORD   LanguageId;         // NLS の Unicode サポート
  DWORD  Version;            // リソース データのバージョン
  DWORD  Characteristics;    // データの特性
  } ;
    

追加情報構造体は、常にリソース ファイル内の DWORD 境界で始まります。
このため、名前フィールドと ResAdditional 構造体の間にさらに埋め込みが
必要なことがあります。

3.5.1　DataVersion

DataVersion フィールドでは、後に続くリソース ヘッダー内の情報の形式を
決定します。このフィールドを使って、後で定義済みの形式に追加情報を入
れることができます。

3.5.2  MemoryFlags

wMemoryFlags フィールドには、一定のリソースの状態を通知するフラグが
設定されます。これらの属性は、.RC スクリプト内の修飾子によって一定の
リソースに付けられたものです。以下のフラグ値は、スクリプトの識別子に
よって挿入されます。

    #define    MOVEABLE            0x0010
    #define    FIXED               ~MOVEABLE
    #define    PURE                0x0020
    #define    IMPURE              ~PURE
    #define    PRELOAD             0x0040
    #define    LOADONCALL          ~PRELOAD
    #define    DISCARDABLE         0x1000
    
MOVEABLE フラグ、IMPURE フラグ、および PRELOAD フラグの設定は、常に 
NT のリソース コンパイラによって無視されます。

3.5.3  LanguageId

各リソース内に設定する言語 ID は、文字列を元の単一のバイト文字列に変換
する必要が生じたとき、文字列を書くときの言語を指定するためのものです。
また、リソース内の文字列の言語が違っているだけで、型および名前がまった
く同じである複数のリソースが存在することがあります。

言語 ID は、NLS 仕様書の付録 A または winnt.h.で説明されています。
リソースまたはリソース群の言語は、LANGUAGE 定義文で指定されます。

3.5.4  バージョンおよび特性

現在、リソースのバージョンおよび特性情報のためのリソース ファイル形式
では、空間があります。これらの値は、VERSION 定義文または CHARACTERISTICS 
定義文を使用して、リソース コンパイラにより設定できます。

3.6  16 ビットと 32 ビットのリソース ファイルの区別

リソース ファイルの読み書きを行う ISV のツールにとっては、従来の 
Windows 16 形式ファイルと新しい Windows 32 形式の両方を読み込めること
が望ましいでしょう。このため Microsoft 社は、不当な型および名前の序数
を使って、このことを行う方法を工夫しました。

この方法では、リソース ファイルに不当なリソースを格納します。このため
に、以下の 8 バイトが選択されました。

     0x00 0x00 0x00 0x00 0x20 0x00 0x00 0x00
     

16 ビット ファイルのとき、先頭の 0x00 で文字列を指定していますが、ゼロ
の長さの文字列は不当な文字列なので型は不当です。したがって、これはこの
ファイルが 32 ビット ファイルであることを示す、不当な 16 ビットのリソー
ス ヘッダーです。

32 ビット ファイルであるとすれば、データのサイズはゼロになりますが、こ
のようなことはありえません。

Windows 32 リソース コンパイラにより、個々の 32 ビットのリソース ファイ
ルの前にこのデータ文字列が付けられます。この文字列の後には追加のデータ
構造体が続き、その中に 0 の序数の型と 0 の序数の名前の付いた、 0 の長さ
のリソースが記述されます。これにより、16 ビットと 32 ビットのリソース 
ファイルが区別できます。リソース ファイルを読み込むためのツールはすべて
このリソースを無視します。

3.7  ファイルの整列

リソースをいくつかのスクリプトに分けておき、リソース ファイルを別々に
コンパイルした後連結すると役に立つことがあります。このため、リソース 
ファイルに埋め込みバイトを付けて DWORD サイズにする指定が必要です。こ
の埋め込みが指定されないと、2 番目以降のリソース ファイルで、先頭の
リソースが DWORD 境界で整列されないことがあります。

4.  リソース データ形式

すべての定義済みのデータの型において、ビットマップ、アイコンおよびフォン
ト ヘッダーの構造を含むすべての構造が DWORD に整列されます。また、データ
は常に DWORD 境界から始まります。

4.1  バージョン リソース

バージョン リソースは、リソース ファイルを使うアプリケーションのバー
ジョンを記録するのに使います。バージョン リソースには、一定量の情報が
格納されています。バージョン リソースの構造は以下のとおりです。

typedef struct tagVS_FIXEDFILEINFO {
  DWORD  dwSignature;        // e.g.  0xfeef04bd
  DWORD  dwStrucVersion;     // e.g.  0x00000042 = "0.42"
  DWORD  dwFileVersionMS;    // e.g.  0x00030075 = "3.75"
  DWORD  dwFileVersionLS;    // e.g.  0x00000031 = "0.31"
  DWORD  dwProductVersionMS; // e.g.  0x00030010 = "3.10"
  DWORD  dwProductVersionLS; // e.g.  0x00000031 = "0.31"
  DWORD  dwFileFlagsMask;    // = 0x3F for version "0.42"
  DWORD  dwFileFlags;        // e.g.  VFF_DEBUG | VFF_PRERELEASE
  DWORD  dwFileOS;           // e.g.  VOS_DOS_WINDOWS16
  DWORD  dwFileType;         // e.g.  VFT_DRIVER
  DWORD  dwFileSubtype;      // e.g.  VFT2_DRV_KEYBOARD
  DWORD  dwFileDateMS;       // e.g.  0
  DWORD  dwFileDateLS;       // e.g.  0
  } VS_FIXEDFILEINFO;

4.2  アイコン リソース

.RC スクリプト内の ICON 定義文によって作られるのは、単一のリソース 
オブジェクトではなく、リソース群です。このため、異なった性能のハード
ウェア構成でも、異なったピクセルに対応するビットマップを使うことによって、
ある程度デバイスに依存しない Windows プログラムが可能です。アイコンは、
たいていの場合、異なった数のピクセル プレーン数およびピクセル カウント
に対応するように設計されています。Windows ではアイコンはグループ化され、
単一のリソースとして処理されますが、.RES ファイルおよび .EXE ファイル
では、リソース群として格納されます。これらのグループが .RES ファイルに
格納されるときは、構成要素が先になり (この場合、別のアイコン [型 3])、
グループ ヘッダーが後に置かれます (型 14)。グループ ヘッダーには 
Windows で表示すべき適切なアイコンを選択できるように、必要な情報が記述
されています。

構成要素の構造は以下のとおりです。

        [リソース ヘッダー (型 = 3)]
    
        [DIB ヘッダー]
        [アイコン XOR マスクのカラー DIBit]
        [AND マスクのモノクロ DIBit]
    

各構成要素には、他のすべてのアイコン構成要素から一意に識別される序数の 
ID が割り当てられています。

デバイスに依存しないビットマップ (DIB) ヘッダーのフィールドは、マスク
の情報を別々に表します。ただし、以下の 2 つの例外があります。まず第 1 
に、高さフィールドは XOR マスクおよび AND マスクの両方を表します。2 
つの DIB をデバイスに依存するビットマップ (DDB) に変換する前に高さを 
2 で割らなければなりません。マスクは常に同じサイズで、DIB ヘッダーで
指定されたサイズの 1/2 です。第 2 に、ピクセル当りのビット数および
ビット カウントは XOR マスクを参照しています。AND マスクは常にモノク
ロであり、ピクセル当り 1 プレーン、1 ビットであると解釈されます。
Windows でアイコンを使う前に、DIB に関する詳細について SDK リファレン
スの説明を参照してください。アイコンの構成要素の形式は .ICO ファイルの
形式とよく似ていますので、このファイル形式の解説が役に立ちます。DDB を 
Windows 32 のアプリケーションには使用しないでください。

グループ ヘッダーを以下に記述します。

    [リソース ヘッダー (型 = 14)]
    
struct IconHeader {
  WORD   wReserved;          // 現在 0
  WORD   wType;              // アイコンのとき 1
  WORD   wCount;             // 構成要素の数
  WORD   padding;            // DWORD 整列のためのフィラー
  };

次の部分は、各構成要素のリソースごとに繰り返されます。

struct ResourceDirectory {
  BYTE   bWidth;
  BYTE   bHeight;
  BYTE   bColorCount;
  BYTE   bReserved;
  WORD   wPlanes;
  WORD   wBitCount;
  DWORD  lBytesInRes;
  WORD   wNameOrdinal;       // 構成要素へのポインタ
  WORD   padding;            // DWORD 整列のためのフィラー
  };
    

グループ ヘッダーは、各グループ構成要素ごとに繰り返される一定のヘッダー
およびデータによって構成されます。これらの部分は両方とも固定長であり、
グループ構成要素の情報に対するランダム アクセスを可能にしています。

このグループ ヘッダーには、.ICO ヘッダーおよび個々のリソース ディスク
リプタから得られるすべてのデータが記述されています。

4.3  メニュー リソース

メニュー リソースは、メニュー ヘッダーと、その後に続くメニュー項目リス
トによって構成されます。メニュー項目には、ポップアップおよび通常のメ
ニュー項目の 2 種類があります。MENUITEM SEPARATOR は通常のメニュー項目
の特殊な場合で、空の名前、0 の ID および 0 のフラグによって構成され
ます。これらの型の形式は以下のとおりです。

    [リソース ヘッダー (型 = 4)]
    
struct MenuHeader {
  WORD   wVersion;           // 現在 0
  WORD   cbHeaderSize;       // ここも 0
  };
    
これらの項目は、メニュー項目ごとに繰り返されます。

ポップアップ メニュー項目 (fItemFlags & POPUP によって識別される):

struct PopupMenuItem {
  WORD   fItemFlags;
  WCHAR  szItemText[];
  };
    
通常のメニュー項目 (!(fItemFlags & POPUP)によって識別される):

struct NormalMenuItem {
  WORD   fItemFlags;
  WORD   wMenuID;
  WCHAR  szItemText[];
  };
    
wVersion 構造体メンバーおよび cbHeaderSize 構造体メンバーによって、メ
ニュー テンプレートのバージョンが識別されます。これらのメンバーは、
Windows 3.0 では両方とも 0 ですが、将来メニュー テンプレートを変更し
た時、増やすことができます。

WORD fItemFlags は、メニュー項目を記述する一群のフラグです。POPUP ビッ
トが設定されたとき、この項目は、POPUP になります。設定されないとき、
通常のメニュー構成要素になります。このほかにも設定可能なフラグ ビットが
いくつかあります。これらの値は以下のとおりです。

    #define    GRAYED         0x0001   // GRAYED キーワード
    #define    INACTIVE       0x0002   // INACTIVE キーワード
    #define    BITMAP         0x0004   // BITMAP キーワード
    #define    OWNERDRAW      0x0100   // OWNERDRAW キーワード
    #define    CHECKED        0x0008   // CHECKED キーワード
    #define    POPUP          0x0010   // 内部使用
    #define    MENUBARBREAK   0x0020   // MENUBARBREAK キーワード
    #define    MENUBREAK      0x0040   // MENUBREAK キーワード
    #define    ENDMENU        0x0080   // 内部使用
    
指示された POPUP 内の最終メニュー項目の fItemFlags 部分は、ENDMENU と
論理和を取ることによってフラグがセットされます。ポップアップはネスト
できるので、ENDMENU がセットされている複数のレベルの項目が存在するこ
とがあります。メニューがネストされているとき、項目は順次に挿入されます。
プログラムで ENDMENU フラグがセットされている項目があるかどうか検査す
ることによって、この階層構造を走査できます。

4.4  ダイアログ ボックス リソース

ダイアログ ボックスは単一のリソースに格納され、ダイアログ ボックス内
のコントロールごとに繰り返されるヘッダーおよび部分によって構成されます。
ヘッダーは以下のとおりです。

    [リソース ヘッダー (型 = 5)]
    
struct DialogBoxHeader {
  DWORD  lStyle;
  DWORD  lExtendedStyle;   // NT で新規
  WORD   NumberOfItems;
  WORD   x;
  WORD   y;
  WORD   cx;
  WORD   cy;
  [Name or Ordinal] MenuName;
  [Name or Ordinal] ClassName;
  WCHAR  szCaption[];
  WORD   wPointSize;       // ダイアログで FONT が設定されているときのみ
  WCHAR  szFontName[];     // 同上
  };
  
DWORD lStyle 項目は、WINDOWS.H 内のフラグからなる標準ウィンドウ スタ
イルです。ダイアログ ボックスのデフォルト スタイルは以下のとおりです。

    WS_POPUP | WS_BORDER | WS_SYSMENU
    
lExtendedStyle DWORD は、拡張ウィンドウ スタイル フラグを指定するのに
使います。拡張スタイルが DIALOG 定義文で指定されたとき、またはほかの省
略可能な修飾子定義文と一緒に指定されたとき、DWORD はこの値に設定されます。

名前または序数の印の付いた項目は、名前または序数の ID を格納するのに、
リソース ファイル全体を通して (特に、各リソース ヘッダーで) 使われて
いるものと同一の形式で格納します。従来どおり先頭バイトが 0xffff である
とき、次の 2 バイトには、序数の ID が設定されます。0xffff でないとき、
先頭の 1 WORD またはそれ以上の WORD に NULL で終わる文字列が設定され
ます。空の文字列は、先頭の位置に単 WORD の 0 で表されます。

ダイアログ ボックスの場合、FONT 定義文が指定されていると、WORD 
wPointSize エントリおよび WCHAR szFontName エントリが存在します。これ
は、lStyle エントリを検査することによって検出できます。
lStyle & DS_SETFONT (DS_SETFONT = 0x40)が真であるとき、これらのエントリ
が存在します。

各コントロールごとのデータは DWORD 境界で始まります。このため、直前の
コントロールからの埋め込みが必要なことがあります。形式は以下のとおりです。

struct ControlData {
  DWORD  lStyle;
  DWORD  lExtendedStyle;
  WORD   x;
  WORD   y;
  WORD   cx;
  WORD   cy;
  WORD   wId;
  [Name or Ordinal] ClassId;
  [Name or Ordinal] Text;
  WORD   nExtraStuff;
  };
    
従来どおり、DWORD lStyle 項目は、WINDOWS.H 内のフラグによって構成さ
れる標準ウィンドウ スタイルです。コントロールの型は、クラスによって決定され
ます。クラスはゼロで終わる文字列によって指定されるか、あるいは通常の 
Windows クラスの場合、多くは空間の節約と処理速度を速くするために 1 
WORD のコードが付けられます。Unicode では 0x8000 は正当な文字なので、
序数の型フィールドおよび名前フィールドと同様に序数のクラスの前に 0xFFFF 
が付けられます。以下に 1 ワードのクラスが示してあります。

    #define    BUTTON              0x8000
    #define    EDIT                0x8100
    #define    STATIC              0x8200
    #define    LISTBOX             0x8300
    #define    SCROLLBAR           0x8400
    #define    COMBOBOX            0x8500
    
lExtendedStyle DWORD は、本コントロールに使う拡張スタイル フラグの指定に使い
ます。拡張スタイル フラグは、座標の後に置かれた CONTROL 定義文または
他の CONTROL 定義文の終わりに設定します。

コントロール データ構造体の終わりの補足情報は現在使いませんが、将来メニュー項目
に補足情報の必要が生じたとき使う予定です。通常、この情報は長さがゼロです。

ダイアログ スクリプトで使う種々の定義文は、特定の修飾スタイルと一緒に
すべてこれらのクラスに割り当てられています。これらのスタイルの値は、
WINDOWS.H に格納されています。すべてのダイアログ コントロールには、WS_CHILD お
よび WS_VISIBLE のデフォルトのスタイルがあります。スクリプト定義文の
作成に使うデフォルトのスタイルのリストが以下に示してあります。

    定義文      デフォルトのクラス デフォルトのスタイル
    CONTROL         None           WS_CHILD|WS_VISIBLE
    LTEXT           STATIC         ES_LEFT
    RTEXT           STATIC         ES_RIGHT
    CTEXT           STATIC         ES_CENTER
    LISTBOX         LISTBOX        WS_BORDER | LBS_NOTIFY
    CHECKBOX        BUTTON         BS_CHECKBOX | WS_TABSTOP
    PUSHBUTTON      BUTTON         BS_PUSHBUTTON | WS_TABSTOP
    GROUPBOX        BUTTON         BS_GROUPBOX
    DEFPUSHBUTTON   BUTTON         BS_DEFPUSHBUTTON | WS_TABSTOP
    RADIOBUTTON     BUTTON         BS_RADIOBUTTON
    AUTOCHECKBOX    BUTTON         BS_AUTOCHECKBOX
    AUTO3STATE      BUTTON         BS_AUTO3STATE
    AUTORADIOBUTTON BUTTON         BS_AUTORADIOBUTTON
    PUSHBOX         BUTTON         BS_PUSHBOX
    STATE3          BUTTON         BS_3STATE
    EDITTEXT        EDIT           ES_LEFT|WS_BORDER|WS_TABSTOP
    COMBOBOX        COMBOBOX       なし
    ICON            STATIC         SS_ICON
    SCROLLBAR       SCROLLBAR      なし
    

コントロール テキストは、上述の「名前または序数」形式で格納されています。

4.5  マウス カーソル リソース

マウス カーソル リソースは、アイコン リソースとよく似ています。これら
がグループ化されるとき、構成要素がヘッダーの前に置かれます。このヘッ
ダーの場合も、個々の構成要素のランダム アクセスを可能にする固定長構成
要素のインデックスを使います。マウス カーソル ヘッダーの構造体は以下
のとおりです。

    [リソース ヘッダー (型 = 12)]
    
struct CursorHeader {
  WORD   wReserved;          // 現在 0
  WORD   wType;              // マウス カーソルのとき 2 
  WORD   cwCount;            // 構成要素数
  WORD   padding;            // DWORD 整列のためのフィラー
  };
    
次の部分は各構成要素リソースごとに繰り返され、DWORD 境界で始まります。

struct ResourceDirectory {
  WORD   wWidth;
  WORD   wHeight;
  WORD   wPlanes;
  WORD   wBitCount;
  DWORD  lBytesInRes;
  WORD   wNameOrdinal;       // 構成要素を指すポインタ
  WORD   padding;            // DWORD 整列のためのフィラー
  };
    
各マウス カーソル構成要素も、各アイコン構成要素に似ています。しかし、
これら 2 つには著しい違いが 1 つあります。マウス カーソルには、アイ
コンにはないホットスポットという概念があります。以下に構成要素の構造体
を示します。

    [リソース ヘッダー (型 = 1)]
    
struct CursorComponent {
  short  xHotspot;
  short  yHotspot;
  }
    [モノクロ XOR マスク]
    [モノクロ AND マスク]
    
これらのマスクは、.CUR ファイルからコピーしたビットマップです。この
点でのアイコンとの主な違いは、マウス カーソルには、アイコンのような 
XOR マスク用のカラー DIB がないということです。ビットマップはモノクロ
であり、DIB ヘッダーやカラー テーブルがありませんが、整列および方向の
点ではビットはやはり DIB 形式になっています。DIB 形式についての詳細は、
SDK のリファレンスを参照してください。

4.6  ビットマップ リソース

Windows 32 では、デバイスに依存しない 2 種類のビットマップを読み込む
ことができます。通常の型の DIB は、Windows 3.0 DIB 形式です。もう一方
の型の DIB は、OS/2 バージョン 1.1 および 1.2 に使うものです。ビット
マップ リソースは単一のデバイスに依存しないビットマップで構成され、
したがってこのDIB は、いずれの形式でも可能です。これらの 2 種類の DIB 
は、ヘッダー構造体によって区別されます。これら両方とも、ヘッダー内の
先頭の DWORD に個々の構造体のサイズが設定されています。これらの構造体
は、両方とも Windows SDK のリファレンスに説明されています。通常の DIB 
のヘッダー構造体は BITMAPINFOHEADER であり、OS/2 の DIB ヘッダーは 
BITMAPCOREHEADER と呼ばれています。正しいサイズ (DWORD) が、構造体の
先頭のエントリ内になければなりません。

    [通常のリソース ヘッダー (型 = 2)]
    
    [BITMAPINFOHEADER または BITMAPCOREHEADER]
　　[ピクセル当り 24 ビットでないとき、カラー テーブル]
    [パックされたピクセル ビットマップ]
    
カラー テーブルは省略可能です。24 ビットのカラー ビットマップ以外は、
すべてその次にカラー テーブルが付加されます。このテーブルの長さは OS/2 
のビットマップのとき 2#BitsPerPixel * 3 バイト により、Windows の
ビットマップのとき 2#BitsPerPixel * 4 バイトにより計算できます。この
ビットマップ イメージ データはカラー テーブルの直後に格納されます。

ビットマップ ファイルは、整列されていないヘッダー構造 (BITMAPFILEHEADER 
構造) をしています。しかしこのヘッダーはファイルの型 (DIB または DDB) 
の識別だけに使われるので、リソース ファイルには格納されません。

4.7  フォントおよびフォント ディレクトリ リソース

フォント リソースは、特定のアプリケーション プログラムのリソースに
追加されないという点で他の型のリソースとは異なっています。フォント 
リソースは .FON ファイルに名前が変更される .EXE ファイルに追加され
ます。これらのファイルは、アプリケーションに対するものとしてライブラリ
と呼ばれます。

フォント リソースではリソース グループ構造体を使います。個々のフォント
は、フォント グループの構成要素です。各構成要素は .RC ファイル内の FONT 
定義文によって定義されます。グループ ヘッダーはすべての構成要素の後に
位置し、この中に特定のフォントへのアクセスに必要な情報がすべて記載され
ています。フォント構成要素のリソースの形式は以下のとおりです。

    [通常のリソースヘッダー (型 = 8)]
    
    [.FNT ファイルの全内容がリソース本体として続きます。-
    - .FNT ファイルの形式については Windows SDK のリファレンスを参照。]

フォントのためのグループ ヘッダーは、通常 .RES ファイルの最後にあります。
マウス カーソル グループおよびアイコン グループとは異なり、フォント 
グループは .RES ファイル内で連続している必要はありません。フォントの
宣言は、他のリソースの宣言と一緒に .RC ファイル内で行われることがあり
ます。グループ ヘッダーは、 .RES ファイルの終わりに RC によって自動的
に付加されます。.RES ファイルを生成するためのプログラムでは、手動で 
FONTDIR エントリを付加しなければなりません。グループ ヘッダーの構造体
は以下のとおりです。

    [通常のリソース ヘッダー (型 = 7)]
    
    WORD NumberOfFonts; // .RES ファイル内の総数
    
これ以外のデータは .RES ファイル内のフォントごとに繰り返されます。
    
WORD fontOrdinal;
struct FontDirEntry {
  WORD   dfVersion;
  DWORD  dfSize;
  char   dfCopyright[60];
  WORD   dfType;
  WORD   dfPoints;
  WORD   dfVertRes;
  WORD   dfHorizRes;
  WORD   dfAscent;
  WORD   dfInternalLeading;
  WORD   dfExternalLeading;
  BYTE   dfItalic;
  BYTE   dfUnderline;
  BYTE   dfStrikeOut;
  WORD   dfWeight;
  BYTE   dfCharSet;
  WORD   dfPixWidth;
  WORD   dfPixHeight;
  BYTE   dfPitchAndFamily;
  WORD   dfAvgWidth;
  WORD   dfMaxWidth;
  BYTE   dfFirstChar;
  BYTE   dfLastChar;
  BYTE   dfDefaultChar;
  BYTE   dfBreakChar;
  WORD   dfWidthBytes;
  DWORD  dfDevice;
  DWORD  dfFace;
  DWORD  dfReserved;
  char   szDeviceName[];
  char   szFaceName[];
  };
    
4.8  文字列テーブル リソース

文字列テーブルは 16 個の文字列からなるブロックで構成されます。16 個の
文字列のこれらのブロックの構成は、種々の文字列に割り当てられた ID に
よって決定されます。ID の下位 4 ビットでブロック内の文字列の位置が決
定され、上位 12 ビットで文字列を設定するブロックが決定されます。16 個
の文字列からなる各ブロックは、1 個のリソース エントリとして格納され
ます。各文字列または各エラー テーブル リソース ブロックは以下のように
格納されます。

    [通常のリソース ヘッダー (型 = 文字列のとき、6 )]
    
    [16 個の文字列のブロック。文字列は、Pascal スタイルで、長さを表す WORD が
    文字列の前に来ます。すべてのスロットが満たされていなくとも、16 個の文字列
    は、常に書き込まれます。ブロック内の、文字列のないすべてのスロットは、長さ
    として WORD 長の 0 が設定されます。]

種々のブロックは、リソース ファイル内に番号順に書き込む必要はありません。
各ブロックには序数の ID が割り当てられています。この ID は、ブロック内の
文字列 ID の上位 12 ビットに 1 を足したものです (序数の ID はゼロであっ
てはならないため)。ブロックは .RC ファイル内で検出された順に .RES ファ
イルに書き込まれ、CVTRES ユーティリティにより COFF オブジェクト内に順番
に並べられます。このようにして、イメージ ファイルが作られます。

4.9  アクセラレータ テーブル リソース

アクセラレータ テーブルは、単一のリソースとして格納されます。複数の
アクセラレータ テーブルも可能です。アクセラレータ テーブルの形式は、
非常に単純です。テーブルのヘッダーは使いません。テーブル内の各エントリ
は単一の 4 ワードのエントリで構成されます。テーブル内の最終エントリ
には 16 進数の値 0x0080 (fFlags |= 0x0080) によってフラグが設定されま
す。エントリがすべて固定長であることから、ランダム アクセスが可能です。
リソース長を 8 で割ることによってテーブル内の要素数が計算できるように
なっています。以下にテーブル エントリの構造体が示してあります。

　    [通常のリソース ヘッダー (型 = 9)]
    
以下の構造体がアクセラレータ テーブル エントリのすべてに対して繰り返し
使用されます。

struct AccelTableEntry {
  WORD   fFlags;
  WORD   wAscii;
  WORD   wId;
  WORD   padding;
  };
    
4.10  ユーザー定義のリソースと RCDATA

RC により、プログラマーは Windows で定義されていないリソースを扱うこと
ができます。ユーザーは標準の型として定義されていない名前を選択し、この
名前を使ってリソースとして使うデータをインクルードすることができます。
このデータは外部ファイルから取り入れるか、または BEGIN 定義文と END 
定義文の間に書くことができます。プログラマーは型を RCDATA として定義す
ることもできます。このときにも同じ結果が得られます。

お分かりのように、本リソースの形式は非常に単純です。これはデータの論理
構造が、リソース コンパイラによって認識されないためです。ここにその
構成を示します。

    [通常のリソース ヘッダー (RCDATA のときは型 = 10、名前付きの型は
    ユーザー定義の型を表します。)]
    
    [BEGIN と END の間に書かれたデータ、または外部ファイルから得られた
    データが変換されずに .RES ファイルに格納されます。]    

4.11  名前テーブルおよびエラー テーブル リソース

名前テーブルおよびエラー リソースは、Windows バイナリ リソース ファイル
形式ではサポートされなくなりました。

4.12  バージョン リソース

プログラムまたはダイナミック リンク ライブラリのどのバージョンをシステ
ムにインストールするかを検出するために、セットアップ プログラムで使用
可能な情報をバージョン リソースで指定します。バージョン リソースを問い
合わせるための一群の API もあります。バージョン リソースに格納される情
報には、3 つの重要な型があります。VS_FIXEDFILEINFO 構造体内の主要な情報、
可変ファイル情報構造体 (VarFileInfo) 内の言語情報データ、および 
StringFileInfo 構造体内のユーザー定義の文字列情報です。Windows 32 で
は、バージョン情報リソース内の文字列は Unicode で格納され、リソースの
ローカライズ情報を提供します。各ブロックの情報は DWORD 整列されます。

バージョン リソースの構造体は、VS_VERSION_INFO 構造体によって記述され
ます。

VS_VERSION_INFO {
    WORD wLength;             /* バージョン リソースの長さ */
    WORD wValueLength;        /* このブロックの値フィールドの長さ */
    WORD wType;               /* 情報の型：1== 文字列, 0== バイナリ */
    WCHAR szKey[];            /* Unicode 文字列の KEY フィールド */
    [WORD Padding1;]          /* 埋め込み可能ワード */
    VS_FIXEDFILEINFO Value;   /* 固定ファイル情報構造体 */
    BYTE Children[];          /* VarFileInfo または StringFileInfo データの位置 */
};

固定ファイル情報構造体には、製品およびファイルのバージョン番号および
ファイルの型などのバージョンに関する基本的な情報が格納されています。

typedef struct tagVS_FIXEDFILEINFO {
    DWORD dwSignature;        /* シグニチャ - 常に 0xfeef04bd */
    DWORD dwStrucVersion;     /* 構造体バージョン - 現在 0*/
    DWORD dwFileVersionMS;    /* 最上位のファイル バージョン dword */
    DWORD dwFileVersionLS;    /* 最下位のファイル バージョン dword */
    DWORD dwProductVersionMS; /* 最上位の製品バージョン*/
    DWORD dwProductVersionLS; /* 最下位の製品バージョン*/
    DWORD dwFileFlagMask;     /* ファイル フラグ マスク*/
    DWORD dwFileFlags;        /* デバッグ/商品/プレリリース/... */
    DWORD dwFileOS;           /* OS の型。常に Windows32 値 */ 
    DWORD dwFileType;         /* ファイルの型 (dll/exe/drv/... ) */
    DWORD dwFileSubtype;      /* ファイルの下位の型*/
    DWORD dwFileDateMS;       /* 日付の最上位桁) */
    DWORD dwFileDateLS;       /* 日付の最下位桁) */
} VS_FIXEDFILEINFO;

ユーザー定義の文字列情報は、StringFileInfo 構造体内に格納されています。
この構造体は 2 つの文字列、すなわちキーおよび情報で 1 組になっています。

StringFileInfo {
    WCHAR       szKey[];      /* Unicode "StringFileInfo" */
    [WORD        padding;]    /* 可能な埋め込み */
    StringTable Children[];
};

StringTable {
    WCHAR      szKey[];   /* 言語を指定する Unicode 文字列 - 8 バイト */
    String Children[];    /* 子の文字列構造体の配列 */
}

String {
    WCHAR   szKey[];          /* 任意の Unicode コード化された KEY 文字列 */
                              /* 定義済みのキーのリストがあります。*/
    [WORD   padding;]         /* 必要なら埋め込み */
    WCHAR Value[];            /* Unicode コード化された KEY 値 */
} String;

可変ファイル情報 (VarFileInfo) ブロックには、アプリケーション /dll の
本バージョンによってサポートされている言語のリストが格納されています。

VarFileInfo {
    WCHAR szKey[];            /* Unicode "VarFileInfo" */
    [WORD padding;];          /* 必要なら埋め込み */
    Var        Children[];    /* 子の配列 */
};

Var {
    WCHAR szKey[];       /* Unicode 変換 (または他のユーザー キー) */
P.23
    [WORD padding;]      /* 必要なら埋め込み */
    WORD  Value[];       /* 1 つ以上の値、通常言語 ID */
};

4.13  メッセージ テーブル リソース

メッセージ テーブルは、エラー メッセージまたはメッセージ ボックス表示
用の書式化テキストを格納するためのリソースです。これは、エラー テーブル 
リソース (一度も使われたことがない) に代わるものです。データは 
MESSAGE_RESOURCE_DATA 構造体によって構成され、この構造体は 1 つ以上の 
MESSAGE_RESOURCE_BLOCKS によって構成され、さらにこのブロックは、1 つ
以上の MESSAGE_RESOURCE_ENTRY 構造体によって構成されることがあります。
この構造体は STRINGTABLE リソースの構造体に似ています。

typedef struct _MESSAGE_RESOURCE_DATA {
    ULONG NumberOfBlocks;
    MESSAGE_RESOURCE_BLOCK Blocks[];
} MESSAGE_RESOURCE_DATA, *PMESSAGE_RESOURCE_DATA;

typedef struct _MESSAGE_RESOURCE_BLOCK {
    ULONG LowId;
    ULONG HighId;
    ULONG OffsetToEntries;
} MESSAGE_RESOURCE_BLOCK, *PMESSAGE_RESOURCE_BLOCK;

typedef struct _MESSAGE_RESOURCE_ENTRY {
    USHORT Length;
    USHORT Flags;
    UCHAR Text[];
} MESSAGE_RESOURCE_ENTRY, *PMESSAGE_RESOURCE_ENTRY;

USHORT フラグが MESSAGE_RESOURCE_Unicode (値 0x0001) であるとき、文字
列は、現在のコードページによる ASCII でなく、Unicode でコード化されます。

