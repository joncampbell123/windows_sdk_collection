<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<HTML>
<HEAD><TITLE>DirectPlay Tutorials</TITLE>
<STYLE>
<!--
.tctop {color: blue}
.cpslug {color: blue; text-decoration: none}
-->
</STYLE>
<SCRIPT LANGUAGE="JAVASCRIPT">
//<!--
function ShowButtons() {
    if (window.top.frames.length!=0 && window.top.frames[0].ShowButtons!=null)
	window.top.frames[0].ShowButtons('/dpbu0008.htm','/dpbu0000.htm','/dpbu0000.htm','/index.htm','/dpbu0010.htm');
}
ShowButtons();
//-->
</SCRIPT>
</HEAD>
<BODY onLoad="ShowButtons()" TOPMARGIN=10 BGPROPERTIES="FIXED" BGCOLOR="#FFFFFF" LINK="#000000" VLINK="#808080" ALINK="#000000">
<FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">
<H2><A NAME="tutorial_0001010901000000">DirectPlay Tutorials</A></H2>
<BR CLEAR=ALL>
<P>This section contains four tutorials that provide step-by-step instructions about how to connect an application with or without a lobby, how to override service provider dialog boxes, and how to create a self-refreshing session list.
<P>The first tutorial demonstrates how to connect an application by using a DirectPlay lobby.
<P>The second tutorial demonstrates how to connect an application by using a dialog box that queries the user for connection information. You should write your application so that it can start by using either method. The code is available in the DPCHAT sample in the LOBBY.CPP and DIALOG.CPP files.
<P>The third tutorial demonstrates the calls you need to supply the service provider with all the information it needs so that it doesn't display dialog boxes to the user requesting information.

<P>The fourth tutorial demonstrates how to create a self-refreshing session list.
<UL><LI><A CLASS=tctop HREF="dpbu0009.htm#tutorial_0001010901010000" TARGET="TEXT">Tutorial 1: Connecting by Using the Lobby</A> (DPCHAT)
<LI><A CLASS=tctop HREF="dpbu0009.htm#tutorial_0001010901020000" TARGET="TEXT">Tutorial 2: Connecting by Using a Dialog Box</A> (DPCHAT)
<LI><A CLASS=tctop HREF="dpbu0009.htm#tutorial_0001010901030000" TARGET="TEXT">Tutorial 3: Overriding the Service Provider Dialogs</A>
<LI> <A CLASS=tctop HREF="dpbu0009.htm#tutorial_0001010901040000" TARGET="TEXT">Tutorial 4: Creating Self-Refreshing Session Lists</A>
<P>
</UL>
<P><B>Note</B>  The sample files in these tutorials are written in C++. If you are using a C compiler, you must make the appropriate changes to the files for them to successfully compile. At the very least, you must add the vtables and <B>this</B> pointers to the interface methods. For more information, see <A CLASS=tctop HREF="dpbu0121.htm#external_0001010a0a000001" TARGET="TEXT">Accessing COM</A> in the <I>DirectX Foundation Software Development Kit</I>.
<H3><A NAME="tutorial_0001010901010000">Tutorial 1: Connecting by Using the Lobby</A></H3>
<P>An application written to use the <A CLASS=tctop HREF="dpbu0068.htm#ref_0001010a04000000" TARGET="TEXT">IDirectPlayLobby2 Interface</A> interface can be connected to a session without requiring the user to manually enter connection information in a dialog box. To demonstrate how to create a lobbied application, the DPCHAT sample performs the following steps:

<UL><LI><A CLASS=tctop HREF="dpbu0009.htm#tutorial_0001010901010100" TARGET="TEXT">Step 1: Creating a DirectPlayLobby Object</A>
<LI><A CLASS=tctop HREF="dpbu0009.htm#tutorial_0001010901010200" TARGET="TEXT">Step 2: Retrieving the Connection Settings</A>
<LI><A CLASS=tctop HREF="dpbu0009.htm#tutorial_0001010901010300" TARGET="TEXT">Step 3: Configuring the Session Description</A>
<LI><A CLASS=tctop HREF="dpbu0009.htm#tutorial_0001010901010400" TARGET="TEXT">Step 4: Connecting to a Session</A>
<LI><A CLASS=tctop HREF="dpbu0009.htm#tutorial_0001010901010500" TARGET="TEXT">Step 5: Creating a Player</A>
</UL>
<H4><A NAME="tutorial_0001010901010100">Step 1: Creating a DirectPlayLobby Object</A></H4>
<P>To use a DirectPlay lobby, you first create an instance of a DirectPlayLobby object by calling the <A HREF="dpbu0014.htm#ref_0001010a01000300" TARGET="TEXT">DirectPlayLobbyCreate</A> function. This function contains five parameters. The first, third, and fourth parameters are always set to NULL and are included for future expansion. The second parameter contains the address of a pointer that identifies the location of the DirectPlayLobby object if it is created. The fifth parameter is always set to 0, and is also included for future expansion.

<P>The following example shows one way to create a DirectPlayLobby object:

<PRE><FONT FACE="Courier" SIZE="2">// Get an ANSI DirectPlay lobby interface.
hr = DirectPlayLobbyCreate(NULL, &amp;lpDirectPlayLobbyA, NULL, NULL, 0);
if FAILED(hr)
    goto FAILURE;
</FONT></PRE>
<H4><A NAME="tutorial_0001010901010200">Step 2: Retrieving the Connection Settings</A></H4>
<P>After the DirectPlayLobby object has been created, use the <A HREF="dpbu0075.htm#ref_0001010a04000700" TARGET="TEXT">IDirectPlayLobby2::GetConnectionSettings</A> method to retrieve the connection settings returned from the lobby. If this method returns <A HREF="dpbu0120.htm#ref_0001010a09000029" TARGET="TEXT">DPERR_NOTLOBBIED</A>, the lobby did not start this application, and the user will have to configure the connection manually. If any other error occurs, your application should report an error that indicates that lobbying the application failed.

<P>The following example shows how to retrieve the connection settings:

<PRE><FONT FACE="Courier" SIZE="2">// Retrieve the connection settings from the lobby.
// If this routine returns DPERR_NOTLOBBIED, then a lobby did not
// start this application and the user needs to configure the
// connection.

// Pass a NULL pointer to retrieve only the size of the 
// connection settings
hr = lpDirectPlayLobbyA-&gt;GetConnectionSettings(0, NULL, &amp;dwSize);
if (DPERR_BUFFERTOOSMALL != hr)
    goto FAILURE;

// Allocate memory for the connection settings.
lpConnectionSettings = (LPDPLCONNECTION) GlobalAllocPtr(GHND, dwSize);
    if (NULL == lpConnectionSettings)
    {
        hr = DPERR_OUTOFMEMORY;
        goto FAILURE;
    }

    // Retrieve the connection settings.
    hr = lpDirectPlayLobbyA-&gt;GetConnectionSettings(0,
        lpConnectionSettings, &amp;dwSize);
    if FAILED(hr)
        goto FAILURE;
</FONT></PRE>
<H4><A NAME="tutorial_0001010901010300">Step 3: Configuring the Session Description</A></H4>
<P>You should examine the <A HREF="dpbu0092.htm#ref_0001010a05000b00" TARGET="TEXT">DPSESSIONDESC2</A> structure to ensure that all the flags and properties that your application needs are set properly. If modifications are necessary, store the modified connection settings by using the <A HREF="dpbu0079.htm#ref_0001010a04000b00" TARGET="TEXT">IDirectPlayLobby2::SetConnectionSettings</A> method.

<P>The following example shows how to configure the session description and set the connection settings:

<PRE><FONT FACE="Courier" SIZE="2">// Before the game connects, it should configure the session 
// description with any settings it needs.

// Set the flags and maximum players used by the game.
lpConnectionSettings-&gt;lpSessionDesc-&gt;dwFlags = DPSESSION_MIGRATEHOST | 
    DPSESSION_KEEPALIVE;
lpConnectionSettings-&gt;lpSessionDesc-&gt;dwMaxPlayers = MAXPLAYERS;

// Store the updated connection settings.
hr = lpDirectPlayLobbyA-&gt;SetConnectionSettings(0, 0,
        lpConnectionSettings);
if FAILED(hr)
    goto FAILURE;
</FONT></PRE>
<H4><A NAME="tutorial_0001010901010400">Step 4: Connecting to a Session</A></H4>
<P>After the session description is properly configured, your application can use the <A HREF="dpbu0069.htm#ref_0001010a04000100" TARGET="TEXT">IDirectPlayLobby2::Connect</A> method to start and connect itself to a session. If this method returns DP_OK, you can create one or more players. If it returns <A HREF="dpbu0120.htm#ref_0001010a09000029" TARGET="TEXT">DPERR_NOTLOBBIED</A>, the user will have to manually select a communication medium for your application. (You can identify the service providers installed on the system by using the <A HREF="dpbu0034.htm#ref_0001010a03000b00" TARGET="TEXT">IDirectPlay3::EnumConnections</A> function.) If any other error value is returned, your application should report an error that indicates that lobbying the application failed.

<P>The following example shows how to connect to a session:

<PRE><FONT FACE="Courier" SIZE="2">// Connect to the session. Returns an ANSI IDirectPlay2A interface.
hr = lpDirectPlayLobbyA-&gt;Connect(0, &amp;lpDirectPlay2A, NULL);
if FAILED(hr)
    goto FAILURE;
// Obtain an IDriectPlay3A interface
hr= lpDirectPlay2A-&gt;QueryInterface(IID_IDirectPlay3A, (LPVOID*)&amp;lpDirectPlay3A);
if FAILED(hr)
    goto FAILURE;
</FONT></PRE>
<H4><A NAME="tutorial_0001010901010500">Step 5: Creating a Player</A></H4>
<P>If the application was successfully started by using the <A HREF="dpbu0069.htm#ref_0001010a04000100" TARGET="TEXT">IDirectPlayLobby2::Connect</A> method, it can now create one or more players. It can use the <A HREF="dpbu0029.htm#ref_0001010a03000600" TARGET="TEXT">IDirectPlay3::CreatePlayer</A> method to create a player with the name specified in the <A HREF="dpbu0090.htm#ref_0001010a05000900" TARGET="TEXT">DPNAME</A> structure (which was filled in by the <A HREF="dpbu0075.htm#ref_0001010a04000700" TARGET="TEXT">IDirectPlayLobby2::GetConnectionSettings</A> method).

<P>The following example shows how to create a player:

<PRE><FONT FACE="Courier" SIZE="2">// create a player with the name returned in the connection settings
hr = lpDirectPlay3A-&gt;CreatePlayer(&amp;dpidPlayer,
    lpConnectionSettings-&gt;lpPlayerName, 
    lpDPInfo-&gt;hPlayerEvent, NULL, 0, 0);
if FAILED(hr)
    goto FAILURE;
</FONT></PRE>
<P>Now your application is connected and you are ready to play.

<H3><A NAME="tutorial_0001010901020000">Tutorial 2: Connecting by Using a Dialog Box</A></H3>
<P>If a lobby did not start your application, you should include code that allows the user to manually enter the connection information. To demonstrate how to manually connect to the session and create one or more players, the DPCHAT sample performs the following steps:

<UL><LI><A CLASS=tctop HREF="dpbu0009.htm#tutorial_0001010901020100" TARGET="TEXT">Step 1: Creating the DirectPlay Object</A>
<LI><A CLASS=tctop HREF="dpbu0009.htm#tutorial_0001010901020200" TARGET="TEXT">Step 2: Enumerating and Initializing the Service Providers</A>
<LI><A CLASS=tctop HREF="dpbu0009.htm#tutorial_0001010901020300" TARGET="TEXT">Step 3: Joining a Session</A>
<LI><A CLASS=tctop HREF="dpbu0009.htm#tutorial_0001010901020400" TARGET="TEXT">Step 4: Creating a Session</A>
<LI><A CLASS=tctop HREF="dpbu0009.htm#tutorial_0001010901020500" TARGET="TEXT">Step 5: Creating a Player</A>
</UL>
<H4><A NAME="tutorial_0001010901020100">Step 1: Creating the DirectPlay Object</A></H4>
<P>Before any methods can be called, the application must create an interface to a DirectPlay object. 


<P>The following example shows how the create the <A CLASS=tctop HREF="dpbu0023.htm#ref_0001010a03000000" TARGET="TEXT">IDirectPlay3A</A> interface:

<PRE><FONT FACE="Courier" SIZE="2">HRESULT CreateDirectPlayInterface( LPDIRECTPLAY3A *lplpDirectPlay3A )
{
   HRESULT         hr;
   LPDIRECTPLAY3A  lpDirectPlay3A = NULL;

   // Create an IDirectPlay3 interface
   hr = CoCreateInstance( CLSID_DirectPlay, NULL, CLSCTX_INPROC_SERVER, 
                            IID_IDirectPlay3A, (LPVOID*)&amp;lpDirectPlay3A);

   // Return interface created
   *lplpDirectPlay3A = lpDirectPlay3A;

   return (hr);
}

</FONT></PRE>
<H4><A NAME="tutorial_0001010901020200">Step 2: Enumerating and Initializing the Service Providers</A></H4>
<P>The next step in creating a manual connection is to request that the user select a communication medium for the application. Your application can identify the <A HREF="dpbu0130.htm#dpgloss_0001010b09000002" TARGET="TEXT">service provider</A>s installed on a personal computer by using the <A HREF="dpbu0034.htm#ref_0001010a03000b00" TARGET="TEXT">EnumConnections</A> method.

<P>The following example shows how to enumerate the service providers:

<PRE><FONT FACE="Courier" SIZE="2">lpDirectPlay3A-&gt;EnumConnections(&amp;DPCHAT_GUID, DirectPlayEnumConnectionsCallback, hWnd, 0);
</FONT></PRE>
<P>The second parameter in the <A HREF="dpbu0034.htm#ref_0001010a03000b00" TARGET="TEXT">EnumConnections</A> method is a callback that enumerates service providers registered with DirectPlay. The following example shows one possible way of implementing this callback function:

<PRE><FONT FACE="Courier" SIZE="2">BOOL FAR PASCAL DirectPlayEnumConnectionsCallback(
     LPCGUID lpguidSP, LPVOID lpConnection, DWORD dwConnectionSize,
     LPCDPNAME lpName, DWORD dwFlags, LPVOID lpContext)
{
   HWND     hWnd = (HWND) lpContext;
   LRESULT&#009;iIndex;
   LPVOID   lpConnectionBuffer;

   // Store service provider name in combo box
   iIndex = SendDlgItemMessage(hWnd, IDC_SPCOMBO, CB_ADDSTRING, 0, 
       (LPARAM) lpName-&gt;lpszShortNameA);
   if (iIndex == CB_ERR)
     goto FAILURE;

   // make space for connection 
   lpConnectionBuffer = GlobalAllocPtr(GHND, dwConnectionSize);
   if (lpConnectionBuffer == NULL)
     goto FAILURE;

   // Store pointer to connection  in combo box
   memcpy(lpConnectionBuffer, lpConnection, dwConnectionSize);
   SendDlgItemMessage(hWnd, IDC_SPCOMBO, CB_SETITEMDATA, (WPARAM) iIndex, 
       (LPARAM) lpConnectionBuffer);

FAILURE:
    return (TRUE);
}

</FONT></PRE>
<P>Once the user selects which connection to use, the DirectPlay object must be initialized with the connection buffer associated with it.
<PRE><FONT FACE="Courier" SIZE="2">
hr = lpDirectPlay3A-&gt;InitializeConnection(lpConnection, 0);
</FONT></PRE>
<H4><A NAME="tutorial_0001010901020300">Step 3: Joining a Session</A></H4>
<P>If the user wants to join an existing session, enumerate the available sessions by using the <A HREF="dpbu0039.htm#ref_0001010a03001000" TARGET="TEXT">IDirectPlay3::EnumSessions</A> method, present the choices to the user, and then connect to that session by using the <A HREF="dpbu0056.htm#ref_0001010a03002100" TARGET="TEXT">IDirectPlay3::Open</A> method, specifying the DPOPEN_JOIN flag. The service provider might display a dialog box requesting some information from the user before it can enumerate the sessions.
<P>See <A CLASS=tctop HREF="dpbu0009.htm#tutorial_0001010901040000" TARGET="TEXT">Tutorial 4</A>
for details on the asynchronous <A HREF="dpbu0039.htm#ref_0001010a03001000" TARGET="TEXT">EnumSessions</A> functionality.

<P>The following example shows how to enumerate the available sessions:

<PRE><FONT FACE="Courier" SIZE="2">// Search for this kind of session.
ZeroMemory(&amp;sessionDesc, sizeof(DPSESSIONDESC2));
sessionDesc.dwSize = sizeof(DPSESSIONDESC2);
sessionDesc.guidApplication = DPCHAT_GUID;

hr = lpDirectPlay3A-&gt;EnumSessions(&amp;sessionDesc, 0, EnumSessionsCallback,
    hWnd, DPENUMSESSIONS_AVAILABLE);
if FAILED(hr)
    goto FAILURE;
</FONT></PRE>
<P>In the previous example, the third parameter in the <A HREF="dpbu0039.htm#ref_0001010a03001000" TARGET="TEXT">IDirectPlay3A::EnumSessions</A> method is a callback that enumerates the available sessions. The following example shows one way to implement this callback function:

<PRE><FONT FACE="Courier" SIZE="2">BOOL FAR PASCAL EnumSessionsCallback(
    LPCDPSESSIONDESC2 lpSessionDesc, LPDWORD lpdwTimeOut,
    DWORD dwFlags, LPVOID lpContext)
{
HWND   hWnd = lpContext;
LPGUID lpGuid;
LONG   iIndex;

// Determine if the enumeration has timed out.
if (dwFlags &amp; DPESC_TIMEDOUT)
    return (FALSE);            // Do not try again

// Store the session name in the list.
iIndex = SendDlgItemMessage(hWnd, IDC_SESSIONLIST, LB_ADDSTRING, 
    (WPARAM) 0, (LPARAM) lpSessionDesc-&gt;lpszSessionNameA);
if (iIndex == CB_ERR)
    goto FAILURE;

// Make space for the session instance GUID.
lpGuid = (LPGUID) GlobalAllocPtr(GHND, sizeof(GUID));
if (lpGuid == NULL)
    goto FAILURE;

// Store the pointer to the GUID in the list.
*lpGuid = lpSessionDesc-&gt;guidInstance;
SendDlgItemMessage(hWnd, IDC_SESSIONLIST, LB_SETITEMDATA, 
    (WPARAM) iIndex, (LPARAM) lpGuid);

FAILURE:
    return (TRUE);
}
</FONT></PRE>
<P>After the user has selected a session, your application can allow the user to join an existing session. The following example shows how to join an existing session:

<PRE><FONT FACE="Courier" SIZE="2">// Join an existing session.
ZeroMemory(&amp;sessionDesc, sizeof(DPSESSIONDESC2));
sessionDesc.dwSize = sizeof(DPSESSIONDESC2);
sessionDesc.guidInstance = *lpguidSessionInstance;

hr = lpDirectPlay3A-&gt;Open(&amp;sessionDesc, DPOPEN_JOIN);
if FAILED(hr)
    goto OPEN_FAILURE;
</FONT></PRE>
<H4><A NAME="tutorial_0001010901020400">Step 4: Creating a Session</A></H4>
<P>If the user wants to create a new session, your application can create it by using the <A HREF="dpbu0056.htm#ref_0001010a03002100" TARGET="TEXT">IDirectPlay3::Open</A> method and specifying the DPOPEN_CREATE flag. Again, the service provider might display a dialog box requesting information from the user before it can create the session.

<P>The following example shows how to create a new session:

<PRE><FONT FACE="Courier" SIZE="2">// Host a new session.
ZeroMemory(&amp;sessionDesc, sizeof(DPSESSIONDESC2));
sessionDesc.dwSize = sizeof(DPSESSIONDESC2);
sessionDesc.dwFlags = DPSESSION_MIGRATEHOST | DPSESSION_KEEPALIVE;
sessionDesc.guidApplication = DPCHAT_GUID;
sessionDesc.dwMaxPlayers = MAXPLAYERS;
sessionDesc.lpszSessionNameA = lpszSessionName;

hr = lpDirectPlay3A-&gt;Open(&amp;sessionDesc, DPOPEN_CREATE);
if FAILED(hr)
    goto OPEN_FAILURE;
</FONT></PRE>
<H4><A NAME="tutorial_0001010901020500">Step 5: Creating a Player</A></H4>
<P>After a session has been created or joined, your application can create one or more players by using the <A HREF="dpbu0029.htm#ref_0001010a03000600" TARGET="TEXT">IDirectPlay3::CreatePlayer</A> method. The following example shows one way to create a player:

<PRE><FONT FACE="Courier" SIZE="2">// Fill out the name structure.
ZeroMemory(&amp;dpName, sizeof(DPNAME));
dpName.dwSize = sizeof(DPNAME);
dpName.lpszShortNameA = lpszPlayerName;
dpName.lpszLongNameA = NULL;

// Create a player with this name.
hr = lpDirectPlay3A-&gt;CreatePlayer(&amp;dpidPlayer, &amp;dpName, 
    lpDPInfo-&gt;hPlayerEvent, NULL, 0, 0);
if FAILED(hr)
    goto CREATEPLAYER_FAILURE;
</FONT></PRE>
<P>Your application can determine a player's communication capabilities by using the <A HREF="dpbu0040.htm#ref_0001010a03001100" TARGET="TEXT">IDirectPlay3::GetCaps</A> and <A HREF="dpbu0049.htm#ref_0001010a03001a00" TARGET="TEXT">IDirectPlay3::GetPlayerCaps</A> methods. Your application can find other players by using the <A HREF="dpbu0038.htm#ref_0001010a03000f00" TARGET="TEXT">IDirectPlay3::EnumPlayers</A> method.

<P>Now your application is connected and you are ready to play.


<H3><A NAME="tutorial_0001010901030000">Tutorial 3: Overriding the Service Provider Dialogs</A></H3>
<P>DirectPlay now gives applications the ability to suppress the standard service provider dialogs. Below is a brief outline of how this is done. A code example can be found in the OVERRIDE sample application.



<P>It is generally not possible to suppress all service provider dialogs. The standard TCP/IP, modem, and serial service provider dialogs can be suppressed (IPX has no dialog box). However, there is the possibility that third party service providers might require fairly complex information from the user which cannot be overridden in any general way. The solution is to simply allow these dialog boxes to appear over your application user interface. If the application is a DirectDraw&#174; full-screen application, be sure to turn off page flipping before calling <A HREF="dpbu0039.htm#ref_0001010a03001000" TARGET="TEXT">IDirectPlay3::EnumSessions</A> or <A HREF="dpbu0056.htm#ref_0001010a03002100" TARGET="TEXT">IDirectPlay3::Open</A> to create a session. 
<P>Another way to suppress service provider dialog boxes is to make your application lobby-aware. Most third party service providers will also have a lobby from which to launch games, and games launched from a lobby do not display a connection dialog box.

<P>An application first calls <A HREF="dpbu0034.htm#ref_0001010a03000b00" TARGET="TEXT">IDirectPlay3::EnumConnections</A> to see which connections are available, presents the list to the user, and allows the user to select one. Once the user has selected one, the application can attempt to override the dialog box before calling <A HREF="dpbu0039.htm#ref_0001010a03001000" TARGET="TEXT">IDirectPlay3::EnumSessions</A> or <A HREF="dpbu0056.htm#ref_0001010a03002100" TARGET="TEXT">IDirectPlay3::Open</A>.
<P>These are the steps you should follow to suppress service provider dialog boxes:
<OL><LI>Examine the service provider GUID of the selected service provider to see if it matches one of the known service providers that the application knows how to override. If the service provider GUID is unknown, then skip the remaining steps and be prepared to allow a dialog box to appear.
<LI>Display the appropriate user interface to collect the information needed from the user for that specific service provider. <B>IPX</B> requires no information. <B>TCP/IP</B> requires an IP address for <B>EnumSessions</B> (DPAID_Inet or DPAID_InetW), but requires nothing to create a session using <B>Open</B>. <B>Modem-to-modem</B> requires the user to select a modem (DPAID_Modem or DPAID_ModemW) and also needs a phone number (DPAID_Phone or DPAID_PhoneW) when calling <B>EnumSessions</B>. <B>Serial link</B> needs the <A HREF="dpbu0085.htm#ref_0001010a05000400" TARGET="TEXT">DPCOMPORTADDRESS</A> structure (DPAID_ComPort) filled in to configure the COM port for both <B>EnumSessions</B> and <B>Open</B>.
<LI>Build a DirectPlay Address using the <A HREF="dpbu0071.htm#ref_0001010a04000300" TARGET="TEXT">IDirectPlayLobby2::CreateCompoundAddress</A> method. The address elements that must be passed in are the service provider GUID (DPAID_ServiceProvider) and the individual address components for the selected service provider.
<LI>Initialize the DirectPlay object by calling <A HREF="dpbu0055.htm#ref_0001010a03002000" TARGET="TEXT">InitializeConnection</A> with the DirectPlay Address.
<LI>Call <B>EnumSessions</B> with the DPENUMSESSIONS_RETURNSTATUS flag. This will prevent any status dialog boxes from appearing and, if the connection cannot be made immediately, <B>EnumSessions</B> will return with a DPERR_CONNECTING error. Your application must periodically call <B>EnumSessions</B> until DP_OK is returned (meaning the enumeration was successful) or some other error is returned (meaning it failed).
<LI>If a session is to be created using the <B>Open</B> method with DPOPEN_CREATE, specify the DPOPEN_RETURNSTATUS flag as well. Like DPENUMSESSIONS_RETURNSTATUS, this will suppress status dialog boxes and return DPERR_CONNECTING until the function is complete.
</OL>
<P><B>Note:</B>  In some cases, the application will need to query the service provider at run time to obtain a list of valid choices for a particular DirectPlay Address element. For example, to obtain a list of the modems installed in the system. The application must create a separate DirectPlay object, initialize the modem service provider, and then call <A HREF="dpbu0048.htm#ref_0001010a03001900" TARGET="TEXT">IDirectPlay3::GetPlayerAddress</A> with a DPID of zero to obtain a DirectPlay Address that will contain the list of modems. After releasing the DirectPlay object, the application must parse the address using <A HREF="dpbu0072.htm#ref_0001010a04000400" TARGET="TEXT">IDirectPlayLobby2::EnumAddress</A> and extract the modem list to present to the user.
<H3><A NAME="tutorial_0001010901040000">Tutorial 4: Creating Self-Refreshing Session Lists</A></H3>
<P><A HREF="dpbu0039.htm#ref_0001010a03001000" TARGET="TEXT">IDirectPlay3::EnumSessions</A> can now be called asynchronously. This gives an application the ability to maintain a self-refreshing session list. A code example can be found in the DUEL and DXVIEW sample applications.
<P>The steps you need to follow to create a self-refreshing session list are:
<OL><LI>Call <A HREF="dpbu0039.htm#ref_0001010a03001000" TARGET="TEXT">IDirectPlay3::EnumSessions</A> with the DPENUMSESSIONS_ASYNC flag and a time-out of zero (which will use the service provider default). The method will not enumerate any sessions and will return immediately. However, DirectPlay is enumerating sessions in the background.
<LI>Display the user interface in which all the sessions will appear. Set a timer to go off at whatever interval you want to refresh your session list. The application can find out what the default time-out interval of the enumeration is by calling <A HREF="dpbu0040.htm#ref_0001010a03001100" TARGET="TEXT">IDirectPlay3::GetCaps</A>.
<LI>Each time the timer goes off, call <A HREF="dpbu0039.htm#ref_0001010a03001000" TARGET="TEXT">EnumSessions</A> to obtain the current session list. This is a complete active session list with stale sessions deleted, new sessions added, and existing sessions updated. Delete all the items from the list before calling <B>EnumSessions</B> and add the sessions back to the list in the <A HREF="dpbu0022.htm#ref_0001010a02000700" TARGET="TEXT">EnumSessionsCallback2</A> function.


</OL>
<P><P><FONT FACE="MS SANS SERIF" SIZE="1" COLOR="BLACK">
<A CLASS=cpslug HREF="copyrite.htm" TARGET="TEXT">&#169; 1998 Microsoft Corporation. All rights reserved. Terms of use.</A>
</FONT>
<BR CLEAR=ALL><P>
</FONT><P>
</BODY></HTML>
