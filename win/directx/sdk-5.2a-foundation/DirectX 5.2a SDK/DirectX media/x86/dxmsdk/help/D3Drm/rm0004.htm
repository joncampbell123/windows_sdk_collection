<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<HTML>
<HEAD><TITLE>Direct3D Retained Mode Interface Overviews</TITLE>
<STYLE>
<!--
.tctop {color: blue}
.cpslug {color: blue; text-decoration: none}
-->
</STYLE>
<SCRIPT LANGUAGE="JAVASCRIPT">
//<!--
function ShowButtons() {
    if (window.top.frames.length!=0 && window.top.frames[0].ShowButtons!=null)
	window.top.frames[0].ShowButtons('/rm0003.htm','/rm0000.htm','/rm0000.htm','/index.htm','/rm0005.htm');
}
ShowButtons();
//-->
</SCRIPT>
</HEAD>
<BODY onLoad="ShowButtons()" TOPMARGIN=10 BGPROPERTIES="FIXED" BGCOLOR="#FFFFFF" LINK="#000000" VLINK="#808080" ALINK="#000000">
<FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">
<H2><A NAME="rmfaceov_0001010401000000">Direct3D Retained Mode Interface Overviews</A></H2>
<BR CLEAR=ALL>
<P>This section contains overviews of the Microsoft&#174; Direct3D&#174; Retained Mode interfaces and includes information on what they do, how to use them, and things to be aware of. For a description of each interface's methods, see the appropriate entry in the <A CLASS=tctop HREF="rm0006.htm#rmfuncs_0001010600000001" TARGET="TEXT">Direct3D Retained Mode Reference</A>.
<UL><LI><A CLASS=tctop HREF="rm0004.htm#rmfaceov_0001010401020000" TARGET="TEXT">IDirect3DRMAnimation and IDirect3DRMAnimationSet Interfaces</A>
<LI><A CLASS=tctop HREF="rm0004.htm#rmfaceov_0001010401030000" TARGET="TEXT">IDirect3DRMDevice, IDirect3DRMDevice2, and IDirect3DRMDeviceArray Interfaces</A>
<LI><A CLASS=tctop HREF="rm0004.htm#rmfaceov_0001010401040000" TARGET="TEXT">Direct3DRMFace</A>
<LI><A CLASS=tctop HREF="rm0004.htm#rmfaceov_0001010401050000" TARGET="TEXT">IDirect3DRMFrame, IDirect3DRMFrame2, and IDirect3DRMFrameArray Interfaces</A>
<LI><A CLASS=tctop HREF="rm0004.htm#rmfaceov_0001010401060000" TARGET="TEXT">IDirect3DRMInterpolator Interface</A>
<LI><A CLASS=tctop HREF="rm0004.htm#rmfaceov_0001010401070000" TARGET="TEXT">IDirect3DRMLight and IDirect3DRMLightArray Interfaces</A>
<LI><A CLASS=tctop HREF="rm0004.htm#rmfaceov_0001010401080000" TARGET="TEXT">IDirect3DRMMaterial Interface</A>
<LI><A CLASS=tctop HREF="rm0004.htm#rmfaceov_0001010401090000" TARGET="TEXT">IDirect3DRMMesh, IDirect3DRMMeshBuilder, and IDirect3DRMMeshBuilder2 Interfaces</A>
<LI><A CLASS=tctop HREF="rm0004.htm#rmfaceov_00010104010a0000" TARGET="TEXT">Direct3DRMObject</A>
<LI><A CLASS=tctop HREF="rm0004.htm#rmfaceov_00010104010b0000" TARGET="TEXT">IDirect3DRMPickedArray and IDirect3DRMPicked2Array Interfaces</A>
<LI><A CLASS=tctop HREF="rm0004.htm#rmfaceov_00010104010c0000" TARGET="TEXT">IDirect3DRMProgressiveMesh Interface</A>
<LI><A CLASS=tctop HREF="rm0004.htm#rmfaceov_00010104010d0000" TARGET="TEXT">IDirect3DRMShadow Interface</A>
<LI><A CLASS=tctop HREF="rm0004.htm#rmfaceov_00010104010e0000" TARGET="TEXT">IDirect3DRMTexture and IDirect3DRMTexture2 Interfaces</A>
<LI><A CLASS=tctop HREF="rm0004.htm#rmfaceov_00010104010f0000" TARGET="TEXT">IDirect3DRMUserVisual Interface</A>
<LI><A CLASS=tctop HREF="rm0004.htm#rmfaceov_0001010401100000" TARGET="TEXT">IDirect3DRMViewport and IDirect3DRMViewportArray Interface</A>
<LI><A CLASS=tctop HREF="rm0004.htm#rmfaceov_0001010401110000" TARGET="TEXT">IDirect3DRMVisual and IDirect3DRMVisualArray Interfaces</A>
<LI><A CLASS=tctop HREF="rm0004.htm#rmfaceov_0001010401120000" TARGET="TEXT">IDirect3DRMWrap Interface</A>
</UL>
<H3><A NAME="dx5_IDirect3DRM_and_IDirect3DRM2_Interfaces_d3drm"></A><A NAME="rmfaceov_0001010401010000">IDirect3DRM and IDirect3DRM2 Interfaces</A></H3>
<P>Applications use the methods of the <B>IDirect3DRM</B> interface to create Direct3D Retained Mode objects and to work with system-level variables. For a reference to the methods of this interface, see <A CLASS=tctop HREF="rm0010.htm#rmid3drm_0001010604000000" TARGET="TEXT">IDirect3DRM</A> or <A CLASS=tctop HREF="rm0011.htm#rmid3dr2_0001010605000000" TARGET="TEXT">IDirect3DRM2</A>.

<P>Applications use the methods of the <B>IDirect3DRMDevice</B> and <B>IDirect3DRMDevice2</B> interfaces to interact with the output device. An <B>IDirect3DRMDevice</B> created from the <B>IDirect3DRM</B> interface works with an <B>IDirect3DDevice</B> Immediate Mode device. An <B>IDirect3DRMDevice2</B> created from the <B>IDirect3DRM2</B> interface, or initialized by the <A HREF="rm0015.htm#rmdev2_0001010609001100" TARGET="TEXT">IDirect3DRMDevice2::InitFromClipper</A>, <A HREF="rm0014.htm#rmdevice_0001010608001100" TARGET="TEXT">IDirect3DRMDevice::InitFromD3D</A>, or <A HREF="rm0015.htm#rmdev2_0001010609001300" TARGET="TEXT">IDirect3DRMDevice2::InitFromSurface</A> method, works with an <B>IDirect3DDevice2</B> Immediate Mode device. The <B>IDirect3DDevice2</B> device supports the <B>DrawPrimitive</B> interface, as well as executes buffers, and is required for progressive meshes and for alpha blending and sorting of transparent objects. 

<P><B>IDirect3DRM2</B> supports all the methods in <B>IDirect3DRM</B>. An additional method is included: <A HREF="rm0011.htm#rmid3dr2_0001010605001000" TARGET="TEXT">IDirect3DRM2::CreateProgressiveMesh</A>. The <A HREF="rm0011.htm#rmid3dr2_0001010605000700" TARGET="TEXT">IDirect3DRM2::CreateDeviceFromSurface</A>, <A HREF="rm0011.htm#rmid3dr2_0001010605000600" TARGET="TEXT">IDirect3DRM2::CreateDeviceFromD3D</A>, and <A HREF="rm0011.htm#rmid3dr2_0001010605000500" TARGET="TEXT">IDirect3DRM2::CreateDeviceFromClipper</A> methods all create a DIRECT3DRMDEVICE2 object. The <A HREF="rm0011.htm#rmid3dr2_0001010605001500" TARGET="TEXT">IDirect3DRM2::CreateViewport</A> method creates a viewport on a DIRECT3DRMDEVICE2 object. The <A HREF="rm0011.htm#rmid3dr2_0001010605001c00" TARGET="TEXT">IDirect3DRM2::LoadTexture</A> and <A HREF="rm0011.htm#rmid3dr2_0001010605001d00" TARGET="TEXT">IDirect3DRM2::LoadTextureFromResource</A> methods load a DIRECT3DRMTEXTURE2 object. 
<P>The <A HREF="rm0010.htm#rmid3drm_0001010604000000" TARGET="TEXT">IDirect3DRM</A> Component Object Model (COM) interface is created by calling the <A HREF="rm0007.htm#rmfuncs_0001010601000500" TARGET="TEXT">Direct3DRMCreate</A> function. To access the <A HREF="rm0011.htm#rmid3dr2_0001010605000000" TARGET="TEXT">IDirect3DRM2</A> COM interface, create an <B>IDirect3DRM</B> object with <B>Direct3DRMCreate</B>, then query for <B>IDirect3DRM2</B> from <B>IDirect3DRM</B>. 

<P>The methods of the <B>IDirect3DRM</B> and <B>IDirect3DRM2</B> interfaces create the following objects:
<UL><LI>Animations and animation sets
 <LI>Devices
 <LI>Faces
 <LI>Frames
 <LI>Generic uninitialized objects
 <LI>Lights
 <LI>Materials
 <LI>Meshes and mesh builders
 <LI>Shadows
 <LI>Textures
 <LI>UserVisuals
 <LI>Viewports
 <LI>Wraps
</UL>
<P>In addition, the <A HREF="rm0011.htm#rmid3dr2_0001010605001000" TARGET="TEXT">IDirect3DRM2::CreateProgressiveMesh</A> creates a DIRECT3DRMPROGRESSIVEMESH object. 


<H3><A NAME="dx5_IDirect3DRMAnimation_and_IDirect3DRMAnimationSet_Interfaces_d3drm"></A><A NAME="rmfaceov_0001010401020000">IDirect3DRMAnimation and IDirect3DRMAnimationSet Interfaces</A></H3>
<P>An animation in Retained Mode is defined by a set of <I>keys</I>. A key is a time value associated with a scaling operation, an orientation, or a position. A Direct3DRMAnimation object defines how a transformation is modified according to the time value. The animation can be set to operate on a Direct3DRMFrame object, so it could be used to animate the position, orientation, and scaling of Direct3DRMVisual, Direct3DRMLight, and Direct3DRMViewport objects. 
<P>The <A HREF="rm0012.htm#rmanim_0001010606000100" TARGET="TEXT">IDirect3DRMAnimation::AddPositionKey</A>, <A HREF="rm0012.htm#rmanim_0001010606000200" TARGET="TEXT">IDirect3DRMAnimation::AddRotateKey</A>, and <A HREF="rm0012.htm#rmanim_0001010606000300" TARGET="TEXT">IDirect3DRMAnimation::AddScaleKey</A> methods each specify a time value whose units are arbitrary. If an application adds a position key with a time value of 99, for example, a new position key with a time value of 49 would occur exactly halfway between the (zero-based) beginning of the animation and the first position key. 
<P>The animation is driven by calling the <A HREF="rm0012.htm#rmanim_0001010606000800" TARGET="TEXT">IDirect3DRMAnimation::SetTime</A> method. This sets the visual object's transformation to the interpolated position, orientation, and scale of the nearby keys in the animation. As with the methods that add animation keys, the time value for <B>IDirect3DRMAnimation::SetTime</B> is an arbitrary value, based on the positions of keys the application has already added.
<P>A Direct3DRMAnimationSet object allows Direct3DRMAnimation objects to be grouped together. This allows all the animations in an animation set to share the same time parameter, simplifying the playback of complex articulated animation sequences. An application can add an animation to an animation set by using the <A HREF="rm0013.htm#rmanimst_0001010607000100" TARGET="TEXT">IDirect3DRMAnimationSet::AddAnimation</A> method, and it can remove one by using the <A HREF="rm0013.htm#rmanimst_0001010607000200" TARGET="TEXT">IDirect3DRMAnimationSet::DeleteAnimation</A> method. Animation sets are driven by calling the <A HREF="rm0013.htm#rmanimst_0001010607000400" TARGET="TEXT">IDirect3DRMAnimationSet::SetTime</A> method.
<P>For related information, see the <A CLASS=tctop HREF="rm0012.htm#rmanim_0001010606000000" TARGET="TEXT">IDirect3DRMAnimation</A> and <A CLASS=tctop HREF="rm0013.htm#rmanimst_0001010607000000" TARGET="TEXT">IDirect3DRMAnimationSet</A> interfaces.


<H3><A NAME="dx5_IDirect3DRMDevice_IDirect3DRMDevice2_and_IDirect3DRMDeviceArray_Interfaces_d3drm"></A><A NAME="rmfaceov_0001010401030000">IDirect3DRMDevice, IDirect3DRMDevice2, and IDirect3DRMDeviceArray Interfaces</A></H3>
<P>All forms of rendered output must be associated with an output device. The device object represents the visual display destination for the renderer. 
<P>The renderer's behavior depends on the type of output device that is specified. You can define multiple viewports on a device, allowing different aspects of the scene to be viewed simultaneously. You can also specify any number of devices, allowing multiple destination devices for the same scene.
<P>Retained Mode supports devices that render directly to the screen, to windows, or into application memory.
<P>While an <B>IDirect3DRMDevice</B>
 interface, when created from the <B>IDirect3DRM</B> interface, works with an <B>IDirect3DDevice</B> Immediate Mode device, an <B>IDirect3DRMDevice2</B> interface, when created from the <B>IDirect3DRM2</B> interface or initialized by the <A HREF="rm0015.htm#rmdev2_0001010609001100" TARGET="TEXT">IDirect3DRMDevice2::InitFromClipper</A>, <A HREF="rm0015.htm#rmdev2_0001010609001200" TARGET="TEXT">IDirect3DRMDevice2::InitFromD3D2</A>, or <A HREF="rm0015.htm#rmdev2_0001010609001300" TARGET="TEXT">IDirect3DRMDevice2::InitFromSurface</A> method, works with an <B>IDirect3DDevice2</B> Immediate Mode device. The <B>IDirect3DDevice2</B> device supports the <B>DrawPrimitive</B>
 interface as well as execute buffers, and is required for progressive meshes and for alpha blending and sorting of transparent objects. 
<P>The <A HREF="rm0015.htm#rmdev2_0001010609001100" TARGET="TEXT">IDirect3DRMDevice2::InitFromClipper</A> and <A HREF="rm0015.htm#rmdev2_0001010609001300" TARGET="TEXT">IDirect3DRMDevice2::InitFromSurface</A> methods use the <A HREF="rm0011.htm#rmid3dr2_0001010605000400" TARGET="TEXT">IDirect3DRM2::CreateDevice</A> method to create an <A HREF="rm0015.htm#rmdev2_0001010609000000" TARGET="TEXT">IDirect3DRMDevice2</A> object. The <A HREF="rm0015.htm#rmdev2_0001010609001200" TARGET="TEXT">IDirect3DRMDevice2::InitFromD3D2</A> method uses an <B>IDirect3D2</B> Immediate Mode object and an <B>IDirect3DDevice2</B> Immediate Mode device to initialize an <B>IDirect3DDevice2</B> Retained Mode device. 
<P>You can still query back and forth between the <A HREF="rm0014.htm#rmdevice_0001010608000000" TARGET="TEXT">IDirect3DRMDevice</A> and <A HREF="rm0015.htm#rmdev2_0001010609000000" TARGET="TEXT">IDirect3DRMDevice2</A> interfaces. The main difference is in how the underlying Immediate Mode device is created. 
<P>The <A HREF="rm0015.htm#rmdev2_0001010609000000" TARGET="TEXT">IDirect3DRMDevice2</A> interface contains all the methods found in the <A HREF="rm0014.htm#rmdevice_0001010608000000" TARGET="TEXT">IDirect3DRMDevice</A> interface, plus two additional ones that allow you to control transparency&#151;<A HREF="rm0015.htm#rmdev2_0001010609000900" TARGET="TEXT">IDirect3DRMDevice2::GetRenderMode</A> and <A HREF="rm0015.htm#rmdev2_0001010609001700" TARGET="TEXT">IDirect3DRMDevice2::SetRenderMode</A>&#151;and one additional initialization method: <A HREF="rm0015.htm#rmdev2_0001010609001300" TARGET="TEXT">IDirect3DRMDevice2::InitFromSurface</A>.
 
<P>For related information, see <A CLASS=tctop HREF="rm0014.htm#rmdevice_0001010608000000" TARGET="TEXT">IDirect3DRMDevice</A> and <A CLASS=tctop HREF="rm0015.htm#rmdev2_0001010609000000" TARGET="TEXT">IDirect3DRMDevice2</A>.
<P>This section describes the options available to display Direct3D images to output devices.
<UL><LI><A CLASS=tctop HREF="rm0004.htm#rmfaceov_0001010401030100" TARGET="TEXT">Quality</A>
<LI><A CLASS=tctop HREF="rm0004.htm#rmfaceov_0001010401030200" TARGET="TEXT">Color Models</A>
<LI><A CLASS=tctop HREF="rm0004.htm#rmfaceov_0001010401030300" TARGET="TEXT">Window Management</A>
</UL>
<H4><A NAME="rmfaceov_0001010401030100">Quality</A></H4>
<P>The device
 allows the scene and its component parts to be rendered with various degrees of realism. The device rendering quality is the maximum quality at which rendering can take place on the rendering surface of that device. Mesh, progressive mesh, and mesh builder objects can also have a specified rendering quality.
<P>A device's or object's quality has three components: shade mode (flat or Gouraud; Phong is not yet implemented and will default to Gouraud shading), lighting type (on or off), and fill mode (point, wireframe or solid).

<P>You can set the quality of a device with <A HREF="rm0014.htm#rmdevice_0001010608001400" TARGET="TEXT">IDirect3DRMDevice::SetQuality</A> and <A HREF="rm0015.htm#rmdev2_0001010609001600" TARGET="TEXT">IDirect3DRMDevice2::SetQuality</A> methods. By default, the device quality is D3DRMRENDER_FLAT (flat shading, lights on, and solid fill). 

<P>You can set the quality of a Direct3DRMProgressiveMesh, Direct3DRMMeshBuilder, or Direct3DRMMeshBuilder2 object with their respective <B>SetQuality</B> methods: <A HREF="rm0026.htm#rmpmesh_0001010614001200" TARGET="TEXT">IDirect3DRMProgressiveMesh::SetQuality</A>, <A HREF="rm0023.htm#rmmshbld_0001010611001f00" TARGET="TEXT">IDirect3DRMMeshBuilder::SetQuality</A>, and <A HREF="rm0024.htm#rmmshbl2_0001010612002000" TARGET="TEXT">IDirect3DRMMeshBuilder2::SetQuality</A>. By default, the quality of these objects is D3DRMRENDER_GOURAUD (Gouraud shading, lights on, and solid fill).

<P>Direct3D Retained Mode renders an object at the lowest quality setting based on the device and object's current setting for each individual component. For example, 
if the object's current quality setting is D3DRMRENDER_GOURAUD, and the device is D3DRMRENDER_FLAT then the object will be rendered with flat shading, solid fill, and lights on. 
<P>If the object's current quality setting is D3DRMSHADE_GOURAUD|D3DRMLIGHT_OFF|D3DRMFILL_WIREFRAME and the device's quality setting is D3DRMSHADE_FLAT|D3DRMLIGHT_ON|D3DRMFILL_POINT, then the object will be rendered with flat shading, lights off, and point fill mode.

<P>These rules apply to Direct3DRMMeshBuilder objects, Direct3DRMMeshBuilder2 objects, and Direct3DRMProgressiveMesh objects. However, Direct3DRMMesh objects do not follow these rules. Mesh objects ignore the device's quality settings and use the group quality setting (which defaults to D3DRMRENDER_GOURAUD).



<H4><A NAME="rmfaceov_0001010401030200">Color Models</A></H4>
<P>Retained Mode supports two color models: an RGB model and a monochromatic (or ramp) model. To retrieve the color model, an application can use the <A HREF="rm0014.htm#rmdevice_0001010608000400" TARGET="TEXT">IDirect3DRMDevice::GetColorModel</A> method.

<P>The RGB model treats color as a combination of red, green, and blue light, and it supports multiple light sources that can be colored. There is no limit to the number of colors in the scene. You can use this model with 8-, 16-, 24-, and 32-bit displays. If the display depth is less than 24 bits, the limited color resolution can produce banding artifacts. You can avoid these artifacts by using optional dithering.

<P>The monochromatic model also supports multiple light sources, but their color content is ignored. Each source is set to a gray intensity. RGB colors at a vertex are interpreted as brightness levels, which (in Gouraud shading) are interpolated across a face between vertices with different brightnesses. The number of differently colored objects in the scene is limited; after all the system's free palette entries are used up, the system's internal palette manager finds colors that already exist in the palette and that most closely match the intended colors. Like the RGB model, you can use this model with 8-, 16-, 24-, and 32-bit displays. (The monochromatic model supports only 8-bit textures, however.) The advantage of the monochromatic model over the RGB model is simply
 performance.
<P>It is not possible to change the color model of a Direct3D device. Your application should use the <A HREF="rm0038.htm#external_000101062000001a" TARGET="TEXT">IDirect3D::EnumDevices</A> or <A HREF="rm0038.htm#external_000101062000001b" TARGET="TEXT">IDirect3D::FindDevice</A> method to identify a driver that supports the required color model, then specify this driver in one of the device-creation methods.
<P>Palettes are supported for textures, off-screen surfaces, and overlay surfaces, none of which is required to have the same palette as the primary surface. If a device supports a 4-bit indexed palette (16 colors) and you have 8-bit indexed art (256 colors), Retained Mode will render the art as 4-bit by taking the first 16 entries from your palette and remapping to those. Therefore, you should put your 16 preferred colors at the front of the palette if possible.




<H4><A NAME="rmfaceov_0001010401030300">Window Management</A></H4>
<P>For correct operation, applications must inform Direct3D when the WM_MOVE, WM_PAINT, and WM_ACTIVATE messages are received from the operating system by using the <A HREF="rm0032.htm#rmwindev_000101061a000200" TARGET="TEXT">IDirect3DRMWinDevice::HandlePaint</A> and <A HREF="rm0032.htm#rmwindev_000101061a000100" TARGET="TEXT">IDirect3DRMWinDevice::HandleActivate</A> methods.
<P>For related information, see <A CLASS=tctop HREF="rm0032.htm#rmwindev_000101061a000000" TARGET="TEXT">IDirect3DRMWinDevice</A>.


<H3><A NAME="dx5_IDirect3DRMFace_and_IDirect3DRMFaceArray_Interfaces_d3drm"></A><A NAME="rmfaceov_0001010401040000">IDirect3DRMFace and IDirect3DRMFaceArray Interfaces</A></H3>
<P>A face represents a single polygon in a mesh. An application can set the color, texture, and material of the face by using the <A HREF="rm0016.htm#rmface_000101060a000e00" TARGET="TEXT">IDirect3DRMFace::SetColor</A>, <A HREF="rm0016.htm#rmface_000101060a000f00" TARGET="TEXT">IDirect3DRMFace::SetColorRGB</A>, <A HREF="rm0016.htm#rmface_000101060a001100" TARGET="TEXT">IDirect3DRMFace::SetTexture</A>, and <A HREF="rm0016.htm#rmface_000101060a001000" TARGET="TEXT">IDirect3DRMFace::SetMaterial</A> methods.

<P>Faces are constructed from vertices by using the <A HREF="rm0016.htm#rmface_000101060a000100" TARGET="TEXT">IDirect3DRMFace::AddVertex</A> and <A HREF="rm0016.htm#rmface_000101060a000200" TARGET="TEXT">IDirect3DRMFace::AddVertexAndNormalIndexed</A> methods. An application can read the vertices of a face by using the <A HREF="rm0016.htm#rmface_000101060a000d00" TARGET="TEXT">IDirect3DRMFace::GetVertices</A> and <A HREF="rm0016.htm#rmface_000101060a000a00" TARGET="TEXT">IDirect3DRMFace::GetVertex</A> methods.
<P>For related information, see <A CLASS=tctop HREF="rm0016.htm#rmface_000101060a000000" TARGET="TEXT">IDirect3DRMFace</A>.


<H3><A NAME="dx5_IDirect3DRMFrame_IDirect3DRMFrame2_and_IDirect3DRMFrameArray_Interfaces_d3drm"></A><A NAME="rmfaceov_0001010401050000">IDirect3DRMFrame, IDirect3DRMFrame2, and IDirect3DRMFrameArray Interfaces</A></H3>
<P>The term <I>frame</I> is derived from an object's physical frame of reference. The frame's role in Retained Mode is similar to a window's role in a windowing system. Objects can be placed in a scene by stating their spatial relationship to a relevant reference frame; they are not simply placed in world space. A frame is used to position objects in a scene, and visuals take their positions and orientation from frames. 
<P>A <I>scene</I> in Retained Mode is defined by a frame that has no parent frame; that is, a frame at the top of the hierarchy of frames. This frame is also sometimes called a <I>root frame</I> or <I>master frame</I>. The scene defines the frame of reference for all of the other objects. You can create a scene by calling the <A HREF="rm0010.htm#rmid3drm_0001010604000900" TARGET="TEXT">IDirect3DRM::CreateFrame</A> method and specifying NULL for the first parameter.
<P>The <A HREF="rm0018.htm#rmframe2_000101060c000000" TARGET="TEXT">IDirect3DRMFrame2</A> interface is an extension of the <A HREF="rm0017.htm#rmframe_000101060b000000" TARGET="TEXT">IDirect3DRMFrame</A> interface. <B>IDirect3DRMFrame2</B> has methods that enable using materials, bounding boxes, and axes with frames. <B>IDirect3DRMFrame2</B> also supports ray picking. 
<P>By using the <A HREF="rm0018.htm#rmframe2_000101060c002f00" TARGET="TEXT">IDirect3DRMFrame2::SetAxes</A> method and using the right-handed projection types in the <A HREF="rm0035.htm#rmtypes_000101061d000a00" TARGET="TEXT">D3DRMPROJECTIONTYPE</A> structure with the <A HREF="rm0031.htm#rmviewpt_0001010619001a00" TARGET="TEXT">IDirect3DRMViewport::SetProjection</A> method, you can enable right-handed projection. 

<P>For related information, see <A CLASS=tctop HREF="rm0017.htm#rmframe_000101060b000000" TARGET="TEXT">IDirect3DRMFrame</A> and <A CLASS=tctop HREF="rm0018.htm#rmframe2_000101060c000000" TARGET="TEXT">IDirect3DRMFrame2</A>.
<P>This section describes frames and how your application can use them.
<UL><LI><A CLASS=tctop HREF="rm0004.htm#rmfaceov_0001010401050100" TARGET="TEXT">Hierarchies</A>
<LI><A CLASS=tctop HREF="rm0004.htm#rmfaceov_0001010401050200" TARGET="TEXT">Transformations</A>
<LI><A CLASS=tctop HREF="rm0004.htm#rmfaceov_0001010401050300" TARGET="TEXT">Motion</A>
<LI><A CLASS=tctop HREF="rm0004.htm#rmfaceov_0001010401050400" TARGET="TEXT">Callback Functions</A>
</UL>
<H4><A NAME="rmfaceov_0001010401050100">Hierarchies</A></H4>
<P>The frames in a scene are arranged in a tree structure. Frames can have a parent frame and child frames. Remember, a frame that has no parent frame defines a scene and is called a <I>root frame</I>. 

<P>Child frames have positions and orientations relative to their parent frames. If the parent frame moves, the child frames also move.

<P>An application can set the position and orientation of a frame relative to any other frame in the scene, including the root frame if it needs to set an absolute position. 

You can also remove frames from one parent frame and add them to another at any time by using the <A HREF="rm0017.htm#rmframe_000101060b000100" TARGET="TEXT">IDirect3DRMFrame::AddChild</A> method. To remove a child frame entirely, use the <A HREF="rm0017.htm#rmframe_000101060b000900" TARGET="TEXT">IDirect3DRMFrame::DeleteChild</A> method. To retrieve a frame's child and parent frames, use the <A HREF="rm0017.htm#rmframe_000101060b000d00" TARGET="TEXT">IDirect3DRMFrame::GetChildren</A> and <A HREF="rm0017.htm#rmframe_000101060b001200" TARGET="TEXT">IDirect3DRMFrame::GetParent</A> methods. 

<P>You can add frames as visuals to other frames, allowing you to use a given hierarchy many times throughout a scene. The new hierarchies are referred to as <I>instances</I>. Be careful to avoid instancing a parent frame into its children because that will degrade performance. Retained Mode does no run-time checking for cyclic hierarchies. You cannot create a cyclic hierarchy by using the methods of the <A CLASS=tctop HREF="rm0017.htm#rmframe_000101060b000000" TARGET="TEXT">IDirect3DRMFrame</A> interface; instead, this is possible only when you add a frame as a visual.


<H4><A NAME="rmfaceov_0001010401050200">Transformations</A></H4>
<P>You can think of the position and orientation of a frame relative to its parent frame as a linear transformation. This transformation takes vectors defined relative to the child frame and changes them to equivalent vectors defined relative to the parent. 
<P>Transformations can be represented by 4&#215;4 matrices, and coordinates can be represented by four-element row vectors, [<I>x, y, z,</I>1].
<P>If <I>v</I><SUB>child</SUB> is a coordinate in the child frame, then <I>v</I><SUB>parent</SUB>, the equivalent coordinate in the parent frame, is defined as:

<P><IMG SRC="art/parenteq.gif" WIDTH="150" HEIGHT="24" ALT="Definition of the parent frame">

<P> <I>T</I><SUB>child</SUB> is the child frame's transformation matrix.

<P>The transformations of all the parent frames above a child frame up to the <A HREF="rm0055.htm#3Dgloss_000101080b000002" TARGET="TEXT">root frame</A> are concatenated with the transformation of that child to produce a world transformation. This world transformation is then applied to the visuals on the child frame before rendering. Coordinates relative to the child frame are sometimes called <I>model coordinates</I>. After the world transformation is applied, coordinates are called <I>world coordinates</I>.

<P>The transformation of a frame can be modified directly by using the <A HREF="rm0017.htm#rmframe_000101060b000600" TARGET="TEXT">IDirect3DRMFrame::AddTransform</A>, <A HREF="rm0017.htm#rmframe_000101060b000500" TARGET="TEXT">IDirect3DRMFrame::AddScale</A>, <A HREF="rm0017.htm#rmframe_000101060b000400" TARGET="TEXT">IDirect3DRMFrame::AddRotation</A>, and <A HREF="rm0017.htm#rmframe_000101060b000700" TARGET="TEXT">IDirect3DRMFrame::AddTranslation</A> methods. Each of these methods specifies a member of the <A HREF="rm0035.htm#rmtypes_000101061d000200" TARGET="TEXT">D3DRMCOMBINETYPE</A> enumerated type, which specifies how the matrix supplied by the application should be combined with the current frame's matrix.

<P>The <A HREF="rm0017.htm#rmframe_000101060b001400" TARGET="TEXT">IDirect3DRMFrame::GetRotation</A> and <A HREF="rm0017.htm#rmframe_000101060b001f00" TARGET="TEXT">IDirect3DRMFrame::GetTransform</A> methods allow you to retrieve a frame's rotation axis and transformation matrix. To change the rotation of a frame, use the <A HREF="rm0017.htm#rmframe_000101060b002c00" TARGET="TEXT">IDirect3DRMFrame::SetRotation</A> method.

<P>Use the <A HREF="rm0017.htm#rmframe_000101060b003a00" TARGET="TEXT">IDirect3DRMFrame::Transform</A> and <A HREF="rm0017.htm#rmframe_000101060b002300" TARGET="TEXT">IDirect3DRMFrame::InverseTransform</A> methods to change between world coordinates and model coordinates.

<P>You can find a more general discussion of transformations in the section devoted to viewports, <A CLASS=tctop HREF="rm0004.htm#rmfaceov_0001010401100300" TARGET="TEXT">Transformations</A>. For an overview of the mathematics of transformations, see <A CLASS=tctop HREF="rm0002.htm#rmmath_0001010201020000" TARGET="TEXT">3-D Transformations</A>.

<H4><A NAME="rmfaceov_0001010401050300">Motion</A></H4>
<P>Every frame has an intrinsic rotation and velocity. Frames that are neither rotating nor translating simply have zero values for these attributes. These attributes are used before each scene is rendered to move objects in the scene, and they can also be used to create simple animations.



<H4><A NAME="rmfaceov_0001010401050400">Callback Functions</A></H4>
<P>Frames support a callback function that you can use to support more complex animations. The application registers a function that the frame calls before the motion attributes are applied. When there are multiple frames in a hierarchy, each with associated callback functions, the parent frames are called before the child frames. For a given hierarchy, rendering does not take place until all of the required callback functions have been invoked.
<P>To add this callback function, use the <A HREF="rm0017.htm#rmframe_000101060b000300" TARGET="TEXT">IDirect3DRMFrame::AddMoveCallback</A> method; to remove it, use the <A HREF="rm0017.htm#rmframe_000101060b000b00" TARGET="TEXT">IDirect3DRMFrame::DeleteMoveCallback</A> method.
<P>You can use these callback functions to provide new positions and orientations from a preprogrammed animation sequence or to implement dynamic motion in which the activities of visuals depend upon the positions of other objects in the scene.


<H3><A NAME="dx5_IDirect3DRMInterpolator_Interface_d3drm"></A><A NAME="rmfaceov_0001010401060000">IDirect3DRMInterpolator Interface</A></H3>
<P>Interpolators provide a way of storing actions and applying them to objects with automatic calculation of in-between values. For example, you can set a scene's background color to red at time zero and green at time ten, and the interpolator will automatically tint successive scenes to blend from red to green. With an interpolator, you can blend colors, move objects smoothly between positions, morph meshes, and perform many other transformations.

<P>In the Direct3D Retained Mode implementation, interpolators are a generalization of the <A HREF="rm0012.htm#rmanim_0001010606000000" TARGET="TEXT">IDirect3DRMAnimation</A> interface that increases the kinds of object parameters you can animate. While the <B>IDirect3DRMAnimation</B> interface allows animation of an object's position, size and orientation, the <A HREF="rm0019.htm#rminterp_000101060d000000" TARGET="TEXT">IDirect3DRMInterpolator</A> interface further enables animation of colors, meshes, textures, and materials. 

<H4><A NAME="rmfaceov_0001010401060100">Interpolator Keys</A></H4>
<P>The actions stored by the interpolator are called keys. A key is a stored procedure call and has an index associated with it. The interpolator automatically calculates between the key values.

<P>Keys are stored in the interpolator by calling one of the supported interface methods that can be interpolated. The method and the parameter values passed to it make up the key. <A CLASS=tctop HREF="rm0004.htm#rmfaceov_0001010401060400" TARGET="TEXT">Methods Supported by the Interpolator</A> supplies a list of supported methods.

<P>Every key stored inside an interpolator has an index value. When the key is recorded, it is stamped with the current interpolator index value. The key's index value never changes once this value is set.


<H4><A NAME="rmfaceov_0001010401060200">Interpolator Types</A></H4>
<P>Objects can be attached to interpolators of an associated type; for example, a Mesh can be attached to a MeshInterpolator. The interpolator types are:
<UL><LI>FrameInterpolator
 <LI>LightInterpolator 
 <LI>MaterialInterpolator 
 <LI>MeshInterpolator 
 <LI>TextureInterpolator 
 <LI>ViewportInterpolator 
</UL>
<P>Other interpolators can also be attached to an interpolator. When you change the index of an interpolator, it sets the indices of any attached interpolators to the same value.

<P>Note that for MeshInterpolators, you add a <B>SetVertices</B> key to a MeshInterpolator object by calling <B>SetVertices</B> on the MeshInterpolator object's <A HREF="rm0022.htm#rmmesh_0001010610000000" TARGET="TEXT">IDirect3DRMMesh</A> interface.
The group index used with <B>SetVertices</B> must correspond to a valid group index in the Mesh object or objects that the interpolator is applied to. 


<H4><A NAME="rmfaceov_0001010401060300">Interpolator Example</A></H4>
<P>As an example, if you want to interpolate a frame's position, you will need a FrameInterpolator object with two interfaces, <A HREF="rm0019.htm#rminterp_000101060d000000" TARGET="TEXT">IDirect3DRMInterpolator</A> and <A HREF="rm0017.htm#rmframe_000101060b000000" TARGET="TEXT">IDirect3DRMFrame</A>.
<PRE><FONT FACE="Courier" SIZE="2">
pd3drm-&gt;CreateObject(CLSID_CDirect3DRMFrameInterpolator, 0, IID_IDirect3DRMInterpolator, &amp;pInterp);
pInterp-&gt;QueryInterface(IID_IDirect3DRMFrame, &amp;pFrameInterp);
</FONT></PRE>
<P>To add a position key to the interpolator, set the interpolator's internal index through the <A HREF="rm0019.htm#rminterp_000101060d000000" TARGET="TEXT">IDirect3DRMInterpolator</A> interface, and record the position by calling the <A HREF="rm0017.htm#rmframe_000101060b002b00" TARGET="TEXT">IDirect3DRMFrame::SetPosition</A> method on the <A HREF="rm0017.htm#rmframe_000101060b000000" TARGET="TEXT">IDirect3DRMFrame</A> interface. This method is applied to the interpolator rather than to a real frame. The function call and its parameters are stored in the interpolator as a new key with the current index.
<PRE><FONT FACE="Courier" SIZE="2">
pInterp-&gt;SetIndex(keytime);
pFrameInterp-&gt;SetPosition(NULL, keypos.x, keypos.y, keypos.z);
</FONT></PRE>
<P>You can add more keys by repeating the sequence of setting the index with <B>SetIndex</B> followed by one or more object methods. To play actions back through a real frame, attach the frame to the interpolator.
<PRE><FONT FACE="Courier" SIZE="2">
pInterp-&gt;AttachObject(pRealFrame);
</FONT></PRE>
<P>Now call <B>Interpolate</B> to set the position of the <I>pRealFrame</I> parameter using the interpolated position.
<PRE><FONT FACE="Courier" SIZE="2">
pInterp-&gt;Interpolate(time, NULL, D3DRMINTERPOLATIONSPLINE | D3DRMINTERPOLATION_OPEN);
</FONT></PRE>
<P>The interpolator will call the attached frame's <B>SetPosition</B> method, passing it a position it has calculated by interpolating (in this case, using a B-spline) between the nearest <B>SetPosition</B> keys.

<P>Alternatively, you can use the immediate form of <B>Interpolate</B> and pass the object as the second parameter. This overrides any attached objects.
<PRE><FONT FACE="Courier" SIZE="2">
pInterp-&gt;Interpolate(time, pRealFrame, D3DRMINTERPOLATIONSPLINE | D3DRMINTERPOLATION_OPEN);
</FONT></PRE>
<P>You can use the same interpolator to store other keys such as orientation, scale, velocity, and color keys. Each property exists on a parallel timeline, and calling <B>Interpolate</B> assigns the interpolated value for each property to the attached frames.

<P>It is possible to interpolate more than one method. For example, you can store <B>SetGroupColor</B> and <B>SetVertices</B> keys in the same interpolator. It is not possible to interpolate between keys of different methods, so they are stored in parallel execution threads called Key Chains. Also, if you specify two keys from different groups, such as <B>SetGroupColor</B>(0, black) and <B>SetGroupColor</B>(2, white), it does not make sense for the interpolator to generate an in-between action of <B>SetGroupColor</B>(1, gray) because the keys apply to different groups. In this case, the keys are also stored in separate chains.


<H4><A NAME="rmfaceov_0001010401060400">Methods Supported by the Interpolator</A></H4>
<P><B>Viewport</B> 
<DL>
<DT>SetFront(value)
 </DT><DT>SetBack(value)
 </DT><DT>SetField(value)
 </DT><DT>SetPlane(left, right, bottom, top)
</DT></DL>
<P><B>Frame and Frame2</B> 
<DL>
<DT>SetPosition(reference*, x, y, z)
 </DT><DT>SetRotation(reference*, x, y, z, theta)
 </DT><DT>SetVelocity(reference*, x, y, z, withRotation*)
 </DT><DT>SetOrientation(reference*, dx, dy, dz, ux, uy, uz)
 </DT><DT>SetColor(color)
 </DT><DT>SetColorRGB(red, green, blue)
 </DT><DT>SetSceneBackground(color)
 </DT><DT>SetSceneBackgroundRGB(red, green, blue)
 </DT><DT>SetSceneFogColor(color)
 </DT><DT>SetSceneFogParams(start, end, density)
 </DT><DT>SetQuaternion(reference*, quat)
</DT></DL>
<P><B>Mesh</B>
<DL>
<DT>Translate(x, y, z)
 </DT><DT>SetVertices(group*, index*, count*, vertices)
 </DT><DT>SetGroupColor(group*, color)
 </DT><DT>SetGroupColorRGB(group*, red, green, blue)
</DT></DL>
<P><B>Light</B>
<DL>
<DT>SetColor(color)
 </DT><DT>SetColorRGB(red, green, blue)
 </DT><DT>SetRange(value) 
 </DT><DT>SetUmbra(value)
 </DT><DT>SetPenumbra(value)
 </DT><DT>SetConstantAttenuation(value)
 </DT><DT>SetLinearAttenuation(value)
 </DT><DT>SetQuadraticAttenuation(value)
</DT></DL>
<P><B>Texture and Texture2</B>
<DL>
<DT>SetDecalSize(width, height)
 </DT><DT>SetDecalOrigin(x, y)
 </DT><DT>SetDecalTransparentColor(color)
</DT></DL>
<P><B>Material</B>
<DL>
<DT>SetPower(value)
 </DT><DT>SetSpecular(red, green, blue)
 </DT><DT>SetEmissive(red, green, blue)
</DT></DL>
<P>*&#151;Indicates keys with different values for this parameter are inserted in separate chains

<P>An attempt to set a key of any unsupported method will result in a non-fatal D3DRMERR_BADOBJECT error.


<H4><A NAME="rmfaceov_0001010401060500">Interpolator Index Span</A></H4>
<P>The interpolator covers a span of index values. This index span is dictated by the following rules:
<UL><LI>The start of the span is the minimum of all key index values and the current index.
<LI>The end of the span is the maximum of all key index values and the current index.
</UL>
<H4><A NAME="rmfaceov_0001010401060600">Interpolation Options</A></H4>
<P>Interpolation can be performed with one or more of the following options: 

<UL><LI> D3DRMINTERPOLATION_CLOSED 
<LI> D3DRMINTERPOLATION_LINEAR 
<LI> D3DRMINTERPOLATION_NEAREST 
<LI> D3DRMINTERPOLATION_OPEN 
<LI> D3DRMINTERPOLATION_SLERPNORMALS 
<LI> D3DRMINTERPOLATION_SPLINE
<LI> D3DRMINTERPOLATION_VERTEXCOLOR 
</UL>
<P>If the interpolator is executed CLOSED, the interpolation is cyclic. The keys effectively repeat infinitely with a period equal to the index span. For compatibility with animations, any key with an index equal to the end of the span is ignored.

<P>If the interpolation is OPEN, the first and last keys of each key chain fix the interpolated values outside of the index span.

<P>The NEAREST, LINEAR, and SPLINE options specify how in-betweening is performed on each key chain. If NEAREST is specified the nearest key value is used. LINEAR performs linear interpolation between the 2 nearest keys. SPLINE uses a B-spline blending function on the 4 nearest keys.

<P>The following two options affect only the interpolation of <A HREF="rm0022.htm#rmmesh_0001010610001200" TARGET="TEXT">IDirect3DRMMesh::SetVertices</A>:
<UL><LI>VERTEXCOLOR specifies that vertex colors should be interpolated.
<LI>SLERPNORMALS specifies that vertex normals should be spherically interpolated (not currently implemented).
</UL>
<H3><A NAME="dx5_IDirect3DRMLight_and_IDirect3DRMLightArray_Interfaces_d3drm"></A><A NAME="rmfaceov_0001010401070000">IDirect3DRMLight and IDirect3DRMLightArray Interfaces</A></H3>
<P>Lighting effects are employed to increase the visual fidelity of a scene. The system colors each object based on the object's orientation to the light sources in the scene. The contribution of each light source is combined to determine the color of the object during rendering. All lights have color and intensity that can be varied independently.
<P>An application can attach lights to a frame to represent a light source in a scene. When a light is attached to a frame, it illuminates visual objects in the scene. The frame provides both position and orientation for the light. In other words, the light originates from the origin of the frame it is attached to. An application can move and redirect a light source simply by moving and reorienting the frame the light source is attached to.
<P>Each viewport owns one or more lights. No light can be owned by more than one viewport. 
<P>Retained Mode currently provides five types of light sources: ambient, directional, parallel point, point, and spotlight.
<P>For a reference to the methods of the <B>IDirect3DRMLight</B> interface, see <A CLASS=tctop HREF="rm0020.htm#rmlight_000101060e000000" TARGET="TEXT">IDirect3DRMLight</A>.
<P>This section describes lighting effects available in Direct3D and how your application can use them. 
<UL><LI><A CLASS=tctop HREF="rm0004.htm#rmfaceov_0001010401070100" TARGET="TEXT">Ambient</A>
<LI><A CLASS=tctop HREF="rm0004.htm#rmfaceov_0001010401070200" TARGET="TEXT">Directional</A>
<LI><A CLASS=tctop HREF="rm0004.htm#rmfaceov_0001010401070300" TARGET="TEXT">Parallel Point</A>
<LI><A CLASS=tctop HREF="rm0004.htm#rmfaceov_0001010401070400" TARGET="TEXT">Point</A>
<LI><A CLASS=tctop HREF="rm0004.htm#rmfaceov_0001010401070500" TARGET="TEXT">Spotlight</A>
</UL>
<H4><A NAME="rmfaceov_0001010401070100">Ambient</A></H4>
<P>An <I>ambient</I> light source illuminates everything in the scene, regardless of the orientation, position, and surface characteristics of the objects in the scene. Because ambient light illuminates a scene with equal strength everywhere, the position and orientation of the frame it is attached to are inconsequential. Multiple ambient light sources are combined within a scene.


<H4><A NAME="rmfaceov_0001010401070200">Directional</A></H4>
<P>A <I>directional</I> light source has orientation but no position. The light is attached to a frame but appears to illuminate all objects with equal intensity, as if it were at an infinite distance from the objects. The directional source is commonly used to simulate distant light sources, such as the sun. It is the best choice of light to use for maximum rendering speed. 


<H4><A NAME="rmfaceov_0001010401070300">Parallel Point</A></H4>
<P>A <I>parallel point</I> light source illuminates objects with parallel light, but the orientation of the light is taken from the position of the parallel point light source. That is, like a directional light source, a parallel point light source has orientation, but it also has position. For example, two meshes on either side of a parallel point light source are lit on the side that faces the position of the source. The parallel point light source offers similar rendering-speed performance to the directional light source.

<H4><A NAME="rmfaceov_0001010401070400">Point</A></H4>
<P>A <I>point</I> light source radiates light equally in all directions from its origin. It requires the calculation of a new lighting vector for every facet or normal it illuminates, and for this reason it is computationally more expensive than a parallel point light source. It does, however, produce a more faithful lighting effect and should be chosen where visual fidelity is the deciding concern.


<H4><A NAME="rmfaceov_0001010401070500">Spotlight</A></H4>
<P>A <I>spotlight</I> emits a cone of light. Only objects within the cone are illuminated. The cone produces light of two degrees of intensity, with a central brightly lit section (the <I>umbra</I>) that acts as a point source, and a surrounding dimly lit section (the <I>penumbra</I>) that merges with the surrounding deep shadow. The angles of these two sections can be individually specified by using the <A HREF="rm0020.htm#rmlight_000101060e000500" TARGET="TEXT">IDirect3DRMLight::GetPenumbra</A>, <A HREF="rm0020.htm#rmlight_000101060e000900" TARGET="TEXT">IDirect3DRMLight::GetUmbra</A>, <A HREF="rm0020.htm#rmlight_000101060e000f00" TARGET="TEXT">IDirect3DRMLight::SetPenumbra</A>, and <A HREF="rm0020.htm#rmlight_000101060e001300" TARGET="TEXT">IDirect3DRMLight::SetUmbra</A> methods.
<P><IMG SRC="art/spot.gif" WIDTH="347" HEIGHT="190" ALT="Illustration of penumbra angle, umbra angle, and umbra cone">



<H3><A NAME="dx5_IDirect3DRMMaterial_Interface_d3drm"></A><A NAME="rmfaceov_0001010401080000">IDirect3DRMMaterial Interface</A></H3>
<P>A material defines how a surface reflects light. A material has two components: an <I>emissive property</I> (whether it emits light) and a <I>specular property</I>, whose brightness is determined by a <I>power</I> setting. The value of the power determines the sharpness of the reflected highlights, with a value of 5 giving a metallic appearance and higher values giving a more plastic appearance. 
<P>An application can control the emission of a material by using the <A HREF="rm0021.htm#rmmatrl_000101060f000100" TARGET="TEXT">IDirect3DRMMaterial::GetEmissive</A> and <A HREF="rm0021.htm#rmmatrl_000101060f000400" TARGET="TEXT">IDirect3DRMMaterial::SetEmissive</A> methods, the specular component by using the <A HREF="rm0021.htm#rmmatrl_000101060f000300" TARGET="TEXT">IDirect3DRMMaterial::GetSpecular</A> and <A HREF="rm0021.htm#rmmatrl_000101060f000600" TARGET="TEXT">IDirect3DRMMaterial::SetSpecular</A> methods, and the power by using the <A HREF="rm0021.htm#rmmatrl_000101060f000200" TARGET="TEXT">IDirect3DRMMaterial::GetPower</A> and <A HREF="rm0021.htm#rmmatrl_000101060f000500" TARGET="TEXT">IDirect3DRMMaterial::SetPower</A> methods.
<P>For a reference to the methods of the <B>IDirect3DRMMaterial</B> interface, see <A CLASS=tctop HREF="rm0021.htm#rmmatrl_000101060f000000" TARGET="TEXT">IDirect3DRMMaterial</A>.


<H3><A NAME="dx5_IDirect3DRMMesh_IDirect3DRMMeshBuilder_and_IDirect3DRMMeshBuilder2_Interfaces_d3drm"></A><A NAME="rmfaceov_0001010401090000">IDirect3DRMMesh, IDirect3DRMMeshBuilder, and IDirect3DRMMeshBuilder2 Interfaces</A></H3>
<P>A mesh is a visual object that is made up of a set of polygonal faces. A mesh defines a set of vertices and a set of faces (the faces are defined in terms of the vertices and normals of the mesh). Changing a vertex or normal that is used by several faces changes the appearance of all faces sharing it.

<P>The vertices of a mesh define the positions of faces in the mesh, and they can also be used to define 2-D coordinates within a texture map.

<P>You can manipulate meshes in Retained Mode by using three COM interfaces: <A CLASS=tctop HREF="rm0022.htm#rmmesh_0001010610000000" TARGET="TEXT">IDirect3DRMMesh</A>, <A CLASS=tctop HREF="rm0023.htm#rmmshbld_0001010611000000" TARGET="TEXT">IDirect3DRMMeshBuilder</A>, and <A CLASS=tctop HREF="rm0024.htm#rmmshbl2_0001010612000000" TARGET="TEXT">IDirect3DRMMeshBuilder2</A>. <B>IDirect3DRMMesh</B> is very fast, and you should use it when a mesh is subject to frequent changes, such as when morphing. <B>IDirect3DRMMeshBuilder</B> is built on top of the <B>IDirect3DRMMesh</B> interface. Although the <B>IDirect3DRMMeshBuilder</B> interface is a convenient way to perform operations on individual faces and vertices, the system must convert a Direct3DRMMeshBuilder object into a Direct3DRMMesh object before rendering it. For meshes that do not change or that change infrequently, this conversion has a negligible impact on performance.

<P><B>IDirect3DRMMeshBuilder2</B> has all the functionality of <B>IDirect3DRMMeshBuilder</B> plus one enhanced and one added method. <A HREF="rm0024.htm#rmmshbl2_0001010612000a00" TARGET="TEXT">IDirect3DRMMeshBuilder2::GenerateNormals2</A> gives you more control over how normals are generated. <A HREF="rm0024.htm#rmmshbl2_0001010612000d00" TARGET="TEXT">IDirect3DRMMeshBuilder2::GetFace</A> allows you to access a single face in a mesh.

<P>If an application needs to assign the same characteristics (such as material or texture) to several vertices or faces, it can use the <B>IDirect3DRMMesh</B> interface to combine them in a group. If the application needs to share vertices between two different groups (for example, if neighboring faces in a mesh are different colors), the vertices must be duplicated in both groups. The <A HREF="rm0022.htm#rmmesh_0001010610000100" TARGET="TEXT">IDirect3DRMMesh::AddGroup</A> method assigns a group identifier to a collection of faces. This identifier is used to refer to the group in subsequent calls. 

<P>The <B>IDirect3DRMMeshBuilder</B>, <B>IDirect3DRMMeshBuilder2</B>, and <B>IDirect3DRMMesh</B> interfaces allow an application to create faces with more than three sides. They also automatically split a mesh into multiple buffers if, for example, the hardware the application is rendering to has a limit of 64K and a mesh is larger than that size. These features set the Direct3DRMMesh and Direct3DRMMeshBuilder API apart from the Direct3D API.

<P>You can add vertices and faces individually to a mesh by using the <A HREF="rm0023.htm#rmmshbld_0001010611000700" TARGET="TEXT">IDirect3DRMMeshBuilder::AddVertex</A>, <A HREF="rm0023.htm#rmmshbld_0001010611000100" TARGET="TEXT">IDirect3DRMMeshBuilder::AddFace</A>, and <A HREF="rm0023.htm#rmmshbld_0001010611000200" TARGET="TEXT">IDirect3DRMMeshBuilder::AddFaces</A> methods or the equivalent <A HREF="rm0024.htm#rmmshbl2_0001010612000000" TARGET="TEXT">IDirect3DRMMeshBuilder2</A> methods. You can retrieve an individual face with the <A HREF="rm0024.htm#rmmshbl2_0001010612000d00" TARGET="TEXT">IDirect3DRMMeshBuilder2::GetFace</A>.

<P>You can define individual color, texture, and material properties for each face in the mesh, or for all faces in the mesh at once, by using the <A HREF="rm0022.htm#rmmesh_0001010610000c00" TARGET="TEXT">IDirect3DRMMesh::SetGroupColor</A>, <A HREF="rm0022.htm#rmmesh_0001010610000d00" TARGET="TEXT">IDirect3DRMMesh::SetGroupColorRGB</A>, <A HREF="rm0022.htm#rmmesh_0001010610001100" TARGET="TEXT">IDirect3DRMMesh::SetGroupTexture</A>, and <A HREF="rm0022.htm#rmmesh_0001010610000f00" TARGET="TEXT">IDirect3DRMMesh::SetGroupMaterial</A> methods.



<P>For a mesh to be rendered, you must first add it to a frame by using the <A HREF="rm0017.htm#rmframe_000101060b000800" TARGET="TEXT">IDirect3DRMFrame::AddVisual</A> method. You can add a single mesh to multiple frames to create multiple instances of that mesh.

<P>Your application can use flat, Gouraud, and Phong shade modes, as specified by a call to the <A HREF="rm0022.htm#rmmesh_0001010610001000" TARGET="TEXT">IDirect3DRMMesh::SetGroupQuality</A> method. (Phong shading is not yet available, however.) This method uses values from the <A HREF="rm0035.htm#rmtypes_000101061d000b00" TARGET="TEXT">D3DRMRENDERQUALITY</A> enumerated type. For more information about shade modes, see <A CLASS=tctop HREF="rm0002.htm#rmmath_0001010201030000" TARGET="TEXT">Polygons</A>.

<P>You can set normals (which should be unit vectors), or normals can be calculated by averaging the face normals of the surrounding faces by using the <A HREF="rm0023.htm#rmmshbld_0001010611000a00" TARGET="TEXT">IDirect3DRMMeshBuilder::GenerateNormals</A> method.



<H3><A NAME="dx5_IDirect3DRMObject_Interface_d3drm"></A><A NAME="rmfaceov_00010104010a0000">Direct3DRMObject</A></H3>
<P>Direct3DRMObject is the common superclass of all objects in the system. A Direct3DRMObject object has characteristics common to all objects. 
<P>Each Direct3DRMObject object is instantiated as a COM object. In addition to the methods of the <A CLASS=tctop HREF="rm0038.htm#external_000101062000001e" TARGET="TEXT">IUnknown</A> interface, each object has a standard set of methods that are generic to all.
<P>To create an object, the application must first have instantiated a Direct3D Retained Mode object by calling the <A HREF="rm0007.htm#rmfuncs_0001010601000500" TARGET="TEXT">Direct3DRMCreate</A> function. The application then calls the method of the object's interface that creates an object, and it specifies parameters specific to the object. For example, to create a Direct3DRMAnimation object, the application would call the <A HREF="rm0010.htm#rmid3drm_0001010604000200" TARGET="TEXT">IDirect3DRM::CreateAnimation</A> method. The creation method then creates a new object, initializes some of the object's attributes from data passed in the parameters (leaving all others with their default values), and returns the object. Applications can then specify the interface for this object to modify and use the object.

<P>Any object can store 32 bits of application-specific data. This data is not interpreted or altered by Retained Mode. The application can read this data by using the <A HREF="rm0025.htm#rmobj_0001010613000400" TARGET="TEXT">IDirect3DRMObject::GetAppData</A> method, and it can write to it by using the <A HREF="rm0025.htm#rmobj_0001010613000700" TARGET="TEXT">IDirect3DRMObject::SetAppData</A> method. Finding this data is simpler if the application keeps a structure for each Direct3DRMFrame object. For example, if calling the <A HREF="rm0017.htm#rmframe_000101060b001200" TARGET="TEXT">IDirect3DRMFrame::GetParent</A> method retrieves a Direct3DRMFrame object, the application can easily retrieve the data by using a pointer to its private structure, possibly avoiding a time-consuming search.
<P>You might also want to assign a name to an object to help you organize an application or as part of your application's user interface. You can use the <A HREF="rm0025.htm#rmobj_0001010613000800" TARGET="TEXT">IDirect3DRMObject::SetName</A> and <A HREF="rm0025.htm#rmobj_0001010613000600" TARGET="TEXT">IDirect3DRMObject::GetName</A> methods to set and retrieve object names.
<P>Another example of possible uses for application-specific data is when an application needs to group the faces within a mesh into subsets (for example, for front and back faces). You could use the application data in the face to note in which of these groups a face should be included.
<P>An application can specify a function to call when an object is destroyed, such as when the application needs to deallocate memory associated with the object. To do this, use the <A HREF="rm0025.htm#rmobj_0001010613000100" TARGET="TEXT">IDirect3DRMObject::AddDestroyCallback</A> method. To remove a function previously registered with this method, use the <A HREF="rm0025.htm#rmobj_0001010613000300" TARGET="TEXT">IDirect3DRMObject::DeleteDestroyCallback</A> method.
<P>The callback function is called only when the object is destroyed&#151;that is, when the object's <A HREF="rm0055.htm#3Dgloss_000101080b000001" TARGET="TEXT">reference count</A> has reached 0 and the system is about to deallocate the memory for the object. If an application kept additional data about an object (so that its dynamics could be implemented, for example), the application could use this callback function as a way to notify itself that it can dispose of the data.
<P>For related information, see <A HREF="rm0025.htm#rmobj_0001010613000000" TARGET="TEXT">IDirect3DRMObject</A> and <A HREF="rm0009.htm#rmarray_0001010603060000" TARGET="TEXT">IDirect3DRMObjectArray</A>.

<H3><A NAME="dx5_IDirect3DRMPickedArray_Interface_d3drm"></A><A NAME="rmfaceov_00010104010b0000">IDirect3DRMPickedArray and IDirect3DRMPicked2Array Interfaces</A></H3>
<P>Picking is the process of searching for visuals in a scene, given a 2-D coordinate in a viewport or a vector in a frame. 
<P>You can use the <A HREF="rm0031.htm#rmviewpt_0001010619001300" TARGET="TEXT">IDirect3DRMViewport::Pick</A> method to retrieve an <A HREF="rm0009.htm#rmarray_0001010603070000" TARGET="TEXT">IDirect3DRMPickedArray</A> interface, and then call the <A HREF="rm0009.htm#rmarray_0001010603070100" TARGET="TEXT">IDirect3DRMPickedArray::GetPick</A> method to retrieve an <A HREF="rm0009.htm#rmarray_0001010603040000" TARGET="TEXT">IDirect3DRMFrameArray</A> interface and a visual object. The array of frames is the path through the hierarchy leading to the visual object; that is, a hierarchical list of the visual object's parent frames, with the topmost parent in the hierarchy first in the array.
<P>You can use the <A HREF="rm0018.htm#rmframe2_000101060c002d00" TARGET="TEXT">IDirect3DRMFrame2::RayPick</A> method to retrieve an <A HREF="rm0009.htm#rmarray_0001010603080000" TARGET="TEXT">IDirect3DRMPicked2Array</A> interface, and then call the <A HREF="rm0009.htm#rmarray_0001010603080100" TARGET="TEXT">IDirect3DRMPicked2Array::GetPick</A> method to retrieve an <A HREF="rm0009.htm#rmarray_0001010603040000" TARGET="TEXT">IDirect3DRMFrameArray</A> interface, a visual object, and information about the object intersected by the ray, including the face and group identifiers, pick position, and horizontal and vertical texture coordinates for the vertex, vertex normal, and color of the object. The array of frames is the path through the hierarchy leading to the visual object.
 


<H3><A NAME="dx5_IDirect3DRMProgressiveMesh_Interface_d3drm"></A><A NAME="rmfaceov_00010104010c0000">IDirect3DRMProgressiveMesh Interface</A></H3>
<P>A mesh is a visual object that is made up of a set of polygonal faces. A mesh defines a set of vertices and a set of faces. 

<P>A progressive mesh is a mesh that is stored as a base mesh (a coarse version) and a set of records that are used to increasingly refine the mesh. This allows you to set the level of detail rendered for a mesh and also allows progressive download from remote sources.

<P>Using the methods of the <A HREF="rm0026.htm#rmpmesh_0001010614000000" TARGET="TEXT">IDirect3DRMProgressiveMesh</A> interface, you can set the number of vertices or faces to render and thereby control the render detail. You can also specify a minimum level of detail required for rendering. Normally, a progressive mesh is rendered once the base mesh is available, but with the <A HREF="rm0026.htm#rmpmesh_0001010614001100" TARGET="TEXT">IDirect3DRMProgressiveMesh::SetMinRenderDetail</A> method you can specify that a greater level of detail is necessary before rendering. You can also build a <B>Direct3DRMMesh</B> object from a particular state of the progressive mesh using the <A HREF="rm0026.htm#rmpmesh_0001010614000300" TARGET="TEXT">IDirect3DRMProgressiveMesh::CreateMesh</A> method.

<P> You can load a progressive mesh from a file, resource, memory, or URL. Loading can be done synchronously or asynchronously. You can check the status of a download with the <A HREF="rm0026.htm#rmpmesh_0001010614000900" TARGET="TEXT">IDirect3DRMProgressiveMesh::GetLoadStatus</A> method, and terminate a download with the <A HREF="rm0026.htm#rmpmesh_0001010614000100" TARGET="TEXT">IDirect3DRMProgressiveMesh::Abort</A> method. If loading is asynchronous, it is up to the application to use events through the <A HREF="rm0026.htm#rmpmesh_0001010614000e00" TARGET="TEXT">IDirect3DRMProgressiveMesh::RegisterEvents</A> and <B>IDirect3DRMProgressiveMesh::GetLoadStatus</B> methods to find out how the load is progressing. 


<H3><A NAME="dx5_IDirect3DRMShadow_Interface_d3drm"></A><A NAME="rmfaceov_00010104010d0000">IDirect3DRMShadow Interface</A></H3>
<P>Applications can produce an initialized and usable shadow simply by calling the <A HREF="rm0010.htm#rmid3drm_0001010604001000" TARGET="TEXT">IDirect3DRM::CreateShadow</A> method. The <A HREF="rm0027.htm#rmshadow_0001010615000000" TARGET="TEXT">IDirect3DRMShadow</A> interface exists so that applications which create a shadow by using the <A HREF="rm0010.htm#rmid3drm_0001010604000f00" TARGET="TEXT">IDirect3DRM::CreateObject</A> method can initialize the shadow by calling the <A HREF="rm0027.htm#rmshadow_0001010615000100" TARGET="TEXT">IDirect3DRMShadow::Init</A> method.

<H3><A NAME="dx5_IDirect3DRMTexture_and_IDirect3DRMTexture2_Interfaces_d3drm"></A><A NAME="rmfaceov_00010104010e0000">IDirect3DRMTexture and IDirect3DRMTexture2 Interfaces</A></H3>
<P>A texture is a rectangular array of colored pixels. (The rectangle does not necessarily have to be square, although the system deals most efficiently with square textures.) You can use textures for texture-mapping faces, in which case their dimensions must be powers of two. 
<P>Your application can use the <A HREF="rm0010.htm#rmid3drm_0001010604001100" TARGET="TEXT">IDirect3DRM::CreateTexture</A> method to create a texture from a <A HREF="rm0034.htm#rmtypes_000101061c000200" TARGET="TEXT">D3DRMIMAGE</A> structure, or the <A HREF="rm0010.htm#rmid3drm_0001010604001200" TARGET="TEXT">IDirect3DRM::CreateTextureFromSurface</A> method to create a texture from a DirectDraw surface. The <A HREF="rm0010.htm#rmid3drm_0001010604001b00" TARGET="TEXT">IDirect3DRM::LoadTexture</A> method allows your application to load a texture from a file; the texture should be in Microsoft&#174; Windows&#174; bitmap (.bmp) or Portable Pixmap (.ppm) format. To avoid unnecessary delays when creating textures, hold onto textures you want to use again, instead of creating them each time they're needed. For optimal performance, use a texture surface format that is supported by the device you are using. This will avoid a costly format conversion when the texture is created and any time it changes.
<P>The texture coordinates of each face define the region in the texture that is mapped onto that particular face. Your application can use a wrap to calculate texture coordinates. For more information, see <A CLASS=tctop HREF="rm0004.htm#rmfaceov_0001010401120000" TARGET="TEXT">IDirect3DRMWrap Interface</A>.
<P>The <B>IDirect3DRMTexture2</B> interface is an extension of the <A HREF="rm0028.htm#rmtextur_0001010616000000" TARGET="TEXT">IDirect3DRMTexture</A> interface. The <A HREF="rm0029.htm#rmtext2_0001010617000d00" TARGET="TEXT">IDirect3DRMTexture2::InitFromResource2</A> method allows resources to be loaded from DLLs and executables other than the currently executing file. In addition, <B>IDirect3DRMTexture2</B> has two new methods. <A HREF="rm0029.htm#rmtext2_0001010617000c00" TARGET="TEXT">IDirect3DRMTexture2::InitFromImage</A> creates a texture from an image in memory. This method is equivalent to <A HREF="rm0010.htm#rmid3drm_0001010604001100" TARGET="TEXT">IDirect3DRM::CreateTexture</A>. <A HREF="rm0029.htm#rmtext2_0001010617000200" TARGET="TEXT">IDirect3DRMTexture2::GenerateMIPMap</A> generates a MIP map from a source image.
<P>Textures are loaded from BMP and DIB (device-independent bitmap) files right-side up in <A HREF="rm0029.htm#rmtext2_0001010617000b00" TARGET="TEXT">IDirect3DRMTexture2::InitFromFile</A> and <A HREF="rm0029.htm#rmtext2_0001010617000d00" TARGET="TEXT">IDirect3DRMTexture2::InitFromResource2</A>, unlike <A HREF="rm0028.htm#rmtextur_0001010616000a00" TARGET="TEXT">IDirect3DRMTexture::InitFromFile</A> and <A HREF="rm0028.htm#rmtextur_0001010616000b00" TARGET="TEXT">IDirect3DRMTexture::InitFromResource</A> where they are loaded inverted. 
<P>For a reference to the methods of these interfaces, see <A CLASS=tctop HREF="rm0028.htm#rmtextur_0001010616000000" TARGET="TEXT">IDirect3DRMTexture</A> and <A CLASS=tctop HREF="rm0029.htm#rmtext2_0001010617000000" TARGET="TEXT">IDirect3DRMTexture2</A>.
<P>This section describes the types of textures supported by Direct3D and how your application can use them. 
<UL><LI><A CLASS=tctop HREF="rm0004.htm#rmfaceov_00010104010e0100" TARGET="TEXT">Decals</A>
<LI><A CLASS=tctop HREF="rm0004.htm#rmfaceov_00010104010e0200" TARGET="TEXT">Texture Colors</A>
<LI><A CLASS=tctop HREF="rm0004.htm#rmfaceov_00010104010e0300" TARGET="TEXT">Mipmaps</A>
<LI><A CLASS=tctop HREF="rm0004.htm#rmfaceov_00010104010e0400" TARGET="TEXT">Texture Filtering</A>
<LI><A CLASS=tctop HREF="rm0004.htm#rmfaceov_00010104010e0500" TARGET="TEXT">Texture Transparency</A>
<LI><A CLASS=tctop HREF="rm0004.htm#rmfaceov_00010104010e0600" TARGET="TEXT">Texture Format Selection Rules</A>
</UL>
<H4><A NAME="rmfaceov_00010104010e0100">Decals</A></H4>
<P>Textures can also be rendered directly, as visuals. Textures used this way are sometimes known as <I>decals</I>, a term adopted by Retained Mode. A decal is rendered into a viewport-aligned rectangle. The rectangle can optionally be scaled by the depth component of the decal's position. The size of the decal is taken from a rectangle defined relative to the containing frame by using the <A HREF="rm0028.htm#rmtextur_0001010616001000" TARGET="TEXT">IDirect3DRMTexture::SetDecalSize</A> method. (An application can retrieve the size of the decal by using the <A HREF="rm0028.htm#rmtextur_0001010616000500" TARGET="TEXT">IDirect3DRMTexture::GetDecalSize</A> method.) The decal is then transformed and perspective projection is applied.

<P>Decals have origins that your application can set and retrieve by using the <A HREF="rm0028.htm#rmtextur_0001010616000e00" TARGET="TEXT">IDirect3DRMTexture::SetDecalOrigin</A> and <A HREF="rm0028.htm#rmtextur_0001010616000300" TARGET="TEXT">IDirect3DRMTexture::GetDecalOrigin</A> methods. The origin is an offset from the top-left corner of the decal. The default origin is [0, 0]. The decal's origin is aligned with its frame's position when rendering.



<H4><A NAME="rmfaceov_00010104010e0200">Texture Colors</A></H4>
<P>You can set and retrieve the number of colors that are used to render a texture by using the <A HREF="rm0028.htm#rmtextur_0001010616000d00" TARGET="TEXT">IDirect3DRMTexture::SetColors</A> and <A HREF="rm0028.htm#rmtextur_0001010616000200" TARGET="TEXT">IDirect3DRMTexture::GetColors</A> methods. 
<P>If your application uses the RGB color model, you can use 8-bit, 24-bit, and 32-bit textures. If you use the monochromatic (or ramp) color model, however, you can use only 8-bit textures. 
<P>Several shades of each color are used when lighting a scene. An application can set and retrieve the number of shades used for each color by calling the <A HREF="rm0028.htm#rmtextur_0001010616001300" TARGET="TEXT">IDirect3DRMTexture::SetShades</A> and <A HREF="rm0028.htm#rmtextur_0001010616000900" TARGET="TEXT">IDirect3DRMTexture::GetShades</A> methods.
<P>A Direct3DRMTexture object uses a <A HREF="rm0034.htm#rmtypes_000101061c000200" TARGET="TEXT">D3DRMIMAGE</A> structure to define the bitmap that the texture will be rendered from. If the application provides the <B>D3DRMIMAGE</B> structure, the texture can easily be animated or altered during rendering.



<H4><A NAME="rmfaceov_00010104010e0300">Mipmaps</A></H4>
<P>A mipmap is a sequence of textures, each of which is a progressively lower resolution, prefiltered representation of the same image. Mipmapping is a computationally low-cost way of improving the quality of rendered textures. Each prefiltered image, or level, in the mipmap is a power of two smaller than the previous level. You can specify mipmaps when filtering textures by calling the <A HREF="rm0014.htm#rmdevice_0001010608001600" TARGET="TEXT">IDirect3DRMDevice::SetTextureQuality</A> method.
<P>For more information about mipmaps, see <A CLASS=tctop HREF="rm0038.htm#external_0001010620000022" TARGET="TEXT">Mipmaps</A>.



<H4><A NAME="rmfaceov_00010104010e0400">Texture Filtering</A></H4>
<P>After a texture has been mapped to a surface, the texture elements (<I>texels</I>) of the texture rarely correspond to individual pixels in the final image. A pixel in the final image can correspond to a large collection of texels or to a small piece of a single texel. You can use texture filtering to specify how to interpolate texel values to pixels.
<P>You can use the <A HREF="rm0014.htm#rmdevice_0001010608001600" TARGET="TEXT">IDirect3DRMDevice::SetTextureQuality</A> method and the <A HREF="rm0035.htm#rmtypes_000101061d000e00" TARGET="TEXT">D3DRMTEXTUREQUALITY</A> enumerated type to specify the texture filtering mode for your application.


<H4><A NAME="rmfaceov_00010104010e0500">Texture Transparency</A></H4>
<P>You can use the <A HREF="rm0028.htm#rmtextur_0001010616001100" TARGET="TEXT">IDirect3DRMTexture::SetDecalTransparency</A> method to produce transparent textures. Another method for achieving transparency is to use DirectDraw's support for <I>color keys</I>. Color keys are colors or ranges of colors that can be part of either the source or destination of a blit or overlay operation. You can specify that these colors should always be overwritten or never be overwritten. 
<P>For more information about DirectDraw's support for color keys, see <A CLASS=tctop HREF="rm0038.htm#external_0001010620000001" TARGET="TEXT">Color Keying</A>.


<H4><A NAME="rmfaceov_00010104010e0600">Texture Format Selection Rules</A></H4>
<P>When you use a device-independent source image to create a device-dependent texture surface for rendering, the rules are (in order of precedence): 
<P>1. Preserve RGB/palettized nature
<P>2. Preserve alpha channel
<P>3. Preserve bit depth or palette size
<P>4. Preserve RBGA masks
<P>5. Prefer 8-bit palettized or 16-bit RGB

<P>For more information about texture pixel formats, see <A CLASS=tctop HREF="rm0038.htm#external_0001010620000023" TARGET="TEXT">Texture Map Formats</A>.

<P>For related information, see <A HREF="rm0028.htm#rmtextur_0001010616000000" TARGET="TEXT">IDirect3DRMTexture</A> and <A HREF="rm0029.htm#rmtext2_0001010617000000" TARGET="TEXT">IDirect3DRMTexture2</A>.

<H3><A NAME="dx5_IDirect3DRMUserVisual_Interface_d3drm"></A><A NAME="rmfaceov_00010104010f0000">IDirect3DRMUserVisual Interface</A></H3>
<P>User-visual objects are application-defined data that an application can add to a scene and then render, typically by using a customized rendering module. For example, an application could add sound as a user-visual object in a scene, and then render the sound during playback.
<P>You can use the <A HREF="rm0010.htm#rmid3drm_0001010604001300" TARGET="TEXT">IDirect3DRM::CreateUserVisual</A> method to create a user-visual object and the <A HREF="rm0030.htm#rmuservz_0001010618000100" TARGET="TEXT">IDirect3DRMUserVisual::Init</A> method to initialize the object.

<H3><A NAME="dx5_IDirect3DRMViewport_and_IDirect3DRMViewportArray_Interface_d3drm"></A><A NAME="rmfaceov_0001010401100000">IDirect3DRMViewport and IDirect3DRMViewportArray Interface</A></H3>
<P>The viewport defines how the 3-D scene is rendered into a 2-D window. The viewport defines a rectangular area on a device that objects will be rendered into.
<P>For a reference to the methods of this interface, see <A CLASS=tctop HREF="rm0031.htm#rmviewpt_0001010619000000" TARGET="TEXT">IDirect3DRMViewport</A>.
<P>This section describes the viewport, its components, and techniques for their use. 
<UL><LI><A CLASS=tctop HREF="rm0004.htm#rmfaceov_0001010401100100" TARGET="TEXT">Camera</A>
<LI><A CLASS=tctop HREF="rm0004.htm#rmfaceov_0001010401100200" TARGET="TEXT">Viewing Frustum</A>
<LI><A CLASS=tctop HREF="rm0004.htm#rmfaceov_0001010401100300" TARGET="TEXT">Transformations</A>
<LI><A CLASS=tctop HREF="rm0004.htm#rmfaceov_0001010401100400" TARGET="TEXT">Picking</A>
</UL>
<H4><A NAME="rmfaceov_0001010401100100">Camera</A></H4>
<P>The viewport uses a Direct3DRMFrame object as a <I>camera</I>. The camera frame defines which scene is rendered and the viewing position and direction. The viewport renders only what is visible along the positive z-axis of the camera frame, with the up direction being in the direction of the positive y-axis.
<P>An application can call the <A HREF="rm0031.htm#rmviewpt_0001010619001600" TARGET="TEXT">IDirect3DRMViewport::SetCamera</A> method to set a camera for a given viewport. This method sets a viewport's position, direction, and orientation to that of the given camera frame. To retrieve the current camera settings, call the <A HREF="rm0031.htm#rmviewpt_0001010619000500" TARGET="TEXT">IDirect3DRMViewport::GetCamera</A> method.


<H4><A NAME="rmfaceov_0001010401100200">Viewing Frustum</A></H4>
<P>The <I>viewing frustum</I> is a 3-D volume in a scene positioned relative to the viewport's <A HREF="rm0048.htm#3Dgloss_0001010804000001" TARGET="TEXT">camera</A>. For perspective viewing, the camera is positioned at the tip of an imaginary pyramid. This pyramid is intersected by two clipping planes, the <A HREF="rm0051.htm#3Dgloss_0001010807000001" TARGET="TEXT">front clipping plane</A> and the <A HREF="rm0047.htm#3Dgloss_0001010803000002" TARGET="TEXT">back clipping plane</A>. The volume in the pyramid between the front and back clipping planes is the viewing frustum. Only objects in the viewing frustum are visible.

<P><IMG SRC="art/frustrum.gif" WIDTH="425" HEIGHT="208" ALT="Diagram showing the front and back clipping plane and the viewing frustum">

<P>The z-axis of the camera runs from the tip of the pyramid to the center of the back clipping plane. Your application can set and retrieve the positions of the front and back clipping planes by using the <A HREF="rm0031.htm#rmviewpt_0001010619001800" TARGET="TEXT">IDirect3DRMViewport::SetFront</A>, <A HREF="rm0031.htm#rmviewpt_0001010619001500" TARGET="TEXT">IDirect3DRMViewport::SetBack</A>, <A HREF="rm0031.htm#rmviewpt_0001010619000900" TARGET="TEXT">IDirect3DRMViewport::GetFront</A>, and <A HREF="rm0031.htm#rmviewpt_0001010619000400" TARGET="TEXT">IDirect3DRMViewport::GetBack</A> methods. 

<P>The dimensions of the viewport on the front clipping plane determine the apparent focal length of the camera's lens. (You can also think of this as a way to set the magnification of objects in the frustum.) To set and retrieve proportional dimensions for the viewport on the front clipping plane, use the <A HREF="rm0031.htm#rmviewpt_0001010619001700" TARGET="TEXT">IDirect3DRMViewport::SetField</A> and <A HREF="rm0031.htm#rmviewpt_0001010619000800" TARGET="TEXT">IDirect3DRMViewport::GetField</A> methods. To set and retrieve arbitrary dimensions for the viewport on the front clipping plane, use the <A HREF="rm0031.htm#rmviewpt_0001010619001900" TARGET="TEXT">IDirect3DRMViewport::SetPlane</A> and <A HREF="rm0031.htm#rmviewpt_0001010619000b00" TARGET="TEXT">IDirect3DRMViewport::GetPlane</A> methods. 

<P>You can use the following equation to determine the relationship between the height (or width) of the front clipping plane and the viewing angle:

<P><IMG SRC="art/frusteq.gif" WIDTH="88" HEIGHT="46" ALT="Equation showing relationship between the front clipping plane and the viewing angle">

<P>In this formula, the viewing angle is <I>A</I>, the front clipping plane is a distance <I>D</I> from the camera, and the height or width of the front clipping plane is 2<I>h</I>. If the device is not square, and thus the clipping planes are not square, the viewing angle is calculated using half the height or half the width of the front clipping plane, whichever
is larger. The scale factors are set to the major axis of the device so you don't get distorted objects. If this is not what you want, you need to set uniform scaling.

<P><IMG SRC="art/frangle.gif" WIDTH="432" HEIGHT="163" ALT="Illustration of the dimensions used in the previous equation">

<P>The viewing frustum is a pyramid only for perspective viewing. For orthographic viewing, the viewing frustum is cuboid. These viewing types (or projection types) are defined by the <A HREF="rm0035.htm#rmtypes_000101061d000a00" TARGET="TEXT">D3DRMPROJECTIONTYPE</A> enumerated type and used by the <A HREF="rm0031.htm#rmviewpt_0001010619000c00" TARGET="TEXT">IDirect3DRMViewport::GetProjection</A> and <A HREF="rm0031.htm#rmviewpt_0001010619001a00" TARGET="TEXT">IDirect3DRMViewport::SetProjection</A> methods.


<H4><A NAME="rmfaceov_0001010401100300">Transformations</A></H4>
<P>To render objects with 3-D coordinates in a 2-D window, the object must be transformed into the <A HREF="rm0048.htm#3Dgloss_0001010804000001" TARGET="TEXT">camera</A>'s frame. A projection matrix is then used to give a four-element homogeneous coordinate [<I>x y z w</I>], which is used to derive a three-element coordinate [<I>x/w y/w z/w</I>], where [<I>x/w y/w</I>] is the coordinate to be used in the window and <I>z/w</I> is the depth, ranging from 0 at the <A HREF="rm0051.htm#3Dgloss_0001010807000001" TARGET="TEXT">front clipping plane</A> to 1 at the <A HREF="rm0047.htm#3Dgloss_0001010803000002" TARGET="TEXT">back clipping plane</A>. The projection matrix is a combination of a perspective transformation followed by a scaling and translation to scale the objects into the window.
<P>The following values are the elements of the projection matrix. In these formulas, <I>h</I> is the half-height of the <A HREF="rm0059.htm#3Dgloss_000101080f000001" TARGET="TEXT">viewing frustum</A>, <I>F</I> is the distance from the camera, and <I>D</I> is the position in z-coordinates of the front clipping plane:
<P><IMG SRC="art/projmat.gif" WIDTH="278" HEIGHT="125" ALT="Projection matrix">
<P>After projection, the next step is clipping and the conversion of x and y to screen-pixel coordinates within a viewport. Use the D3DVIEWPORT data members for this. The viewport is a rectangular window on the rendering surface.
<PRE><FONT FACE="Courier" SIZE="2">typedef struct _D3DVIEWPORT {
    DWORD    dwSize;
    DWORD    dwX;
    DWORD    dwY; 
    DWORD    dwWidth;
    DWORD    dwHeight; 
    D3DVALUE dvScaleX; 
    D3DVALUE dvScaleY; 
    D3DVALUE dvMaxX;  
    D3DVALUE dvMaxY;  
    D3DVALUE dvMinZ;   
    D3DVALUE dvMaxZ;   
} D3DVIEWPORT, *LPD3DVIEWPORT;

</FONT></PRE>
<P>The <B>dwX</B> and <B>dwY</B> fields specify the offset in screen pixels to the top left of the viewport on the surface.

<P>The <B>dwWidth</B> and <B>dwHeight</B> fields are the width and height of the viewport in screen pixels.

<P>The <B>dvScaleX</B> and <B>dvScaleY</B> fields are the scaling factors that are applied to the x and y values to yield screen coordinates. You would usually want to map the entire normalized perspective view volume onto the viewport using the following formulas:
<PRE><FONT FACE="Courier" SIZE="2">
  dvScaleX = dwWidth / 2
  dvScaleY = dwHeight / 2
</FONT></PRE>
<P>X coordinates, for example, in the range of -1 to 1, will be scaled into the range of -dwWidth / 2 to dwWidth / 2. An offset of dwWidth / 2 is then added. This scaling occurs after clipping.

<P>If the window is not square and you would like to preserve a correct aspect ratio, use the larger of the two window dimensions for both scaling values. You will also need to clip some of the view volume.

<P>The <B>dvMaxX</B>, <B>dvMaxY</B>, <B>dvinZ</B>, and <B>dvMaxZ</B> fields specify the clipping planes: x = <B>dvMaxX</B>, x = &#151;<B>dvMaxX</B>, y = <B>dvMaxy</B>, y = &#151;<B>dvMaxY</B>, z = <B>dvMinZ</B>, z = <B>dvMaxZ</B>. To display all of the view volume, for example, you would set <B>dvMaxX</B> = <B>dvMaxY</B> = <B>dvMaxZ</B> = 1 and <B>dvMinZ</B> = 0. As noted above, if you want to preserve the correct aspect ratio on a nonsquare window, you will need to clip some of the view volume. To do so, use the following equations. These equations also work with square viewports, so use them all the time. 
<PRE><FONT FACE="Courier" SIZE="2">
dvMaxX = dwWidth / (2 * dvScaleX)
dvMaxY = dwHeight / (2 * dvScaleY)

</FONT></PRE>
<P>An application uses the viewport transformation to ensure that the distance by which the object is moved in world coordinates is scaled by the object's distance from the camera to account for perspective. Note that the result from <A HREF="rm0031.htm#rmviewpt_0001010619001c00" TARGET="TEXT">IDirect3DRMViewport::Transform</A> is a four-element homogeneous vector. This avoids the problems associated with coordinates being scaled by an infinite amount near the camera's position.

<P>For information about transformations for frames, see <A CLASS=tctop HREF="rm0004.htm#rmfaceov_0001010401050200" TARGET="TEXT">Transformations</A>. For an overview of the mathematics of transformations, see <A CLASS=tctop HREF="rm0002.htm#rmmath_0001010201020000" TARGET="TEXT">3-D Transformations</A>.



<H4><A NAME="rmfaceov_0001010401100400">Picking</A></H4>
<P>Picking is the process of searching for visuals in the scene given a 2-D coordinate in the viewport's window. An application can use the <A HREF="rm0031.htm#rmviewpt_0001010619001300" TARGET="TEXT">IDirect3DRMViewport::Pick</A> method to retrieve either the closest object in the scene or a depth-sorted list of objects.


<H3><A NAME="dx5_IDirect3DRMVisual_and_IDirect3DRMVisualArray_Interfaces_d3drm"></A><A NAME="rmfaceov_0001010401110000">IDirect3DRMVisual and IDirect3DRMVisualArray Interfaces</A></H3>
<P>Visuals are objects that can be rendered in a scene. Visuals are visible only when they are added to a frame in that scene. An application can add a visual to a frame by using the <A HREF="rm0017.htm#rmframe_000101060b000800" TARGET="TEXT">IDirect3DRMFrame::AddVisual</A> method. The frame provides the visual with position and orientation for rendering.
<P>You should use the <A HREF="rm0009.htm#rmarray_00010106030a0000" TARGET="TEXT">IDirect3DRMVisualArray</A> interface to work with groups of visual objects; although there is a <B>IDirect3DRMVisual</B> COM interface, it has no methods.
<P>The most common visual types are Direct3DRMMeshBuilder and Direct3DRMTexture objects.



<H3><A NAME="dx5_IDirect3DRMWrap_Interface_d3drm"></A><A NAME="rmfaceov_0001010401120000">IDirect3DRMWrap Interface</A></H3>
<P>You can use a wrap to calculate texture coordinates for a face or mesh. To create a wrap, the application must specify a type, a reference frame, an origin, a direction vector, and an up vector. The application must also specify a pair of scaling factors and an origin for the texture coordinates.
<P>Your application calls the <A HREF="rm0010.htm#rmid3drm_0001010604001500" TARGET="TEXT">IDirect3DRM::CreateWrap</A> function to create an <B>IDirect3DRMWrap</B> interface. This interface has two unique methods: <A HREF="rm0033.htm#rmwrap_000101061b000100" TARGET="TEXT">IDirect3DRMWrap::Apply</A>, which applies a wrap to the vertices of the object, and <A HREF="rm0033.htm#rmwrap_000101061b000200" TARGET="TEXT">IDirect3DRMWrap::ApplyRelative</A>, which transforms the vertices of a wrap as it is applied.
<P>In the examples, the direction vector (the v vector) lies along the z-axis, and the up vector (the u vector) lies along the y-axis, with the origin at [0 0 0]. 

<P>For a reference to the methods of the <B>IDirect3DRMWrap</B> interface, see <A CLASS=tctop HREF="rm0033.htm#rmwrap_000101061b000000" TARGET="TEXT">IDirect3DRMWrap</A>.
<P>This section describes the wrapping flags and the four wrapping types:
<UL><LI><A CLASS=tctop HREF="rm0004.htm#rmfaceov_0001010401120100" TARGET="TEXT">Wrapping Flags</A>
<LI><A CLASS=tctop HREF="rm0004.htm#rmfaceov_0001010401120200" TARGET="TEXT">Flat</A>
<LI><A CLASS=tctop HREF="rm0004.htm#rmfaceov_0001010401120300" TARGET="TEXT">Cylindrical</A>
<LI><A CLASS=tctop HREF="rm0004.htm#rmfaceov_0001010401120400" TARGET="TEXT">Spherical</A>
<LI><A CLASS=tctop HREF="rm0004.htm#rmfaceov_0001010401120500" TARGET="TEXT">Chrome</A>
</UL>
<H4><A NAME="rmfaceov_0001010401120100">Wrapping Flags</A></H4>
<P>The <A HREF="rm0036.htm#rmtypes_000101061e000500" TARGET="TEXT">D3DRMMAPPING</A> type includes the D3DRMMAP_WRAPU and D3DRMMAP_WRAPV flags. These flags determine how the rasterizer interprets texture coordinates. The rasterizer always interpolates the shortest distance between texture coordinates&#151;that is, a line. The path taken by this line, and the valid values for the u- and v-coordinates, varies with the use of the wrapping flags. If either or both flags is set, the line can wrap around the texture edge in the u or v direction, as if the texture had a cylindrical or toroidal topology.
<UL><LI>In flat wrapping mode, in which neither of the wrapping flags is set, the plane specified by the u- and v-coordinates is an infinite tiling of the texture. In this case, values greater than 1.0 are valid for u and v. The shortest line between (0.1, 0.1) and (0.9, 0.9) passes through (0.5, 0.5).
<LI>If either D3DRMMAP_WRAPU or D3DRMMAP_WRAPV is set, the texture is a cylinder with an infinite length and a circumference of 1.0. Texture coordinates greater than 1.0 are valid only in the dimension that is not wrapped. The shortest distance between texture coordinates varies with the wrapping flag; if D3DRMMAP_WRAPU is set, the shortest line between (0.1, 0.1) and (0.9, 0.9) passes through (0, 0.5).
<LI>If both D3DRMMAP_WRAPU and D3DRMMAP_WRAPV are set, the texture is a torus. Because the system is closed, texture coordinates greater that 1.0 are invalid. The shortest line between (0.1, 0.1) and (0.9, 0.9) passes through (0, 0).
</UL>
<P>Although texture coordinates that are outside the valid range may be truncated to valid values, this behavior is not defined.
<P>Typically, applications set a wrap flag for cylindrical wraps when the intersection of the texture edges does not match the edges of the face; applications do not set a wrap flag when more than half of a texture is applied to a single face.


<H4><A NAME="rmfaceov_0001010401120200">Flat</A></H4>
<P>The flat wrap conforms to the faces of an object as if the texture were a piece of rubber that was stretched over the object.
<P>The [<I>u v</I>] coordinates are derived from a vector [<I>x y z</I>] by using the following equations:

<P><IMG SRC="art/flateq.gif" WIDTH="84" HEIGHT="45" ALT="Equations for deriving u-v coordinates from a vector in a flat wrap">

<P>In these formulas, <I>s</I> is the window-scaling factor and <I>o</I> is the window origin. The application should choose a pair of scaling factors and offsets that map the ranges of <I>x</I> and <I>y</I> to the range from 0 to 1 for <I>u</I> and <I>v</I>. 

<H4><A NAME="rmfaceov_0001010401120300">Cylindrical</A></H4>
<P>The cylindrical wrap treats the texture as if it were a piece of paper that is wrapped around a cylinder so that the left edge is joined to the right edge. The object is then placed in the middle of the cylinder and the texture is deformed inward onto the surface of the object.
<P>For a cylindrical texture map, the effects of the various vectors are shown in the following illustration.
<P><IMG SRC="art/cylwrap.gif" WIDTH="247" HEIGHT="201" ALT="Diagram showing the effects of vectors on a cylindrical wrap">
<P>The direction vector specifies the axis of the cylinder, and the up vector specifies the point on the outside of the cylinder where <I>u</I> equals 0. To calculate the texture [<I>u v</I>] coordinates for a vector [<I>x y z</I>], the system uses the following equations:
<P><IMG SRC="art/texveceq.gif" WIDTH="113" HEIGHT="45" ALT="Equations for deriving u-v coordinates from a vector in a cylindrical wrap">


<P>Typically, <I>u</I> would be left unscaled and <I>v</I> would be scaled and translated so that the range of <I>z</I> maps to the range from 0 to 1 for <I>v</I>.



<H4><A NAME="rmfaceov_0001010401120400">Spherical</A></H4>
<P>For a spherical wrap, the u-coordinate is derived from the angle that the vector [<I>x y</I> 0] makes with the x-axis (as in the cylindrical map) and the v-coordinate from the angle that the vector [<I>x y z</I>] makes with the z-axis. Note that this mapping causes distortion of the texture at the z-axis.
<P><IMG SRC="art/sphwrap.gif" WIDTH="246" HEIGHT="169" ALT="Diagram showing the effects of vectors on a spherical wrap">
<P>This translates to the following equations:
<P><IMG SRC="art/sphwrpeq.gif" WIDTH="186" HEIGHT="68" ALT="Equations for deriving u-v coordinates from a vector in a spherical wrap">
<P>The scaling factors and texture origin will often not be needed here as the unscaled range of <I>u</I> and <I>v</I> is already 0 through 1.



<H4><A NAME="rmfaceov_0001010401120500">Chrome</A></H4>
<P>A chrome wrap allocates texture coordinates so that the texture appears to be reflected onto the objects. The chrome wrap takes the reference frame position and uses the vertex normals in the mesh to calculate reflected vectors. The texture u- and v-coordinates are then calculated from the intersection of these reflected vectors with an imaginary sphere that surrounds the mesh. This gives the effect of the mesh reflecting whatever is wrapped on the sphere.

<P><P><FONT FACE="MS SANS SERIF" SIZE="1" COLOR="BLACK">
<A CLASS=cpslug HREF="copyrite.htm" TARGET="TEXT">&#169; 1998 Microsoft Corporation. All rights reserved. Terms of use.</A>
</FONT>
<BR CLEAR=ALL><P>
</FONT><P>
</BODY></HTML>
