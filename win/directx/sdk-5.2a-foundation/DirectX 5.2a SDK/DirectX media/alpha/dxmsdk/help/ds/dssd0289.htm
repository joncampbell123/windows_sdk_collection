<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<HTML>
<HEAD><TITLE>Debugging with DirectShow</TITLE>
<STYLE>
<!--
.tctop {color: blue}
.cpslug {color: blue; text-decoration: none}
-->
</STYLE>
<SCRIPT LANGUAGE="JAVASCRIPT">
//<!--
function ShowButtons() {
    if (window.top.frames.length!=0 && window.top.frames[0].ShowButtons!=null)
	window.top.frames[0].ShowButtons('/dssd0288.htm','/dssd0000.htm','/dssd0288.htm','/index.htm','/dssd0290.htm');
}
ShowButtons();
//-->
</SCRIPT>
</HEAD>
<BODY onLoad="ShowButtons()" TOPMARGIN=10 BGPROPERTIES="FIXED" BGCOLOR="#FFFFFF" LINK="#000000" VLINK="#808080" ALINK="#000000">
<FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">
<H2><A NAME="debug_0001060401000000">Debugging with DirectShow</A></H2>
<BR CLEAR=ALL>
<P>This article discusses debugging practices in Microsoft&#174; DirectShow&#153; for the C and C++ languages. Many of these practices apply both to writing filters and to writing applications that use the DirectShow run time. The article provides some tips on writing code that can be easily debugged and some general debugging topics. This article also provides some hints about detecting memory leaks.

<P><B>Contents of this article</B>:
<UL><LI><A CLASS=TCTOP HREF="dssd0289.htm#debug_0001060401010000" TARGET="TEXT">Writing Code You Can Test and Debug</A>
<LI><A CLASS=TCTOP HREF="dssd0289.htm#debug_0001060401020000" TARGET="TEXT">Using Different Kinds of Builds</A>
<LI><A CLASS=TCTOP HREF="dssd0289.htm#debug_0001060401030000" TARGET="TEXT">Debugging New Filters</A>
<LI><A CLASS=TCTOP HREF="dssd0289.htm#debug_0001060401040000" TARGET="TEXT">Detecting Leaks</A>
</UL>
<A NAME="debug_0001060401010000"></A><P><B>Writing Code You Can Test and Debug</B>
<P>Debugging code in the DirectShow environment can be easier if it's written to be easily tested and debugged in the first place. Some techniques that DirectShow supports include the following, which are discussed in this section.

<UL><LI><A CLASS=TCTOP HREF="dssd0289.htm#debug_0001060401010100" TARGET="TEXT">Assertion Checking</A>
<LI><A CLASS=TCTOP HREF="dssd0289.htm#debug_0001060401010200" TARGET="TEXT">Pass Debugging Names</A>
<LI><A CLASS=TCTOP HREF="dssd0289.htm#debug_0001060401010300" TARGET="TEXT">Debug Logging</A>
<LI><A CLASS=TCTOP HREF="dssd0289.htm#debug_0001060401010400" TARGET="TEXT">IOStream Sample Code</A>
<LI><A CLASS=TCTOP HREF="dssd0289.htm#debug_0001060401010500" TARGET="TEXT">Critical Section Usage</A>
<LI><A CLASS=TCTOP HREF="dssd0289.htm#debug_0001060401010600" TARGET="TEXT">Pointer Validation</A>
<LI><A CLASS=TCTOP HREF="dssd0289.htm#debug_0001060401010700" TARGET="TEXT">DLL Base Address Conflicts</A>
</UL>
<A NAME="debug_0001060401010100"></A><P><B>Assertion Checking</B>
<P>Use assertion checking liberally. If you're not familiar with asserts, they're a popular way to isolate potential programming errors. DirectShow provides a number of assertion macros and functions, including <A HREF="dssd0290.htm#fmdebug_0001060402000100" TARGET="TEXT">ASSERT</A>. The Microsoft&#174; Foundation Classes (MFC) have an equivalent <B>ASSERT</B> macro. For example the following displays a message box if the value of <I>First</I> does not equal NULL:

<PRE><FONT FACE="Courier" SIZE="2">
    ASSERT( First != NULL );
</FONT></PRE>
<P>For more information about assertion, see <A CLASS=TCTOP HREF="dssd0290.htm" TARGET="TEXT">Assert Macros and Functions</A>.

<A NAME="debug_0001060401010200"></A><P><B>Pass Debugging Names</B>
<P>Pass the debugging name to the constructors that support it. Tracking object creation and destruction is provided in debugging builds for the <A HREF="dssd0208.htm" TARGET="TEXT">CBaseObject</A> class and classes derived from it. The <I>object register</I> is the list of objects that have been created but not yet destroyed in those classes. The debugging name that is passed to the constructors of those classes is stored in the object register.
For more information about debugging object registers and the <A HREF="dssd0297.htm#fmdebug_0001060409000100" TARGET="TEXT">DbgDumpObjectRegister</A> function, see <A CLASS=TCTOP HREF="dssd0297.htm" TARGET="TEXT">Object Register Debugging</A>.

<A NAME="debug_0001060401010300"></A><P><B>Debug Logging</B>
<P>Use the DirectShow <A HREF="dssd0296.htm#fmdebug_0001060408020300" TARGET="TEXT">DbgLog</A> function to display debugging messages on a debugger as your program executes. Here's an example from the bouncing ball source filter:

<PRE><FONT FACE="Courier" SIZE="2">
    DbgLog(( LOG_TRACE, 1, TEXT("New time: %d, Proportion: %d"),
        m_iRepeatTime, q.Proportion));
</FONT></PRE>
<P>See the <A CLASS=TCTOP HREF="dssd0296.htm" TARGET="TEXT">Debug Logging by Module Level</A> for more information on the following topics:
<UL><LI>The macros and functions you can call to do debugging logging from
code you write.
<LI>How to enable and disable debugging logging by module level at run time.
<LI>How to indicate the destination of the output of the debugging log.
</UL>
<A NAME="debug_0001060401010400"></A><P><B>IOStream Sample Code</B>
<P>The C and C++ helpers provided in the IOStream helper library, SampIOS.lib, provide text output of the <A HREF="dssd0123.htm" TARGET="TEXT">IBaseFilter</A> interface and other DirectShow objects. The output from these helpers might be useful during debugging, to help understand the details of a given pin or filter. You can use these helpers in your DirectShow filters and applications. For more information about this library, see 
<A CLASS=TCTOP HREF="dssd0372.htm#samples_000107020b000000" TARGET="TEXT">SampIOS Sample (IOStream Helper Library)</A>.

<A NAME="debug_0001060401010500"></A><P><B>Critical Section Usage</B>
<P>To make deadlocks easier to track, insert assertions in the code that determine whether a critical section is owned by the calling code. The <A HREF="dssd0272.htm#fmutil_0001060304000100" TARGET="TEXT">CritCheckIn</A> and <A HREF="dssd0272.htm#fmutil_0001060304000200" TARGET="TEXT">CritCheckOut</A> functions indicate whether the calling thread owns the given critical sections, and are generally called in <A HREF="dssd0290.htm#fmdebug_0001060402000100" TARGET="TEXT">ASSERT</A> macros. For more information about these functions, see <A CLASS=TCTOP HREF="dssd0272.htm" TARGET="TEXT">CCritSec Debug Functions</A>.

<P>For debug logging of each lock and unlock of a given critical section, you might want to use the DirectShow <A HREF="dssd0272.htm#fmutil_0001060304000300" TARGET="TEXT">DbgLockTrace</A> function.

<P><B>Note</B>  Logging can affect performance.<A NAME="debug_0001060401010600"></A><P><B>Pointer Validation</B>
<P>Consider using the pointer validation macros. For example, you can call <A HREF="dssd0294.htm#fmdebug_0001060406000200" TARGET="TEXT">ValidateReadPtr</A> to ensure that the given pointer actually points to readable memory. Note the performance cost of each of these calls. Currently, the DirectShow pointer validation macros are built on top of the Win32 pointer validation functions such as <A HREF="dssd0406.htm#external_00010a01090000ad" TARGET="TEXT">IsBadReadPtr</A>. On some systems, the Win32 pointer validation functions swap in every page in the range specified. For more information about validation macros, see <A CLASS=TCTOP HREF="dssd0294.htm" TARGET="TEXT">Pointer Validation Macros</A>.

<A NAME="debug_0001060401010700"></A><P><B>DLL Base Address Conflicts</B>
<P>If you copy any sample makefile to create any new DLL, including filters and plug-in distributors (PIDs), ensure you change the base address to avoid collisions with other DLLs. A <I>collision</I> of DLL load address results in one of the DLLs having to be relocated during the time of loading. This increases the load time for that DLL.

<P>In the sample makefiles, the DLL base address is set in DLL_BASE, which is used in ActiveX.mak. Do not let ActiveX.mak use the default value for DLL_BASE, because this will cause collisions.


<A NAME="debug_0001060401020000"></A><P><B>Using Different Kinds of Builds</B>
<P>DirectShow can be built for three kinds of builds: retail, debug, and performance. See <A CLASS=TCTOP HREF="dssd0405.htm#reserved_00010a0108000000" TARGET="TEXT">Reserved Identifiers</A> for information on the kinds of builds. Debugging has varying degrees of difficulty for the three kinds of builds, depending on the situation. For instance, the debug build can provide much more information, but it can run so slowly as to make real-time debugging impossible.

<P>The binaries you create must match the kind of build you're using. The makefiles provided for each sample use ActiveX.mak, which comes with the DirectShow SDK. Comments at the head of ActiveX.mak explain the various nmake command-line parameters to use to obtain binaries compatible with the different DirectShow builds. Some of these parameters define identifiers like <A HREF="dssd0405.htm#reserved_00010a0108000001" TARGET="TEXT">DEBUG</A> and <A HREF="dssd0405.htm#reserved_00010a0108000002" TARGET="TEXT">PERF</A> when compiling the C or C++ code.

<P>If you must have build-dependent code, you can conditionally compile with the same identifiers that the DirectShow headers use for that purpose. See <A CLASS=TCTOP HREF="dssd0405.htm#reserved_00010a0108000000" TARGET="TEXT">Reserved Identifiers</A> for a list of the identifiers reserved for that purpose.

<P>For instance, in C or C++, you can conditionally compile code like this:

<PRE><FONT FACE="Courier" SIZE="2">
    ...   /* normal processing */
#ifdef DEBUG
    ...   /* debug only code */
#endif
    ...   /* resume normal processing */
</FONT></PRE>
<A NAME="debug_0001060401030000"></A><P><B>Debugging New Filters</B>
<P>This section discusses the following points of which you should be aware when debugging new filters:
<UL><LI><A CLASS=TCTOP HREF="dssd0289.htm#debug_0001060401030100" TARGET="TEXT">Avoid GUID Conflicts</A>
<LI><A CLASS=TCTOP HREF="dssd0289.htm#debug_0001060401030200" TARGET="TEXT">Test With the Filter Graph Editor and Other Sample Filters</A>
<LI><A CLASS=TCTOP HREF="dssd0289.htm#debug_0001060401030300" TARGET="TEXT">Add the Filter as an Additional DLL in Developer Studio</A>
</UL>
<A NAME="debug_0001060401030100"></A><P><B>Avoid GUID Conflicts</B>
<P>DirectShow uses globally unique identifiers (<A HREF="dssd0414.htm#gloss_00010b0108000001" TARGET="TEXT">GUID</A>s) to find each filter, pin, and property page. Avoid reusing any of the same <B>GUID</B>s when copying from the DirectShow sample code. The Guidgen.exe and Uuidgen.exe utilities generate unique <B>GUID</B>s.


<A NAME="debug_0001060401030200"></A><P><B>Test With the Filter Graph Editor and Other Sample Filters</B>
<P>Register your new filter. See <A CLASS=TCTOP HREF="dssd0058.htm" TARGET="TEXT">Register DirectShow Objects</A> and <A HREF="dssd0275.htm#fmutil_0001060307000300" TARGET="TEXT">AMovieDllRegisterServer2</A> for information about registering a filter.

<P>After you have registered your filter, you can use a tool called the Filter Graph Editor (also called GraphEdit, or Graphedt.exe) to insert your filter into a filter graph and connect it to other filters. You can access GraphEdit from the DXMedia SDK program group. Run GraphEdit and choose Insert Filters from the Graph menu to insert your filter. 

<P>If you are debugging an audio filter, there are two sample filters you might consider connecting to your filter to make sure it behaves as expected. You can also look at the source code for those samples to see how they implement methods and member functions. For overviews of those code samples, see <A CLASS=TCTOP HREF="dssd0365.htm#samples_0001070203030000" TARGET="TEXT">Synth Sample (Audio Synthesizer Filter)</A> and <A CLASS=TCTOP HREF="dssd0368.htm#samples_0001070206030000" TARGET="TEXT">Scope Sample (Oscilloscope Filter)</A>.

<P>After you have the Filter Graph Editor successfully loading your new filter, you can use the File Dump Filter (Dump.ax) as a useful debugging tool. For instance, it can be used to verify, bit by bit, the results of a transform filter. Build a graph manually using the Filter Graph Editor and hook the File Dump Filter onto the output of a transform or any other pin. You can also hook up the <A CLASS=TCTOP HREF="dssd0367.htm#samples_0001070205000000" TARGET="TEXT">Inftee Sample (Infinite-Pin Tee Filter)</A> (InfTee.ax), and put the File Dump Filter on one leg of the tee and the "normal" output on another to monitor what happens in the real-time case. For more information, see <A CLASS=TCTOP HREF="dssd0368.htm#samples_0001070206010000" TARGET="TEXT">Dump Sample (Dump Filter)</A>.


<A NAME="debug_0001060401030300"></A><P><B>Add the Filter as an Additional DLL in Developer Studio</B>
<P>If you're going to debug your filter with Microsoft Developer Studio version 5.0, you must tell the debugger about your filter. Here are the steps you should follow in Developer Studio to identify your filter as being a debuggable DLL:

<OL><LI>From the Project menu, choose Settings....
<LI>Select the Debug tab.
<LI>Choose "Additional DLLs" from the Category drop-down list.
<LI>Add "myfilter.ax" to the list, where "myfilter" is the name of your filter.
</OL>
<A NAME="debug_0001060401040000"></A><P><B>Detecting Leaks</B>
<P>Detecting and fixing memory leaks is another important debugging topic.

<P>Visual C++ has an optional debug heap, which can be useful in tracking down memory leaks. (See the "Using the Debug Heap" section of the Visual C++ documentation for more information.) For example, the Visual C++ <A HREF="dssd0406.htm#external_00010a0109000001" TARGET="TEXT">_CrtSetDbgFlag</A> function enables you to turn on the memory-leak-checking flag bit.

<P>Other providers of memory leak tools can be found in the Microsoft Enterprise Development Partners directory.

<P>Another kind of leak is of COM object references. You can track down object reference leaks by performing the following steps.

<OL><LI>Put a break point on the <A HREF="dssd0265.htm#Lib_000106024b030300" TARGET="TEXT">NonDelegatingAddRef</A> and <A HREF="dssd0265.htm#Lib_000106024b030500" TARGET="TEXT">NonDelegatingRelease</A> methods of that object.
<LI>Use Developer Studio (or another debugger) and step through every reference count change, trying to pair them up.
<LI>Look at the call stack for each change.
</OL>
<P><P><FONT FACE="MS SANS SERIF" SIZE="1" COLOR="BLACK">
<A CLASS=cpslug HREF="copyrite.htm" TARGET="TEXT">&#169; 1998 Microsoft Corporation. All rights reserved. Terms of Use.</A>
</FONT>
<BR CLEAR=ALL><P>
</FONT><P>
</BODY></HTML>
