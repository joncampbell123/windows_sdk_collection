<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<HTML>
<HEAD><TITLE>Further Reading</TITLE>
<STYLE>
<!--
.tctop {color: blue}
.cpslug {color: blue; text-decoration: none}
-->
</STYLE>
<SCRIPT LANGUAGE="JAVASCRIPT">
//<!--
function ShowButtons() {
    if (window.top.frames.length!=0 && window.top.frames[0].ShowButtons!=null)
	window.top.frames[0].ShowButtons('/rm0037.htm','/rm0000.htm','/rm0006.htm','/index.htm','/rm0039.htm');
}
ShowButtons();
//-->
</SCRIPT>
</HEAD>
<BODY onLoad="ShowButtons()" TOPMARGIN=10 BGPROPERTIES="FIXED" BGCOLOR="#FFFFFF" LINK="#000000" VLINK="#808080" ALINK="#000000">
<FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">
<H2><A NAME="external_0001010620000000">Further Reading</A></H2>
<BR CLEAR=ALL>
<P> 
<DL>
<DT><B><A NAME="external_0001010620000001">Color Keying</A></B>
</DT><DD>A color key is typically a single uncommon color that the artist does not use for anything but transparency, but it can also be a specified range of colors. Using the <B>IDirectDrawSurface3::SetColorKey</B> method, you can set the color key for a surface. After the color key is set, subsequent calls to <B>IDirectDrawSurface3::BltFast</B> take advantage of that color key, ignoring the pixels that match it. This type of color key is known as a source color key. Because the source color key prevents "transparent" pixels from being written to the destination, the original background pixels are preserved in these places, making it look like a sprite is a non-rectangular object passing over the background. You can also use a color key that effects the destination surface (a destination color key).

<P>A destination color key is a color on a surface that is used for pixels that can be overwritten by a sprite. Again, the artist chooses an arbitrary color that is not used elsewhere in the image, reserving it as a portion of the image where you are allowed to blit. When you blit a sprite to the destination surface with a destination color key specified, the sprite's pixels will only be blitted to pixels on the destination that are using the destination color key. Because the normal destination pixels are preserved, it looks like the sprite passes behind the image on the destination surface. For more information, see "Transparent Blitting and Color Keys" in the "Sprite Concepts" topic of the "DirectDraw Getting Started: Basic Graphics Concepts" section of the <I>DirectX Foundation SDK</I>.

</DD><DT><B><A NAME="external_0001010620000002">D3DCOLOR_MONO</A></B>
</DT><DD>A value of the <A HREF="rm0036.htm#rmtypes_000101061e000200" TARGET="TEXT">D3DRMCOLORMODEL</A> constant that tells the system to use a monochromatic model (or ramp model). In this model, the blue component of a vertex color is used to define the brightness of a lit vertex. 

</DD><DT><B><A NAME="external_0001010620000003">D3DCOLOR_RGB</A></B>
</DT><DD>A value of the <A HREF="rm0036.htm#rmtypes_000101061e000200" TARGET="TEXT">D3DRMCOLORMODEL</A> constant that tells the system to use a full RGB model.

</DD><DT><B><A NAME="external_0001010620000004">D3DCOLORMODEL</A></B>
</DT><DD>A constant that defines the color model in which the system will run. 
<PRE><FONT FACE="Courier" SIZE="2">
typedef enum _D3DCOLORMODEL { 
    D3DCOLOR_MONO = 1, 
    D3DCOLOR_RGB  = 2, 
} D3DCOLORMODEL; 
</FONT></PRE>
</DD><DT><B><A NAME="external_0001010620000005">D3DDEVICEDESC</A></B>
</DT><DD>A structure that contains a description of the current device. For more information, see "Structures" in the <I>DirectX Foundation Immediate Mode Reference</I>.


</DD><DT><B><A NAME="external_0001010620000006">D3DENUMDEVICESCALLBACK</A></B>
</DT><DD>The prototype definition for the callback function to enumerate installed Direct3D devices. For more information, see "Callback Functions" in the <I>DirectX Foundation Immediate Mode Reference</I>.
<PRE><FONT FACE="Courier" SIZE="2">
typedef HRESULT (FAR PASCAL * LPD3DENUMDEVICESCALLBACK)
  (LPGUID lpGuid,                     
  LPSTR lpDeviceDescription,          
  LPSTR lpDeviceName,                 
  LPD3DDEVICEDESC lpD3DHWDeviceDesc,  
  LPD3DDEVICEDESC lpD3DHELDeviceDesc,  
  LPVOID lpUserArg                    
);
</FONT></PRE>
</DD><DT><B><A NAME="external_0001010620000007">D3DMATRIX</A></B>
</DT><DD>A structure that describes a matrix.
<PRE><FONT FACE="Courier" SIZE="2">
typedef struct _D3DMATRIX { 
    D3DVALUE _11, _12, _13, _14; 
    D3DVALUE _21, _22, _23, _24; 
    D3DVALUE _31, _32, _33, _34; 
    D3DVALUE _41, _42, _43, _44; 
} D3DMATRIX, *LPD3DMATRIX; 
</FONT></PRE>
</DD><DT><B><A NAME="external_0001010620000008">D3DPRIMCAPS</A></B>
</DT><DD>A structure that defines the capabilities for each primitive type. Used by <A HREF="rm0010.htm#rmid3drm_0001010604000500" TARGET="TEXT">IDirect3DRM::CreateDeviceFromClipper</A> and <A HREF="rm0011.htm#rmid3dr2_0001010605000500" TARGET="TEXT">IDirect3DRM2::CreateDeviceFromClipper</A> to set these default capabilities:
<P>
<B><A NAME="external_0001010620000009">D3DPCMPCAPS_LESSEQUAL</A></B> &#151; Pass the z-buffer comparison if the new z is less than or equal to the current z.
 
<P>
<B><A NAME="external_000101062000000a">D3DPMISCCAPS_CULLCCW</A></B> &#151; The driver supports counterclockwise culling through the <B>D3DRENDERSTATE_CULLMODE</B> state. (This applies only to triangle primitives.)
<P>
<B><A NAME="external_000101062000000b">D3DPRASTERCAPS_FOGVERTEX</A></B> &#151; The device calculates the fog value during the lighting operation, places the value into the alpha component of the D3DCOLOR value given for the specular member of the D3DTLVERTEX structure, and interpolates the fog value during rasterization. 
<P>
<B><A NAME="external_000101062000000c">D3DPSHADECAPS_ALPHAFLATSTIPPLED</A></B> &#151; The device can support an alpha component for flat blended and stippled transparency, respectively (the D3DSHADE_FLAT state for the D3DSHADEMODE enumerated type). In these modes, the alpha color component for a primitive is provided as part of the color for the first vertex of the primitive. </DD><DD><B><A NAME="external_000101062000000d">D3DPTADDRESSCAPS_WRAP</A></B> &#151; The device can wrap textures to addresses. 
<P>
<B><A NAME="external_000101062000000e">D3DPTBLENDCAPS_COPY</A></B> | <B><A NAME="external_000101062000000f">D3DPTBLENDCAPS_MODULATE</A></B> &#151; The copy texture-blending mode (D3DTBLEND_COPY from the D3DTEXTUREBLEND enumerated type) and the modulate texture-blending mode (D3DTBLEND_MODULATE from the D3DTEXTUREBLEND enumerated type) are supported. 
<P> 
<B><A NAME="external_0001010620000010">D3DPTEXTURECAPS_PERSPECTIVE</A></B> | <B><A NAME="external_0001010620000011">D3DPTEXTURECAPS_TRANSPARENCY</A></B> &#151; Perspective correction and texture transparency are supported.
<P>
<B><A NAME="external_0001010620000012">D3DPTFILTERCAPS_NEAREST</A></B> &#151; The texel (a single element of a texture) with coordinates nearest to the desired pixel value is used. This applies to both zooming in and zooming out. If either zooming in or zooming out is supported, then both must be supported.

 
</DD><DT><B><A NAME="external_0001010620000013">D3DRECT</A></B>
</DT><DD>A structure that is a rectangle definition.
<PRE><FONT FACE="Courier" SIZE="2">
typedef struct _D3DRECT { 
    union { 
        LONG x1;  
        LONG lX1;  //upper left x
    }; 
    union { 
        LONG y1; 
        LONG lY1;  //upper left y
    }; 
    union { 
        LONG x2; 
        LONG lX2; //lower right x
    }; 
    union { 
        LONG y2; 
        LONG lY2;  //lower right y
    }; 
} D3DRECT, *LPD3DRECT; 
</FONT></PRE>
</DD><DT><B><A NAME="external_0001010620000014">D3DTRIANGLE</A></B>
</DT><DD>The structure that describes the base type for all triangles. The triangle is the main rendering primitive.

</DD><DT><B><A NAME="external_0001010620000015">D3DVALUE</A></B>
</DT><DD>The fundamental Direct3D fractional data type.
<PRE><FONT FACE="Courier" SIZE="2">
typedef float D3DVALUE, *LPD3DVALUE; 
</FONT></PRE>
</DD><DT><B><A NAME="external_0001010620000016">D3DVECTOR</A></B>
</DT><DD>The structure that defines a vector for many Direct3D and Direct3D Retained Mode methods and structures.
<PRE><FONT FACE="Courier" SIZE="2">
typedef struct _D3DVECTOR { 
    union { 
        D3DVALUE x; 
        D3DVALUE dvX; 
    }; 
    union { 
        D3DVALUE y; 
        D3DVALUE dvY; 
    }; 
    union { 
        D3DVALUE z; 
        D3DVALUE dvZ; 
    }; 
} D3DVECTOR, *LPD3DVECTOR; 
</FONT></PRE>
</DD><DT><B><A NAME="external_0001010620000017">DirectDrawCreate</A></B>
</DT><DD>A function that creates an instance of a DirectDraw object. For more information, see "Functions" in the <I>DirectX Foundation DirectDraw Reference</I>. 

</DD><DT><B><A NAME="external_0001010620000018">DirectDrawCreateClipper</A></B>
</DT><DD>A function that creates an instance of a DirectDrawClipper object not associated with a DirectDraw object. For more information, see "Functions" in the <I>DirectX Foundation DirectDraw Reference</I>. 


</DD><DT><B><A NAME="external_0001010620000019">IDirect3D</A></B>
</DT><DD>Applications use the methods of the <B>IDirect3D2</B> interface to create Direct3D objects and to set up the environment. For more information, see "IDirect3D2" in the "Interfaces" topic in <I>DirectX Foundation Immediate Mode Reference</I>.
</DD><DD><B><A NAME="external_000101062000001a">IDirect3D::EnumDevices</A></B> &#151; This method enumerates all Direct3D device drivers installed on the system.
</DD><DD><B><A NAME="external_000101062000001b">IDirect3D::FindDevice</A></B> &#151; This method finds a device with the specified characteristics and retrieves a description of it.


</DD><DT><B><A NAME="external_000101062000001c">IDirectDrawClipper</A></B>
</DT><DD>Applications use the methods of the <B>IDirectDrawClipper</B> interface to manage clip lists. For more information, see the <I>DirectX Foundation DirectDraw Reference</I>. 
</DD><DD><B><A NAME="external_000101062000001d">IDirectDrawClipper::SetHWnd</A></B> &#151; This method sets the window handle that will obtain the clipping information.

</DD><DT><B><A NAME="external_000101062000001e">IUnknown Interface</A></B>
 </DT><DD>All Component Object Model (COM) interfaces are derived from the IUnknown interface. This interface provides control of the object's lifetime and the ability to navigate multiple interfaces. IUnknown has three methods: <B>AddRef</B>, which increments the object's reference count by 1 when an interface or another application binds itself to the object; <B>QueryInterface</B>, which queries the object about the features it supports by requesting pointers to a specific interface; <B>Release</B>, which decrements the object's reference count by 1. When the count reaches 0, the object is deallocated.
<P>
</DD><DD><B><A NAME="external_000101062000001f">IUnknown::AddRef</A></B> and <B><A NAME="external_0001010620000020">IUnknown::Release</A></B> &#151; These <A HREF="rm0038.htm#external_000101062000001e" TARGET="TEXT">IUnknown</A> methods maintain an object's reference count. For example, if you create a DirectPlay object (with <B>CoCreateInstance</B>, for example), the object's reference count is set to 1. Every time a function returns a pointer to an interface for that object, the function must call <B>AddRef</B> through that pointer to increment the reference count. You must match each <B>AddRef</B> call with a call to <B>Release</B>. Before the pointer can be destroyed, you must call <B>Release</B> through that pointer. After an object's reference count reaches 0, the object is destroyed and all interfaces to it become invalid.

</DD><DD><B><A NAME="external_0001010620000021">IUnknown::QueryInterface</A></B> &#151; This <A HREF="rm0038.htm#external_000101062000001e" TARGET="TEXT">IUnknown</A> method determines whether an object supports a specific interface. If an object supports the interface, <B>QueryInterface</B> returns a pointer to that interface. You then can use the methods contained in that interface to communicate with the object. If <B>QueryInterface</B> successfully returns a pointer to an interface, it implicitly calls <B>AddRef</B> to increment the reference count, so your application must call <B>Release</B> to decrement the reference count before destroying the pointer to the interface.

</DD><DT><B><A NAME="external_0001010620000022">Mipmaps</A></B> 
</DT><DD>A mipmap is a sequence of textures, each of which is a progressively lower resolution, prefiltered representation of the same image. Each prefiltered image, or level, in the mipmap is a power of two smaller than the previous level. A high-resolution level is used for objects that are close to the viewer. Lower-resolution levels are used as the object moves farther away. Mipmapping is a computationally low-cost way of improving the quality of rendered textures. For more information, see "Mipmaps" in the "Textures" topic in the "Direct3D Immediate-Mode Essentials" section of the <I>DirectX Foundation SDK</I>.
 
</DD><DT><B><A NAME="external_0001010620000023">Texture Map Formats</A></B> 
</DT><DD>A wide range of texture pixel formats are supported by the Microsoft&#174; DirectX&#174; hardware-emulation layer. The table in "Texture Map Formats" in the "Pixel Format Masks" topic in the <I>DirectX Foundation DirectDraw Reference</I> shows these formats. 

</DD></DL>
<P><P><FONT FACE="MS SANS SERIF" SIZE="1" COLOR="BLACK">
<A CLASS=cpslug HREF="copyrite.htm" TARGET="TEXT">&#169; 1998 Microsoft Corporation. All rights reserved. Terms of use.</A>
</FONT>
<BR CLEAR=ALL><P>
</FONT><P>
</BODY></HTML>
