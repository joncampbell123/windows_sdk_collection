<!-- DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN" -->

<HTML>
<HEAD><TITLE>Using Behaviors</TITLE>
<SCRIPT LANGUAGE="JavaScript"> var sRelPath = '../' </SCRIPT>


<META NAME="Description" CONTENT="Using Behaviors">
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; CHARSET=iso8859-1">
<META NAME="MS.LOCALE" CONTENT="EN-US">
<META NAME="ROBOTS" CONTENT="all">

<!-- SNIFF_START -->

<SCRIPT LANGUAGE="JAVASCRIPT">
//<!--
var g_isIE = false, g_isNav = false, g_iMaj = 0, g_sPlat = "";
// -->

</SCRIPT>
<SCRIPT SRC="../ver.js"></SCRIPT>
<SCRIPT SRC="../gloss.js"></SCRIPT>


<SCRIPT DEFER SRC="../common.js"></SCRIPT>
<SCRIPT DEFER>
//<!--
function InitPage()
{
	if (g_isIE && g_iMaj >= 4)	
	{

		SetTOC();
	}
}
//-->

</SCRIPT>

<!-- STYLE_START -->

<SCRIPT LANGUAGE="JAVASCRIPT">
//<!--
   var sVR = '../'	// Set root for the style sheet
   var sCSS = '<LINK REL="stylesheet" HREF="' + sVR;

   if(g_isIE)
   {
	   if (g_iMaj >= 4) // For MSIE 4.0 or later
	   {
		   sCSS += 'dxm_basicSDKIE4';
		   if (g_sPlat == "Win") // Windows only for now
		   {
			   document.createStyleSheet(sVR + 'dxm_advSDKIE4.css');
		   }
	   }
	   else // For MSIE 3.0 or earlier
	   {
		   sCSS += 'dxm_basicSDKIE3';
	   }
   }
   else if (g_isNav) // For all Nav versions
   {
	   sCSS += 'dxm_basicSDKNAV';
   }
   else
   {
	   sCSS += 'dxm_basicSDKIE3'; // default to IE3 sheet
   }

   sCSS += (sCSS == '' ? '' : '.css" TYPE="text/css">');

   document.write(sCSS);
//-->

</SCRIPT>
<!-- STYLE_END -->


</HEAD>
<BODY onload="InitPage(); if (g_isIE && g_iMaj >= 4){HdgrphControl(); initGloss()}" BGCOLOR="#FFFFFF">
<A NAME="pagetop"></A><A NAME="Using_Behaviors"></A>



<!-- HEADGRAPH_START -->

<TABLE CLASS="main" BORDER=0 CELLSPACING="0" CELLPADDING="0" WIDTH="*">
<TR>
<TD ROWSPAN="3" VALIGN="TOP" WIDTH="*">
<IMG SRC="../art/header1.gif" WIDTH="107" HEIGHT="110" BORDER=0 ALT="Using Behaviors"></TD>
<TD ROWSPAN="2" VALIGN="TOP" WIDTH="217">
<IMG SRC="../art/hdrdanim.gif" WIDTH="217" HEIGHT="110" BORDER=0 ALT="DirectAnimation Animated Header --Using Behaviors"></TD><TD VALIGN="TOP" WIDTH="383"><IMG SRC="../art/header3.gif" WIDTH="383" HEIGHT="95" BORDER=0 ALT="*">
</TD>
<TD VALIGN="TOP" WIDTH="100%">
<IMG SRC="../art/spacer1.gif" WIDTH="100%" HEIGHT="94" BORDER=0 ALT="Microsoft DirectAnimation SDK">
</TD>
</TR>
<!-- HEADGRAPH_END -->


<!-- DACONTROL_START -->

	<DIV ID="HeadGraphAnim"></DIV>
	<SCRIPT LANGUAGE="JAVASCRIPT">if((g_isIE == true) && (g_iMaj > 3)) {window.self.document.writeln('<SCR' + 'IPT SRC="../anim.js"></SCR' + 'IPT>')}</SCRIPT>
<!-- DACONTROL_END -->


<!-- NAV_LINKS_START -->


<TR><TD VALIGN="TOP"><PRE><IMG ID="TOC_" SRC="../art/yelbtn.gif" WIDTH="11" HEIGHT="11" ALIGN="MIDDLE" BORDER=0 ALT="*"><A STYLE="color:black;font-weight:bold" ID="TOC" HREF="../contents.htm">Contents</A>  <IMG SRC="../art/yelbtn.gif" WIDTH="11" HEIGHT="11" ALIGN="MIDDLE" BORDER=0 ALT="*"><A STYLE="color:black;font-weight:bold" HREF="../index.htm">Index</A>  <IMG SRC="../art/yelbtn.gif" WIDTH="11" HEIGHT="11" ALIGN="MIDDLE" BORDER=0 ALT="*"><A STYLE="color:black;font-weight:bold" HREF="proguide_oview.htm">Topic Contents</A>
</PRE></TD></TR>
<TR><TD COLSPAN="2" VALIGN="TOP"><PRE><IMG SRC="../art/yelbtn.gif" WIDTH="11" HEIGHT="11" ALIGN="MIDDLE" BORDER=0 ALT="*"><B>Previous Topic:</B> <A STYLE="color:black" HREF="proguide_MediaBehaviors.htm">Using Media Behaviors</A>
<IMG SRC="../art/yelbtn.gif" WIDTH="11" HEIGHT="11" ALIGN="MIDDLE" BORDER=0 ALT="*"><B>Next Topic:</B> <A  STYLE="color:black" HREF="proguide_UsingModels.htm">Using Models</A>
</PRE></TD></TR></TABLE>
<!-- NAV_LINKS_END -->


<!-- START POP-UP GLOSSARY -->

<SCRIPT LANGUAGE="JAVASCRIPT">if((g_isIE == true) && (g_iMaj > 3)) {window.self.document.writeln('<SCR' + 'IPT SRC="../tip.js"></SCR' + 'IPT><IFRAME ID="G_L_S" NAME="SecretBuffer" STYLE="display: none" SRC=""></IFRAME>')}</SCRIPT>
<!-- END POP-UP GLOSSARY -->



<BLOCKQUOTE CLASS="body">

<!-- CONTENTS_START -->

<H1>Using Behaviors</H1>

<P>This section describes Microsoft&reg; DirectAnimation&#153; behaviors and how to use them. 
The basic class in DirectAnimation&#153; is a <I>behavior</I>. See <A HREF="proguide_UsingBehaviors.htm#DirectAnimation_Behaviors">DirectAnimation&#153; Behaviors</A>, <A HREF="proguide_UsingBehaviors.htm#Creating_Behaviors">Creating Behaviors</A>, and <A HREF="proguide_UsingBehaviors.htm#Displaying_Behaviors">Displaying Behaviors</A> for an overview of behaviors.
<P>The topic <A HREF="proguide_UsingBehaviors.htm#Reacting_to_Events">Reacting to Events</A> describes reactive and non-reactive behaviors, events, picking, and all forms of the <A HREF="../ref_script/dastaticfunctions/DABehaviorObjects.htm#untilv_beh">Until</A> function. 
<P>The topic <A HREF="proguide_UsingBehaviors.htm#More_Ways_to_Use_Behaviors">More Ways to Use Behaviors</A> describes many useful ways to use behaviors, including reaction to events, sequencing, switching, time substitution, integrals and derivatives, and more. 

<P>This section contains the following topics.

<UL><LI><A HREF="proguide_UsingBehaviors.htm#DirectAnimation_Behaviors">DirectAnimation Behaviors</A>
<LI><A HREF="proguide_UsingBehaviors.htm#Creating_Behaviors">Creating Behaviors</A>
<LI><A HREF="proguide_UsingBehaviors.htm#Displaying_Behaviors">Displaying Behaviors</A>
<LI><A HREF="proguide_UsingBehaviors.htm#Adding_Behaviors">Adding Behaviors</A>
<LI><A HREF="proguide_UsingBehaviors.htm#Reacting_to_Events">Reacting to Events</A> 
<LI><A HREF="proguide_UsingBehaviors.htm#More_Ways_to_Use_Behaviors">More Ways to Use Behaviors</A>
<LI><A HREF="proguide_UsingBehaviors.htm#Using_Behaviors_in_Applications">Using Behaviors in Java Applications</A>
</UL>
<P>DirectAnimation is composed of several tightly integrated technologies. Different media, such as two-dimensional (2-D) and three-dimensional (3-D) images, video, and audio can be used in a single application, and all are handled in much the same way. Once you learn how to manipulate one type of media (for example, <A CLASS="Glossary" HREF="javascript:Glossary(sRelPath + 'gloss/gloss_I.htm#image')">images</A>), you can apply the same techniques to other media types, such as geometries or <A CLASS="Glossary" HREF="javascript:Glossary(sRelPath + 'gloss/gloss_S.htm#sound')">sound</A>,  simplifying media integration. 
<p>DirectAnimation provides the following services.

<UL><LI>Enables smooth, high-performance presentation of interactive graphics, sound, and video in both two and three dimensions. 
<LI>Includes optimized run-time services for animation and media streaming. The run-time services are capable of controlling both the frame and event-generation loops for the application. 
<LI>Provides media access for network entertainment and communications applications. 
<LI>Works in an HTML environment. The scripting library provides functions for animating images, <A CLASS="Glossary" HREF="javascript:Glossary(sRelPath + 'gloss/gloss_S.htm#sprite')">sprites</A>, movies, sound, and other 2-D and 3-D objects. The library works in conjunction with the DirectAnimation integrated-media control (<A HREF="../ref_script/class/DAViewerControlClass.htm#DAViewerControl_Class">DAViewerControl</A>). 
</UL>
<H2><A NAME="DirectAnimation_Behaviors" IDX_CONCEPT="noindex; Behaviors, summary">DirectAnimation Behaviors</A></H2>
<P>DirectAnimation supports a set of classes and functions (and Java classes and methods) that are used to construct time-varying, interactive behaviors. 

<P>DirectAnimation can perform sequences of operations on images, <A CLASS="Glossary" HREF="javascript:Glossary(sRelPath + 'gloss/gloss_G.htm#geometry')">geometry</A>, or sounds. One of the most important features of the media operations available in DirectAnimation is that animations are completely encapsulated (completely defined within DirectAnimation) and composable (the result of one operation is operated on by the next operation and so on). This provides flexibility, expressiveness, and power with a relatively small number of base operations. 

<P>Any element of these compositions can be animated and made interactive. 

<P>The following table summarizes the behaviors available in DirectAnimation.</P>

<TABLE>
<TR><TH>Category</TH><TH>Scripting class/Java class</TH><TH>Description</TH></TR>

<TR><TD>any</TD>
<TD><A HREF="../ref_script/class/DAArrayClass.htm#DAArray_Class">DAArray</A>/<A HREF="../ref_java/class/ArrayBvr.htm#ArrayBvr_Class">ArrayBvr</A></TD>
<TD>Arrays of behaviors that are all the same type. Objects can be selected from the array based on a time-varying index.

</TD>
</TR>
<TR><TD>2-D/3-D</TD>
<TD><A HREF="../ref_script/class/DABbox2Class.htm#DABbox2_Class">DABbox2</A>/<A HREF="../ref_java/class/Bbox2Bvr.htm#Bbox2Bvr_Class">Bbox2Bvr</A> and <A HREF="../ref_script/class/DABbox3Class.htm#DABbox3_Class">DABbox3</A>/<A HREF="../ref_java/class/Bbox3Bvr.htm#Bbox3Bvr_Class">Bbox3Bvr</A> </TD>
<TD>The <A HREF="../ref_script/class/DABbox2Class.htm#DABbox2_Class">DABbox2</A> and <A HREF="../ref_java/class/Bbox2Bvr.htm#Bbox2Bvr_Class">Bbox2Bvr</A> behaviors represent two-dimensional <A CLASS="Glossary" HREF="javascript:Glossary(sRelPath + 'gloss/gloss_B.htm#bounding_box')">bounding boxes</A>. Extracting a bounding box from an image results in a box that encloses all the tangible parts of the image.
<P>The <A HREF="../ref_script/class/DABbox3Class.htm#DABbox3_Class">DABbox3</A> and <A HREF="../ref_java/class/Bbox3Bvr.htm#Bbox3Bvr_Class">Bbox3Bvr</A> behaviors represent three-dimensional bounding boxes. Extracting a bounding box from a geometry results in a box that encloses all the tangible parts of the geometry.

</TD>
</TR>
<TR><TD>logic</TD>
<TD><A HREF="../ref_script/class/DABooleanClass.htm#DABoolean_Class">DABoolean</A>/<A HREF="../ref_java/class/BooleanBvr.htm#BooleanBvr_Class">BooleanBvr</A> </TD>
<TD>Animated TRUE/FALSE values. Traditional Boolean operations such as <A HREF="../ref_script/dastaticfunctions/DABooleanObjects.htm#andv_bool">And</A>, <A HREF="../ref_script/dastaticfunctions/DABooleanObjects.htm#notv_bool">Not</A>, and <A HREF="../ref_script/dastaticfunctions/DABooleanObjects.htm#orv_bool">Or</A> are available. <A HREF="../ref_script/dastaticfunctions/DABooleanObjects.htm#keyStatev_misc">KeyState</A> returns a Boolean object that is true when the specified key is down, and false when the key is up. 

</TD>
</TR>
<TR><TD>2-D/3-D</TD>
<TD><A HREF="../ref_script/class/DAColorClass.htm#DAColor_Class">DAColor</A>/<A HREF="../ref_java/class/ColorBvr.htm#ColorBvr_Class">ColorBvr</A> </TD>
<TD>Animated <A CLASS="Glossary" HREF="javascript:Glossary(sRelPath + 'gloss/gloss_C.htm#color')">color</A> values in an abstract color space. The run time supports all color bit depths. These behaviors can be constructed by supplying three animated numbers (<A HREF="../ref_script/class/DANumberClass.htm#DANumber_Class">DANumber</A>s or <A HREF="../ref_java/class/NumberBvr.htm#NumberBvr_Class">NumberBvr</A>s) that are interpreted as either Red/Green/Blue or as Hue/Saturation/Lightness components. 
 
</TD>
</TR>
<TR><TD>3-D</TD>
<TD><A HREF="../ref_script/class/DACameraClass.htm#DACamera_Class">DACamera</A>/<A HREF="../ref_java/class/CameraBvr.htm#CameraBvr_Class">CameraBvr</A></TD>
<TD>Movie <A CLASS="Glossary" HREF="javascript:Glossary(sRelPath + 'gloss/gloss_C.htm#camera')">camera</A> to turn a 3-D scene into an animated image. All camera attributes can be animated. The camera is used with the <A HREF="../ref_script/class/DAGeometryClass.htm#rendercamv_g">Render</A> function on <A HREF="../ref_script/class/DAGeometryClass.htm#DAGeometry_Class">DAGeometry</A> to project a geometry onto an image. There are two basic types of cameras: one for parallel projection and one for perspective projection. Both types of cameras are oriented so that they point in the negative z direction, with positive y considered up. Both types of cameras have a near clipping plane. This plane (a product of Z-buffered rendering) specifies the closest distance at which an object is visible. Objects closer than the near clipping plane cannot be seen. 
<P>Cameras are manipulated through standard three-dimensional transform operations. These transforms modify the camera characteristics and also position and orient the camera.


</TD>
</TR>
<TR><TD>text</TD>
<TD><A HREF="../ref_script/class/DAFontStyleClass.htm#DAFontStyle_Class">DAFontStyle</A>/<A HREF="../ref_java/class/FontStyleBvr.htm#FontStyleBvr_Class">FontStyleBvr</A></TD>
<TD>Specifies the font face, size, color, and attributes (such as bold or italic). The functions and methods of these behaviors are similar to the HTML tags specifying the font characteristics.

</TD>
</TR>
<TR><TD>3-D</TD>
<TD><A HREF="../ref_script/class/DAGeometryClass.htm#DAGeometry_Class">DAGeometry</A>/<A HREF="../ref_java/class/GeometryBvr.htm#GeometryBvr_Class">GeometryBvr</A> </TD>
<TD>3-D geometry, the primary 3-D data type. Can be created by importing .X files; by applying transformations to existing geometries; by applying material properties to geometries; by combining multiple geometries; by embedding sound into 3-D; by specifying 3-D lights; by applying <A HREF="../ref_script/class/DAImageClass.htm#DAImage_Class">DAImage</A>s and <A HREF="../ref_java/class/ImageBvr.htm#ImageBvr_Class">ImageBvr</A>s behaviors as <A CLASS="Glossary" HREF="javascript:Glossary(sRelPath + 'gloss/gloss_T.htm#texture')">textures</A>; by varying <A CLASS="Glossary" HREF="javascript:Glossary(sRelPath + 'gloss/gloss_O.htm#opacity')">opacity</A>, and so on. 
Given a <A HREF="../ref_script/class/DACameraClass.htm#DACamera_Class">DACamera</A> or <A HREF="../ref_java/class/CameraBvr.htm#CameraBvr_Class">CameraBvr</A>, a geometry can be projected onto an image. 

</TD>
</TR>
<TR><TD>2-D/3-D</TD>
<TD><A HREF="../ref_script/class/DAImageClass.htm#DAImage_Class">DAImage</A>/<A HREF="../ref_java/class/ImageBvr.htm#ImageBvr_Class">ImageBvr</A> </TD>
<TD>Animated images, including cell animation, bitmaps, vector-graphic animations, animated 3-D projections, partially transparent images, and animated textures for 3-D animated geometry. Images can be constructed by importing GIF, BMP, JPEG, and PNG files. Importing a movie (such as an MPEG or AVI file) also constructs an image. Images can be constructed as solid color images, by rendering text into an image; by projecting a 3-D geometry with a camera into an image; by stroking a line with a <A CLASS="Glossary" HREF="javascript:Glossary(sRelPath + 'gloss/gloss_P.htm#path')">path</A> behavior; and by creating an image by smoothly varying colors across the face of a polygon. Java AWT Images can also be used to construct a DirectAnimation <A HREF="../ref_java/class/ImageBvr.htm#ImageBvr_Class">ImageBvr</A>. 
<P>Images can also be created by overlaying two existing images; by applying an opacity value to an existing image; by clipping an image to a matte behavior; by<A CLASS="Glossary" HREF="javascript:Glossary(sRelPath + 'gloss/gloss_C.htm#crop')">cropping</A> an image to a box; by tiling an image; and by applying a <A HREF="../ref_script/class/DATransform2Class.htm#DATransform2_Class">DATransform2</A> or <A HREF="../ref_java/class/Transform2Bvr.htm#Transform2Bvr_Class">Transform2Bvr</A> to an image. Any image, even if it is time-varying and interactive, can serve as a texture on a <A HREF="../ref_script/class/DAGeometryClass.htm#DAGeometry_Class">DAGeometry</A> or <A HREF="../ref_java/class/GeometryBvr.htm#GeometryBvr_Class">GeometryBvr</A>. 

</TD>
</TR>
<TR><TD>line</TD>
<TD><A HREF="../ref_script/class/DALineStyleClass.htm#DALineStyle_Class">DALineStyle</A>/<A HREF="../ref_java/class/LineStyleBvr.htm#LineStyleBvr_Class">LineStyleBvr</A>, <A HREF="../ref_script/class/DAEndStyleClass.htm#DAEndStyle_Class">DAEndStyle</A>/<A HREF="../ref_java/class/EndStyleBvr.htm#EndStyleBvr_Class">EndStyleBvr</A>, <A HREF="../ref_script/class/DAJoinStyleClass.htm#DAJoinStyle_Class">DAJoinStyle</A>/<A HREF="../ref_java/class/JoinStyleBvr.htm#JoinStyleBvr_Class">JoinStyleBvr</A>, and <A HREF="../ref_script/class/DADashStyleClass.htm#DADashStyle_Class">DADashStyle</A>/<A HREF="../ref_java/class/DashStyleBvr.htm#DashStyleBvr_Class">DashStyleBvr</A> </TD>
<TD>Specify how lines are drawn. 
<A HREF="../ref_script/class/DALineStyleClass.htm#DALineStyle_Class">DALineStyle</A> provides for dashing, line width, line end, and line join styles when a <A HREF="../ref_script/class/DAPath2Class.htm#DADAPath2Class">DAPath2</A> is being stroked into a <A HREF="../ref_script/class/DAImageClass.htm#DAImage_Class">DAImage</A>. <A HREF="../ref_script/class/DAEndStyleClass.htm#DAEndStyle_Class">DAEndStyle</A> defines the shape applied to the end of line segments when they are drawn. <A HREF="../ref_script/class/DAJoinStyleClass.htm#DAJoinStyle_Class">DAJoinStyle</A> defines the shape of joints between intersecting line segments in a path. <A HREF="../ref_script/class/DADashStyleClass.htm#DADashStyle_Class">DADashStyle</A> defines whether lines are drawn as a continuous stroke or as a sequence of dashes. 


</TD>
</TR>
<TR><TD>2-D</TD>
<TD><A HREF="../ref_script/class/DAMatteClass.htm#DAMatte_Class">DAMatte</A>/<A HREF="../ref_java/class/MatteBvr.htm#MatteBvr_Class">MatteBvr</A></TD>
<TD>Stencils for creating animated cutouts in images. A matte can be constructed by filling in a <A HREF="../ref_script/class/DAPath2Class.htm#DADAPath2Class">DAPath2</A> or <A HREF="../ref_java/class/Path2Bvr.htm#Path2Bvr_Class">Path2Bvr</A> behavior, by constructing it from a text outline, and by performing logical operations (such as union, intersection, and difference) on other mattes. 

</TD>
</TR>
<TR><TD>sound</TD>
<TD><A HREF="../ref_script/class/DAMicrophoneClass.htm#DAMicrophone_Class">DAMicrophone</A>/<A HREF="../ref_java/class/MicrophoneBvr.htm#MicrophoneBvr_Class">MicrophoneBvr</A></TD>
<TD>Used to make sounds seem to have been recorded in a 3-D space. This behavior is used with the <A HREF="../ref_script/class/DAGeometryClass.htm#rendermicv_g">RenderSound</A> function on a geometry to extract a 3-D volume of sound from that geometry and produce a <A HREF="../ref_script/class/DASoundClass.htm#DASound_Class">DASound</A> behavior. 

</TD>
</TR>
<TR><TD>2-D</TD>
<TD><A HREF="../ref_script/class/DAMontageClass.htm#DAMontage_Class">DAMontage</A>/<A HREF="../ref_java/class/MontageBvr.htm#MontageBvr_Class">MontageBvr</A></TD>
<TD>A layered set of animated images with depth ordering, sometimes called 2.5-D images. A montage is constructed by providing an image and a potentially time-varying number as the depth value, and by uniting the montages together. The <A HREF="../ref_script/class/DAMontageClass.htm#renderv_mont">Render</A> function resolves all the depths and constructs a <A HREF="../ref_script/class/DAImageClass.htm#DAImage_Class">DAImage</A>. 

</TD>
</TR>
<TR><TD>2-D</TD>
<TD><A HREF="../ref_script/class/DANumberClass.htm#DANumber_Class">DANumber</A>/<A HREF="../ref_java/class/NumberBvr.htm#NumberBvr_Class">NumberBvr</A> 
</TD>
<TD>Time-varying numbers. For example, the <A HREF="../ref_script/dastaticfunctions/DAColorObjects.htm#colorRgbv_col">ColorRgb</A> function takes three static numbers (doubles) as parameters for the red, green, and blue values, while the <A HREF="../ref_script/dastaticfunctions/DAColorObjects.htm#colorRgbanv_col">ColorRgbAnim</A> function takes three potentially time-varying <A HREF="../ref_script/class/DANumberClass.htm#DANumber_Class">DANumber</A>s as parameters. <P>A Java <A HREF="../ref_java/class/NumberBvr.htm#NumberBvr_Class">NumberBvr</A> can be constructed by using the <A HREF="../ref_java/staticmethods/NumberBvrObjects.htm#toBvr_num">toBvr</A> method on a Java number. Many arithmetic methods are available. These include addition, subtraction, multiplication, division, exponentiation, sine, cosine, random-number sequences, integrals, and derivatives. Additionally, the time-varying seeds for animation, <A HREF="../ref_script/dastaticproperties/DANumberObjects.htm#LocalTimev_num">LocalTime</A> and <A HREF="../ref_script/dastaticproperties/DANumberObjects.htm#GlobalTimev_num">GlobalTime</A>
are <A HREF="../ref_script/class/DANumberClass.htm#DANumber_Class">DANumber</A>s. 

</TD>
</TR>
<TR><TD>2-D</TD>
<TD><A HREF="../ref_script/class/DAPath2Class.htm#DADAPath2Class">DAPath2</A>/<A HREF="../ref_java/class/Path2Bvr.htm#Path2Bvr_Class">Path2Bvr</A> </TD>
<TD>Animated 2-D <A CLASS="Glossary" HREF="javascript:Glossary(sRelPath + 'gloss/gloss_V.htm#vector')">vector</A> graphics (2-D geometry). These behaviors represent lines (one-dimensional paths) through two-dimensional space. Paths have a direction and can be open or closed. A path can be constructed as a series of connected line segments; as a B-spline curve; as a concatenation of other paths; or as a 2-D transformation of another path. Closed paths can be filled to create images.

</TD>
</TR>
<TR><TD>2-D</TD>
<TD><A HREF="../ref_script/class/DAPoint2Class.htm#DAPoint2_Class">DAPoint2</A>/<A HREF="../ref_java/class/Point2Bvr.htm#Point2Bvr_Class">Point2Bvr</A>, <A HREF="../ref_script/class/DAVector2Class.htm#DAVector2_Class">DAVector2</A>/<A HREF="../ref_java/class/Vector2Bvr.htm#Vector2Bvr_Class">Vector2Bvr</A></TD>
<TD>Animated 2-D points and directed magnitudes. Both points and vectors can be constructed by supplying animated numbers (<A HREF="../ref_script/class/DANumberClass.htm#DANumber_Class">DANumber</A>s or <A HREF="../ref_java/class/NumberBvr.htm#NumberBvr_Class">NumberBvr</A>s) that can be interpreted either as Cartesian coordinates or polar coordinates. Available operations include subtracting points to yield a vector, adding a vector to a point, determining the distance between points, creating a point from a B-spline, and taking the derivative of either a point or a vector. 

</TD>
</TR>
<TR><TD>3-D</TD>
<TD><A HREF="../ref_script/class/DAPoint3Class.htm#DAPoint3_Class">DAPoint3</A>/<A HREF="../ref_java/class/Point3Bvr.htm#Point3Bvr_Class">Point3Bvr</A>, <A HREF="../ref_script/class/DAVector3Class.htm#DAVector3_Class">DAVector3</A>/<A HREF="../ref_java/class/Vector3Bvr.htm#Vector3Bvr_Class">Vector3Bvr</A></TD>
<TD>Animated 3-D points and directed magnitudes. These behaviors are the 3-D analogs of <A HREF="../ref_script/class/DAPoint2Class.htm#DAPoint2_Class">DAPoint2</A>/<A HREF="../ref_java/class/Point2Bvr.htm#Point2Bvr_Class">Point2Bvr</A> and <A HREF="../ref_script/class/DAVector3Class.htm#DAVector3_Class">DAVector3</A>/<A HREF="../ref_java/class/Vector3Bvr.htm#Vector3Bvr_Class">Vector3Bvr</A> behaviors. 



</TD>
</TR>
<TR><TD>sound,<br>3-D</TD>
<TD><A HREF="../ref_script/class/DASoundClass.htm#DASound_Class">DASound</A>/<A HREF="../ref_java/class/SoundBvr.htm#SoundBvr_Class">SoundBvr</A></TD>
<TD>The main sound data type, which can have animated properties such as gain. Sound can be embedded in a geometry to occupy a 3-D space and then rendered with a microphone. Sound can be created by importing MIDI, WAV, and video files, by applying methods that affect gain, phase, frequency, and pan, or by mixing existing sounds. Also, limited audio synthesis is supported. 


</TD>
</TR>
<TR><TD>text</TD>
<TD><A HREF="../ref_script/class/DAStringClass.htm#DAString_Class">DAString</A>/<A HREF="../ref_java/class/StringBvr.htm#StringBvr_Class">StringBvr</A></TD>
<TD>Strings of characters. The JScript syntax for creating a <A HREF="../ref_script/class/DAStringClass.htm#DAString_Class">DAString</A> is:
<PRE>
   AnimStr = m.DAString(&quot;string&quot;);
</PRE>
<P><A HREF="../ref_java/class/StringBvr.htm#StringBvr_Class">StringBvr</A>s can be constructed from Java strings. Simple operations such as concatenation (<A HREF="../ref_script/dastaticfunctions/DAStringObjects.htm#concatv_str">ConcatString</A> or the Java <A HREF="../ref_java/staticmethods/StringBvrObjects.htm#concat_str">concat</A>) are available. For example:
<PRE>
   MyStr = m.ConcatString(&quot;My&quot;, &quot; String&quot;);
</PRE>
</TD>
</TR>
<TR><TD>2-D</TD>
<TD><A HREF="../ref_script/class/DATransform2Class.htm#DATransform2_Class">DATransform2</A>/<A HREF="../ref_java/class/Transform2Bvr.htm#Transform2Bvr_Class">Transform2Bvr</A></TD>
<TD>Animated scaling, rotation, shearing, and translation in 2-D. Transformations can be constructed from translations, uniform and non-uniform scales, rotations, 3 by 2 matrices, and composition of other transforms.

</TD>
</TR>
<TR><TD>3-D</TD>
<TD><A HREF="../ref_script/class/DATransform3Class.htm#DATransform3_Class">DATransform3</A>/<A HREF="../ref_java/class/Transform3Bvr.htm#Transform3Bvr_Class">Transform3Bvr</A></TD>
<TD>Animated scaling, rotation, shearing, and translation in 3-D. These behaviors are the 3-D analogs of <A HREF="../ref_script/class/DATransform2Class.htm#DATransform2_Class">DATransform2</A> and <A HREF="../ref_java/class/Transform2Bvr.htm#Transform2Bvr_Class">Transform2Bvr</A>. 


</TD>
</TR>
<TR><TD>any</TD>
<TD><A HREF="../ref_script/class/DATupleClass.htm#DATuple_Class">DATuple</A>/<A HREF="../ref_java/class/TupleBvr.htm#TupleBvr_Class">TupleBvr</A></TD>
<TD>Arrays of behaviors that can be different types. Objects can be selected from the list based on an index.

</TD>
</TR>
</TABLE>

<P>Remember, all attributes of all behavior types can be animated and can react to events. 


<H2><A NAME="Creating_Behaviors">Creating Behaviors</A></H2>
<P>Once you have declared your <A HREF="../ref_script/class/DAViewerControlClass.htm#DAViewerControl_Class">DAViewerControl</A> object, as shown in the section on <A HREF="proguide_basics.htm#Scripting">Scripting</A>, you assign a variable to the object (attached to either the <A HREF="../ref_script/class/DAViewerControlClass.htm#pixelv_control">PixelLibrary</A> or the <A HREF="../ref_script/class/DAViewerControlClass.htm#meterv_control">MeterLibrary</A>, depending on the units you want to use). Through the variable (<I>m</I> in the following example), you access functions and properties in the <A HREF="../ref_script/class/DAStaticsClass.htm#DAStatics_Class">DAStatics</A> library. You use these functions and properties to construct behavior types.
<PRE>
    m = DAViewer.PixelLibrary;
    im = m.SolidColorImage(m.Red);
</PRE>
<P>Compound behaviors are produced by operations that take behaviors and produce new modified behaviors from them, rather than by modifying the original behavior. For example:

<PRE>
   mySound = m.ImportSound(&quot;file://c:/dxmedia/media/sound/clock1.mp2&quot;).Sound;

  // Loop the imported sound with the position-varying pan for 12 seconds, then 
  // silence the sound.
  DAViewer.Sound = m.Until(mySound.Loop().PanAnim(panFac),m.Timer(12),m.Silence);  
 </PRE>
<P>Java behavior types are created by declaring a behavior and assigning it a value, as shown in the following code: 

<PRE>
     ImageBvr im = solidColorImage(red);
</PRE>
<P>Compound Java behaviors are produced in the same way as compound scripting behaviors. For example:

<PRE>  
      URL geomBase = buildURL(getImportBase(),&quot;file:/c:/DxM/Media/geometry/&quot;);
      GeometryBvr geom = importGeometry(buildURL(geomBase,&quot;cube.x&quot;));
      GeometryBvr geom2 = geom.diffuseColor(red);
</PRE>
<P>In this case, the original behavior <I>geom</I> is cube. The new behavior <I>geom2</I> is a red cube. 

<P>Alternatively, because each of these methods produces a value, you could combine them into the following statement: 

<PRE>
     GeometryBvr geom2 = importGeometry(buildURL(geomBase,&quot;cube.x&quot;)).diffuseColor(red);
</PRE>
<H2><A NAME="Displaying_Behaviors">Displaying Behaviors</A></H2>
<P>In DirectAnimation, only sound and image behaviors are actually rendered or displayed. The final animation consists of some combination of image behaviors and sound behaviors. 
<P>The <A HREF="../ref_script/class/DAViewerControlClass.htm#DAViewerControl_Class">DAViewerControl</A> class displays DirectAnimation behaviors in an HTML page. Here is an example of how it is specified:
<PRE>

&lt;DIV ID=controlDiv&gt;
&lt;OBJECT ID=&quot;DAViewer&quot;
        STYLE=&quot;position:absolute; left:10; top:10;width:450;height:450&quot;
        CLASSID=&quot;CLSID:B6FFC24C-7E13-11D0-9B47-00C04FC2F51D&quot;&gt;
&lt;/OBJECT&gt;
&lt;/DIV&gt;

</PRE>
<P>The actual behavior to be rendered is set as the <A HREF="../ref_script/class/DAViewerControlClass.htm#imagev_control">Image</A> property or <A HREF="../ref_script/class/DAViewerControlClass.htm#soundv_control">Sound</A> property of <A HREF="../ref_script/class/DAViewerControlClass.htm#DAViewerControl_Class">DAViewerControl</A>. The rendering is invoked with the <B>DAViewerControl</B> subroutine <A HREF="../ref_script/class/DAViewerControlClass.htm#startv_control">Start()</A>. Whatever <B>Image</B> property or <B>Sound</B> property the <B>DAViewerControl</B> object has when started determines what will be rendered. For example, the following code displays a solid blue screen:
<PRE>
   m = DAViewer.MeterLibrary;
   DAViewer.Image = m.SolidColorImage(m.Blue);
   DAViewer.Start();

</PRE>
<P>In Java, you must provide an instance of the <A HREF="../ref_java/class/Model.htm#Model_Class">Model</A> class to view behaviors. The <B>Model</B> class method <A HREF="../ref_java/class/Model.htm#createModel_model">createModel</A> builds the behaviors to be viewed.
<P>Applications override the <A HREF="../ref_java/class/Model.htm#Model_Class">Model</A> class and implement the <A HREF="../ref_java/class/Model.htm#createModel_model">createModel</A> method. This method creates the set of behaviors to be displayed and calls the <A HREF="../ref_java/class/Model.htm#setImage_model">setImage</A> and <A HREF="../ref_java/class/Model.htm#setSound_model">setSound</A> methods on the image and sound behaviors that are intended to be viewed. 
<P>The DirectAnimation system is responsible for invoking the <A HREF="../ref_java/class/Model.htm#createModel_model">createModel</A> method. 
<P>Behaviors are run as soon as the model starts. 



<P>The following code shows how to use the <A HREF="../ref_java/class/Model.htm#Model_Class">Model</A> class to construct a blue image. 

<PRE>public class RedImg extends Model {
  // Create the image behavior that will be displayed 
  public void createModel(BvrsToRun blist) {
    ImageBvr im = solidColorImage(blue);
    setImage(im);
    }
}
</PRE>
<P>Java behaviors that are not part of the model can also be run when the model is started by calling <A HREF="../ref_java/class/Model.htm#createModel_model">createModel</A> with the <I>BvrsToRun</I> parameter. For example: 

<PRE>
public class OutsideBehavior extends Model {
    public void createModel(BvrsToRun blist)) {
        ...
    }
}
</PRE>
<P>The behaviors in <I>blist</I> will be run when the model is started.

<H2><A NAME="Adding_Behaviors">Adding Behaviors</A></H2>

<p>The <B>DAViewerControl</B> displays a DirectAnimation model in an HTML page. The <B>DAViewerControl</B> method, <A HREF="../ref_script/class/DAViewerControlClass.htm#addbvrv_control">AddBehaviorToRun</A>, adds behaviors to the control that are not specified in the model. When the system starts the model, it retrieves these additional behaviors and runs them with the same start time as the behaviors included in the model.

<P>As an example, consider the following VBScript sample, which displays the local time as a text value.</P>
<PRE>
&lt;HTML&gt;
&lt;BODY&gt;
&lt;CENTER&gt;&lt;INPUT TYPE=&quot;TEXT&quot; NAME=&quot;txtInp&quot; VALUE=&quot;&quot;&gt;&lt;/CENTER&gt;
&lt;OBJECT ID=&quot;DAControl&quot; WIDTH=400 HEIGHT=300
CLASSID=&quot;CLSID:B6FFC24C-7E13-11D0-9B47-00C04FC2F51D&quot;&gt;
&lt;/OBJECT&gt;
&lt;/HTML&gt;
&lt;/BODY&gt;

&lt;OBJECT ID=&quot;DAControl&quot; WIDTH=400 HEIGHT=300
CLASSID=&quot;CLSID:B6FFC24C-7E13-11D0-9B47-00C04FC2F51D&quot;&gt;
&lt;/OBJECT&gt;

&lt;SCRIPT LANGUAGE=&quot;VBScript&quot;&gt;
Sub window_onLoad
   Set m = DAControl.MeterLibrary
   Set timeVal = m.Localtime
   Set timeVal = timeVal.AnimateProperty( &quot;txtInp.value&quot;, &quot;VBScript&quot;, false, .01 )
   DAControl.AddBehaviorToRun( timeVal )
   DAControl.Start
End Sub
&lt;/SCRIPT&gt;
</PRE>



<H2><A NAME="Reacting_to_Events" IDX_CONCEPT="NOINDEX; Events, Reacting to; Reacting to Events">Reacting to Events </A></H2>
<P>This section includes the following topics.
<UL><LI><A HREF="proguide_UsingBehaviors.htm#Non_Reactive_Behaviors">Non-Reactive Behaviors</A>
<LI><A HREF="proguide_UsingBehaviors.htm#Reactive_Behaviors">Reactive Behaviors</A>
<LI><A HREF="proguide_UsingBehaviors.htm#Events">Events</A>
<LI><A HREF="proguide_UsingBehaviors.htm#Picking">Picking</A>
<LI><A HREF="proguide_UsingBehaviors.htm#Until_Function">The Until Function</A>
<LI><A HREF="proguide_UsingBehaviors.htm#UntilEx_Function">The UntilEx Function</A>
<LI><A HREF="proguide_UsingBehaviors.htm#untilNotify_Method">The UntilNotify and UntilNotifyScript Methods</A>
<LI><A HREF="proguide_UsingBehaviors.htm#Until_and_LocalTime">Until and LocalTime</A>
</UL>

<H3><A NAME="Non_Reactive_Behaviors">Non-Reactive Behaviors</A></H3>
<P>All behaviors can potentially vary with time, react to events, and interact with the user. Non-reactive behaviors are those that are constant or time-varying (but do not react to events). 
<P>Constant behaviors are not time-varying. In the previous example in <A HREF="proguide_UsingBehaviors.htm#Creating_Behaviors">Creating Behaviors</A>, the rotated cube used behaviors that were constant. Using the <A HREF="../ref_script/dastaticproperties/DANumberObjects.htm#LocalTimev_num">LocalTime</A> behavior value in the <A HREF="../ref_script/dastaticfunctions/DATransform3Objects.htm#rotatedgv_xf3">Rotate3Degrees</A> method, you can construct a new red cube to spin around the y-axis at a rate of one degree per second, as shown in the following code:
<PRE>
mediaBase = &quot;..\\..\\..\\..\\media\\&quot;;
geoBase = mediaBase + &quot;geometry\\&quot;;
Geo1 = m.ImportGeometry(geoBase + &quot;cube.x&quot;).
		DiffuseColor(m.Red).Geo2.Transform(m.Rotate3Degrees(m.YVector3, m.LocalTime));

</PRE>
<P>The behavior value <A HREF="../ref_script/dastaticproperties/DANumberObjects.htm#LocalTimev_num">LocalTime</A> (and the Java equivalent <A HREF="../ref_java/staticfields/NumberBvrObjects.htm#localTime_num">localTime</A>) allows animation to be injected into behaviors. It is a number-valued behavior (<A HREF="../ref_script/class/DANumberClass.htm#DANumber_Class">DANumber</A> or Java <A HREF="../ref_java/class/NumberBvr.htm#NumberBvr_Class">NumberBvr</A>) that starts at time 0 and increases at the rate of one unit per second. It can be used as an argument to any behavior-constructing method that takes a number-valued behavior as an argument to construct a time-varying behavior. For example, consider the following statements: 
<PRE>
Sawtooth = m.Mod(m.LocalTime, 1);
MyCol = m.ColorRgb(Sawtooth, 0, 0);
</PRE>
<P>The first creates a number behavior that goes from 0 to 1, 0 to 1, 0 to 1, and so on, by taking the modulus of the ever-increasing <A HREF="../ref_script/dastaticproperties/DANumberObjects.htm#LocalTimev_num">LocalTime</A> value and 1. It then uses this value to create a time-varying color whose red component is that number behavior.
<P>Animations constructed using <A HREF="../ref_script/dastaticproperties/DANumberObjects.htm#LocalTimev_num">LocalTime</A> are unaffected by fluctuations in the frame rate of the DirectAnimation implementation. This means that the Sawtooth behavior will go from 0 to 1 in a period of 1 second, no matter how many frames are actually generated. This is a very important feature of DirectAnimation because it allows applications to be constructed independently of the hardware on which they will ultimately run. 
<P>There are other forms of time-varying input, such as <A HREF="../ref_script/dastaticproperties/DAPoint2Objects.htm#mousepositionv_pt2">MousePosition</A> that can add interactivity to behaviors. The <B>MousePosition</B> (and Java <A HREF="../ref_java/staticfields/Point2BvrObjects.htm#mouseposition_pt2">mouseposition</A>) behavior, for example, provides the continuous 2-D world-coordinate position of the mouse. It can be used, for example, as an argument to a translation function for tracking the mouse. 



<H3><A NAME="Reactive_Behaviors">Reactive Behaviors</A></H3>
<P>Non-reactive behaviors change with time but do not change as the result of discrete events. However, being able to change as a result of events (either internal or external) is important for truly useful behaviors, especially in interactive animations. 
<P>Events are discussed in the section <A HREF="proguide_UsingBehaviors.htm#Events">DirectAnimation Events</A>. The general data type for events is <A HREF="../ref_script/class/DAEventClass.htm#DAEvent_Class">DAEvent</A> and the Java <A HREF="../ref_java/class/DXMEvent.htm#DXMEvent_Class">DXMEvent</A>. This topic discusses creating behaviors that switch from one behavior to another based on events.


<H3><A NAME="Events" IDX_CONCEPT="noindex; Events in DirectAnimation">Events</A></H3>
<P>DirectAnimation events come from a number of sources, including: 

<UL><LI>Predicates. These are time-varying logical expressions (<A HREF="../ref_script/class/DABooleanClass.htm#DABoolean_Class">DABoolean</A> objects) that are converted to events. When the expression becomes true, the event is triggered. These are constructed by calling the <A HREF="../ref_script/dastaticfunctions/DAEventObjects.htm#predicatev_dxmevent">Predicate</A> function with a (<B>DABoolean</B> object. For example:
<PRE>Event1 = m.Predicate(m.LTE(var1, var2))
</PRE>
<P>That is, when the <I>var1</I> becomes less than or equal to <I>var2</I>, Event1 is triggered. 
<LI>Built-in events. There are a number of built-ins events provided, such as key press events, mouse button events, and events resulting from a pick (hit with the mouse). 
<LI>Timer events. These are events that trigger after a given amount of time has elapsed. 
<LI>Application-triggered events. Applications can construct an event, include it as part of a behavior, and then trigger it explicitly through the application, optionally providing event data along with it. 
<LI>Compound events. These are events that can be constructed from other events. For instance, <A HREF="../ref_script/dastaticfunctions/DAEventObjects.htm#andEventv_dxmevent">AndEvent</A>, <A HREF="../ref_script/dastaticfunctions/DAEventObjects.htm#orEventv_dxmevent">OrEvent</A>, and <A HREF="../ref_script/dastaticfunctions/DAEventObjects.htm#notEventv_dxmevent">NotEvent</A> take events and construct conjunction, disjunction, and negation events respectively. 
</UL>

<P>This section gives an overview of the following event topics.
<UL><LI><A HREF="proguide_UsingBehaviors.htm#Key_and_Button_Events">Key and Button Events</A> 
<LI><A HREF="proguide_UsingBehaviors.htm#Timer_Events">Timer Events</A>
<LI><A HREF="proguide_UsingBehaviors.htm#Application_Triggered_Events">Application-Triggered Events</A>
<LI><A HREF="proguide_UsingBehaviors.htm#Compound_Events">Compound Events</A>
<LI><A HREF="proguide_UsingBehaviors.htm#The_attachData_Method">The AttachData Function</A>
<LI><A HREF="proguide_UsingBehaviors.htm#Event_Data">Event Data</A>
<LI><A HREF="proguide_UsingBehaviors.htm#Picking">Picking</A>
</UL>
<H3><A NAME="Key_and_Button_Events">Key and Button Events</A></H3>
<P>Events can be produced when the user presses a mouse button or keyboard key. For example, consider the following JScript code:
<PRE>Bvr1 = m.Until (initial_behavior, m.LeftButtonDown, second_behavior);
</PRE>
<P>This defines <I>Bvr1</I> as an initial behavior until the left mouse button is pressed, then <I>Bvr1</I> becomes the second behavior. 
<P>You can trigger from an event produced when the user presses a specific key. For example:
 <PRE>Bvr2 = m.Until (initial_behavior, m.KeyDown(27), second_behavior);
</PRE>
<P>This defines <I>Bvr2</I> as an initial behavior until the <SMALL>ESC</SMALL> key is pressed, then <I>Bvr2</I> becomes the second behavior. 

<P>You can also determine the state (whether it is pressed or not) of a mouse button or key with the <A HREF="../ref_script/dastaticproperties/DABooleanObjects.htm#leftButtonv_bool">LeftButtonState</A>, <A HREF="../ref_script/dastaticproperties/DABooleanObjects.htm#rightButtonv_bool">RightButtonState</A>, and <A HREF="../ref_script/dastaticfunctions/DABooleanObjects.htm#keyStatev_misc">KeyState</A> functions. You can then trigger on that state using the <A HREF="../ref_script/dastaticfunctions/DAEventObjects.htm#predicatev_dxmevent">Predicate</A> event, as shown in the following JScript code: 
<PRE>Bvr3 = m.Until (initial_behavior, m.Predicate(m.LeftButtonState), second_behavior)
</PRE>
<H3><A NAME="Timer_Events">Timer Events</A></H3>
<P>DirectAnimation supports the explicit specification of timer events, based upon <A HREF="../ref_script/dastaticproperties/DANumberObjects.htm#LocalTimev_num">LocalTime</A>.
For example, the following expression causes a behavior to switch from red to blue two seconds after it starts: 
<PRE>m.Until(m.Red, m.Timer(2), m.Blue)
</PRE>
<P>The value given to timer can be any number-valued behavior. 



<H3><A NAME="Application_Triggered_Events">Application-Triggered Events</A></H3>
<P>Applications often receive events through means other than DirectAnimation. Examples include GUI elements and incoming network data. An application-triggered event is a subclass of the <A HREF="../ref_script/class/DAEventClass.htm#DAEvent_Class">DAEvent</A> type (<A HREF="../ref_java/class/DXMEvent.htm#DXMEvent_Class">DXMEvent</A> Java type), and supports an additional trigger method. These events can be constructed with the <I>new</I> operator, placed into reactive behaviors, and triggered at any time by the application. For instance, the following Java example turns a cube from red to blue upon some external application event: 

<PRE>
  URL geomBase = buildURL(getImportBase(),&quot;file:/c:/DxM/Media/geometry/&quot;);
  GeometryBvr cube = importGeometry(buildURL(geomBase,&quot;cube.x&quot;));
  AppTriggeredEvent appEvent = new AppTriggeredEvent();
  ColorBvr col = (ColorBvr)until(red, appEvent, blue);
  GeometryBvr coloredCube = cube.diffuseColor(col);
//... elsewhere, when the application receives the proper event...
appEvent.trigger();
//... now coloredCube will turn blue (assuming it's running)
</PRE>
<P>Note that the trigger method is an immediate method. The trigger occurs when the program executes the statement containing the trigger call. 

<H3><A NAME="Compound_Events">Compound Events</A></H3>
<P>Events can be combined in a variety of simple ways. The method <A HREF="../ref_script/dastaticfunctions/DAEventObjects.htm#andEventv_dxmevent">AndEvent</A> takes two events and creates a third that occurs only when both constituent events occur simultaneously. The event resulting from <A HREF="../ref_script/dastaticfunctions/DAEventObjects.htm#orEventv_dxmevent">OrEvent</A> occurs when either of the constituent events occur (or both occur). The event resulting from <A HREF="../ref_script/dastaticfunctions/DAEventObjects.htm#notEventv_dxmevent">NotEvent</A> occurs whenever the constituent event does not occur. 

<P>The <A HREF="../ref_script/dastaticfunctions/DAEventObjects.htm#andEventv_dxmevent">AndEvent</A> function always produces a pair of event data. Each element of the pair is the event data from one of the constituent events. The <A HREF="../ref_script/dastaticfunctions/DAEventObjects.htm#orEventv_dxmevent">OrEvent</A> function produces the event data of whichever event caused <B>OrEvent</B> to trigger. The event data from <A HREF="../ref_script/dastaticfunctions/DAEventObjects.htm#notEventv_dxmevent">NotEvent</A> is undefined because an event not occurring doesn't produce any information. 


<H3><A NAME="The_attachData_Method" IDX_CONCEPT="noindex; AttachData function, using">The AttachData Function</A></H3>
<P>DirectAnimation events support an <A HREF="../ref_script/class/DAEventClass.htm#AttachDatav_dxmevent">AttachData</A> function that takes an event and produces a new event. The new event occurs at the same time as the original event, but its data is now the data that has been specified in the call to <B>AttachData</B>. This allows an application to associate arbitrary client data with an event and know that it will be delivered to the notifier when the event occurs. 

<P>This method can be used in conjunction with <A HREF="../ref_script/dastaticfunctions/DABehaviorObjects.htm#until2v_beh">UntilEx</A> and <A HREF="../ref_script/dastaticfunctions/DAEventObjects.htm#orEventv_dxmevent">OrEvent</A> to allow a behavior to switch to one of several new behaviors, depending on which event occurred. For instance, if you want a behavior that is red until the left mouse button is pressed (in which case it turns green) or the right mouse button is pressed (in which case it turns yellow), you could use the following code: 

<PRE>
GreenLeft = m.LeftButtonDown.AttachData(m.Green);
YellowRight = m.RightButtonDown.AttachData(m.Yellow);
MyCol = m.UntilEx(m.Red, m.OrEvent(GreenLeft, YellowRight);
</PRE>
<P>Because <A HREF="../ref_script/class/DAEventClass.htm#AttachDatav_dxmevent">AttachData</A> can take any behavior, the application can associate any type of data with events, rather than only behaviors. 


<H3><A NAME="Event_Data">Event Data</A></H3>
<P>It is often necessary to know more about an event than just its occurrence. This is why some events also produce data. For instance, a pick event provides information about the location of the intersection. To give applications the ability to access this data, DirectAnimation for Java calls the <A HREF="../ref_script/class/DAEventClass.htm#Notifyv_ev">Notify</A> function. This function creates a new event that occurs when the original event occurs. It then calls the notifier and uses the result as its event data. It is the responsibility of the application to retrieve the necessary data. 

<P><B>Event Data from Picking</B>
<P>The pick event returns data that can be accessed through the <A HREF="../ref_script/class/DAPickableResultClass.htm#pickevv_pickr">PickEvent</A> property of the <A HREF="../ref_script/class/DAPickableResultClass.htm#DAPickableResult_Class">DAPickableResult</A> class or from within an <A HREF="../ref_script/dastaticfunctions/DABehaviorObjects.htm#untilv_beh">Until</A> or <A HREF="../ref_script/dastaticfunctions/DABehaviorObjects.htm#untilv_beh">UntilEx</A> function. The data returned is a <A HREF="../ref_script/class/DAPairClass.htm#DAPair_Class">DAPair</A> behavior whose first element is the intersection point of the event, and whose second element is a vector perpendicular to the surface of the picked object. Both of these pieces of data are supplied in the local coordinate system of the image or geometry used to construct a pickable image object (with the <A HREF="../ref_script/class/DAImageClass.htm#DAImage_Class">DAImage</A> property <A HREF="../ref_script/class/DAImageClass.htm#pickv_i">Pickable</A>) or pickable geometry object (with the <A HREF="../ref_script/class/DAGeometryClass.htm#DAGeometry_Class">DAGeometry</A> property <A HREF="../ref_script/class/DAGeometryClass.htm#pickv_g">Pickable</A>). This is needed to enable images and geometries to retain their interactivity independent of the context into which they are embedded. For example, an interactive image that is replicated three times, each time with a different scale, should retain its interactivity in all three contexts. 
<P>The sample in DXMedia\Samples\Multimedia\DAnim\VBScript\Showcase\Pick3.html demonstrates picking.

<P>The samples GeometryDrag and ImageDrag in DXMedia\Samples\Multimedia\DAnim\Java\Templates\ 
directory show Java code that creates a geometry and an image that can be picked and, when picked, follows (or is dragged by) the mouse. When released, the geometry or image stays where it was released, waiting for the next pick. Because the event data is returned in the local modeling coordinates of the image itself, the resultant images can be used under any modeling transformation. 
<P>Because the draggable operation is so common, dragging utilities are provided in the DXMedia\Samples\Multimedia\DAnim\Java\Utility directory. 

<P><B>Event Detection</B>
<P>Descriptions of the <A HREF="../ref_script/dastaticfunctions/DAEventObjects.htm#predicatev_dxmevent">Predicate</A> function, which creates an event from a Boolean, might give the impression that this event is fired anytime the event occurs. In general, this is not possible, due to the possibilities of temporal aliasing. Therefore, DirectAnimation places implementation-specific restrictions on the form of Boolean that will successfully and consistently trigger events. For example, the event denoted by m.Predicate(m.EQ(m.Sin(m.LocalTime), 0)) is expected to fire exactly when Sin(LocalTime) is 0. However, in reality, this event will rarely, if ever, fire. This is because of the sample-driven nature of detecting predicate events. If the implementation doesn't sample at exactly the right time, the event will be missed. Thus, applications should use inequality events, such as m.Predicate(m.GTE(m.Sin(m.LocalTime), 0)) to test for events on continuous behaviors. It is this imprecision in sampling events that is the motivation for the specialized timer event. 
<P>There is a subtlety associated with imprecise sampling. If a notifier is invoked using <A HREF="../ref_script/class/DAEventClass.htm#Notifyv_ev">Notify</A> waiting for the above event, the event time will not generally be the exact time that the event became true. If precise timing is a requirement, the event time should not be used directly. Instead, the inaccuracy must be compensated for in some application-specific manner. 


<H3><A NAME="Picking">Picking</A></H3>
<P>In DirectAnimation the <A HREF="../ref_script/class/DAImageClass.htm#pickv_i">Pickable</A>
 property of <A HREF="../ref_script/class/DAImageClass.htm#DAImage_Class">DAImage</A> and <A HREF="../ref_script/class/DAGeometryClass.htm#DAGeometry_Class">DAGeometry</A> objects provides a simple mechanism by which picking (or hit detection) on images and geometry results in DirectAnimation events. In Java, the same mechanism is supported by the classes <A HREF="../ref_java/class/PickableImage.htm#PickableImage_Class">PickableImage</A> and <A HREF="../ref_java/class/PickableGeometry.htm#PickableGeometry_Class">PickableGeometry</A>. Applications can use these events as they would any other event. Additionally, information such as where on the object the pick occurred is provided with the resulting event data. 

<P>The support for image and geometry hit detection is identical. 

<P>Hit detection works even when geometry is embedded into an image, and the image is in turn textured onto a geometry.

<P>Images and geometry, even when embedded, retain their interactive nature. 

<P>If an application needs to be informed that the mouse is over a particular image, it constructs a <A HREF="../ref_script/class/DAPickableResultClass.htm#DAPickableResult_Class">DAPickableResult</A> object by invoking the Pickable property on an image or geometry. It can then use the <B>DAPickableResult</B> property <A HREF="../ref_script/class/DAPickableResultClass.htm#pickevv_pickr">PickEvent</A>. If the mouse is directly on top of a pickable image or geometry (without intervening images or geometries) then the event fires. It is possible for a pickable object to appear multiple times in a scene. However, each time the mouse is on top of any of these images, the event occurs. To distinguish multiple uses of an image, and provide separate events based upon separate uses, the application must construct multiple pickable objects. For example:
<PRE>
    pim1 = image.Pickable;
    pim2 = image.Pickable;
</PRE>
<H3><A NAME="A_Simple_Picking_Exa" IDX_CONCEPT="NOINDEX; Picking Example, Simple">A Simple Picking Example </A></H3>
<P>This JScript example demonstrates how to make an image pickable, meaning it reacts to an event when the mouse is within its borders. In this example, the square cycles between blue and red when the mouse is within its borders and the left button is down. To view the sample, click on the &quot;Show Sample&quot; button; to view the source code, click on &quot;Show Sample Code&quot;."
<!--***********************Simple Picking Sample**********************-->

<P><B>Simple Picking Sample</B>
<P><BR>

<INPUT TYPE=BUTTON VALUE="Show Sample" STYLE="width:150" ID=btnStart_pick OnClick="start_pick()"><BR>
<DIV ID="controlDiv_pick" align="center"> &nbsp; </DIV>
<P><BR>
<INPUT TYPE=BUTTON VALUE="Show Sample Code" STYLE="width:150" ID=btnShowCode_pick OnClick="ShowHideCode_pick()"><BR>
<PRE><DIV ID="dispSourceCode_pick"></DIV></PRE>
<SCRIPT LANGUAGE="JavaScript">
  var FlagNotStarted_pick = true;
  var FlagSCNotVisible_pick = true;
  var DACONTROL_pick = '<OBJECT ID="DAViewer_pick" STYLE="width:600;height:100;z-index: -1" \n'+
  'CLASSID="CLSID:B6FFC24C-7E13-11D0-9B47-00C04FC2F51D"> \n'+
'</OBJECT> ';
 
function CreateDA_pick() {
	controlDiv_pick.innerHTML = DACONTROL_pick;
}

function start_pick(){
   if (FlagNotStarted_pick){
   	CreateDA_pick();
	runthis_pick();
	show_pick();
    }
    else {
    	hide_pick();
    }
}

function show_pick(){
	FlagNotStarted_pick = false;
	btnStart_pick.value="Hide Sample";
	btnShowCode_pick.style.display='';
}
function hide_pick(){
	FlagNotStarted_pick=true;
	controlDiv_pick.innerHTML = '';
	btnStart_pick.value="Show Sample";
	controlDiv_pick.innerHTML = '';
}
function ShowHideCode_pick(){
	if (FlagSCNotVisible_pick){
		dispSourceCode_pick.innerText = DACONTROL_pick + '\n' + DAScript_pick.innerHTML;
		FlagSCNotVisible_pick = false;
		btnShowCode_pick.value = "Hide Sample Code";
	}
	else{
		dispSourceCode_pick.innerText = '';
		FlagSCNotVisible_pick = true;
		btnShowCode_pick.value = "Show Sample Code";
	}
}

</SCRIPT>

<P><BR>
<!--***********************Simple Picking Sample**********************-->


<P>The following simple Java example imports a GIF image and a piece of text rendered on top of the GIF image. The text changes when the mouse is over the GIF image. 
<PRE>
URL imageBase =buildURL(getImportBase(),&quot;../../Media/image/&quot;);
ImageBvr gif = importImage(buildURL(imageBase,&quot;picture.gif&quot;));

// Grab image, make pickable, grab the event.
PickableImage pGif = new PickableImage(gif);
DXMEvent ev = pGif.getPickEvent();

// Make the string change when mouse is over the image
StringBvr str =(StringBvr) until(toBvr(&quot;not picked&quot;), ev, 
  toBvr(&quot;picked&quot;));

// Render the string to an image, and <A CLASS="Glossary" HREF="javascript:Glossary(sRelPath + 'gloss/gloss_O.htm#overlay')">overlay</A> on top of the
// pickable GIF.
ImageBvr  textIm = simpleText(str).render();
ImageBvr  result = overlay(textIm, pGif.getImageBvr());
</PRE>
<P>Note that the pick event occurs when the mouse is directly over the image (and no other detectable images occlude its visibility.) A mouse button press is not required to fire the event. The effect is analogous to an HTML hotspot. To ensure that the event fires only when the mouse button is pressed, use the event constructed by <B>andEvent(leftButtonDown, ev)</B>.


<H3><A NAME="Until_Function" IDX_CONCEPT="noindex; Until function, using">The Until Function</A></H3>
<P>This section discusses the <A HREF="../ref_script/dastaticfunctions/DABehaviorObjects.htm#untilv_beh">Until</A> function (Java <A HREF="../ref_java/staticmethods/BehaviorObjects.htm#until_beh">until</A> method), which enables developers to incorporate interactive elements into their animations. Here is an example of how to create a behavior that is red until the left mouse button is pressed, and then turns to blue: 
<PRE>
Col = m.Until(m.Red, m.LeftButtonDown, m.Blue);
</PRE>
<P>In general, <A HREF="../ref_script/dastaticfunctions/DABehaviorObjects.htm#untilv_beh">Until</A> takes a behavior, an event, and another behavior. It produces a new behavior. This new behavior is the first behavior until the event occurs. It then becomes the second behavior. Because <B>Until</B> takes behaviors and returns a behavior, it can be nested, as the following example demonstrates:
<PRE>
Col = m.Until(m.Red, m.LeftButtonDown, 
                             m.Until(m.Blue, m.LeftButtonDown, m.Green));
</PRE>
<P>In this example, the resulting behavior is red until the button is pressed. It is then blue until the button is pressed again, and then it is green.
<P>Note that the result is cast to the proper subclass of Behavior, because <A HREF="../ref_script/dastaticfunctions/DABehaviorObjects.htm#untilv_beh">Until</A> is defined on the Behavior superclass.
<P>The previous example could have been written as: 
<PRE>
Col1 = m.Until(m.Blue, m.LeftButtonDown, m.Green)
Col2 = m.Until(m.Red, m.LeftButtonDown, Col1);
</PRE>
<P>Looking at the example in this form raises the following question: &quot;When the <A HREF="../ref_script/dastaticproperties/DAEventObjects.htm#leftButtonDownv_dxmevent">LeftButtonDown</A> event occurs, <I>Col2</I> changes from red to <I>Col1</I>, but <I>Col1</I> doesn't change from blue to green. Why not? Both of them appear to be waiting for the <B>LeftButtonDown</B> event, so why doesn't the first occurrence of this event cause them both to change?&quot;
<P>The reason the example works properly is because of the way <A HREF="../ref_script/dastaticfunctions/DABehaviorObjects.htm#untilv_beh">Until</A> works. Consider the following example: 
<PRE>
b1 = m.Until(b2, ev, b3);
</PRE>
<P>Behaviors are run automatically by the system when needed. Assume that behavior <I>b1</I> is started by the system with a start time of t0. This causes <I>b2</I> to be started at t0 also, and causes the system to start looking for the first occurrence of the event <I>ev</I> after t0. The system does not start behavior <I>b3</I>. When the event does occur (call this time te), the system starts behavior <I>b3</I> at time te and stops looking for event <I>ev</I>.
<P>In DirectAnimation, global time is ever-increasing, but local time for each behavior starts at 0 when the behavior is started. For example, if behavior <I>b3</I> starts two seconds after <I>b2</I>, it will start with its own local time of 0. 
<P>Consider the original example: 
<PRE>
Col1 = m.Until(m.Blue, m.LeftButtonDown, m.Green)
Col2 = m.Until(m.Red, m.LeftButtonDown, Col1);
</PRE>
<P>When <I>Col2</I> is started, the system looks for the <B>LeftButtonDown</B> event in <I>Col2</I>, but not in <I>Col1</I>. When the <I>Col1</I> behavior starts, the system looks for the <B>LeftButtonDown</B> event in <I>Col1</I>.

<H3><A NAME="UntilEx_Function" IDX_CONCEPT="noindex; UntilEx function, using">The UntilEx Function</A></H3>
<P>The <A HREF="../ref_script/dastaticfunctions/DABehaviorObjects.htm#until2v_beh">UntilEx</A> function (<A HREF="../ref_java/staticmethods/BehaviorObjects.htm#until2_beh">untilEx</A> Java method) takes two parameters, a behavior and an event with a behavior associated with it: <I>UntilEx(InitialBehavior, Event)</I>. The resulting behavior will have the initial behavior until the event happens, then will transition to whatever behavior the event produces.
<P>There are several ways to associate a behavior with an event, including the <A HREF="../ref_script/class/DAEventClass.htm#AttachDatav_dxmevent">AttachData</A>, <A HREF="../ref_script/class/DAEventClass.htm#Notifyv_ev">Notify</A>, and <A HREF="../ref_script/class/DAEventClass.htm#snapshotv_dxmevent">Snapshot</A> functions (and the Java <A HREF="../ref_java/class/DXMEvent.htm#attachData_dxmevent">attachData</A>, <A HREF="../ref_java/class/DXMEvent.htm#notifyEvent_ev">notifyEvent</A>, and <A HREF="../ref_java/class/DXMEvent.htm#snapshot_dxmevent">snapshotEvent</A> methods).
<P>The <A HREF="../ref_script/class/DAEventClass.htm#AttachDatav_dxmevent">AttachData</A> function enables you to associate data with an event. The data associated with the event can be a behavior. In the following example, the behavior is red until a mouse button is pressed. It then turns either green or yellow, depending on which event happens first. 
<PRE>
GreenLeft = m.LeftButtonDown.AttachData(m.Green);
YellowRight = m.RightButtonDown.AttachData(m.Yellow);
MyCol = m.UntilEx(m.Red, m.OrEvent(GreenLeft, YellowRight);
</PRE>
<P>The <A HREF="../ref_script/class/DAEventClass.htm#Notifyv_ev">Notify</A> function calls the notifier when an event occurs, and uses the result as event data. 
<P>The <A HREF="../ref_script/class/DAEventClass.htm#snapshotv_dxmevent">Snapshot</A> function takes a behavior as a parameter. When the event to which it is attached occurs, it samples the behavior and returns it as a constant behavior. In the following example, the value of <I>n</I> is <A HREF="../ref_script/dastaticproperties/DANumberObjects.htm#LocalTimev_num">LocalTime</A> until the left mouse button is pressed. It then becomes whatever the value of <B>LocalTime</B> was when the event occurred: 
<PRE>
n=m.Until(m.LocalTime, m.LeftButtonDown.Snapshot(m.LocalTime));
</PRE>
<H3><A NAME="untilNotify_Method" IDX_CONCEPT="UntilNotify function, using; UntilNotifyScript, using">The UntilNotify and UntilNotifyScript Functions</A></H3>
<P>The DAStatics <A HREF="../ref_script/DAStaticFunctions/DABehaviorObjects.htm#untilNotifyv_beh">UntilNotify</A> and <A HREF="../ref_script/DAStaticFunctions/dabehaviorobjects.htm#UntilNotifyScriptv_beh">UntilNotifyScript</A> methods (and the Java <A HREF="../ref_java/staticmethods/BehaviorObjects.htm#untilNotify_beh">untilNotify</A> method) provide a delay mechanism for using event time data to construct the behavior that occurs after the event occurs. At the time of the event, a user-constructed notification method is invoked and passes the current behavior and the event data. This is somewhat like a user callback. The user code (called the notification method) uses the passed current behavior and event data to construct and return the behavior that occurs after the event. <A HREF="../ref_script/DAStaticFunctions/DABehaviorObjects.htm#untilNotifyv_beh">UntilNotify</A> constructs a behavior that changes upon the given event to the behavior specified in the <B>DAUntilNotifier</B> <A HREF="../ref_script/class/DAUntilNotifierClass.htm#Notifyv_until">Notify</A> method. The 
<A HREF="../ref_script/DAStaticFunctions/dabehaviorobjects.htm#UntilNotifyScriptv_beh">UntilNotifyScript</A> method constructs a behavior that changes upon the given event to the behavior in the specified script procedure.
<p>The JScript samples in samples/multimedia/danim/jscript/templates/Dragimg.html and samples/multimedia/danim/jscript/showcase/draggeo.html demonstrate the use of <B>UntilNotifyScript</B>. The C++ sample in samples/multimedia/danim/c++/showcase/BvrHookCntrl demonstrates the use of <B>UntilNotify</B>.



<H3><A NAME="When_Does_Until_Chan" IDX_CONCEPT="Until, when it changes behaviors">When Does <i>Until</i> Change Behaviors?</A></H3>
<P>This subsection discusses a subtlety present in the DirectAnimation event model. 
<P>Consider the statement: 
<PRE>
until(b1, ev, b2);
</PRE>
<P>If the event <I>ev</I> occurs at time te, the <I>b2</I> behavior will not be sampled until the first sample time strictly greater than te. If this rule were not followed, many cyclically defined behaviors would be infinitely recursive.

<P>Consider this example, which is a red behavior until LocalTime is greater than or equal to 2, then is a green behavior: 
<PRE>
m.Until(m.Red, m.Predicate(m.GTE(m.LocalTime, 2)), m.Green)
</PRE>
<P>If this behavior is sampled at local time 1.8, the result will be red. At local time 2.1, the predicate will hold true, but the DirectAnimation implementation assumes that the event time is 2.1 (because this is the time the implementation became aware of the event). Because of the &quot;strictly greater than&quot; rule described above, the result will still be red. Not until the next sampling, for example at local time 2.4, will the result be green.
<P>If the application wants to ensure that situations like this react more accurately, it can use the <B>timer</B> method, and rewrite the example as:
<PRE>
m.Until(m.Red, m.Predicate(m.Timer(2)), m.Green)
</PRE>
<P>In Java, this statement would be:
<PRE>
until(red, timer(toBvr(2)), green) 
</PRE>
<H3><A NAME="Until_and_LocalTime">Until and LocalTime</A></H3>
<P>The <A HREF="../ref_script/dastaticfunctions/DABehaviorObjects.htm#untilv_beh">Until</A> function and the <A HREF="../ref_script/dastaticproperties/DANumberObjects.htm#LocalTimev_num">LocalTime</A> behavior starts at 0 and increases at the rate of 1 unit per second. Because <B>Until</B> starts its component behaviors at different times, the use of <B>LocalTime</B> within an <B>Until</B> function allows for the creation of distinct local timelines. For example: 
<PRE>
sine = m.Sin(m.LocalTime);
slope = m.LocalTime;
sineSlope = m.Until(sine, m.Timer(5), slope); 
</PRE>
<P>The sineSlope behavior behaves like the sine behavior until just after time 5 (in its local time line). It then behaves like the slope behavior. The following is a chart of the running value of <I>sineSlope</I> graphed against its local time line.
<P>
<P><IMG SRC="../art/user02.gif" WIDTH="390" HEIGHT="257" ALT="Sine/Slope graph"> 
<P>
<P>Any instances of <A HREF="../ref_script/dastaticproperties/DANumberObjects.htm#LocalTimev_num">LocalTime</A> in a behavior will start at 0 when that behavior is running, including when the behavior is transitioned to as the result of an event. 
<P>This local timeline property of <A HREF="../ref_script/dastaticproperties/DANumberObjects.htm#LocalTimev_num">LocalTime</A> is important because it allows behaviors to operate in their own local timelines. When placed in any <B>Until</B> function, started at any time, they will follow their prescribed behavior. 
<P>This form of <B>Until</B> doesn't describe every situation that might arise when designing a behavior that reacts to events. Specifically, this form only works when the component behaviors can be completely described when the resultant behavior is defined; for example, that the color becomes green when the button is pressed. 
<P>However, consider a stopwatch implemented as a number behavior representing a timer that starts counting from 0 and increases 1 unit per second until the left button is pressed. At that time, the behavior is permanently set to the value that existed when the button was pressed. This can be accomplished with the <A HREF="../ref_script/class/DAEventClass.htm#snapshotv_dxmevent">Snapshot</A> function and the <A HREF="../ref_script/dastaticfunctions/DABehaviorObjects.htm#until2v_beh">UntilEx</A> function, as shown in the following example:
<PRE>
Stopwatch=m.Until(m.LocalTime, m.LeftButtonDown.Snapshot(m.LocalTime));
</PRE>
<H2><A NAME="More_Ways_to_Use_Behaviors" IDX_CONCEPT="NOINDEX; Behaviors, different ways to use">More Ways to Use Behaviors</A></H2>
<P>This section describes how to use behaviors in different situations for different results. It includes the following topics:
<UL><LI><A HREF="proguide_UsingBehaviors.htm#Results">Results of Operations on Behaviors</A>
<LI><A HREF="proguide_UsingBehaviors.htm#Some_Defaults">Some Defaults When Constructing Behaviors</A>
<LI><A HREF="proguide_UsingBehaviors.htm#When_Are_Behaviors_Run">When Are Behaviors Run?</A>
<LI><A HREF="proguide_UsingBehaviors.htm#Java_toBvr">Java toBvr Method</A>
<LI><A HREF="proguide_UsingBehaviors.htm#Constructing_Cyclic_Java_Behaviors">Constructing Cyclic Java Behaviors</A>
<LI><A HREF="proguide_UsingBehaviors.htm#Sequencing">Sequencing</A>
<LI><A HREF="proguide_UsingBehaviors.htm#Switching">Switching</A>
<LI><A HREF="proguide_UsingBehaviors.htm#Integrals_and_Derivatives">Integrals and Derivatives</A>
<LI><A HREF="proguide_UsingBehaviors.htm#The_Extract_Function">The Extract Function</A>
<LI><A HREF="proguide_UsingBehaviors.htm#The_Cond_Function">The Cond Function</A>
<LI><A HREF="proguide_UsingBehaviors.htm#Time_Substitution">Time Substitution</A>
<LI><A HREF="proguide_UsingBehaviors.htm#Uninitialized_Behaviors_in_Java">Uninitialized Behaviors in Java</A>
</UL>
<H3><A NAME="Results" IDX_CONCEPT="Operations on Behaviors, Results of">Results of Operations on Behaviors</A></H3>
<P>A common feature throughout the behavior classes is that operations generally take behaviors and produce new behaviors from them, rather than modifying the original inputs. For example, consider the expression: 
<PRE>
Cube.Transform(xform)
</PRE>
<P>This does not change the specified cube. Instead, it produces a new geometry that is a transform applied to the original cube. 
<P>The following example creates a red cube rotated around the y-axis by 60 degrees: 
<PRE>
mediaBase = &quot;..\\..\\..\\..\\media\\&quot;;
geoBase = mediaBase + &quot;geometry\\&quot;;
Geo1 = m.ImportGeometry(geoBase + &quot;cube.x&quot;);
Geo2 = Geo1.DiffuseColor(m.Red);
Geo3 = Geo2.Transform(m.Rotate3Degrees(m.YVector3, 60));
</PRE>
<P>Alternatively, because each of these functions produce a value, they could all be combined into the following statement:
<PRE>
Geo1= m.ImportGeometry(geoBase + &quot;cube.x&quot;).
		DiffuseColor(m.Red).Transform(m.Rotate3Degrees(m.YVector3, 60));
</PRE>
<P>It is important to remember that these calls always create new values and never modify the existing values. For example, consider the following code:
<PRE>
Geo1 = m.ImportGeometry(geoBase + &quot;cube.x&quot;);
//Incorrect Usage
Geo1.DiffuseColor(m.Red);
Geo1.Transform(m.Rotate3Degrees(m.YVector3, 60));
</PRE>
<P>This code will <B>not</B> create a cube, make that cube red, then rotate that cube. Instead, <I>Geo1</I> remains the original, imported cube. The second and third lines are useless because they don't do anything with their return values. The results of those operations are inaccessible.
<P>Within the DirectAnimation&#153; implementation, 
new values may or may not actually be constructed. However, from the developer's point of view they always are. Additionally, when new values are constructed they are very inexpensive in terms of system resources. Generally, they are represented by a pointer to the old value and the data for the new attribute. 

<H3><A NAME="Some_Defaults" IDX_CONCEPT="noindex; Defaults When Constructing Behaviors; Constructing Behaviors, Defaults">Some Defaults When Constructing Behaviors</A></H3>
<P>In DirectAnimation, methods for constructing media data types (images, geometry, points, and so on) use the following defaults:
<UL><LI>Importing a bitmap image positions that image at the origin of the coordinate system. Transformations are then used on the original image to create new images with different locations.
<LI>The <A CLASS="Glossary" HREF="javascript:Glossary(sRelPath + 'gloss/gloss_L.htm#light')">light</A> constant is located at the 3-D origin, and transformed accordingly.
<LI>Directional light is in the direction of the negative Z-axis. <A CLASS="Glossary" HREF="javascript:Glossary(sRelPath + 'gloss/gloss_A.htm#ambient_light')">Ambient light</A> doesn't have geometric aspects.
</UL>
<P>This approach minimizes the replication of extraneous parameters. You don't need to define image imports, simple text, or light constants to take a position and size parameter. This both simplifies and aids consistency in animations.



<H3><A NAME="When_Are_Behaviors_Run" IDX_CONCEPT="noindex; Running Behaviors; Behaviors, Running; behaviors, starting time">When Are Behaviors Run?</A></H3>
<P>This section lists the ways behaviors are run, and how the start time that becomes associated with the running behavior is determined. The different ways of running behaviors are: 
<UL><LI>In the statement &quot;c1 = m.Until(c2, ev, c3)&quot; when behavior <I>c1</I> is started at t0, behavior <I>c2</I> gets started at t0. Any time after this, when the event <I>ev</I> occurs at time te, behavior <I>c3</I> is started at te. Prior to <I>ev</I>, <I>c3</I> is not running.
<LI>In all media combination methods, such as &quot;p1 = m.DistancePoint2(p2, p3)&quot;, when <I>p1</I> is started at t0, <I>p2</I> and <I>p3</I> are also started at time 0. 
<LI>Scripting behaviors are run as soon as the <A HREF="../ref_script/class/DAViewerControlClass.htm#DAViewerControl_Class">DAViewerControl</A> <A HREF="../ref_script/class/DAViewerControlClass.htm#startv_control">Start</A> subroutine is started, and all are started at time 0. 
<LI>Java behaviors established in a Model with the <B>createModel</B> method are run as soon as the model is started, and all are started at time 0. This method is effectively the <B>main</B> entry point for DirectAnimation for Java, and describes the initial model. 
Behaviors that are not part of the Java Model can be explicitly identified for running by adding them to the list of behaviors passed to <B>createModel</B> method. Behaviors can be added with the <A HREF="../ref_java/class/BvrsToRun.htm#BvrsToRun_Class">BvrsToRun</A> class <A HREF="../ref_java/class/BvrsToRun.htm#add_bvrs">add</A> method.
</UL>
<A NAME="RunOnce_Function"></A><P><B>The RunOnce Function</B>
<P>Certain applications need to be able to reference a running behavior without the behavior restarting when events occur. Consider two animated, time-varying images (perhaps movies) and an application that plays the first movie from its beginning for 10 seconds, then, over the course of the next two seconds, fades from it to the second movie, then continues playing the second movie. Assuming the existence of a Fade operation (which can be constructed easily from overlay and opacity), a first attempt might look like this:
<P><B>Incorrect Usage</B>
<PRE>
wrongResult = m.Until(movie1, 
                  m.Timer(10),
                  m.Until(Fade(movie1, movie2),
                        m.Timer(2),
                        movie2);
</PRE>
<P>Unfortunately this doesn't work. The problem is that after the first event the <I>movie1</I> behavior will be started again, resulting in seconds 1 and 2 of <I>movie1</I> fading, rather than seconds 11 and 12. Also, after the second event the <I>movie2</I> behavior also starts again, replaying seconds 1 and 2 rather than continuing on from the end of 2 seconds.
<P>This particular application calls for a behavior that, once running, is always referred to without restarting. This means that after the initial start, no new behaviors are created. The <A HREF="../ref_script/class/DABehaviorClass.htm#runOncev_beh">RunOnce</A> function satisfies this requirement. With <B>RunOnce</B>, the fader example can be expressed as:
<PRE>
movie1Once = movie1.RunOnce();
movie2Once = movie2.RunOnce();
faderMovie = m.Until(movie1Once, m.Timer(10), m.Until(Fade(movie1Once, movie2Once), 
          m.Timer(2), movie2Once);
</PRE>
<P>In this example, <I>movie1Once</I> and <I>movie2Once</I> are constructed as behaviors that are not yet running, but once they are started, subsequent references to these behaviors will return to the behavior already running. 


<H3><A NAME="Java_toBvr" IDX_CONCEPT="noindex; toBvr method, using">Java toBvr Method</A></H3>
<P>The <A HREF="../ref_java/staticmethods/NumberBvrObjects.htm#toBvr_num">toBvr</A> method converts a double precision Java number into a constant <A HREF="../ref_java/class/NumberBvr.htm#NumberBvr_Class">NumberBvr</A> behavior. This conversion is necessary because the DirectAnimation for Java methods generally take arguments that are behaviors and not Java constant numbers. The <B>toBvr</B> method exists for all core Java types that have DirectAnimation equivalents. For example, it converts Boolean types and java.lang.String types to BooleanBvr and StringBvr respectively. 
<P>The only time that <B>toBvr</B> is used is when converting a Java number, Boolean, or String to a DirectAnimation type. It is not used for constants such as red, yVector3, and origin2, because these are defined as constant behaviors. 


<H3><A NAME="Constructing_Cyclic_Java_Behaviors">Constructing Cyclic Java Behaviors</A></H3>
<P>Often there is a need to construct a behavior that cycles through some number of values when an event occurs. The Cycler object solves this problem. It is a subclass of the Behavior class. Here is an example that cycles through the three sounds upon each <B>leftButtonDown</B> event: 
<PRE>
URL soundBase =buildURL(getImportBase(),&quot;../../Media/sounds/&quot;);
SoundBvr snd1 = importSound(buildURL(soundBase,&quot;do.wav&quot;), null);
SoundBvr snd2 = importSound(buildURL(soundBase,&quot;re.wav&quot;), null);
SoundBvr snd3 = importSound(buildURL(soundBase,&quot;mi.wav&quot;), null);

//Create an array of sounds
Behavior[]snds = {snd1, snd2, snd3};
Cycler cycle = new Cycler(snds, leftButtonDown);
SoundBvr currentSnd = (SoundBvr)(cycle.getBvr());
</PRE>
<P>Note that each component behavior gets started each time there is a transition to it.
<P>The <A HREF="../ref_java/class/Cycler.htm#Cycler_Class">Cycler Class</A> entry in the <I>Java Reference</I> describes Cycler. 
<P>The Cycler utility can be constructed easily in Scripting classes using <A HREF="../ref_script/dastaticfunctions/DABehaviorObjects.htm#untilv_beh">Until</A> and uninitialized behaviors.


<H3><A NAME="Sequencing" IDX_CONCEPT="JScript Sequencing">Sequencing</A></H3>
<P>Sequencing enables you to sequence behaviors with finite durations. Consider the following JScript sample which sequences through a set of labels. You can see how sequencing is used in animation by viewing the sample DXMedia\Samples\Multimedia\DAnim\JScript\Templates\Sequencing.
<PRE>
labels = new Array(&quot;First&quot;, &quot;Second&quot;, &quot;Third&quot;, &quot;Fourth&quot;, &quot;Fifth&quot;,
                      &quot;Sixth&quot;, &quot;Seventh&quot;, &quot;Repeat the Sequence Forever&quot;);
   
durations = new Array(tDur, tDur, p1, sDur, p2, tDur, tDur, p1, sDur, p2, 1);

// Construct a sequence of labels 
len = labels.length;
label = m.DAString(&quot;&quot;).Duration(0);
for (i=0; i&lt;len; i++) 
   label = m.Sequence(label, m.DAString(labels[i]).Duration(durations[i])); 

font = m.DefaultFont.Color(m.Blue); 
textImg = m.TextImage(label, font);
</PRE>
<P> Note that the last duration of one second is for the last string, which will stay forever since it is the end of the sequence.



<H3><A NAME="Switching">Switching</A></H3>
<P>Sometimes there is a need to modify behaviors that is not dependent on events. The <A HREF="../ref_script/class/DABehaviorClass.htm#switchtov_beh">SwitchTo</A> function fills this need. A switchable object is created with the <A HREF="../ref_script/dastaticfunctions/DABehaviorObjects.htm#modbehv_beh">ModifiableBehavior</A> function and is given an initial behavior. When <B>SwitchTo</B> is called with another behavior, the modifiable behavior switches to the provided behavior. Here is an example: 
<PRE>
// Create a modifiable color with the initial value blue. 
col = m.ModifiableBehavior(m.Red)
im = m.SolidColorImage(col);
//... somewhere else in the program ...
col.SwitchTo(m.Blue);
</PRE>
<P>Anywhere that <I>col</I> was used will turn from red to blue when <A HREF="../ref_script/class/DABehaviorClass.htm#switchtov_beh">SwitchTo</A> is called. Calls to <B>SwitchTo</B> must carry arguments of the same behavior type as the initial behavior. The behavior switches when the program executes the statement containing the <B>SwitchTo</B> call. 


<H3><A NAME="Integrals_and_Derivatives" IDX_CONCEPT="Derivatives and Integrals">Integrals and Derivatives</A></H3>
<P>DirectAnimation supports explicit construction of the integrals and derivatives of certain types with respect to time. Integration can be performed on values of type <A HREF="../ref_script/class/DANumberClass.htm#DANumber_Class">DANumber</A> with the <A HREF="../ref_script/dastaticfunctions/DANumberObjects.htm#integralv_num">Integral</A> function and on <A HREF="../ref_script/class/DAVector2Class.htm#DAVector2_Class">DAVector2</A> and <A HREF="../ref_script/class/DAVector3Class.htm#DAVector3_Class">DAVector3</A> types with the <A HREF="../ref_script/dastaticfunctions/DAVector2Objects.htm#integralv_v2">IntegralVector2</A> and <A HREF="../ref_script/dastaticfunctions/DAVector3Objects.htm#integralv_v3">IntegralVector3</A> functions. Derivatives can be taken on all these types and also on <A HREF="../ref_script/class/DAPoint2Class.htm#DAPoint2_Class">DAPoint2</A> and <A HREF="../ref_script/class/DAPoint3Class.htm#DAPoint3_Class">DAPoint3</A> with the <A HREF="../ref_script/dastaticfunctions/DANumberObjects.htm#derivativev_num">Derivative</A>, <A HREF="../ref_script/dastaticfunctions/DAVector2Objects.htm#derivativev_v2">DerivativeVector2</A>, <A HREF="../ref_script/dastaticfunctions/DAVector3Objects.htm#derivativev_v3">DerivativeVector3</A>, <A HREF="../ref_script/dastaticfunctions/DAPoint2Objects.htm#derivativev_pt2">DerivativePoint2</A>, and <A HREF="../ref_script/dastaticfunctions/DAPoint3Objects.htm#derivativev_pt3">DerivativePoint3</A> functions. 
<P>When an integral behavior begins, it starts building a conceptually continuous summation of values from that start time. 
<P>For example, the following JScript code creates a rotating ball that stops and starts on every left mouse button click. <A HREF="../ref_script/dastaticfunctions/DATransform3Objects.htm#rotateRatedgv_xf3">Rotate3RateDegrees</A> takes an implicit <A HREF="../ref_script/dastaticproperties/DANumberObjects.htm#LocalTimev_num">LocalTime</A> parameter. This parameter is replaced by the integral when <A HREF="../ref_script/class/DABehaviorClass.htm#substituteTimev_beh">SubstituteTime</A> is called. The <I>changingRate</I> variable is a velocity that cycles between 0 and 1. The integral of that velocity increases gradually. This integral is used as the angle of rotation for the geometry. 

<PRE>
Ball = m.ImportImage(&quot;ball.gif&quot;);
RollingBall = Ball.Transform(m.Rotate3RateDegrees(m.Vector3(1,5,3), 540));
changingRate = new ActiveXObject(&quot;DirectAnimation.DANumber&quot;);
changingRate.Init(m.Until(m.DANumber(0), m.LeftButtonDown,
		m.Until(m.DANumber(1), m.LeftButtonDown, changingRate)));
finalImg = RollingBall.SubstituteTime(m.Integral(changingRate));
</PRE>
<P>The following Java code creates a spinning cube that stops and starts on every left mouse button click.

<PRE>
URL mediaBase =buildURL(getImportBase(),&quot;../../Media/&quot;);
GeometryBvr geo = importGeometry(buildURL(mediaBase,&quot;cube.x&quot;));
NumberBvr[] zeroAndOne = { toBvr(0), toBvr(1) };
Cycler cyc = new Cycler(zeroAndOne, leftButtonDown);
NumberBvr angularVelocity = (NumberBvr)(cyc.getBvr());
NumberBvr angle = integral(angularVelocity);
GeometryBvr spinningGeo = geo.transform(rotate(zVector3, angle));
</PRE>
<H3><A NAME="The_Extract_Function" IDX_CONCEPT="noindex; Extract function, using">The Extract Function</A></H3>
<P>For behavior types that have primitive equivalents, (<A HREF="../ref_script/class/DABooleanClass.htm#DABoolean_Class">DABoolean</A>, <A HREF="../ref_script/class/DANumberClass.htm#DANumber_Class">DANumber</A>, and <A HREF="../ref_script/class/DAStringClass.htm#DAString_Class">DAString</A>, and the Java types <A HREF="../ref_java/class/BooleanBvr.htm#BooleanBvr_Class">BooleanBvr</A>, <A HREF="../ref_java/class/NumberBvr.htm#NumberBvr_Class">NumberBvr</A>, and <A HREF="../ref_java/class/StringBvr.htm#StringBvr_Class">StringBvr</A>), a value in the underlying type is often needed. For instance, you might need an actual float in order to call out to a C++ or Java routine. The <A HREF="../ref_script/class/DABooleanClass.htm#extractv_bool">Extract</A> function (Java <A HREF="../ref_java/class/BooleanBvr.htm#extract_bool">extract</A> method) exists for these classes of behaviors, takes no arguments, and is expected to be called on a behavior that is actually constant. 
<H3><A NAME="The_Cond_Function" IDX_CONCEPT="noindex; Cond function, using">The Cond Function</A></H3>
<P>The <A HREF="../ref_script/dastaticfunctions/DABehaviorObjects.htm#condv_beh">Cond</A> function enables the construction of a behavior out of a Boolean behavior and two other behaviors. The value of the resultant behavior at any point in time is equal to the value of one of the two other behaviors. Which value is chosen is determined by the value of the Boolean behavior. This is a behavior-level conditional. 
<P>The following example creates a behavior, y, which is either another behavior, x, or 1.0 if x is greater than 0.5:
<PRE>
x = m.Sin(M.LocalTime);
y = m.Cond(m.GTE(x, 0.5), 1.0, x);
</PRE>
<H3><A NAME="Time_Substitution" IDX_CONCEPT="substituting time">Time Substitution</A></H3>
<P>By default, the <A HREF="../ref_script/dastaticproperties/DANumberObjects.htm#LocalTimev_num">LocalTime</A> behavior starts at 0 and increases at the rate of one unit per second. However, this behavior can be modified. DirectAnimation supports time substitution. Time substitution creates a new behavior from an existing behavior and a number behavior. In the new behavior, the number behavior replaces all occurrences of <B>LocalTime</B> that were found in the original behavior. This includes behaviors where <B>LocalTime</B> is implicit, such as in imported movies. Time substitution allows behaviors to be time-scaled so that they can, for example, run faster or slower, be time-shifted to start at a different time, or be frozen at a particular point in time. This can be used to accelerate and decelerate animation objects.
<P>The <A HREF="../ref_script/class/DABehaviorClass.htm#substituteTimev_beh">SubstituteTime</A> function takes the following form:
<PRE>
newBvr = origBvr.SubstituteTime(newTime)
</PRE>
<P>The parameter <I>newTime</I> is a <A HREF="../ref_script/class/DANumberClass.htm#DANumber_Class">DANumber</A> behavior that gets substituted for <A HREF="../ref_script/dastaticproperties/DANumberObjects.htm#LocalTimev_num">LocalTime</A> in the <I>origBvr</I> behavior. The value of <I>newBvr</I> at time <I>t</I> is found by taking the value of <I>newTime</I> at time <I>t</I>, and using that as <B>LocalTime</B> in evaluating the behavior <I>origBvr</I>.
<P>Here are some simple examples:
<PRE>
//Create an original behavior: a point moving
//one unit in the x direction per second, starting at 0
pt1 = m.Point2(m.LocalTime, 0);

//Create a new behavior moving 0.5 units per second
//Do this by replacing localTime with LocalTime/2
pt2 = pt2.SubstituteTime(m.Div(m.LocalTime, 2);

//Create a new behavior moving 1 unit per second 
//starting at time 33, by replacing LocalTime with 
//LocalTime + 33
pt3 = pt1.SubstituteTime(m.Add(m.LocalTime, 33);


//Create new behavior by freezing the original behavior
// at time 77
pt4 = pt1.SubstituteTime(77);

//Tie the new behavior to the x-component of the mouse
pt5 = pt1.SubstituteTime(m.MousePosition.X); 
</PRE>
<P>Also note that time substitutions are cumulative. For example, the following series:
<PRE>
c0 = m.Point2(m.LocalTime, 0);
c1 = c0.SubstituteTime(m.Add(m.LocalTime, 33));
c2 = c1.SubstituteTime(m.Mul(m.LocalTime, 2));
</PRE>
<P>Could also be expressed as:
<PRE>
c0 = m.Point2(m.LocalTime, 0);
c1 = c0.SubstituteTime(m.Add(m.Mul(m.LocalTime, 2), 33));
</PRE>
<P>This Java example shows how to make images of sailboats rock on the water. First a simple number behavior is created:
<PRE>
NumberBvr angle = mul(sin(localTime), toBvr(Math.PI/6));
</PRE>
<P>This behavior begins (at local time zero) with the value zero and then varies with time between +/-p/6 radians (that is, +/-30 degrees). It repeats the behavior every 2p seconds. Assume that the applet has already constructed (or imported) a behavior representing the geometry of a sailboat, <I>sailboat0</I>, that is centered at the origin with its long axis aligned along Z. You can use the behavior <I>angle</I> to rock the boat as shown in the following code:
<PRE>
Transform3Bvr heel1 = rotate(zVector3, angle);
GeometryBvr sailboat1 = sailboat0.transform(heel1);
</PRE>
<P>The boat is initially upright and then heels from one side to the other, passing through upright (sin(0)=0) approximately every p seconds.
<P>Now, create a boat that is rocking more slowly than <I>sailboat1</I>:
<PRE>
Transform3Bvr heel2 = 
(Transform3Bvr)heel1.substituteTime(div(localTime, toBvr(8)));
GeometryBvr sailboat2 = sailboat0.transform(heel2);
</PRE>
<P>The second sailboat, <I>sailboat2</I>, rotates the same amount as <I>sailboat1</I> but has a period that is 8 times longer (y = sin1/8x).
<P>Note that, even though the period of rocking is different for each boat, both are initially upright. Now add a third boat that rocks at the same period as <I>sailboat2</I>, but is 90 degrees out of phase with it (y = cos 1/8x). The third boat can be defined as:
<PRE>
GeometryBvr sailboat3 = (GeometryBvr)
sailboat2.substituteTime(add(localTime, toBvr(Math.PI/2)));
</PRE>
<P>At the start, this boat is heeled over by p/6 (cos(0)=1) and rocks at the same rate as <I>sailboat2</I>. Notice how using time substitutions contributes to the modularity of the code. The phase change could be achieved by changing the definition of <I>angle</I>, but this would have also changed the phase of the first two boats as well. The code for <I>angle</I> could have been duplicated and the phase changed, but if <I>angle</I> had a more complicated definition or if the source were not available, this approach would be difficult or impossible.

<P>Time substitutions provide the same modularity benefits in the temporal domain as 2-D and 3-D transformations provide in the spatial domain. They enable you to define objects, and then manipulate them, from outside to alter their behavior, without needing to know the internals of the objects.

<P>Naturally, there are certain restrictions on the time substitutions that can be applied to behaviors. For instance, user input in general cannot be time-substituted; and time-substitution cannot replace event transitions that have already occurred.


<H3><A NAME="Uninitialized_Behaviors_in_Java">Uninitialized Behaviors in Java</A></H3>
<P>Sometimes you need to reference a Java behavior before it has been defined. As an example, consider a colored rectangle whose color changes when picked (when the mouse clicks on it or hovers over it). In this case, the color depends on whether or not the image is picked, but the image is dependent upon the color. The <I>uninitialized behavior</I> is provided for these cases and for cases of cyclic dependency. This behavior enables you to create a behavior and use it in the definition of other behaviors, but not actually define its contents until some later point. Uninitialized behaviors are created with the <B>newUninitBvr</B> method of the behavior object being created. All the behavior types have a <B>newUninitBvr</B> method for this purpose. 
<P>The following code shows how to use uninitialized behaviors to construct the animation described above. It assumes you have defined the function <I>makeColoredRectangle</I> elsewhere: 
<PRE>
ColorBvr col = ColorBvr.newUninitBvr();
ImageBvr im = makeColoredRectangle(col);
PickableImage pim = new PickableImage(im);
DXMEvent ev = pim.getPickEvent();
col.init( until(red, ev, green) );
</PRE>
<P>This example changes the color from red to green the first time the rectangle is passed over by the mouse. Here the behavior is initialized to the color dependent upon the event once the event occurs.
<P>Consider what happens when the last line of the previous code is changed to the following:
<PRE>
col.init ( until(red, ev, until(green, notEvent(ev), col)) );
</PRE>
<P>The rectangle will be red whenever the mouse is not over it, and green when the mouse is over it. This is accomplished by making the <I>col</I> behavior itself cyclic, going back to red and waiting for the pick after the <B>notEvent(ev)</B> occurs.
<P>When using this feature, you should be aware that the system will generate a run-time error if you:
<UL><LI>Initialize a non-uninitialized behavior 
<LI>Initialize an uninitialized behavior that's already been initialized
<LI>Start an uninitialized behavior that has not yet been initialized
</UL>
<H2><A NAME="Using_Behaviors_in_Applications">Using Behaviors in Java Applications</A></H2>
<P>A Java application can display behaviors in either an applet or a canvas. There are three general steps to displaying behaviors:

<OL><LI>The application overrides (subclasses) the DirectAnimation <A HREF="../ref_java/class/Model.htm#Model_Class">Model</A> class and implements the <A HREF="../ref_java/class/Model.htm#createModel_model">createModel</A> method to build up the image, sound, and geometry behaviors to be viewed. The application can optionally implement settings that apply specifically to this model. 


<LI>The application constructs an instance of a <A HREF="../ref_java/class/DXMApplet.htm#DXMApplet_Class">DXMApplet</A> or <A HREF="../ref_java/class/DXMCanvas.htm#DXMCanvas_Class">DXMCanvas</A> class, providing an instance of the <A HREF="../ref_java/class/Model.htm#Model_Class">Model</A> subclass. 
<LI>The application uses the applet or canvas as it would use any other applet or canvas. The model (and all of its component behaviors) is automatically sampled and displayed. 
</OL>
<P>For example, the following code sample shows how to view the RedImg model created in the previous section.
<PRE>
public class MyApplet extends DXMApplet {
    public void init() {
       // Always call the superclass's init() first to ensure codeBase is set
       super.init();
       // Now set the model
       setModel(new redImg());
    }
}
</PRE>
<P>Given a model, the <A HREF="../ref_java/class/DXMApplet.htm#setModel_app">setModel</A> method is all you need to construct an applet to view that model. 

<P>The use of <A HREF="../ref_java/class/DXMCanvas.htm#DXMCanvas_Class">DXMCanvas</A> is identical to <A HREF="../ref_java/class/DXMApplet.htm#DXMApplet_Class">DXMApplet</A>, except that you must position the canvas inside an application frame as you would any other canvas.


<!-- CONTENTS_END -->

<!-- START_PAGE_FOOTER -->


<H6><HR size=1></H6>
<P><A Class="line" HREF="#pagetop"><IMG src="../art/arrowup1.gif" WIDTH="11" HEIGHT="11" ALIGN="MIDDLE" BORDER=0 ALT="Top of Page">&nbsp;Top of Page</A>
<BR><A Class="line" HREF="../../cpyright.htm">&#169; 1998 Microsoft Corporation. All rights reserved. Terms of Use.</A>
<!-- END_PAGE_FOOTER -->

<!--***********************Simple Picking Sample**********************-->

<SPAN ID="DAScript_pick">
<SCRIPT LANGUAGE="JavaScript">
<!--
 function runthis_pick()
{

  // This example demonstrates how to make an image "pickable." This means it reacts to
  // an event when the mouse is within its borders.

  // In this example, the square goes cycles between blue and red when the mouse is within
  // its borders and the the left button is down.


  // First, select the meter library 
  m=DAViewer_pick.MeterLibrary;

  // Create a detectable empty image. We need this because we can only make 
  // images and geometries pickable and we have to define our pickable events. 

  myImage=m.DetectableEmptyImage;

  // We need to crop it, so set the minimum and maximum points equal to those of the square
  // we're going to draw later on.
  minPt=m.Point2(-.01,-.01)
  maxPt=m.Point2(.01,.01);

  // Now crop the detectable empty image to the right size
  myImage=myImage.Crop(minPt, maxPt);

  // Make the image pickable
  pickImg=myImage.Pickable();

  // Construct an event. This means something will happen only when the mouse
  // is within the pickable region AND when the mouse's left button is down. 
  myEvent=m.AndEvent(m.LeftButtonDown, pickImg.PickEvent);
  
  // Set up the two colors of the rectangle
  myBlue=m.ColorRgb(0,0,1);
  myRed=m.ColorRgb(1,0,0);

  // Now create an object that holds our colors and our event
  // This will set the color first to blue, then, when the event occurs, to red
  // then, when the event occurs again, back to blue (It cycles between the two).
  colcyc=new ActiveXObject("DirectAnimation.DAColor");
  colcyc.Init(m.Until(myBlue, myEvent, m.Until(myRed, myEvent, colcyc)));
 
  // This will be the fill for the square
  myFill=m.SolidColorImage(colcyc);

  // Now draw a square (a rectangle with equal width and height, and fill it in
  // with our cycling colors
  sqImg=m.Rect(.02,.02).Fill(m.DefaultLineStyle, myFill);

  // Finally, put our pickable, empty image on top of the rectangle
  dualImg=m.Overlay(pickImg.Image, sqImg);
 
  // And display it 
  DAViewer_pick.Image=dualImg; 
  DAViewer_pick.Start(); 
}

 -->

</SCRIPT>
</SPAN>
<!--***********************Simple Picking Sample**********************-->

</BLOCKQUOTE>
</BODY>
</HTML>
