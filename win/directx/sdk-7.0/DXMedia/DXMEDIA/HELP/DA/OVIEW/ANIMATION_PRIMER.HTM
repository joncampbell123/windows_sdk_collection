<!-- DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN" -->

<HTML>
<HEAD><TITLE>Animation Primer</TITLE>
<META NAME="Description" CONTENT="Animation Primer">
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; CHARSET=iso8859-1">
<META NAME="MS.LOCALE" CONTENT="EN-US">
<META NAME="ROBOTS" CONTENT="all">

<SCRIPT LANGUAGE="JavaScript">var sRelPath = '../' </SCRIPT>
<SCRIPT LANGUAGE="JAVASCRIPT">var g_isIE = false, g_isNav = false, g_iMaj = 0, g_sPlat = "";</SCRIPT>
<SCRIPT SRC="../ver.js"></SCRIPT>
<SCRIPT SRC="../gloss.js"></SCRIPT>
<SCRIPT SRC="../samples.js"></SCRIPT>
<SCRIPT DEFER SRC="../common.js"></SCRIPT>
<SCRIPT DEFER>
//<!--
function InitPage()
{
	if (g_isIE && g_iMaj >= 4)	
	{

		SetTOC();
	}
}
//-->

</SCRIPT>

<!-- STYLE_START -->

<SCRIPT LANGUAGE="JAVASCRIPT">
//<!--
   var sVR = '../'	// Set root for the style sheet
   var sCSS = '<LINK REL="stylesheet" HREF="' + sVR;

   if(g_isIE)
   {
	   if (g_iMaj >= 4) // For MSIE 4.0 or later
	   {
		   sCSS += 'dxm_basicSDKIE4';
		   if (g_sPlat == "Win") // Windows only for now
		   {
			   document.createStyleSheet(sVR + 'dxm_advSDKIE4.css');
		   }
	   }
	   else // For MSIE 3.0 or earlier
	   {
		   sCSS += 'dxm_basicSDKIE3';
	   }
   }
   else if (g_isNav) // For all Nav versions
   {
	   sCSS += 'dxm_basicSDKNAV';
   }
   else
   {
	   sCSS += 'dxm_basicSDKIE3'; // default to IE3 sheet
   }

   sCSS += (sCSS == '' ? '' : '.css" TYPE="text/css">');

   document.write(sCSS);
//-->

</SCRIPT>
<!-- STYLE_END -->


</HEAD>
<BODY onload="InitPage(); if (g_isIE && g_iMaj >= 4){HdgrphControl(); initGloss()}" BGCOLOR="#FFFFFF">
<A NAME="pagetop"></A><A NAME="Animation_Primer"></A>

<!-- HEADGRAPH_START -->

<TABLE CLASS="main" BORDER=0 CELLSPACING="0" CELLPADDING="0" WIDTH="*">
<TR>
<TD ROWSPAN="3" VALIGN="TOP" WIDTH="*">
<IMG SRC="../art/header1.gif" WIDTH="107" HEIGHT="110" BORDER=0 ALT="The Basics"></TD>
<TD ROWSPAN="2" VALIGN="TOP" WIDTH="217">
<IMG SRC="../art/hdrdanim.gif" WIDTH="217" HEIGHT="110" BORDER=0 ALT="DirectAnimation Animated Header --The Basics"></TD><TD VALIGN="TOP" WIDTH="383"><IMG SRC="../art/header3.gif" WIDTH="383" HEIGHT="95" BORDER=0 ALT="DirectAnimation Animated Header">
</TD>
<TD VALIGN="TOP" WIDTH="100%">
<IMG SRC="../art/spacer1.gif" WIDTH="100%" HEIGHT="94" BORDER=0 ALT="Microsoft DirectAnimation SDK">
</TD>
</TR>
<!-- HEADGRAPH_END -->


<!-- DACONTROL_START -->

	<DIV ID="HeadGraphAnim"></DIV>
	<SCRIPT LANGUAGE="JAVASCRIPT">if((g_isIE == true) && (g_iMaj > 3)) {window.self.document.writeln('<SCR' + 'IPT SRC="../anim.js"></SCR' + 'IPT>')}</SCRIPT>
<!-- DACONTROL_END -->


<!-- NAV_LINKS_START -->


<TR><TD VALIGN="TOP"><PRE><IMG ID="TOC_" SRC="../art/yelbtn.gif" WIDTH="11" HEIGHT="11" ALIGN="MIDDLE" BORDER=0 ALT="*"><A STYLE="color:black;font-weight:bold" ID="TOC" HREF="../contents.htm">Contents</A>  <IMG SRC="../art/yelbtn.gif" WIDTH="11" HEIGHT="11" ALIGN="MIDDLE" BORDER=0 ALT="*"><A STYLE="color:black;font-weight:bold" HREF="../index.htm">Index</A>  <IMG SRC="../art/yelbtn.gif" WIDTH="11" HEIGHT="11" ALIGN="MIDDLE" BORDER=0 ALT="*"><A STYLE="color:black;font-weight:bold" HREF="../default.htm">Topic Contents</A>
</PRE></TD></TR>
<TR><TD COLSPAN="2" VALIGN="TOP"><PRE><IMG SRC="../art/yelbtn.gif" WIDTH="11" HEIGHT="11" ALIGN="MIDDLE" BORDER=0 ALT="*"><B>Previous Topic:</B> <A STYLE="color:black" HREF="proguide_UsingModels.htm">Using Models</A>
<IMG SRC="../art/yelbtn.gif" WIDTH="11" HEIGHT="11" ALIGN="MIDDLE" BORDER=0 ALT="*"><B>Next Topic:</B> <A  STYLE="color:black" HREF="../ref_script/scriptref.htm">Scripting Reference - DirectAnimation Classes</A>
</PRE>
</TD></TR></TABLE>
<!-- NAV_LINKS_END -->


<!-- START POP-UP GLOSSARY -->

	<SCRIPT LANGUAGE="JAVASCRIPT">if((g_isIE == true) && (g_iMaj > 3)) {window.self.document.writeln('<SCR' + 'IPT SRC="../tip.js"></SCR' + 'IPT><IFRAME ID="G_L_S" NAME="SecretBuffer" STYLE="display: none" SRC=""></IFRAME>')}</SCRIPT>
<!-- END POP-UP GLOSSARY -->


<BLOCKQUOTE CLASS="body">

<!-- CONTENTS_START -->


<H1>Animation Primer</H1>

<p>Before reading this primer, you should first browse through the rest of the material in the Microsoft&reg; DirectAnimation&#153; SDK, especially the <A HREF="proguide_intro.htm">Programmer's Guide</A> and the <A HREF="examps.htm">Guide to Samples</A>, to learn the basic concepts of DirectAnimation. Then come back to read this section.</p>

<p>As you have learned from the rest of the documentation, you can take advantage of DirectAnimation for creating static images on Web pages, adding new media types to HTML content, or just for the media integration and consistent programming model that help simplify application development. But, if you are using DirectAnimation just for that, you are missing out on all the other features the DirectAnimation run time has to offer. DirectAnimation provides you with an animation engine and all the features that go along with it.</p>


<p>This primer covers some aspects of using the animation features, addressing issues and questions brought up by DirectAnimation developers like you. The purpose is to make sure you can exploit all that is made available to you through DirectAnimation. You can contact us through email or through our newsgroup if you find that a topic is confusing or not covered in sufficient depth. Your comments and suggestions will be incorporated in future releases.</p>


<p>This primer is intended to bring together the different concepts described throughout the DirectAnimation SDK. Many other topics and uses could be covered, but this should suffice to get you going in the right direction.</p>

<p>The primer contains the following topics. Because these topics build on each other, it helps to read them in order.
<ul>
<li><A HREF="animation_primer.htm#Time">Time in DirectAnimation</A>
<li><A HREF="animation_primer.htm#Timelines">Timelines</A>
<li><A HREF="animation_primer.htm#Behaviors_Duration">Behaviors' Duration</A>
<li><A HREF="animation_primer.htm#Sequencing_Behaviors">Sequencing Behaviors</A>
<li><A HREF="animation_primer.htm#Changing_Content">Changing the Content in an Animation</A>
<li><A HREF="animation_primer.htm#RunOnce_Behaviors">RunOnce Behaviors</A>
<li><A HREF="animation_primer.htm#Events_and_Predicates">Events and Predicates</A>
<li><A HREF="animation_primer.htm#Playing_with_Time">Playing with Time</A>
</ul>

<H2><A NAME="Time" IDX_CONCEPT="noindex; Time in DirectAnimation, primer">Time in DirectAnimation</A></h2>

<p>As you probably noticed by now, DirectAnimation is a time-based API. All the behavior constructs have an inherent notion of time.


 This allows for animations that are scalable, because the content will be consistent in terms of a timeline, regardless of the performance of the playback platform.</p>

<p>If you are familiar with some of the authoring tools that expose a frame-based model, or if
you are considering developing a tool or content that relies on this model, you might be
wondering if DirectAnimation's continuous-time model can accommodate that. It turns
out that it does.


 One of the advantages of DirectAnimation's continuous-time model
is that it allows frame-based models to be built on top of it (the same is not true if you
wanted to build a continuous-time model on top of a frame-based system). So, given the
key role that time plays in DirectAnimation's world, this primer starts by
examining the role of timelines.</p>

<H2><A NAME="Timelines" IDX_CONCEPT="noindex; Timelines, primer">Timelines</A></h2>

<p>A timeline, in DirectAnimation, refers to the progress of time for a behavior. When a behavior starts, its timeline starts at zero. As a result, each behavior has its own notion of time, which is its <I>local time</I>. A behavior's local time is exposed through a behavior called <A HREF="../ref_script/DAStaticProperties/DANumberObjects.htm#LocalTimev_num">LocalTime</A>, accessible through the <B>DAStatics</B> object. The <B>LocalTime</B> object enables you to use a behavior's time as part of its own animation. The concept of <B>LocalTime</B> enables you to take a behavior and move it to different points in the global timeline, without affecting how the behavior plays. This is traditionally the model presented by authoring tools.</p>

<p>But, when do behaviors, and their times, start? When you start one of the DirectAnimation controls through the <A HREF="../ref_script/class/DAViewerControlClass.htm#Startv_control">Start</A> method or a <B>DAView</B> object


 through its <A HREF="../ref_COM_C++/idaview.htm#StartModel">StartModel</A> method, all behaviors that don't depend on events are started immediately, with their individual timelines starting at zero. You can delay when a behavior starts by using constructs such as <A HREF="../ref_script/DAStaticFunctions/DABehaviorObjects.htm#Untilv_beh">Until</a> or <A HREF="../ref_script/DAStaticFunctions/DABehaviorObjects.htm#Sequencev_beh">Sequence</A>. Take a look at the following example.</p>

<PRE>
stringImg1 =
   m.StringImageAnim(m.LocalTime.ToString(3),
   m.defaultfont.size(60).color(m.Red));
// This image behavior will play first.

stringImg2 =
   m.StringImageAnim(m.LocalTime.ToString(3),
   m.defaultfont.size(60).color(m.Green));
// This image behavior will play second.

changingString =
   m.Until(stringImg1, m.LeftButtonDown, stringImg2);
// The second image plays after the click event.
</PRE>

<p>Click the <B>Show Sample</B> button to start the following sample. After the sample is running, when you click it you will see the red string behavior transition to the green string behavior, and time, displayed in green, will start at zero. This is because the <B>LocalTime</B> for the green behavior starts at zero, after that behavior gets started (which in this case is due to the mouse click). This primer will keep referring back to and modifying this example.</p>

<p><input TYPE="button" VALUE="Show Sample" STYLE="width:150" ID="btnSAMP1" OnClick="samp(1)"> </p>
<div ID="divSAMP1" align="center"></div>

<p><input TYPE="button" VALUE="Show Sample Code" STYLE="width:150" ID="btnCODE1" OnClick="code(1)"> </p>
<div ID="divCODE1"></div>

<p>
 <span ID="SAMP1_SCRIPT"><script LANGUAGE="JScript">
<!--
function SAMP1(){
   // The DirectAnimation library
   m = DAControl_1.MeterLibrary;

   stringImg1 = m.StringImageAnim(m.LocalTime.ToString(3),
		m.defaultfont.size(60).color(m.Red));

   stringImg2 = m.StringImageAnim(m.LocalTime.ToString(3),
		m.defaultfont.size(60).color(m.Green));

   changingString = m.Until(stringImg1, m.LeftButtonDown, stringImg2);

   //Assign the animation back to the control and start it
   DAControl_1.Image = m.Overlay(changingString, m.SolidColorImage(m.White));
   DAControl_1.Start();
}
-->

</script> </span></p>

<p>In this sample, the code relies on an event to control the transition and the start of a
behavior, the green string. Events are discussed in more detail later. An alternative to using events is to use the <A HREF="../ref_script/DAStaticFunctions/DABehaviorObjects.htm#Sequencev_beh">Sequence</A> construct. <B>Sequence</B> enables you to tie the start of one behavior to the end of another one. But, before sequences are discussed, the length or duration of behaviors needs to be examined, so that you can
determine when behaviors end.</p>

<H2><A NAME="Behaviors_Duration" IDX_CONCEPT="noindex; Behaviors Duration, primer">Behaviors' Duration</A></h2>


<p>All behaviors have a duration, usually referred to as their natural duration. Most behaviors' natural durations are infinite, meaning that they never end. For example, an image behavior created from a <A HREF="../ref_script/DAStaticFunctions/DAImageObjects.htm#SolidColorImagev_i">SolidColorImage</A> never ends. However, some behaviors do have a finite natural duration; for example, sound and movie behaviors have a length associated with them.</p>

<p>Many times, it is useful to give an infinite behavior a fixed duration. You can do this by using the <A HREF="../ref_script/class/DABehaviorClass.htm#durationv_beh">Duration</A> method, as seen in the following:</p>

<PRE>
myImg = m.SolidColorImage(m.Red).Duration(5.5);
// This image is now 5.5 seconds long.
</PRE>

<p>You can also use <B>Duration</B> method to cut short or lengthen a behavior's duration.</p>

<pre>
shortImg = myImg.Duration(3);
// The image from the previous example now has a duration
// of 3 seconds.

longImg = myImg.Duration(10);
// The image from the previous example now lasts for
// 10 seconds.
</pre>

<p>When you lengthen a behavior's duration, you are holding that behavior's final value. For example, a movie's image transitions to black when the movie ends. Lengthening the duration of a movie results in a black image being displayed for the remainder of the duration.


 For sound behaviors, the end value is silence. These concepts apply
to all behaviors, including number behaviors. In the following example, a
number behavior interpolates from 0 to 3 linearly over 4 seconds. Its natural
duration is 4 seconds.</p>

<pre>
myNumber = m.interpolate(0,3,4);
// interpolate from 0 to 3 over 4 seconds
</pre>

<p>You can make this number last longer, by specifying a new duration:</p>

<pre>
longerNumber = myNumber.Duration(10);
// longer duration number
</pre>

<p>The value of <I>longerNumber</I> after 4 seconds (the end of the interpolation) is going to
hold at 3, its final value.</p>


<H2><A NAME="Sequencing_Behaviors" IDX_CONCEPT="noindex; Sequencing Behaviors, primer">Sequencing Behaviors</A></h2>

<p>Now that you understand behaviors' durations, consider the <A HREF="../ref_script/DAStaticFunctions/DABehaviorObjects.htm#Sequencev_beh">Sequence</A>
construct. The first example, dealing with images from strings, is rewritten here using <B>Sequence</B> instead of <B>Until</B>.</p>

<pre>
stringImg1 =
   m.StringImageAnim(m.LocalTimeToString(3),
   m.defaultfont.size(60).color(m.Red));
// This image behavior will play first.

stringImg2 =
   m.StringImageAnim(m.LocalTimeToString(3),
   m.defaultfont.size(60).color(m.Green));
// This image behavior will play second.

stringImgSeq = m.Sequence(stringImg1, stringImg2);
// This will not work as desired.
</pre>

<p>In the preceding example, given that the natural durations for both <I>stringImg1</I> and
<I>stringImg2</I> are infinite, you would never see the second string appear, because the first one
would never end. Here is a case where you would have to use the <B>Duration</B> method. Say that you want the first string to be displayed for 2.8 seconds and then transition to the second string. You could achieve this by setting the first string's duration to 2.8.</p>

<pre>
stringImg1Finite = stringImg1.Duration(2.8);
</pre>

<p>You can now use this behavior with a finite duration in the sequence and have it perform
as expected.</p>

<pre>
stringImgSeq = m.Sequence(stringImg1Finite, stringImg2);
// Note that stringImg2 still lasts forever.
</pre>

<p>If you are dealing with objects that already have a finite duration (sounds and
movies), you can just use them in a sequence without having to specify a duration.</p>

<pre>
soundTrack = m.sequence(sound1,sound2);
// Sound 1 will play, followed by sound 2, followed by silence.
</pre>

<p>Natural duration for sounds and movies did not work for versions prior to the version
released as part of Microsoft&reg; DirectX&reg; Media 6.0. If you need to build content that is backward
compatible, you should specify the duration even for objects that have a finite natural
duration. Thus, the previous example using sound would be as follows:</p>

<pre>
soundTrack =
m.Sequence( sound1.DurationAnim(sound1Import.Duration), sound2);
//for backward compatibility with Internet Explorer 4.x run time
</pre>

<H2><A NAME="Changing_Content" IDX_CONCEPT="noindex; Changing the Content in an Animation, primer">Changing the Content in an Animation</A></h2>


<p>You have seen how to use either <B>Until</B> or <B>Sequence</B> constructs to change the content of an animation by relying on events or a behavior's duration. Another way to accomplish this is through the use of a <A HREF="../ref_script/DAStaticFunctions/DABehaviorObjects.htm#modbehv_beh">ModifiableBehavior</A>. You can think of a <B>ModifiableBehavior</B> as a placeholder for other behaviors of the same type. A <B>ModifiableBehavior</B> holds one behavior at a time, and its current behavior can be changed through the <A HREF="../ref_script/class/DABehaviorClass.htm#SwitchTov_beh">SwitchTo</A> method. Note that you can only switch to a behavior of the same type as the original behavior used to create the <B>ModifiableBehavior</B>.</p>

<pre>
modifiableColor = m.ModifiableBehavior(m.Red);
// Given an initial color value, this modifiable behavior can
// hold only color behaviors from now on.

rectImg = m.Rect(100,100).Fill(m.DefaultLineStyle,modifiableColor);
// This creates a rectangle with an initial color of red.
</PRE>

<p>At any time, you can cause the color to change, as shown in the following example.</p>

<pre>
modifiableColor.SwitchTo(m.Blue);
// This causes the color of the rectangle to change to blue.
</pre>

<p>How would you use this? A basic use is to rely on modifiable behaviors, instead of <B>Until</B> or <B>Sequence</B>, when you need to drive the animation from a change that happens outside the animation content. In general, if a change is triggered by another change in the animation itself or the change is time-dependent it is more efficient and better for synchronization to use the <B>Until</B> or <B>Sequence</B> constructs.</p>

<p>If you think of an animation as a sequence of images or behaviors, with your code controlling the transition from one frame to another, modifiable behaviors should provide a good base to build upon.


 You can think of the animation's scene as a <B>ModifiableBehavior</B>, where each frame represents a new value for that <B>ModifiableBehavior</B>.</p>

<p>Every time a behavior is switched, the behavior is considered to start and its timeline
starts from 0, as seen in the following example. Click the <B>Show Sample</B> button to start this sample. The upper red oval and the lower blue rectangle increase in size with time. Click the <B>Switch To Oval</B> button to change the lower object from a blue rectangle to a red oval and note that the size is maintained. </p>

<p><input TYPE="button" VALUE="Show Sample" STYLE="width:150" ID="btnSAMP2" OnClick="samp(2)"> </p>
<div ID="divSAMP2" align="center"></div>

<p><input TYPE="button" VALUE="Switch To Oval" STYLE="width:150" OnClick="doSwitch()"> </p>

<p>
 <span ID="SAMP2_SCRIPT"><script LANGUAGE="JScript">
<!--
function SAMP2(){
   // The DirectAnimation library
   m = DAControl_2.MeterLibrary;

  // define constants used throughout

  playTime = 14.0;
  playTimeBvr = m.DANumber(playTime);
  inBetweenFrames = 5;
  scaleBvr = m.DANumber(1.5);

  // define time varying behaviors that are shared

  increment = m.Interpolate(1,2,playTime);

  transX = m.Add(m.DANumber(-0.12),m.Div(increment,m.DANumber(13)));

  localTimeImg = m.StringImageAnim(m.LocalTime.ToString(2),m.DefaultFont.Size(9));

  content = m.ModifiableBehavior(m.EmptyImage);

  // ***************************************************************
  //
  // define the rectangle behavior
  //
  // ***************************************************************
  rect = new Array(inBetweenFrames);

  rectImg = m.Rect(0.005,0.005).Fill(m.defaultLineStyle,m.SolidColorImage(m.Blue));

  // this is the core rectangle behavior with the time varying scaling and displaying local time
  rectImg = m.Overlay(localTimeImg,rectImg).Transform(m.Scale2UniformAnim(m.Mul(increment,scaleBvr)));

  // this is the version of the rect behavior that moves along the x axis
  rectAnimImg = rectImg.Transform(m.Translate2Anim(transX,m.DANumber(0.04)));

  // the rectangles in the array serve as a background reference
  for( counter = 0; counter < inBetweenFrames; counter++) {
	// these are snapshots in time of the behavior
 	rect[counter] = rectAnimImg.Opacity(0.2).SubstituteTime(m.DANumber(playTime*counter/(inBetweenFrames-1)));
  }

  // combine all the rect background images
  rectArrayImg = m.OverlayArray( rect );

  // ***************************************************************
  //
  // define the oval behavior
  //
  // ***************************************************************
  oval = new Array(inBetweenFrames);

  ovalImg = m.Oval(0.005,0.005).Fill(m.defaultLineStyle,m.SolidColorImage(m.Red));

  // this is the core oval behavior with the time varying scaling and displaying local time
  ovalImg = m.Overlay(localTimeImg,ovalImg).Transform(m.Scale2UniformAnim(m.Mul(increment,scaleBvr)));

  // this is the version of the oval behavior that moves along the x axis
  ovalAnimImg = ovalImg.Transform(m.Translate2Anim(transX,m.DANumber(0.015)));

  // the ovals in the array serve as a background reference
  for( counter = 0; counter < inBetweenFrames; counter++) {
	// these are snapshots in time of the behavior
 	 oval[counter] = ovalAnimImg.Opacity(0.2).SubstituteTime(m.DANumber(playTime*counter/(inBetweenFrames-1)));
  }

  ovalArrayImg = m.OverlayArray( oval );

  restartEv = m.AppTriggeredEvent();

  restartEvent = m.OrEvent(m.Timer(playTime/2).RepeatForever(),restartEv);

  cyclicOval = new ActiveXObject("DirectAnimation.DAImage");
  cyclicOval.Init(m.Until(ovalImg, restartEvent, cyclicOval));

  runOncedOval = cyclicOval.RunOnce();

  DAControl_2.AddBehaviorToRun(runOncedOval);

  // ***************************************************************
  //
  // Here we combine all the behaviors from above
  //
  // ***************************************************************

  topHalfImg = m.OverlayArray( new Array(rectAnimImg, rectArrayImg, ovalAnimImg, ovalArrayImg));

  // ***************************************************************
  //
  // Now let's construct the switchers
  //
  // ***************************************************************

  switcher1 = m.ModifiableBehavior(rectImg)

  switcher1Img = switcher1.Transform(m.Translate2Anim(transX,m.DANumber(-0.02)));

  bottomHalfImg = switcher1Img;

  // ***************************************************************
  //
  // Here we create some anotation behaviors, such as labels and separators
  //
  // ***************************************************************

  separatorLine = m.Line(m.Point2(-0.07,0),m.Point2(0.07,0)).Draw(m.DefaultLineStyle);

  timeLine =  m.Line(m.Point2(0,-0.04),m.Point2(0,0.08)).Draw(m.DefaultLineStyle.Width(3)).Opacity(0.4);

  timeLineAnim = timeLine.Transform(m.Translate2Anim(transX,m.DANumber(-0.02)));

  textFont = m.DefaultFont.Size(-14);

  switchToTextImg = m.StringImage("SwitchTo Example",textFont).Transform(m.Translate2(0.032,-0.005));

  anotationsImg = m.OverlayArray( new Array(separatorLine, switchToTextImg));

  // ***************************************************************
  //
  // Put all the behaviors together and start the animation
  //
  // ***************************************************************

  finalImg =  m.OverlayArray( new Array(anotationsImg, topHalfImg, bottomHalfImg, timeLineAnim)).Duration(playTime);

  repeatingTime = m.Mod(m.LocalTime, m.DANumber(playTime+1));
  //animImg = m.Overlay(finalImg.Duration(playTime+1), m.SolidColorImage(m.White)).SubstituteTime(repeatingTime);
  animImg = m.Overlay(finalImg, m.SolidColorImage(m.White)).SubstituteTime(repeatingTime);

  content.SwitchTo(animImg);

  DAControl_2.Image = content;
  DAControl_2.Start();
}
  // ***************************************************************
  //
  // This function gets trigerred when the HTML button is clicked
  //
  // ***************************************************************
  function doSwitch() {
	switcher1.SwitchTo(ovalImg);
  }

  function restart() {
	//switcher1.SwitchTo(rectImg);
	//switcher2.SwitchTo(rectImg);
	//runOncedOval.SwitchTo(ovalImg.RunOnce());
	m.TriggerEvent(restartEv,m.DANumber(0));
	content.SwitchTo(animImg);
  }
-->

</script> </span></p>

<p>However, sometimes you don't want a behavior to restart when switched. This
brings up the concept of <A HREF="../ref_script/class/DABehaviorClass.htm#runOncev_beh">RunOnce</A>.</p>

<H2><A NAME="RunOnce_Behaviors" IDX_CONCEPT="noindex; RunOnce Behaviors, primer">RunOnce Behaviors</A></h2>

<p>Now look at an example where you are watching the progress of several behaviors over time. In the following example, every click on the green area causes a flower to grow. The example reuses the same flower, inserting it into the animation's graph at the location specified by the mouse click. In this case, you want each new flower object's timeline to restart at zero, so that you see the flower growing at each new location.</p>

<p><input TYPE="button" VALUE="Show Sample" STYLE="width:150" ID="btnSAMP3" OnClick="samp(3)"> </p>
<div ID="divSAMP3" align="center"></div>

<p><input TYPE="button" VALUE="Show Sample Code" STYLE="width:150" ID="btnCODE3" OnClick="code(3)"> </p>
<div ID="divCODE3"></div>

<p>
 <span ID="SAMP3_SCRIPT"><script LANGUAGE="JScript">
<!--
function SAMP3(){
   // The DirectAnimation library
   m = DAControl_3.MeterLibrary;

  content = new ActiveXObject("DirectAnimation.DAImage");

  flower = CreateFlower();

  sky = CreateSky();

  grass = m.Rect(0.15,0.04).Fill(m.emptyLineStyle,m.SolidColorImage(m.colorRgb(0,0.5,0.3)));
  grass = grass.Transform(m.Translate2(0,-0.02));
  
  pickFg = grass.Pickable();
  pickEvent = m.AndEvent(m.LeftButtonDown, pickFg.PickEvent);
  mouseCoords = m.UntilEx(m.MousePosition, m.always.Snapshot(m.MousePosition));
  content.Init(
	m.Until(m.EmptyImage, pickEvent,
	m.Overlay(flower.Transform(m.Translate2Anim(mouseCoords.X,mouseCoords.Y)),content))
  );  

  DAControl_3.Image = m.OverlayArray( new Array(content, pickFg.Image, sky));
  DAControl_3.Start();
}
  function CreateSky()
  {
	pointsArray = new Array(
		m.Point2(-0.06,0.03), 
		m.Point2(0.06,0.03),
		m.Point2(0.06,-0.01),
		m.Point2(-0.06,-0.01)
		);

	colorsArray = new Array( 
		m.ColorRgb(0.7,0.7,0.95),
		m.ColorRgb(0.7,0.7,0.95),
		m.ColorRgb(0.5,0.5,0.6),
		m.ColorRgb(0.5,0.5,0.6)
		);

	return m.GradientPolygon(pointsArray,colorsArray);
  }

  function CreateFlower()
  {
	stemGrowthTime = 3;

  	p1 = m.Point2(0,0);
  	p2Y = m.Interpolate(0.001,0.02,stemGrowthTime);
  	p2 = m.Point2Anim(m.DANumber(0),p2Y);

  	stem = m.Line(p1,p2).Draw(m.defaultLineStyle.Width(2).Color(m.colorRgb(0,0.8,0.2)));

	scalex = m.Interpolate(1,4,8);

	petal = m.Oval(0.001,0.0005).Fill(m.EmptyLineStyle,m.SolidColorImage(m.Red));
	petal1 = petal.Transform(m.Translate2(0.0005,0));
	petal2 = petal.Transform(m.Rotate2Degrees(45)).Transform(m.Translate2(0.0005,0.0005));
	petal3 = petal.Transform(m.Rotate2Degrees(90)).Transform(m.Translate2(0,0.0005));
	petal4 = petal.Transform(m.Rotate2Degrees(135)).Transform(m.Translate2(-0.0005,0.0005));
	petal5 = petal.Transform(m.Rotate2Degrees(180)).Transform(m.Translate2(-0.0005,0));
	petal6 = petal.Transform(m.Rotate2Degrees(225)).Transform(m.Translate2(-0.0005,-0.0005));
	petal7 = petal.Transform(m.Rotate2Degrees(270)).Transform(m.Translate2(0,-0.0005));
	petal8 = petal.Transform(m.Rotate2Degrees(315)).Transform(m.Translate2(0.0005,-0.0005));

	petals = m.OverlayArray( new Array(
		petal1,petal2,petal3,petal4,petal5,petal6,petal7,petal8));
	petals = petals.Transform(m.Scale2UniformAnim(scalex));

  	radius = m.interpolate(0.001,0.003,8);
  	ovalImg = m.OvalAnim(radius,radius).Fill(m.emptyLineStyle,m.SolidColorImage(m.Yellow));

	flowerCenter = m.OverlayArray( new Array(ovalImg, petals)).transform(m.translate2Anim(m.DANumber(0),p2Y));

	flowerCenter = m.Overlay(flowerCenter, stem.SubstituteTime(m.DANumber(3)));

  	return m.Sequence(stem.Duration(stemGrowthTime), flowerCenter);
  }
-->

</script> </span></p>

<p>However, say that you have a sample with several objects changing over time, and you allow the end-user to hide some of the objects and focus on only one or a few. Furthermore, say that you show and hide the behaviors by switching to an <A HREF="../ref_script/DAStaticProperties/DAImageObjects.htm#emptyv_i">EmptyImage</A>, as shown in the following example.</p>

<pre>
interestingObject = m.ModifiableBehavior(timeChangingImg);
</pre>

<p>When you need to hide the object, call the following:</p>

<pre>
interestingObject.SwitchTo(m.EmptyImage);
</pre>

<p>When you need to show the object, call the following:</p>

<pre>
interestingObject.SwitchTo(timeChangingImg);
</pre>

<p>The preceding code above would almost work, except for the fact that the <I>timeChangingImg</I> behavior would start back from zero every time it was switched in. To avoid this, specify that the <I>timeChangingImg</I> should be started only once in the animation, as follows:</p>

<pre>
timeChangingImg = timeChangingImg.RunOnce();
</pre>

<p>From now on, when <I>timeChangingImg</I> is switched in, it continues with its timeline as if
it had never gone away (or in other words, it follows the global timeline).</p>


<H2><A NAME="Events_and_Predicates" IDX_CONCEPT="noindex; Events and Predicates, primer">Events and Predicates</A></h2>

<p>You saw previously how to use events to cause transitions for <B>Until</B> constructs. Events are very powerful tools, not only because they can bring user actions into the animation content, but also because they can be used to express relations 
between behaviors. Events can be very simple, such as the event caused by the click of the mouse, or they can be triggered by complex statements (predicates), or even
arbitrarily triggered by your application or content.</p>

<p>In the following example, the color of the objects change when the distance between their
centers is less than 1 centimeter.</p>

<p><input TYPE="button" VALUE="Show Sample" STYLE="width:150" ID="btnSAMP4" OnClick="samp(4)"> </p>
<div ID="divSAMP4" align="center"></div>

<p><input TYPE="button" VALUE="Show Sample Code" STYLE="width:150" ID="btnCODE4" OnClick="code(4)"> </p>
<div ID="divCODE4"></div>

<p>
 <span ID="SAMP4_SCRIPT"><script LANGUAGE="JScript">
<!--
function SAMP4(){
    // The DirectAnimation library
   m = DAControl_4.MeterLibrary;

   circlePosition = m.Sequence(m.Interpolate(-0.05,0.05,3),m.Interpolate(0.05,-0.05,3)).RepeatForever();
   rectPosition = m.Sequence(m.Interpolate(0.05,-0.05,5),m.Interpolate(-0.05,0.05,5)).RepeatForever();

   distanceCondition = m.LT(m.abs(m.Sub(circlePosition,rectPosition)),m.DANumber(0.01));
   changingColor = m.Cond(distanceCondition, m.Red, m.Blue);

   circleImg = m.Oval(0.02,0.02).Fill(m.DefaultLineStyle,m.SolidColorImage(changingColor));
   rectImg = m.Rect(0.02,0.02).Fill(m.DefaultLineStyle,m.SolidColorImage(changingColor));

   movingCircle = circleImg.transform(m.translate2Anim(circlePosition, m.DANumber(0.01)));
   movingRect = rectImg.transform(m.translate2Anim(rectPosition, m.DANumber(-0.01)));

   //Assign the animation back to the control and start it
   DAControl_4.Image = m.OverlayArray( new Array(movingCircle, movingRect, m.SolidColorImage(m.White)));
   DAControl_4.Start();
}
-->

</script> </span></p>

<p>The key constructs in this example are the following two lines.</p>

<pre>
distanceCondition =
m.LT(m.abs(m.Sub(circlePosition,rectPosition)),m.DANumber(0.01));

changingColor = m.Cond(distanceCondition, m.Red, m.Blue);
</pre>

<p>Instead of using a predicate, you can also trigger an event from outside the animation
through an application-triggered event. In this case, the <I>changingColor</I> line in the
preceding example would change to the following:</p>

<pre>
colorBvr = m.Until(m.Red,changeColorEv,m.Blue);
</pre>

<p>The <B>changeColorEv</B> would be defined as:</p>

<pre>
changeColorEv = m.AppTriggeredEvent();
</pre>

<p>This example would need some external way to cause the event to fire, for example
through some logic expressed in script:</p>

<pre>
m.TriggerEvent(changeColorEv, m.DANumber(0));
</pre>


<H2><A NAME="Playing_with_Time" IDX_CONCEPT="noindex; Playing with Time, primer">Playing with Time</A></h2>

<p>You already know that a behavior's timeline starts at zero, and that every behavior has a
duration. If you want to accelerate, slow down, stop, or revert a behavior, you can use the <A HREF="../ref_script/class/DABehaviorClass.htm#substituteTimev_beh">SubstituteTime</A> method. <B>SubstituteTime</B> can take a constant value, which causes time to stop at that point, or it can take an expression that evaluates time.</p>

<p>For example, given a movie's image behavior, <I>movieImg</I>, you can stop the image at 12
seconds into the movie by doing the following:</p>

<pre>
movieImg = movieImport.Image;

stoppedImg = movieImg.SubstituteTime(12);
</pre>

<p>If you wanted to make the movie run at twice its original speed, you could express that
as follows:</p>

<pre>
fasterImg = movieImg.SubstituteTime(
m.Mul( m.DANumber(2), m.LocalTime));
</pre>

<p>To make the movie go backward, you could do it as follows:</p>

<pre>
backwardsImg = movieImg.SubstituteTime(
m.Sub(movieImport.Duration,m.LocalTime));
</pre>

<p>Note that in the preceding example dealing with faster playback, you could have easily made
the speed of playback dependent on an event, as shown in the following:</p>

<pre>
movieSpeed =
m.Until(m.DANumber(1),m.LeftButtonDown,m.DANumber(2));

fasterImg =
movieImg.SubstituteTime( m.Mul( movieSpeed, m.LocalTime));
</pre>

<H6><HR size=1></H6>
<P><A CLASS="line" HREF="#pagetop"><IMG src="../art/arrowup1.gif" WIDTH="11" HEIGHT="11" ALIGN="MIDDLE" BORDER=0 ALT="Top of Page">&nbsp;Top of Page</A>
<BR><A CLASS="line" HREF="../../cpyright.htm">&#169; 1998 Microsoft Corporation. All rights reserved. Terms of Use.</A>
<!-- END_PAGE_FOOTER -->


</BLOCKQUOTE>
</BODY>
</HTML>