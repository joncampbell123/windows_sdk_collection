<!-- DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN" -->

<HTML>
<HEAD><TITLE>The Basics</TITLE>
<META NAME="Description" CONTENT="The Basics">
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; CHARSET=iso8859-1">
<META NAME="MS.LOCALE" CONTENT="EN-US">
<META NAME="ROBOTS" CONTENT="all">

<SCRIPT LANGUAGE="JavaScript">var sRelPath = '../' </SCRIPT>
<SCRIPT LANGUAGE="JAVASCRIPT">var g_isIE = false, g_isNav = false, g_iMaj = 0, g_sPlat = "";</SCRIPT>
<SCRIPT SRC="../ver.js"></SCRIPT>
<SCRIPT SRC="../gloss.js"></SCRIPT>
<SCRIPT SRC="../samples.js"></SCRIPT>
<SCRIPT DEFER SRC="../common.js"></SCRIPT>
<SCRIPT DEFER>
//<!--
function InitPage()
{
	if (g_isIE && g_iMaj >= 4)	
	{

		SetTOC();
	}
}
//-->

</SCRIPT>

<!-- STYLE_START -->

<SCRIPT LANGUAGE="JAVASCRIPT">
//<!--
   var sVR = '../'	// Set root for the style sheet
   var sCSS = '<LINK REL="stylesheet" HREF="' + sVR;

   if(g_isIE)
   {
	   if (g_iMaj >= 4) // For MSIE 4.0 or later
	   {
		   sCSS += 'dxm_basicSDKIE4';
		   if (g_sPlat == "Win") // Windows only for now
		   {
			   document.createStyleSheet(sVR + 'dxm_advSDKIE4.css');
		   }
	   }
	   else // For MSIE 3.0 or earlier
	   {
		   sCSS += 'dxm_basicSDKIE3';
	   }
   }
   else if (g_isNav) // For all Nav versions
   {
	   sCSS += 'dxm_basicSDKNAV';
   }
   else
   {
	   sCSS += 'dxm_basicSDKIE3'; // default to IE3 sheet
   }

   sCSS += (sCSS == '' ? '' : '.css" TYPE="text/css">');

   document.write(sCSS);
//-->

</SCRIPT>
<!-- STYLE_END -->


</HEAD>
<BODY onload="InitPage(); if (g_isIE && g_iMaj >= 4){HdgrphControl(); initGloss()}" BGCOLOR="#FFFFFF">
<A NAME="pagetop"></A><A NAME="The_Basics"></A>

<!-- HEADGRAPH_START -->

<TABLE CLASS="main" BORDER=0 CELLSPACING="0" CELLPADDING="0" WIDTH="*">
<TR>
<TD ROWSPAN="3" VALIGN="TOP" WIDTH="*">
<IMG SRC="../art/header1.gif" WIDTH="107" HEIGHT="110" BORDER=0 ALT="The Basics"></TD>
<TD ROWSPAN="2" VALIGN="TOP" WIDTH="217">
<IMG SRC="../art/hdrdanim.gif" WIDTH="217" HEIGHT="110" BORDER=0 ALT="DirectAnimation Animated Header --The Basics"></TD><TD VALIGN="TOP" WIDTH="383"><IMG SRC="../art/header3.gif" WIDTH="383" HEIGHT="95" BORDER=0 ALT="DirectAnimation Animated Header">
</TD>
<TD VALIGN="TOP" WIDTH="100%">
<IMG SRC="../art/spacer1.gif" WIDTH="100%" HEIGHT="94" BORDER=0 ALT="Microsoft DirectAnimation SDK">
</TD>
</TR>
<!-- HEADGRAPH_END -->


<!-- DACONTROL_START -->

	<DIV ID="HeadGraphAnim"></DIV>
	<SCRIPT LANGUAGE="JAVASCRIPT">if((g_isIE == true) && (g_iMaj > 3)) {window.self.document.writeln('<SCR' + 'IPT SRC="../anim.js"></SCR' + 'IPT>')}</SCRIPT>
<!-- DACONTROL_END -->


<!-- NAV_LINKS_START -->


<TR><TD VALIGN="TOP"><PRE><IMG ID="TOC_" SRC="../art/yelbtn.gif" WIDTH="11" HEIGHT="11" ALIGN="MIDDLE" BORDER=0 ALT="*"><A STYLE="color:black;font-weight:bold" ID="TOC" HREF="../contents.htm">Contents</A>  <IMG SRC="../art/yelbtn.gif" WIDTH="11" HEIGHT="11" ALIGN="MIDDLE" BORDER=0 ALT="*"><A STYLE="color:black;font-weight:bold" HREF="../index.htm">Index</A>  <IMG SRC="../art/yelbtn.gif" WIDTH="11" HEIGHT="11" ALIGN="MIDDLE" BORDER=0 ALT="*"><A STYLE="color:black;font-weight:bold" HREF="proguide_oview.htm">Topic Contents</A>
</PRE></TD></TR>
<TR><TD COLSPAN="2" VALIGN="TOP"><PRE><IMG SRC="../art/yelbtn.gif" WIDTH="11" HEIGHT="11" ALIGN="MIDDLE" BORDER=0 ALT="*"><B>Previous Topic:</B> <A STYLE="color:black" HREF="proguide_Intro.htm">Introduction</A>
<IMG SRC="../art/yelbtn.gif" WIDTH="11" HEIGHT="11" ALIGN="MIDDLE" BORDER=0 ALT="*"><B>Next Topic:</B> <A  STYLE="color:black" HREF="proguide_MediaBehaviors.htm">Using Media Behaviors</A>
</PRE>
</TD></TR></TABLE>
<!-- NAV_LINKS_END -->


<!-- START POP-UP GLOSSARY -->

	<SCRIPT LANGUAGE="JAVASCRIPT">if((g_isIE == true) && (g_iMaj > 3)) {window.self.document.writeln('<SCR' + 'IPT SRC="../tip.js"></SCR' + 'IPT><IFRAME ID="G_L_S" NAME="SecretBuffer" STYLE="display: none" SRC=""></IFRAME>')}</SCRIPT>
<!-- END POP-UP GLOSSARY -->





<BLOCKQUOTE CLASS="body">

<!-- CONTENTS_START -->



<H1>The Basics</H1>

<P>This section covers a variety of concepts and techniques useful to many types of DirectAnimation authors: Web site builders, script writers, and application developers. The following topics are discussed in this section:

<UL><LI><A HREF="proguide_basics.htm#Thinking_About_DirectAnimation">Thinking About DirectAnimation</A>
<LI><A HREF="proguide_basics.htm#Media_Files_Supported_by_DirectAnimation">Media Files Supported by DirectAnimation</A>
<LI><A HREF="proguide_basics.htm#Scripting">Scripting</A>
<LI><A HREF="proguide_basics.htm#The_Statics_Class">The Statics Class</A>
<LI><A HREF="proguide_basics.htm#Naming_Conventions_in_DirectAnimation">Naming Conventions in DirectAnimation</A>
<LI><A HREF="proguide_basics.htm#Viewing_DirectAnimation_Functions">Viewing DirectAnimation Functions in Visual Basic</A>
<LI><A HREF="proguide_basics.htm#A_Simple_JScript_Example">A Simple JScript Example</A>
<LI><A HREF="proguide_basics.htm#A_Simple_Java_Example">A Simple Java Example</A>
<LI><A HREF="proguide_basics.htm#Coordinates_in_DirectAnimation">Coordinates in DirectAnimation</A>
<LI><A HREF="proguide_basics.htm#Timelines">Scripting Timelines Using Duration</A>
<LI><A HREF="proguide_basics.htm#Arrays_and_Tuples">Arrays and Tuples</A>
<LI><A HREF="proguide_basics.htm#URLs_and_Paths">URLs and Paths</A>
<LI><A HREF="proguide_basics.htm#Lights">Lights</A>
<LI><A HREF="proguide_basics.htm#Drawing_Surface">Drawing Surface</A>
<LI><A HREF="proguide_basics.htm#Splines">Splines</A>
<LI><A HREF="proguide_basics.htm#C++_programming">Using the Scripting Reference in C++ Programming</A>
<LI><A HREF="proguide_basics.htm#Transforms">Using DirectX Transform Effects</A>
</UL>
<H2><A NAME="Thinking_About_DirectAnimation" IDX_CONCEPT="noindex; Thinking about DirectAnimation">Thinking About DirectAnimation</A></H2>
<P>This section introduces the basic elements of the DirectAnimation model, including media expressions in DirectAnimation, and suggests analogies to number expressions and spreadsheets.
<A NAME="Media_Expressions"></A><P><B>Media Expressions</B>
<P>DirectAnimation can be explained in terms of the familiar concept of expressions on numbers in programming languages (Fortran, C++, Visual Basic, Java, and so on). Such expressions are based on operations that construct new numbers from existing numbers. For example, (5 + 7) * 4 + 3 constructs the number 51.
<P>Before expressions were introduced into programming languages, it took the following tedious steps to evaluate this expression:
<PRE>
  Load 5 -&gt; x
  Load 7 -&gt; y
  Add  x,y -&gt; x
  Load 4 -&gt; y
  Mult x,y -&gt; x
  Load 3 -&gt; y
  Add x,y -&gt; x
</PRE>
<P>DirectAnimation uses an expression-based approach to construct more complex media values based on simpler media values and operations working on these values. For example, the expression
<PRE>frontImage*rotation + backImage
</PRE>
<P>Evaluates to a rotating <A CLASS="Glossary" HREF="javascript:Glossary(sRelPath + 'gloss/gloss_I.htm#image')">image</A> overlaying a second image, just as the above expression evaluates to 51.

<P>In algebra, operations and numbers combine to return a result according to certain rules. So too, in DirectAnimation, do operations on animation and media elements combine to produce interesting interactive, animated and mixed-media content. You can apply many of the concepts of algebra to constructing interesting animation in DirectAnimation. 

<P>DirectAnimation has a set of abstract data types, for example, a number behavior (NumberBvr) or a <A CLASS="Glossary" HREF="javascript:Glossary(sRelPath + 'gloss/gloss_C.htm#color')">color</A> behavior (ColorBvr). Abstract types are described in terms of the high-level operations they support without exposing implementation or representation details. Since it is typical to have thousands of behaviors in an animation, thinking of behaviors as operations on abstract data types can help make the complexity manageable. Operations create composite behaviors; for example, angle = sin(NumberBvr theta), or redGeo = geo.diffuseColor(ColorBvr red), applies the color constant red to a <A CLASS="Glossary" HREF="javascript:Glossary(sRelPath + 'gloss/gloss_G.htm#geometry')">geometry</A>. 

<P>As in algebra, where in an expression such as angle = sin(t* 2*pi/period) t is time, behaviors in DirectAnimation can be time-varying. DirectAnimation generalizes time-varying values beyond numbers. For example, you can construct a time-varying image as follows: 
<PRE>
ImageBvr image3 = overlay(image1.transform(rotate(localTime)), image2)
</PRE>
<P>This expression sets image3 to be image1 rotating at one radian per second and overlaying image2. 

<A NAME="Behaviors_Are_Retained"></A><P><B>Behaviors Are Retained</B>
<P>Time-varying behaviors in DirectAnimation are retained, in the sense that executing a behavior expression (such as the one in the previous section) constructs a data structure that is retained after the execution concludes. This is unlike traditional number expressions in programming languages where the expression evaluates conclusively into a result at the time of execution. In this respect, DirectAnimation expressions are more like cells in a spreadsheet; they don't execute just once, but are retained, and their value changes as their parameters (other behaviors) change.

<P>Using behavior expressions relieves the developer of significant maintenance work. For example, assume you have defined a <A CLASS="Glossary" HREF="javascript:Glossary(sRelPath + 'gloss/gloss_P.htm#path')">path</A> behavior (<A HREF="../ref_java/class/Path2Bvr.htm#Path2Bvr_Class">Path2Bvr</A> ) called <I>line</I> and a transformation behavior (<A HREF="../ref_java/class/Transform2Bvr.htm#Transform2Bvr_Class">Transform2Bvr</A>) called <I>wiggle</I> that is a sinusoidal translation. You can then combine them into a time-varying image behavior (<A HREF="../ref_java/class/ImageBvr.htm#ImageBvr_Class">ImageBvr</A> ) called <I>wigglingLine</I>. You can then import an image (perhaps a JPEG from a file) and call it <I>background</I> and <A CLASS="Glossary" HREF="javascript:Glossary(sRelPath + 'gloss/gloss_O.htm#overlay')">overlay</A> <I>wigglingLine</I> on <I>background</I>. Call this time-varying image <I>myImage</I>.

<P>Now, assume you have imported or synthesized a three-dimensional (3-D) cube and assigned it a path to traverse or a rate at which to expand. You can <A CLASS="Glossary" HREF="javascript:Glossary(sRelPath + 'gloss/gloss_T.htm#texture')">texture</A> the animated cube with <I>myImage</I> and get a cube that is both animated and has an animated texture. Since this behavior is retained, once you have joined the texture to the cube the texturing operation keeps checking the time-varying value of its wiggling line; it calculates the result and applies the new texture to the cube. The programmer constructs the relation between the texture and the cube and then doesn't need to intervene any further. If, on the other hand, the line is fixed and not wiggling, DirectAnimation is optimized not to calculate texture values over and over and thus saves CPU cycles. 
<A NAME="Reactive_Behaviors"></A><P><B>Reactive Behaviors</B>
<P>There are two key concepts in DirectAnimation: continuous behaviors, and events. These are combined into reactive behaviors. A reactive behavior varies continuously with time and reacts to specific events by switching to new behaviors. For example, a ball bouncing (moving on its path) in a room is a continuous behavior. The ball colliding with the wall or floor is an event. 

<P>Assume you have imported two geometries (from two .X files, for instance) that are 3-D balls with radii r1 and r2 separated by a time-varying distance d. You can define a collision event as:

<PRE>Collide = Predicate(leq(d, add(r1, r2))
</PRE>
<P>That is, when the distance between the two balls is less than or equal to the sum of their radii, they collide.

<P>This event can be used as follows:
<PRE>bvr1 = until (initial_behavior, Collide, bounce_behavior)
</PRE>
<P>The <A HREF="../ref_java/staticmethods/BehaviorObjects.htm#until_beh">until</A> operation constructs a behavior which starts as an initial behavior (such as "parabolic path") until the event occurs, then switches to a bounce behavior. The behavior switched to after the event can be constant (the ball stops) or can be calculated from parameters at the time of the event (a new path is calculated based on the ball's position and the paths the two balls were traveling at the time of the collision). Thus, <B>until</B> creates a new reactive behavior (bvr1) that is the first behavior until the event occurs, and then becomes the second behavior.

<P>Similarly, it is possible to define an event based on the user selecting one of the balls by pointing and clicking:
<PRE>Grab= andEvent(Pick, leftButtonDown)
</PRE>
<P>And used as follows:
<PRE>bvr2= until(parabolic_path_behavior, Grab,
follow_mouse_position_behavior)
</PRE>
<P>Or you can make the ball explode on either event as follows:
<PRE>Explosion = orEvent(Collide, Grab)
Explosion_Bvr = until(parabolic_path_behavior,
Explosion, flying_ball_fragments_behavior)
</PRE>
<P>DirectAnimation supports both arrays and tuples. An <i>array</i> is a homogeneous list of behaviors (behaviors that are all of the same type, such as all colors or all images). A <i>tuple</i> is a heterogeneous list of behaviors (behaviors that can be different, such as a color behavior and an image behavior). Tuples are especially useful for grouping behaviors that all switch at the same event. For example:
<PRE>Synch_tuple = until(tuple1, event, tuple2)
</PRE>
<P>This helps to synchronize the switching of different behaviors at one event. 

<A NAME="Interactive_versus_Reactive_Behaviors"></A><P><B>Interactive Versus Reactive Behaviors</B>
<P>Reactivity is the notion of switching from one behavior to another based on some event. Interactivity is the notion of user input and how it influences the progression of the animation. Events can be based on user input (such as a button press) or they can be synthetic (based on computations, such as the collision event discussed previously). User input can be in the form of an event or it can be in the form of a continuous behavior such as moving the mouse cursor. For example, a user can drag the ball with a mouse to give it continuous motion, or click on the ball and stop it with an event. Both plain behaviors and events can be either interactive or computed (synthetically generated). 
<A NAME="Media_Graphs"></A><P><B>Media Graphs</B>
<P>DirectAnimation supports operations on media types that result in expressions producing composite media values. These expressions build retained structures called media graphs which operate on time-varying entities. Media graphs are akin to scene graphs in 3-D graphics systems, but they differ in that they are mixed-media based and contain combinations of behaviors, events, and user input. User input (as both continuous behaviors and events) feeds into constructed media graphs, which in turn produce visual and audio media behaviors that are displayed on the user's system.


<H2><A NAME="Media_Files_Supported_by_DirectAnimation">Media Files Supported by DirectAnimation</A></H2>
<P>DirectAnimation supports the following media file types:
<UL><LI>Three-dimensional (3-D) images: .x files
<LI>Two-dimensional (2-D) images: .gif, .png, .jpg, and .bmp files
<LI>Video: .avi, .mpg, .mpeg, .mpv, .mp2, .mpe, .mov, and .qt files
<LI>Audio: .mid and .wav files
</UL>
<P>DirectAnimation supports all the audio and video file types supported in DirectShow. If the user has a DirectShow filter installed for a particular format, such as DV or Line 21 (for closed captions), then this format also will be supported.


<H2><A NAME="Scripting" IDX_CONCEPT="noindex; scripting in DirectAnimation">Scripting</A></H2>
<P>The DirectAnimation scripting interfaces make it easy to use DirectAnimation from an HTML environment. The DirectAnimation library provides a set of methods for animating multimedia elements such as images, <A CLASS="Glossary" HREF="javascript:Glossary(sRelPath + 'gloss/gloss_S.htm#sprite')">sprites</A>, movies, and <A CLASS="Glossary" HREF="javascript:Glossary(sRelPath + 'gloss/gloss_S.htm#sound')">sound</A>, in addition to 2-D and 3-D objects. It includes support for animation paths, rotations, and other transformations. A timeline sequencing feature makes it possible to build lifelike animations using simple components as modular building blocks. 
<P>The library works in cooperation with the DirectAnimation integrated-media control (<A HREF="../ref_script/class/DAViewerControlClass.htm#DAViewerControl_Class">DAViewerControl</A>). Library calls are made through a scripting language such as JScript or VBScript to construct an animation and play it in the Dynamic HTML compositing space. 
<P>Typically you declare your <A HREF="../ref_script/class/DAViewerControlClass.htm#DAViewerControl_Class">DAViewerControl</A> object as shown in the following JScript sample. The object's name can be anything. Here it is <I>DAControl</I>. The CLSID must be as shown:
<PRE>
&lt;DIV ID=controlDiv&gt;
&lt;OBJECT ID="DAControl"
        STYLE="position:absolute; left:10; top:10;width:500;height:450"
        CLASSID="CLSID:B6FFC24C-7E13-11D0-9B47-00C04FC2F51D"&gt;
&lt;/OBJECT&gt;
&lt;/DIV&gt;

&lt;SCRIPT LANGUAGE="JScript"&gt;
&lt;!--
   m = DAControl.PixelLibrary;
   ...
//--&gt;
&lt;/SCRIPT&gt;
</PRE>
<P>The variable "m" is shorthand for the <A HREF="../ref_script/class/DAStaticsClass.htm#DAStatics_Class">DAStatics</A> Library. All functions and properties contained in that library must be preceded by an "m" so the interpreter can find them. For example:
<PRE>
  myImage = m.SolidColorImage(m.Red);
</PRE>
<P>In this example, <A HREF="../ref_script/dastaticfunctions/DAImageObjects.htm#solidColorImagev_i">SolidColorImage</A> is a <A HREF="../ref_script/class/DAStaticsClass.htm#DAStatics_Class">DAStatics</A> function that creates a <A HREF="../ref_script/class/DAImageClass.htm#DAImage_Class">DAImage</A> object, and <A HREF="../ref_script/class/DAColorClass.htm#getRedv_col">Red</A> is a <B>DAStatics</B> property that defines the color red.
<P>Once you have constructed the renderable media type (an image or sound), you tell the <A HREF="../ref_script/class/DAViewerControlClass.htm#DAViewerControl_Class">DAViewerControl</A> object what to display, as shown in the following JScript code: 
<PRE>
   DAControl.Image = myImage;
   DAControl.Sound = mySound;
</PRE>
<P>Then tell the object to start the model with the <A HREF="../ref_script/class/DAViewerControlClass.htm#startv_control">Start</A> subroutine, as shown in the following JScript code:
<PRE>
   DAControl.Start();
</PRE>
<P>The <A HREF="../ref_script/class/DAViewerControlClass.htm#DAViewerControl_Class">DAViewerControl</A> has the CLSID B6FFC24C-7E13-11D0-9B47-00C04FC2F51D and is a windowless control, so it can be used with Dynamic HTML, and it can be used over or under other objects on the screen. DirectAnimation also provides the more traditional windowed control (class <B>DAViewerControlWindowed</B>) with the CLSID 69AD90EF-1C20-11D1-8801-00C04FC29D46. If you are working in a traditional environment, such as Visual Basic, it is recommended that you use the windowed control.


<H2><A NAME="The_Statics_Class" IDX_CONCEPT="noindex; Statics Class, using">The Statics Class</A></H2>
<P>The <A HREF="../ref_script/class/DAStaticsClass.htm#DAStatics_Class">DAStatics</A> class (in Java, the <B>com.ms.dxmedia.Statics</B> class) collects all the static functions and constants provided by the other classes and makes them available as static methods on the <B>DAStatics</B> (Java <A HREF="../ref_java/class/Statics.htm#Statics_Class">Statics</A>) class. In scripting languages this means all the static functions and constants are available through the control object. For example:
<PRE>
&lt;DIV ID=controlDiv&gt;
&lt;OBJECT ID="DAControl"
        STYLE="position:absolute; left:10; top:10;width:500;height:450"
        CLASSID="CLSID:B6FFC24C-7E13-11D0-9B47-00C04FC2F51D"&gt;
&lt;/OBJECT&gt;
&lt;/DIV&gt;

&lt;SCRIPT LANGUAGE="JScript"&gt;
&lt;!--
   m = DAControl.PixelLibrary;
   ...
//--&gt;
&lt;/SCRIPT&gt;
</PRE>
<P>After this declaration, each function, property, and constant that is contained in the <A HREF="../ref_script/class/DAStaticsClass.htm#DAStatics_Class">DAStatics</A> library must be preceded by an "m" so the interpreter can find it. For example:
<PRE>
  myImage = m.SolidColorImage(m.Red);
</PRE>
<P>In Java, all of the static methods in the <A HREF="../ref_java/class/Statics.htm#Statics_Class">Statics</A> library become available without qualification. For example:
<PRE>
ImageBvr im = solidColorImage(blue);
</PRE>
<P>If you want to write DirectAnimation code outside of a <B>Model</B> class without qualifying your calls to static methods, you can create your own class that extends the <A HREF="../ref_script/class/DAStaticsClass.htm#DAStatics_Class">DAStatics</A> class. If this is not feasible (because the class already extends another class), then explicit name qualifications are required.


<H2><A NAME="Naming_Conventions_in_DirectAnimation" IDX_CONCEPT="noindex; Naming Conventions in DirectAnimation">Naming Conventions in DirectAnimation</A></H2>
<P>This section discusses the naming conventions used in the COM API, which are exposed to JScript and VBScript users. In COM, and thus in scripting, when two similar methods differ only in the type of at least one of their parameters, then these two methods must have different names. This is in contrast to other languages such as Java and C++, which make it possible to use the same method name in such a case. For this reason, in the <I>Scripting Reference</I> you'll find different variations of essentially the same method, with slightly adapted names. The different suffixes that are used are as follows:
<UL><LI><A HREF="proguide_basics.htm#Anim_Naming_Convention">Anim</A>
<LI><A HREF="proguide_basics.htm#Rate_Naming_Convention">Rate</A>
<LI><A HREF="proguide_basics.htm#Degrees_Naming_Convention">Degrees</A>
</UL>
<A NAME="Anim_Naming_Convention"></A><P><B>Anim Naming Convention</B>
<P>The functions with <I>Anim</I> in the name, such as <A HREF="../ref_script/dastaticfunctions/DAPoint2Objects.htm#point2anv_pt2">Point2Anim</A>, are counterparts of the non-<I>Anim</I> versions, such as <A HREF="../ref_script/dastaticfunctions/DAPoint2Objects.htm#point2v_pt2">Point2</A>. The difference is that the <I>Anim</I> versions take time-varying parameters, and produce animated results. Functions with <I>Anim</I> take animated parameters of type <A HREF="../ref_script/class/DANumberClass.htm#DANumber_Class">DANumber</A> or <A HREF="../ref_script/class/DAStringClass.htm#DAString_Class">DAString</A>. Functions without <I>Anim</I> take parameters that are doubles, integers, and regular strings. For example the following two statements are equivalent:
<PRE>
   M = DAControl.PixelLibrary;
   P1 = m.Point2(34, 100);
   P2 = m.Point2Anim(m.DANumber(34), m.DANumber(100));
</PRE>
<P>(Note that <B>DANumber</B>(<I>x</I>) converts the regular number <I>x</I> into a number behavior.)
<P>Since the second form is longer, what is its value? The longer form becomes necessary if you want to construct a time-varying point. For example:
<PRE>
   //constructs a number that varies between 34 and 50 in 3 secs.
   xNum = m.SlowInSlowOut(34, 50, 3, 0);&#009;
   // constructs a point that travels on the Y = 100 line, between
   // the two X values in 3 secs.
   P2 = m.Point2Anim(xNum, m.DANumber(100));
</PRE>
<P><I>P2</I> is a time-varying point that can be used to build other time-varying entities. For example, it can be used as a parameter to <A HREF="../ref_script/dastaticfunctions/DATransform2Objects.htm#translateptv_xf2">Translate2Point</A>. Note that in cases where there is no non-<I>Anim</I> version of a certain function then the <I>Anim</I> suffix is omitted even if the function's parameters are time-varying, as is the case with <B>Translate2Point</B>. 

<A NAME="Rate_Naming_Convention"></A><P><B>Rate Naming Convention</B>
<P>Sometimes to construct time-varying values it is easier to specify the rate of change of the value than to specify the value itself. DirectAnimation provides variations to functions that accept rate-of-change parameters as a convenience. For example:
<PRE>
   RotXf = m.Rotate2Rate(Math.PI/3);
</PRE>
<P> This code constructs a time varying 2-D rotation of PI/3 per second, and is equivalent to:
<PRE>
   RotXf = m.Rotate2Anim(m.Mul(m.LocalTime, m.DANumber(Math.PI/3)));
</PRE>
<P>Note that <A HREF="../ref_script/dastaticfunctions/DANumberObjects.htm#mulv_num">Mul</A> is for multiplying two <A HREF="../ref_script/class/DANumberClass.htm#DANumber_Class">DANumber</A>s together, and <A HREF="../ref_script/dastaticproperties/DANumberObjects.htm#LocalTimev_num">LocalTime</A> is time, which increases by one unit per second.

<A NAME="Degrees_Naming_Convention"></A><P><B>Degrees Naming Convention</B>
<P>Methods with the <I>Degrees</I> suffix take their angle parameters in degrees as opposed to radians. These are convenience functions that spare the user from doing the conversion explicitly, if the user chooses to specify angle parameters in degrees. For example, consider the following statement with radian parameters:
<PRE>
   RotXf = m.Rotate2Rate(Math.PI/3);
</PRE>
<P>This can be expressed with degrees as:
<PRE>
   RotXf = m.Rotate2RateDegrees(60);
</PRE>
<H2><A NAME="Viewing_DirectAnimation_Functions" IDX_CONCEPT="noindex; Visual Basic, viewing DirectAnimation functions in">Viewing DirectAnimation Functions in Visual Basic</A></H2>
<P>To view the DirectAnimation library functions in Visual Basic, follow these steps:
<OL><LI>Install DirectAnimation.
<LI>In Visual Basic, choose <B>Components</B> from the <B>Project</B> menu. A <B>Components</B> dialog box appears.
<LI>On the <B>Controls</B> tab, check the box next to <B>DirectAnimation Library</B>, and click the <B>OK</B> button. The DAViewerControl will appear as a choice in the Toolbox.
<LI>Click on the control in the Toolbox, then draw the control onto a form.
<LI>Choose <B>Object Browser</B> from the <B>View</B> menu. The object browser appears.
<LI>At the top left of the object browser (where it says <B>All Libraries</B>), choose <B>DirectAnimationCtl</B> from the drop-down list.
<LI>Click a class or interface to display its functions.
<LI>Click a function to display its Visual Basic syntax (at the bottom of the object browser).
</OL>
<H2><A NAME="A_Simple_JScript_Example" IDX_CONCEPT="NOINDEX; JScript Example, Basic">A Simple JScript Example</A></H2>
<P>The following code creates a red oval and spins it around. To create this JScript example, follow these steps:
<OL><LI>Declare the <A HREF="../ref_script/class/DAViewerControlClass.htm#DAViewerControl_Class">DAViewerControl</A> windowless control with an &#060;OBJECT&#062; tag. 
<P>
You can use any name for the control. You can set the control's position and size on the HTML page by specifying the value of the left position, the value of the top position, and the height and width of the control. You can also specify that the windowless control appears underneath other images and text on the page by specifying <br>z-index: -1.
<PRE>&lt;OBJECT ID="DAControl"
  STYLE="position:absolute;
  left:30%; top:100;width:300;height:300;z-index: -1" 
  CLASSID="CLSID:B6FFC24C-7E13-11D0-9B47-00C04FC2F51D"&gt;
&lt;/OBJECT&gt;
</PRE>
<LI>In the scripting section of your HTML file, declare a <A HREF="../ref_script/class/DAStaticsClass.htm#DAStatics_Class">DAStatics</A> library object (<I>m</I> in the example below) and attach it to either the <A HREF="../ref_script/class/DAViewerControlClass.htm#pixelv_control">PixelLibrary</A> or <A HREF="../ref_script/class/DAViewerControlClass.htm#meterv_control">MeterLibrary</A>. 
<PRE>
  m = DAControl.PixelLibrary;
</PRE>
<LI>Access functions and subroutines in the <A HREF="../ref_script/class/DAStaticsClass.htm#DAStatics_Class">DAStatics</A> library through the object (<I>m</I> in the example below) to create or import your media types (such as images, movies, and sound) and animate them.
<PRE>
  fillImg = m.SolidColorImage(m.Red);
</PRE>
<LI>Set the media to be displayed as a property of the <A HREF="../ref_script/class/DAViewerControlClass.htm#DAViewerControl_Class">DAViewerControl</A> object, either the <A HREF="../ref_script/class/DAViewerControlClass.htm#imagev_control">Image</A> property or <A HREF="../ref_script/class/DAViewerControlClass.htm#soundv_control">Sound</A> property. 
<PRE>
  DAControl.Image = finalImg; 
</PRE>
<LI>Invoke rendering of the control with <A HREF="../ref_script/class/DAViewerControlClass.htm#startv_control">Start()</A>. Whatever <A HREF="../ref_script/class/DAViewerControlClass.htm#imagev_control">Image</A> property or <A HREF="../ref_script/class/DAViewerControlClass.htm#soundv_control">Sound</A> property the <A HREF="../ref_script/class/DAViewerControlClass.htm#DAViewerControl_Class">DAViewerControl</A> object has when started determines what will be rendered. 
<PRE>
  DAControl.Start()
</PRE>
</OL>
<P>Click the <B>Show Sample</B> button to display the JScript example. To see the code, click the <b>Show Sample Code</b> button.







<H4>Simple Sample</H4>

<P>
&nbsp;<INPUT TYPE=button VALUE="Show Sample" STYLE="width:150" ID=btnSAMP1 OnClick="samp(1)">
<P><BR>
<DIV ID=divSAMP1 align="center"></DIV>
<TABLE BORDER="0" CELLSPACING="4" CELLPADDING="0"><TR><TD>

<INPUT TYPE=button VALUE="Show Sample Code" STYLE="width:150" ID=btnCODE1 OnClick="code(1)">
<PRE><DIV ID=divCODE1></DIV></PRE>
</TD></TR></TABLE> 



<SPAN ID="SAMP1_SCRIPT">
<SCRIPT LANGUAGE="JScript">
<!--
function SAMP1(){
 // The DirectAnimation library
  m=DAControl_1.PixelLibrary;

  // define a red oval
  fillImg=m.Until(m.SolidColorImage(m.Red), m.LeftButtonDown, m.SolidColorImage(m.Green));
  ovalImg=m.Oval(100,100).Fill(m.DefaultLineStyle, fillImg);

  // rotate 45 degrees per sec around first diagonal
  rotXf =m.Rotate3RateDegrees(m.Vector3(1,1,1), 45).ParallelTransform2();   
  finalImg=ovalImg.Transform(rotXf);

  // set the rotating oval, an image, as the model to be displayed
  DAControl_1.Image=finalImg; 
  // set the background in case of a non-windowless browser (like IE3)
  DAControl_1.BackgroundImage=m.SolidColorImage(m.Blue);     
     
  // start the animation       
  DAControl_1.Start();
}
//-->

</SCRIPT>
</SPAN>






<P>You can add interaction to this sample by changing the code to respond to a user-initiated event. You can make an image red until the left mouse button is clicked, then turn it green with the following statement:
<PRE>
  fillImg = m.Until(m.SolidColorImage(m.Red), m.LeftButtonDown,
  m.SolidColorImage(m.Green));
</PRE>
<P>The <A HREF="../ref_script/dastaticfunctions/DABehaviorObjects.htm#untilv_beh">Until</A> function causes <I>fillImg</I> to be red until the <A HREF="../ref_script/dastaticproperties/DAEventObjects.htm#leftButtonDownv_dxmevent">LeftButtonDown</A> event occurs, then turns <I>fillImg</I> green. 



<H2><A NAME="A_Simple_Java_Example" IDX_CONCEPT="NOINDEX; Java Example, Basic">A Simple Java Example</A></H2>
<P>The following "Hello, World" example demonstrates some of the basic steps involved in developing a DirectAnimation application. The first step uses DirectAnimation for Java to construct an applet that, when displayed, results in a rendered text string that says "Hello, World." There is no animation and no interaction. 
<PRE>
import com.ms.dxmedia.*;
public class MyModel extends Model {
  public void createModel(BvrsToRun blist) {
    FontStyleBvr fs = defaultFont.family(toBvr("Arial").color(blue)
	.bold();
    ImageBvr tx = (toBvr("Hello, World"), fs);
    setImage(tx);
  }
}
public class MyApplet extends DXMApplet {
  public void init(){
     // Always call the superclass's init() first to ensure codeBase
	 is set.
     super.init();
     // Now set the model.
     setModel(new MyModel());
  }
}  
</PRE>
<P>This DirectAnimation applet simply renders a piece of static text. You can make this example more interesting by adding just a few more lines of code. First, however, you must understand how the initial example works. 
<P>The DirectAnimation <A HREF="../ref_java/class/Model.htm#Model_Class">Model</A> class includes the abstract <A HREF="../ref_java/class/Model.htm#createModel_model">createModel</A> method. MyModel subclasses <B>Model</B> and implements <B>createModel</B> to build behaviors; this example has a string behavior and an image behavior. The <B>createModel</B> method then calls the <A HREF="../ref_java/class/Model.htm#setImage_model">setImage</A> method to set the model's image behavior. 
 
<P>The DirectAnimation <A HREF="../ref_java/class/ImageBvr.htm#ImageBvr_Class">ImageBvr</A> type is constructed by converting a character string ("Hello, World") into an <B>ImageBvr</B> behavior with the <A HREF="../ref_java/staticmethods/StringBvrObjects.htm#toBvr_str">toBvr</A> method. The <B>toBvr</B> method converts the literal string "Hello, World" into an image of the text with the font style specified in the <A HREF="../ref_java/staticfields/FontStyleBvrObjects.htm#default_fontstyle">defaultFont</A> method.

<P>Next, MyApplet subclasses the DirectAnimation <A HREF="../ref_java/class/DXMApplet.htm#DXMApplet_Class">DXMApplet</A> subclass of the Abstract Windows Toolkit (AWT) Applet class. This initializes its superclass <B>DXMApplet</B> to take an instance of the MyModel class. When the applet is invoked, DirectAnimation builds the model (by invoking <A HREF="../ref_java/class/Model.htm#createModel_model">createModel</A>) and displays it in the applet. 



<H3><A NAME="Adding_Animation" IDX_CONCEPT="noindex; Java Example, basic, adding animation to">Adding Animation</A></H3>
<P>A small addition to the previous code causes the text to change color continuously as it is rendered. The MyApplet class doesn't change at all, while the MyModel class is changed to the following: 

<PRE>
public class MyModel extends Model {
  public void createModel(BvrsToRun blist) {
    ColorBvr col = colorHsl(localTime, toBvr(0.5), toBvr(0.5));  
    FontStyleBvr fs = defaultFont.family(toBvr("Arial")).color(col)
	.bold();
    ImageBvr tx = (toBvr("Hello, World"), fs);
    setImage(tx);
    
  }
}
</PRE>
<P>One line was added to the <B>createModel</B> method. It defines a color, using the <A HREF="../ref_java/staticmethods/ColorBvrObjects.htm#colorHsl_col">colorHsl</A> method. This method allows you to define a color using the Hue, Saturation, Lightness (HSL) model. The <B>colorHsl</B> method takes 0.5 for its saturation and lightness arguments, but uses the built-in behavior called <A HREF="../ref_java/staticfields/NumberBvrObjects.htm#localTime_num">localTime</A> for the hue. The <B>localTime</B> behavior is a time-varying value of type <A HREF="../ref_java/class/NumberBvr.htm#NumberBvr_Class">NumberBvr</A> that increases at the rate of one unit per second. Values of all the defined DirectAnimation types are potentially time-varying and interactive.
<P>Using <b>localTime</b> in a color-producing method such as <b>colorHsl</b> yields a time-varying color. Using this time-varying color as an argument in the font style <I>color(col)</I> method yields a time-varying font color. Attaching the time-varying color value to text that is converted into an image produces a time-varying image. Because <A HREF="../ref_java/class/Model.htm#setImage_model">setImage</A> now sets a time-varying image, the result of this code is an image that is animated. 
<P>Note that the entire applet is as you see it. No other methods are required and, in particular, there is no need for a frame loop, even though the applet is displaying an animation. For programmers who have been using the awt.Graphics package to do animation, this means you do not need to worry about threads, <B>while()</B> loops, or repainting the screen.

<H3><A NAME="Adding_Simple_Intera" IDX_CONCEPT="noindex; Java Example, basic, adding interaction to">Adding Simple Interaction</A></H3>
<P>The next step is to add some simple interactivity. The new version of MyModel, shown here, uses the time-varying color until the left mouse button is pressed. It then changes the color to red. 
<PRE>
public class MyModel extends Model {
  public void createModel(BvrsToRun blist) {
    ColorBvr col = colorHsl(localTime, toBvr(0.5), toBvr(0.5));  
    ColorBvr mouseCol = (ColorBvr)until(col, leftButtonDown, red);
    FontStyleBvr fs = defaultFont.family(toBvr("Arial")).color(mouseCol)
    .bold();
    ImageBvr tx = (toBvr("Hello, World"), fs);
    setImage(tx);
  }
}
</PRE>
<P>A single line of code adds the ability to respond to the mouse:
<PRE>
until(col, leftButtonDown, red);
</PRE>
<P>This expression produces a color behavior that is initially <I>col</I> and remains so until the <B>leftButtonDown</B> event occurs. When this happens, <I>col</I> changes to red. There is still no need to provide a frame
loop. In addition, there is no need to provide an event detection/response loop (to wait for the <B>leftButtonDown</B>), because this is dealt with explicitly in the implementation of the <B>until</B> method.
<P>As this sample shows, time-varying, interactive behaviors are constructed out of media data types and operations. The DirectAnimation run-time system then takes on the task of animation, event detection, and media presentation. 


<H2><A NAME="Coordinates_in_DirectAnimation">Coordinates in DirectAnimation</A></H2>
<P>The DirectAnimation API uses continuous temporal and spatial 2-D and 3-D coordinate systems. The basic unit of time is the second. The basic unit of space is the meter. The x-axis is the horizontal axis, increasing to the right. The y-axis is the vertical axis, increasing upward. Three-dimensional coordinates are y-axis up, positive z-axis near, and negative z-axis far.
<P>The following diagram illustrates these coordinate systems. 

<P><IMG SRC="../art/xyaxes.gif" WIDTH="411" HEIGHT="154" ALT="Image coordinate systems">


<P>DirectAnimation provides several mechanisms for handling these differences. Fundamentally, the DirectAnimation coordinate system is a meter-based system. When PARAM tags are used to specify all or part of the model, the coordinate system will implicitly be that of HTML. When the library mode of the DirectAnimation control is set to pixel mode the coordinate system is converted from the DirectAnimation default to the pixel convention. With these methods, the scripter can construct models in resolution-independent units. For example, in JScript:
<PRE>
  m = DAControl.PixelLibrary;
</PRE>
<P>- or -
<PRE>
  m = DAControl.MeterLibrary; 
</PRE>
<P>This section discusses the following topics:
<UL>
<LI><A HREF="proguide_basics.htm#HTML_and_Pixel_Coordinates">HTML and Pixel Coordinates</A>
<LI><A HREF="proguide_basics.htm#Units">Units</A>
<LI><A HREF="proguide_basics.htm#Working_with_Pixel_Values">Working with Pixel Values</A>
<LI><A HREF="proguide_basics.htm#Continuous_Coordinate_Systems">Continuous Coordinate Systems</A>
<LI><A HREF="proguide_basics.htm#Image_Coordinate_System">Image Coordinate System</A>
<LI><A HREF="proguide_basics.htm#Geometry_Coordinate_System">Geometry Coordinate System</A>
<LI><A HREF="proguide_basics.htm#Meter_Based_Space">Meter-Based Space</A>
<LI><A HREF="proguide_basics.htm#Pixel_Based_Space">Pixel-Based Space</A>
<LI><A HREF="proguide_basics.htm#Center_Based_Positioning">Center-Based Positioning</A>
</UL>
<A NAME="HTML_and_Pixel_Coordinates"></A><P><B>HTML and Pixel Coordinates
</B>
<P>HTML uses device pixels as the standard unit of measure with a left-handed coordinate system with the y-axis down and the origin in the upper left corner. When PARAM tags are used to specify animations the coordinate system is that of HTML. The DirectAnimation client controls use a pixel-coordinate system with the y-axis down and the origin in the center of the window. 

<P>DirectAnimation is fundamentally a meter-based coordinate system, which is preferred for resolution independent animation. However, DirectAnimation provides the <I>pixel construction mode</I> as a convenience for users who are familiar with the HTML coordinate system and would like their animation coordinates to match that as closely as possible. 
<P>When using the <A HREF="../ref_script/class/DAViewerControlClass.htm#pixelv_control">PixelLibrary</A> (as opposed to the <A HREF="../ref_script/class/DAViewerControlClass.htm#meterv_control">MeterLibrary</A>) the 2-D coordinate system is left-handed, having the positive Y-axis going downward, and it has a centered origin (not an origin in the upper-left-corner, as in the HTML coordinate system). See the sample in  DXMedia\Samples\Multimedia\DAnim\JScript\Templates\CoordsAndPath.html for a detailed example of the <I>pixel construction mode</I>.
Also, compare the PixelMode.html and MeterMode.html samples in DXMedia\Samples\Multimedia\DAnim\JScript\Exercises.
All 2-D coordinate references such as points, paths, and translation factors in this construction mode are interpreted as pixel-valued. Note that this is a construction mode only, so when you extract information back, like extents, you get them in meters, because these are the units in the internal representation. For advanced animations, the meter mode is strongly recommended, especially because the conversion from meter to HTML coordinate space is a single transform.


<A NAME="Units"></A><P><B>Units</B>
<P>The DirectAnimation API is designed to ensure that one unit is actually one meter in physical space. However,but variables such as monitor curvature and monitor controls that change the display area preclude absolute accuracy. 

<P>DirectAnimation provides predefined constants that you can use as multipliers to convert to other units, including <A HREF="../ref_script/MiscDAStaticProperties.htm#cmv_misc">cm</A>, <A HREF="../ref_script/MiscDAStaticProperties.htm#footv_misc">foot</A>, <A HREF="../ref_script/MiscDAStaticProperties.htm#inchv_misc">inch</A>, <A HREF="../ref_script/MiscDAStaticProperties.htm#meterv_misc">meter</A>, <A HREF="../ref_script/MiscDAStaticProperties.htm#mmv_misc">mm</A>, and <A HREF="../ref_script/MiscDAStaticProperties.htm#pixelv_misc">pixel</A>. 


<A NAME="Working_with_Pixel_Values"></A><P><B>Working with Pixel Values</B>
<P>Given that pixel size differs from one display to another and even across different settings of the same display device, DirectAnimation provides a built-in number behavior, <A HREF="../ref_script/MiscDAStaticProperties.htm#pixelv_misc">pixel</A>, which is the dimension of a pixel in meters. The <B>pixel</B> is a scalar because the pixel is a square. 

<P>The <b>pixel</b> constant allows an author to coordinate synthetic imagery precisely with imported bitmaps regardless of the display resolution. 


<A NAME="Continuous_Coordinate_Systems"></A><P><B>Continuous Coordinate Systems</B>
<P>Continuous coordinate systems, such as those used by DirectAnimation, provide some key advantages. They remove problems of device- and resolution-dependence, allow for more portable content, and provide more flexibility to the implementation. However, continuous coordinate systems do not always meet the needs of programmers. For example, in addition to continuous time, DirectAnimation also provides the mechanism for applications to control frame generation through application-generated time ticks. Similarly, in spatial coordinates, it is generally the case that a programmer who imports a GIF or JPEG file wants it displayed at the same resolution at which it was authored and stored. For this reason, DirectAnimation supports pixels. 

<A NAME="Image_Coordinate_System"></A><P><B>Image Coordinate System</B>
<P>The image coordinate system is called the <I>image plane</I>. Depending on whether the PixelLibrary or MeterLibrary is used, or if PARAM tags are used, the default unit of measure is pixels or meters, and the coordinate system is in pixel coordinates (origin centered, y down), meter coordinates (origin centered, y up), or HTML coordinates (origin in the upper left, y down).

<P>All image and 2-D geometric primitives live in this same continuous coordinate system. This includes all of the <B>Vector2</B>, <B>Point2</B>, <B>Transform2</B>, <B>Path2</B>, <B>Matte</B>, <B>Text</B>, <B>Montage</B>, and <B>Image</B> values. 

<P>On its own, the image plane extends infinitely, with an origin and x- and y-axes. DirectAnimation images are constructed in this abstract coordinate system. However, when it is time to display a DirectAnimation image, a certain section of the infinite plane is mapped on a region of a display device called a viewport, as shown in the following illustration.
 
<P><IMG SRC="../art/2Dspace.gif" WIDTH="186" HEIGHT="136" ALT="Image plane">

<P>The programmer decides what the display region or viewport will be. The mapping from the image plane into the viewport is straightforward. The origin of the image plane is mapped to the center of the viewport, and then the mapping happens in like units of measure. For example, if there is a red point 2 centimeters above the origin in the image plane, this point would map to a red pixel 2 centimeters above the center of the viewport. (Note that windowless controls commonly don't occupy their full viewports.)


<A NAME="Geometry_Coordinate_System"></A><P><B>Geometry Coordinate System</B>
<P>The geometry coordinate system is a 3-D coordinate system of infinite extent where geometric models are specified and transformed. The default unit of measure is the meter. It has an origin and x-, y-, and z-axes. The coordinate system is a right-handed one, as shown in the following illustration.
 
<P><IMG SRC="../art/3Daxes.gif" WIDTH="132" HEIGHT="119" ALT="Geometry coordinate system">

<P>The following illustration shows the direction of positive rotation along an axis of rotation (the arrow points in the positive direction).
 
<P><IMG SRC="../art/arrow3.gif" WIDTH="167" HEIGHT="67" ALT="Positive rotation">

<P>DirectAnimation geometric models are constructed in this abstract coordinate system. However, you must have a <A CLASS="Glossary" HREF="javascript:Glossary(sRelPath + 'gloss/gloss_C.htm#camera')">camera</A> to display a model. The camera projects infinite space into an infinite plane, which is the image plane discussed in the <A HREF="proguide_basics.htm#Image_Coordinate_System">Image Coordinate System</A> section. In other words, the 2-D image plane is the 3-D projection plane, because the result of projecting geometry through a camera is an image. The resulting abstract image is amenable to the same operations and rules as other images, including the display through a viewport. 


<A NAME="Meter_Based_Space"></A><P><B>Meter-Based Space</B>
<P>In a meter-based 2-D-composition space, 3-D models are authored to a certain size in meters, which is to be preserved in all renderings, and images are imported and scaled into a predetermined size, also in meters, independent of the pixel resolution. You can determine how much to scale an image by determining the <A CLASS="Glossary" HREF="javascript:Glossary(sRelPath + 'gloss/gloss_B.htm#bounding_box')">bounding box</A> of the imported image, comparing the desired size to the bounding box, and using that factor to scale the image. This effectively compensates for pixel size variability. 

<P>While this technique has the advantage of being independent of the device resolution, you need to scale images before displaying them. It thus requires more processing than simple pixel blitting and is prone to pixel aliasing. (Pixel blitting is bit block transfer of pixels used to transfer all or part of a bitmap from a source such as memory or the screen, to a destination such as another memory or display surface. Pixel aliasing causes ragged edges because pixels are blocks. This can be improved by averaging edge pixels together.)

<A NAME="Pixel_Based_Space"></A><P><B>Pixel-Based Space</B>
<P>In a pixel-based composition space, images are imported and displayed in a pixel-to-pixel mapping onto the screen, which is the traditional method in 2-D sprite systems and content (for example, 2-D sprite-based games and Director content). While the result is device-resolution dependent, there are several benefits. One is the large amount of legacy material written in this method. The reuse of this content requires using this pixel-based space. 

<P>In addition, because the pixels are mapped pixel-to-pixel, without any transformations, this method tends to be very fast and avoids pixel aliasing. The 3-D parts must be scaled based on the pixel size, so that when they are projected into the image plane they have consistent proportionality and coordination with the 2-D images. 


<A NAME="Center_Based_Positioning"></A><P><B>Center-Based Positioning</B>
<P>When DirectAnimation imports or constructs an image, it is centered on the origin in the image plane. Similarly, when an image is created by rendering text (which takes no coordinates as parameters), it also is centered on the origin. The center of a camera's field of view coincides with the origin of the image plane. This means that scenes, when rendered into images, are centered on the origin. 



<H2><A NAME="Timelines" IDX_CONCEPT="noindex; Timelines Using Duration, creating; Scripting Timelines Using Duration">Scripting Timelines Using Duration</A></H2>
<P>A key concept behind DirectAnimation is the idea of "video editing" or "media timelines." Editing a video sequence and moving a sprite (subimage) along an animation path are conceptually very similar. Both scripted animation, such as that used in multimedia applications, and natural media, such as recorded sound and video, are sequences of <A CLASS="Glossary" HREF="javascript:Glossary(sRelPath + 'gloss/gloss_C.htm#clip')">clips</A>. Each clip has a local timeline. Each can be used in more than one place on the screen (compositing) or in more than one place in time (sequencing). DirectAnimation uses the term <i>behavior</i> to denote these fundamental building blocks of media presentation. 
<P>A DirectAnimation behavior is a subsequence of media with its own timeline. You build an animated presentation by sequencing and compositing (overlaying or rendering) the behavior subsequences. 
DirectAnimation behaviors support a range of media types. For instance, there are image behaviors that treat video, cel animation, sprite (subimage) animation, and animated line graphics uniformly. There is a sound behavior for mixed, parameterized audio. Animated <A CLASS="Glossary" HREF="javascript:Glossary(sRelPath + 'gloss/gloss_L.htm#light')">light</A> behaviors illuminate three-dimensional scenes. 
<P>Timelines are animation fragments of (typically) fixed duration that can be sequenced together to form complex behaviors. Timelines are a flexible mechanism for constructing, manipulating, and running sequences of animation. For example, consider the following JScript code:
<PRE>
 startPt = m.Point2(25, 50);
 endPt = m.Point2(150, 50);
 myPath = m.Line(startPt, endPt);
 followPath = m.FollowPath(myPath, 5);
</PRE>
<P>The <A HREF="../ref_script/dastaticfunctions/DATransform2Objects.htm#followpv_xf2">FollowPath</A> method creates a behavior of fixed duration that represents movement along a geometric path (<I>myPath</I>) that lasts five seconds. There are several ways to create timelines. The most general way is to construct an animation fragment by setting a <A HREF="../ref_script/class/DABehaviorClass.htm#durationanv_beh">Duration</A> for a behavior. In the following JScript example, colors are given a duration of 5 seconds:
<PRE>
  color1 = m.Red.Duration(5);
  color2 = m.Green.Duration(5);
  myImage = m.SolidColorImage(m.Sequence(color1, color2));
</PRE>
<P>In general, you can think of behaviors as animations (movies, sounds, sprite animations, 3-D animations, and so on) that run forever. 

<P>Consider the following JScript sample:







<H3>Moving Circle</H3>


<P>
&nbsp;<INPUT TYPE=button VALUE="Show Sample" STYLE="width:150" ID=btnSAMP2 OnClick="samp(2)">
<P><BR>
<DIV ID=divSAMP2 align="center"></DIV>
<TABLE BORDER="0" CELLSPACING="4" CELLPADDING="0"><TR><TD>
<INPUT TYPE=button VALUE="Show Sample Code" STYLE="width:150" ID=btnCODE2 OnClick="code(2)">
<PRE><DIV ID=divCODE2></DIV></PRE>
</TD></TR></TABLE>



<SPAN ID="SAMP2_SCRIPT">
<SCRIPT LANGUAGE="JScript">
<!--
   function SAMP2()
    {

   // This script draws a red circle that moves in a straight line. It starts at the beginning of the line,
   // waits 1 seconds, and then starts to move. It goes from the beginning of the line to end in 4 seconds.
   // It repeats these actions 3 times and then stops at the end.

   // All our measurements will be in pixels, so we use the PixelLibrary

   // The variable "l" is shorthand for the DAStatics Library. Every function that is in that library 
   // (most of them!) needs to be preceded by an "l" so the interpreter knows where to find them
    l=DAControl_2.PixelLibrary;

   // Now construct a red circle
  
   // First set the color that will fill the inside of the circle to red
   fill=l.SolidColorImage(l.Red);

   // Now draw a circle. A circle is an oval whose radius along the x-axis is the same
   // as its radius along the y-axis

   ovalImg=l.Oval(50, 50).Fill(l.DefaultLineStyle, fill);

   // Now construct a straight path that the circle will travel along

   // Our path is a line, and lines are defined by their starting and ending points
   startingPoint=l.Point2(25, 50);
   endingPoint=l.Point2(150, 50);

   // Now make the line (in this case, it isn't drawn on the screen -- it's a guide for the circle)
   myPath=l.Line(startingPoint, endingPoint);

   // Define the instruction that will tell the circle where to begin

   // To translate something means to move it. If you want to move something, 
   // you need to know where it's going. In this case we want to move the circle to "startingPoint". Because we are defining the
   // place we want to go as a point, we use the Translate2Point function. There are other Translate functions
   // for different ways of expressing where to place something.

   // The Duration function means to wait for 1 seconds at the location we've defined. So, to sum up, this says:
   // "Go to the starting point and wait 1 seconds" (Note that it doesn't need the l in front of it. That's because
   // a Translate2 returns a DATransform2 and that kind of object has the Duration function in its own class. 
   goToStart=l.Translate2Point(startingPoint).Duration(1);

   // Now we'll define the instruction that will tell the circle to follow the path:
   // The FollowPath function does exactly what it's name says and it defines how long it should take to go
   // from one end of the path to the other.
   // Here we're saying, follow myPath and go from the beginning to end in 4 seconds. Do this 3 times
   followRoute=l.FollowPath(myPath, 4).Repeat(3);

   
   // Next, we'll combine the two instructions. 
   combineMovements=l.Sequence(goToStart, followRoute);

   // Finally, we need to tell the circle our instructions
   // We're transforming our static drawing of a circle into one that moves along a path.
   movingCircle=ovalImg.Transform(combineMovements);
   
   // Now tell the DAViewer what image to display (our moving circle)
   DAControl_2.Image=movingCircle;

   // Finally, give it the go-ahead
   DAControl_2.Start();
  }
//-->

</SCRIPT>
</SPAN>





<P>This script draws a red circle that moves in a straight line. It starts at the beginning of the line, waits 1 second, and then starts to move. It goes from the beginning of the line to the end in 4 seconds. It repeats these actions 3 times and then stops at the end. Click the <B>Show Sample</B> button to display the JScript example. To see the code, click the <b>Show Sample Code</b> button. All measurements are in pixels, so the code uses the <b>PixelLibrary</b>. Because the control is windowless, the red circle can pass on top of or underneath the button. It passes underneath the button if you specify z-index: -1 in the &#060;STYLE&#062; tag within the &#060;OBJECT&#062; tag, as shown in this example.



<H2><A NAME="Arrays_and_Tuples" IDX_CONCEPT="Tuples and Arrays">Arrays and Tuples</A></H2>
<P>A common way to construct behaviors is to loop through a sequence of other behaviors over time. Examples include flipping through pre-rendered images or a list of colors. DirectAnimation supports this through the <A HREF="../ref_script/class/DAArrayClass.htm#DAArray_Class">DAArray</A> and Java <A HREF="../ref_java/class/ArrayBvr.htm#ArrayBvr_Class">ArrayBvr</A> types. 

<P>The following JScript sample constructs a <b>DAArray</b> object from an array and uses the <A HREF="../ref_script/class/DAArrayClass.htm#nthanv_array">NthAnim</A> function with a time-varying parameter to cycle through the array. Click the <B>Show Sample</B> button to display the JScript example. To see the code, click the <b>Show Sample Code</b> button. 








<H3>Array</H3>


<P>
&nbsp;<INPUT TYPE=button VALUE="Show Sample" STYLE="width:150" ID=btnSAMP3 OnClick="samp(3)">
<P><BR>
<DIV ID=divSAMP3 align="center"></DIV>
<TABLE BORDER="0" CELLSPACING="4" CELLPADDING="0"><TR><TD>
<INPUT TYPE=button VALUE="Show Sample Code" STYLE="width:150" ID=btnCODE3 OnClick="code(3)">
<PRE><DIV ID=divCODE3></DIV></PRE>
</TD></TR></TABLE>



<SPAN ID="SAMP3_SCRIPT">
<SCRIPT LANGUAGE="JScript">
<!--
function SAMP3() {

 // The DirectAnimation library
  m=DAControl_3.PixelLibrary;

//Create a new array
  ColArr=new Array(m.Red, m.Green, m.Blue, m.Magenta);
//Create a DAArray object
  Col=m.Array(ColArr);

//Make an array index based on local time
  Index=m.Mod(m.LocalTime,Col.Length()) ;

//Cycle through the array colors
  CycleCol=Col.NthAnim(Index);

//Create a square whose color cycles
  fillImg=m.SolidColorImage(CycleCol);
  SquareImg=m.Rect(50,50).Fill(m.DefaultLineStyle,fillImg);

//Set the image to display  
  DAControl_3.Image=SquareImg;
 
//Start the animation       
  DAControl_3.Start();
}

//-->

</SCRIPT>
</SPAN>







<P>The following Java code constructs an <A HREF="../ref_java/class/ArrayBvr.htm#ArrayBvr_Class">ArrayBvr</A> out of a Java array, and uses the <B>nth</B> method with a time-varying parameter to cycle through that list.
<PRE>
ColorBvr[] arr = { red, green, blue, yellow, green, cyan, magenta };
ArrayBvr arrBvr = new ArrayBvr(arr);
// build an indexer to go from 0 to length - 1, then back to 0, etc.
// going at a rate of one unit per second.
NumberBvr indexer = mod(localTime, toBvr(arr.length -1));
// Use this to index into the ArrayBvr.
ColorBvr cyclingCol = (ColorBvr)arrBvr.nth(indexer);
</PRE>
<P>Note that while <B>nth</B> takes a NumberBvr, it uses the greatest integer value less than the number's value to determine the index. The array's index starts at base 0, and any attempt to index beyond its length generates a run-time error.
<P>Tuple behaviors (<A HREF="../ref_script/class/DATupleClass.htm#DATuple_Class">DATuple</A> and Java <A HREF="../ref_java/class/TupleBvr.htm#TupleBvr_Class">TupleBvr</A>) are the same as array behaviors, except that a tuple object can contain behaviors of different types (such as a <A HREF="../ref_script/class/DAColorClass.htm#DAColor_Class">DAColor</A> and a <A HREF="../ref_script/class/DAImageClass.htm#DAImage_Class">DAImage</A>), while all the behaviors in an array object must be the same type. Tuple objects are useful for grouping behaviors that all switch at the same event. For example:
<PRE>SynchTuple = m.Until(tuple1, event, tuple2);
</PRE>
<P>This helps to synchronize many different behaviors to one event.
<P>Note that unlike array behaviors, a tuple behavior cannot have an animated index.

<H2><A NAME="URLs_and_Paths" IDX_CONCEPT="Paths and URLs">URLs and Paths</A></H2>
<P>

<P>Paths in DirectAnimation are created by building a URL base, and then adding relative paths to the base. For example:
<PRE>
  mediaBase = "..\\..\\..\\..\\media\\";
  sndBase = mediaBase + "sound\\";
  imgBase = mediaBase + "image\\";
  geoBase = mediaBase + "geometry\\";

  mySnd = m.ImportSound(sndBase + "clock1.mp2").Sound;
  myImage = m.ImportImage(imgBase + "bird.gif");
  cubeGeo = m.ImportGeometry(geoBase + "cube.x");
</PRE>
<P>When you install the DirectX Media SDK, the geometry, image, and sound files are installed by default in DXMedia\Media\geometry, DXMedia\Media\image, and DXMedia\Media\sound directories, respectively. Your path should be the relative path to your media files from where your HTML file resides. 
<P>Alternatively, you can specify the URL absolutely. For example:
<PRE>
  mySnd = m.ImportSound("file://c:/dxmedia/media/sound/clock1.mp2").Sound;
  myImage = m.ImportImage("file://c:/dxmedia/media/image/bird.gif");
</PRE>
<P>In Java, a base URL is set for you automatically. When you build a Java applet, the base URL is set by default to the directory from which your class files are loaded. If you are creating an application instead of an applet, the base URL is set by default to the current working directory. You can also set the base URL explicitly with the <A HREF="../ref_java/class/Model.htm#setImportBase_model">setImportBase</A> method, as shown in the following Java code: 

<PRE>
try {
   setImportBase(new URL("file:/c:/dx/dxm/media/image/"));
} catch (MalformedURLException exc){
   System.out.println("Bad URL - " + exc);
  }
</PRE>
<P>The URL you specify in <A HREF="../ref_java/class/Model.htm#setImportBase_model">setImportBase</A> can be any fully-qualified URL. For example:
<PRE>
setImportBase(new URL("http:/www.mycompany.com/MediaLib/"));
</PRE>
<P>To build your full URL relative to the URL base, you retrieve the URL base with the <A HREF="../ref_java/class/Model.htm#getImportBase_model">getImportBase</A> method, and then complete your path relative to this base. For example, if your applet was built in the directory C:\Animations\MyAnimations\DA\Java\MyApp, the following code would set the URL <I>mediaBase</I> to C:\Animations\Media.

<PRE>
URL mediaBase = buildURL(getImportBase(),"../../../Media/");
</PRE>
<P>You then use the URL base as shown in the following code:
<PRE>
ImageBvr image1 = importImage(buildURL(mediaBase, "image/apple.gif"));
ImageBvr image2 = importImage(buildURL(mediaBase,
"../../MyMediaLibrary/MyImages/peach.gif"));
</PRE>
<P>You can also override the base URL and specify a fully-qualified URL. Note that the URL does not become the default base URL.
<PRE>
URL altURL = buildURL(getImportBase(),"file:/c:/dx/dxm/media/image/);
URL anotherURL = buildURL(getImportBase(),
"http:/www.mycompany/MediaLib/");
</PRE>
<P>You could then import images as show in the following code:
<PRE>
ImageBvr img1 = importImage(buildURL(altURL, "apple.gif"));
ImageBvr img2 = importImage(buildURL(anotherURL, "pictures/orange.gif"));
</PRE>
<P>You can also import from absolute URLs without building a URL base. For example:
<PRE>
ImageBvr img1 = importImage(buildURL(getImportBase(),
"file:/c:/dx/dxm/media/image/apple.gif"));
ImageBvr img2 = importImage(buildURL(getImportBase(),
"http:/www.mycompany/MediaLib/pictures/orange.gif"));
</PRE>

<H2><A NAME="Lights" IDX_CONCEPT="noindex; Lights, using">Lights</A></H2>
<p>
The following illumination equation describes the general lighting model
used by DirectAnimation. Note that the actual implementation depends on the
rendering device, but this equation gives the general model.
<pre>
    I = <var>emissive</var>
      + (<var>La</var> * <var>ambient</var>)
      + foreach(i) {<var>Li</var> * <var>diffuse</var> * cos(theta)}
      + foreach(i) {<var>Li</var> * <var>specular</var> * cos**<var>specularExp</var>(phi)}
      + ((white - <var>opacity</var>) * <var>Lt</var>)
</pre>

<p>In the preceding equation, <I>La</I> is the <A CLASS="Glossary" HREF="javascript:Glossary(sRelPath + 'gloss/gloss_A.htm#ambient_light')">ambient light</A>; <I>Li</I> parameters are point, spot or <A CLASS="Glossary" HREF="javascript:Glossary(sRelPath + 'gloss/gloss_D.htm#directional_light')">directional lights</A>; and <I>Lt</I> is the light coming through the object. The properties that describe the material are <I>emissive</I>, <I>ambient</I>, <I>diffuse</I>,
<I>specular</I>, and <I>specularExp</I>.

<p>The <I>emissive</I> property is the color that the object emits independent of
lighting. In other words, if an object has an emissive color of red, it will
appear red even if you're in a dark room with all of the lights turned off.
Emissive color is useful for making objects that glow (LEDs for example) or objects that
are fluorescent, or for turning invisible (ultra-violet) illumination into visible
illumination, for "blacklight" or neon effects. In addition, emissive
color is useful for representing light sources. For example, if you want to
model a light bulb, you will probably put a white-emitting sphere around a point
light source. The emissive color can be set with <A HREF="../ref_script/class/DAGeometryClass.htm#EmissiveColorv_g">EmissiveColor</A>.

<p>Ambient light (<I>La</I> in the preceding equation) approximates the light in a scene that is everywhere, due to reflection from the many surfaces in a scene. In reality, ambient light is not constant; otherwise, you'd have no darker areas in a room. However, this helps ensure that surfaces not directly lit by a light don't appear completely black. For images in space, you usually set the ambient light to black, since surfaces in shadow receive almost no illumination. You can also set the ambient light to a color, if most of the lights in the room are that color. For example, if you're modeling a submarine interior under red-lighting, you'd probably want to set your shadow color to a red tint also.

<p>The <I>ambient</I> property is the color reflected for ambient light. You will almost
always want to set this value to the same color as the diffuse color. In other
words, your material in shadow will be the color of the object, but darker. In some rare situations, you might set the ambient color of the object to be shifted to the hue of its neighboring surface colors, but this is unusual.

<p>The <I>diffuse</I> property is the diffuse color of the material. Think of it as the
fundamental color of the surface. This color is multiplied by <I>cos(theta)</I>,
where theta is the angle between the surface and the light. If the surface is
facing the light, then it is brightly lit; otherwise, it fades to shadow. The diffuse color can be set with <A HREF="../ref_script/class/DAGeometryClass.htm#diffuseColorv_g">DiffuseColor</A>.

<p>The <I>specularExp</I> property gives the shininess of the surface. Shiny surfaces are
approximated by high values of <I>specularExp</I>, and less shiny surfaces
by lower values. The lowest value this should be set to is 1, which yields a
very broad highlight that closely resembles diffuse reflection. A value of
10-20 is quite reasonable for a moderately glossy surface, and a value of 100
yields a shiny object. The specular exponent can be set with <A HREF="../ref_script/class/DAGeometryClass.htm#SpecularExponentAnimv_g">SpecularExponentAnim</A>.

<p>Imagine a ray going from the light to the surface, and then bouncing off. If
you as the viewer are hit in the eye with the ricocheting ray, then you're
looking at a direct reflection of the light, so it appears bright. As you move
away from that ray, you move away from the reflection of the light, so its
reflection looks less bright. The parameter <I>Phi</I> is the angle between you and the reflecting ray. As <I>specularExp</I> increases, it makes this reflection sharper. Specifically, the specular exponent is the power of the cosine function between
the reflection <A CLASS="Glossary" HREF="javascript:Glossary(sRelPath + 'gloss/gloss_V.htm#vector')">vector</A> and the sight vector.  Thus, the higher the specular
exponent, the higher the falloff, and the sharper the highlight.

<p>The <I>specular</I> property is the color of the specular reflection. Surfaces such as
plastic, ceramic, or colored glass tend to reflect the light without shifting
the light's color. Thus, you generally want the specular color to be a grey-level so 
that it doesn't alter the color of the light source. For example, the
reflection of a white light on a blue plastic material looks white. The specular property can be set with <A HREF="../ref_script/class/DAGeometryClass.htm#SpecularColorv_g">SpecularColor</A>.


<p>On the other hand, metallic surfaces color the reflection of the light with
their surface color. For example, a white light reflected off a green metallic
surface will look green. This is also true for materials such as satin or
pearl. For these materials, you should set the specular color to some
intensity of the diffuse color.

<p>For some materials, the specular reflection can be a different color
than the diffuse reflection. For example, some beetle shells have diffuse
green colors with yellow specular highlights.

<p><I>Lt</I> in the preceding equation is the light transmitted through the object. If the object is opaque, then no light is transmitted. In simple transparency (the
way most simple scan-line renderers do it today), <I>Lt</I> is
just the color of the scene behind the material (that is, no refraction).

<p>The <I>opacity</I> property is the color in which the material appears completely opaque. If the opacity color is blue, for example, the material looks completely opaque to blue light, and completely transparent to colors that have no blue. DirectAnimation supports only scalar transparency, which is a value from 0 to 1 (invisible to opaque,
respectively). The <A CLASS="Glossary" HREF="javascript:Glossary(sRelPath + 'gloss/gloss_O.htm#opacity')">opacity</A> can be set with <A HREF="../ref_script/class/DAGeometryClass.htm#opacityanv_g">OpacityAnim</A>.

<p>Note that opacity does not affect the emissive or specular components of a material. This means that if you make the material of an object more transparent, you'll still see the highlight at full strength. This mimics what you'd see, for example, as you made the glass for a sphere more and more transparent - you'd still see the light's reflection from the surface. Similarly, if you take a glass sphere and heat it red-hot, you still see
the redness (emissive color), regardless of how clear the glass is.

<p>If you want to modulate specular and emissive color of the object, you need only multiply the specular and emissive color by the opacity. The end result is the same as rendering the object at full opacity, and then applying a single transparency value to the resulting image.

<h3>Light Examples</h3>

<p>This set of examples gives you the property settings you need to mimic different materials.

<dl>
<dt>standard matte material (chalk-like):
<dd><ul>
    <li>specular = black
    <li>emissive = black
</ul>

<dt>glowing indicators, such as a red LED:
<dd><ul>
    <li>emissive = red
 </ul>
<dt>plastic, glass, enamel:
<dd><ul>
    <li>specular = white (Reflects the color of the light sources.)
 </ul>
<dt>metallic:
<dd><ul>
    <li>specular = factor * diffuse (Modulates light color with the surface color.)
    </ul>
<dt>neon green:
<dd><ul>
    <li>emissive = green * neon-factor
    <li>ambient = green
    <li>diffuse = green
    </ul>
<dt>satin/pearl:
<dd><ul>
    <li>ambient, diffuse = very dark
    <li>specular = color
    <li>specular exponent = somewhat shiny, 5 - 20
    </ul>

<dt>light bulb:
<dd><ul>
    <li>emissive = color of the light
    <li>ambient = color of the light, dark
    <li>diffuse = color of the light, dark
    <li>specular = white (glass)
    <li>specular exponent = 2 - infinity (<i>Frosted to reflective glass</i>)
    </ul>
</dl>

<H2><A NAME="Drawing_Surface" IDX_CONCEPT="noindex; Drawing Surface">Drawing Surface</A></H2>
<P>The core DirectAnimation API is based on values and expressions. In contrast, the Drawing Surface API provides an alternative style in which methods are used to set a context and then primitives are rendered based on this context. The context can be saved into a stack and restored. The Drawing Surface API is limited to constructing 2-D vector models, so to get to broader features such as sound, images, and 3-D, use the core API. 
<P>
You can use the Drawing Surface API in conjunction with the core API. After a 2-D vector model is constructed, it can be rendered into an image and then combined with images based on the core API. In the VBScript sample <i>Runners</i>(DXMedia\Samples\Multimedia\DAnim\VBScript\Showcase\Runners.html), the runner model is constructed using the Drawing Surface API, while the animation is constructed using the core API. For basic Drawing Surface samples, see DXMedia\Samples\Multimedia\DAnim\JScript\Templates\BasicDS.html and DXMedia\Samples\Multimedia\DAnim\VBScript\Templates\BasicDS.html. 


<P>The <A HREF="../ref_script/class/DADrawingSurfaceClass.htm#DADrawingSurface_Class">DADrawingSurface</A> class uses a style of drawing that depends on a <I>graphics context</I>. This is in contrast to the other DirectAnimation classes that use a <I>constructive</I> approach. The constructive approach combines primitive data types into a more complex model, in a hierarchical fashion.

<P>The graphics context approach is analogous to a pen plotter, where the pen acts as the mechanical extension of a hand, and the plotter acts as a piece of paper. To draw something, the pen is directed to a location on the plotter and then draws the shape. Many people find this approach to be more familiar than hierarchical modeling. For example, to draw the sun in the sky, it may seem more obvious to simply draw a yellow circle exactly where you want it, instead of first drawing a circle, then creating a yellow circle, and then, with a transform, creating yet another yellow circle that is now correctly placed. The difference is in the approach rather than in capabilities.

<P>A <A HREF="../ref_script/class/DADrawingSurfaceClass.htm#DADrawingSurface_Class">DADrawingSurface</A> object maintains a <I>graphics state</I> object for 2-D graphics. This state includes attributes such as line style, fill style, border style, font style, and 2-D transformations. The drawing commands (such as <A HREF="../ref_script/class/DADrawingSurfaceClass.htm#ovalv_draw">Oval</A> and <A HREF="../ref_script/class/DADrawingSurfaceClass.htm#roundrectv_draw">RoundRect</A> are always interpreted in terms of the current state. See <B>DADrawingSurface</B> in the <I>Scripting Reference</I> for details about the subroutines and functions.

<P>To use a <A HREF="../ref_script/class/DADrawingSurfaceClass.htm#DADrawingSurface_Class">DADrawingSurface</A> functions and subroutines, create a <A HREF="../ref_script/class/DAViewerControlClass.htm#DAViewerControl_Class">DAViewerControl</A> object in your HTML as usual, then use the <A HREF="../ref_script/class/DAStaticsClass.htm#DAStatics_Class">DAStatics</A> subroutine <A HREF="../ref_script/dastaticfunctions/DADrawingSurfaceObjts.htm#newddsv_draw">NewDrawingSurface</A> to create the <B>DADrawingSurface</B> object, as shown in the following JScript code: 
<PRE>
&lt;DIV ID=controlDiv&gt;
&lt;OBJECT ID="DAControl"
        STYLE="position:absolute; left:10; top:10;width:450;height:450"
        CLASSID="CLSID:B6FFC24C-7E13-11D0-9B47-00C04FC2F51D"&gt;
&lt;/OBJECT&gt;
&lt;/DIV&gt;

&lt;SCRIPT LANGUAGE="JScript"&gt;
  m  = DAControl.MeterLibrary;
  ds = m.NewDrawingSurface();
</PRE>
<P>Once you have the <A HREF="../ref_script/class/DADrawingSurfaceClass.htm#DADrawingSurface_Class">DADrawingSurface</A> object <I>ds</I>, you can use its functions and subroutines. For example, the following JScript code draws a line between the specified x and y coordinates.
<PRE>
  ds.Line(-0.1,.04, 0.01,.04);
  DAControl.Image = ds.Image;
  DAControl.Start();

&lt;/SCRIPT&gt;
</PRE>
<P>Consider the following JScript sample:






<H3>Drawing Surface</H3>


<P>
&nbsp;<INPUT TYPE=button VALUE="Show Sample" STYLE="width:150" ID=btnSAMP4 OnClick="samp(4)" style="DISPLAY: inline">
<P><BR>
<DIV ID=divSAMP4 align="center"></DIV>
<TABLE BORDER="0" CELLSPACING="4" CELLPADDING="0"><TR><TD>
<INPUT TYPE=button VALUE="Show Sample Code" STYLE="width:150" ID=btnCODE4 OnClick="code(4)" style="DISPLAY: block">
<PRE><DIV ID=divCODE4></DIV></PRE>
</TD></TR></TABLE>



<SPAN ID="SAMP4_SCRIPT">
<SCRIPT LANGUAGE="JScript">
<!--
function SAMP4(){
s = DAControl_4.MeterLibrary;
  ds=s.NewDrawingSurface();


  // Here is how to draw a line, using x,y coordinates
 
  ds.Text("A line, drawn using its starting and ending x,y coordinates", -.07,.045);
  ds.Line(-0.1,.04, 0.01,.04);

  // Here is a red line, drawn using points instead of coordinates

  ds.Text("A red line, drawn using points", -.06,.02);
  ds.LineColor(s.Red);
  ds.LinePoints(s.Point2(-.05,-.01), s.Point2(0,.02));

  // An animated line that rotates about a fixed point (0,0)
   
  // The line is going to move in a circle the same way a second hand sweeps around a clock face
  // Any line, even one that's moving (or animated) has a starting point and an ending point
  // Our line has a fixed starting point so we can create it the same way as in the previous example.
  // The endpoint, however, needs to be animated, which means we will need to use Point2Anim rather than Point2
  
  // Our circle is a unit circle, which means it has a radius of 1
  // The x-coordinate of a point moving about a circle with radius 1 is x=cos(t)
  // The y-coordinate of a point moving about a circle with radius 1 is y=sin(t)
  // For t, use the built-in behavior LocalTime, which changes at the rate of 1 unit/second
  // We'll also scale down the size of the line to .02 meters

  myXCoord=s.Mul(s.DANumber(.02), s.Cos(s.LocalTime));
  myYCoord=s.Mul(s.DANumber(.02), s.Sin(s.LocalTime));
  endPt=s.Point2Anim(myXCoord, myYCoord);
  ds.Text("A line with an animated endpoint", 0,-.01);
  ds.LineColor(s.Red);
  ds.LinePoints(s.Point2(0,0), endPt);


  DAControl_4.Image=ds.Image;
  DAControl_4.Start();
}
//-->

</SCRIPT>
</SPAN>


<!-- END SAMPLE #4 -->


<P>This script draws two static lines and a rotating line, in addition to text. Click the <B>Show Sample</B> button to display the JScript example. To see the code, click the <b>Show Sample Code</b> button.  


<P>You can use the Structured Graphics control with the Drawing Surface interface. For example, the following VBScript code uses the Drawing Surface methods with the Structured Graphics control's drawing surface: 
<PRE>
&lt;OBJECT ID=SG1
STYLE="POSITION: absolute; HEIGHT:200;WIDTH:200;TOP:130;LEFT:215;
VISIBILITY:VISIBLE; ZINDEX:1" 
CLASSID="CLSID:369303C2-D7AC-11d0-89D5-00A0C90833E6"&gt;
...
&lt;/OBJECT&gt;
&lt;SCRIPT LANGUAGE=VBSCRIPT&gt;
...
Sub renderNew
&#009;Set Lib = SG1.Library
&#009;Set DRS = SG1.DrawSurface
&#009;Call DRS.LineDashStyle(0)
&#009;Call DRS.FillColor(Lib.green)
&#009;Call DRS.SecondaryFillColor(Lib.red)
&#009;Call DRS.GradientExtent(0,0,200,0)
&#009;Call DRS.GradientRolloffPower(1)
&#009;Call DRS.FillStyle(9)
&#009;Call DRS.Rect(-75,-75,100,100)
&#009;SG1.DrawSurface = DRS
End Sub
&lt;/SCRIPT&gt;
</PRE>
<P>The statement <I>SG1.DrawSurface = DRS</I> resets the Structured Graphics control's drawing surface to what has been created in <I>DRS</I>. 

<P><B>Note on using the DirectAnimation Structured Graphics control with the Drawing Surface interface in the</B> <A HREF="../ref_script/class/DAViewerControlClass.htm#pixelv_control">Pixel</A> <B>construction mode:</B>
<P>Although the positive y-axis goes downward, angles in the arc and pie functions are interpreted as counter-clockwise. For example, a pie shape created by calling <A HREF="../ref_script/class/DADrawingSurfaceClass.htm#piedv_draw">PieDegrees</A> with a starting angle of 0 degrees and an ending angle of 90 degrees will be above the x-axis (negative y), while a pie created with a starting angle of 0 degrees and an ending angle of -90 degrees will be below the x-axis (positive y). 


<H2><A NAME="Splines">Splines</A></H2>
<P>DirectAnimation supports animation <A CLASS="Glossary" HREF="javascript:Glossary(sRelPath + 'gloss/gloss_S.htm#spline')">splines</A>. These are effectively animation paths for numbers, 2-D points and vectors, and 3-D points and vectors. The paths can be linear, quadratic, or cubic b-splines, both rational and non-rational. In DirectAnimation, an animation spline is constructed by supplying an array of knots, control points, and, possibly, weights (all of which themselves are behaviors and are potentially time-varying). This creates either a <A HREF="../ref_script/class/DANumberClass.htm#DANumber_Class">DANumber</A>, <A HREF="../ref_script/class/DAPoint2Class.htm#DAPoint2_Class">DAPoint2</A>, <A HREF="../ref_script/class/DAPoint3Class.htm#DAPoint3_Class">DAPoint3</A>, <A HREF="../ref_script/class/DAVector2Class.htm#DAVector2_Class">DAVector2</A>, or <A HREF="../ref_script/class/DAVector3Class.htm#DAVector3_Class">DAVector3</A> behavior. 
<P>The <A HREF="../ref_script/dastaticfunctions/DAPath2Objects.htm#cubicv_path2">CubicBSplinePath</A> function is a form of spline that constructs a 2-D cubic b-spline polynomial path (other forms construct numbers, points, and vectors). This path, like any other path, can be stroked as a line, filled by any fill style, or used for extracting a motion path with the <A HREF="../ref_script/dastaticfunctions/DATransform2Objects.htm#followpanv_xf2">FollowPath</A>, <A HREF="../ref_script/dastaticfunctions/DATransform2Objects.htm#followpaanv_xf2">FollowPathAngle</A>, and <A HREF="../ref_script/dastaticfunctions/DATransform2Objects.htm#followpauanv_xf2">FollowPathAngleUpright</A>
functions. See the JScript sample AnnotatedLogo.html in DXMedia\Samples\Multimedia\DAnim\JScript\Templates where this spline is used as both the shape of the logo and as an animation path for HTML text in a DIV tag.

<P>You need a knot vector and a list of control elements to construct a spline. The control elements (numbers, points, or vectors) relate intuitively to the shape of the spline, while the knots don't. If you want to construct your spline in terms of control elements and not in terms of the knot vector, chose a uniform knot vector with standard end conditions (interpolate first and last points). This means the first and last knots are repeated <I>d</I> times where <I>d</I> is the degree of the spline, and intermediate knots are 1 unit apart. For example, the following JScript function (used in the sample CoordsAndPaths.html in DXMedia\Samples\Multimedia\DAnim\JScript\Templates) takes a list of 2-D control points, generates the uniform knot vector automatically, and constructs and returns a <A HREF="../ref_script/dastaticfunctions/DAPath2Objects.htm#cubicv_path2">CubicBSplinePath</A>.
<PRE>
function SimpleSpline(pts) {
    // divide by 2 since 2-D coordinates.
    numPts = pts.length/2;
    // We need 2 more knots (since cubic spline) than control points.
    knts = new Array(numPts + 2);
    // Set the uniform knots. Note that the knot vector doesn't need
    // to start from 0, only the relative spacing between knots
    // is significant.
    for (i=2; i &lt; numPts; i++) knts[i] = i;
    // first knot must have duplicity 3 (the degree) to interpolate
    // first point.
    knts[0] = knts[1] = knts[2];
    // last knot must have duplicity 3 (the degree) to interpolate
    // last point.
    knts[numPts+1] = knts[numPts] = knts[numPts-1];
    // Finally construct and return the spline path.
    return(m.cubicBSplinePath(pts, knts));
}
</PRE>
<P>In the absence of a visual authoring tool for creating splines, it may be easiest to create them by using a pencil and paper with a square grid. Draw the X and Y axes and draw the desired spline, then place points that follow the general shape of the spline, starting and ending with the same point that needs to be on the spline. You need to pick either the <A HREF="../ref_script/class/DAViewerControlClass.htm#pixelv_control">PixelLibrary</A> or the <A HREF="../ref_script/class/DAViewerControlClass.htm#meterv_control">MeterLibrary</A>. If you use pixels, place the spline points only on the grid points, and map each square length to 25 pixels.


<H2><A NAME="C++_Programming" IDX_CONCEPT="noindex; C++, Using the Scripting Reference for">Using the Scripting Reference for C++ Programming</A></H2>

<p>The <A HREF="../ref_COM_C++/COMref.htm">COM/C++ Reference</A> contains methods that can only be accessed from C++, typically because they use <B>IUnknown</B> pointers or arrays with unspecified bounds. However, C++ programmers can also access all the properties and methods listed in the <A HREF="../ref_script/scriptref.htm">Scripting Reference</A>. In order to use the Scripting Reference to create C++ code, you need to adapt the scripting syntax to C++ syntax. How you adapt the scripting syntax depends on whether you include the line <code class="text">#import "danim.dll"</code> in your header file.

<p>The easiest way to use DirectAnimation from C++ is by including <code class="text">#import "danim.dll"</code> in your header file. When you use <code class="text">#import "danim.dll"</code>, the DirectAnimation objects are wrapped and you are provided with smart pointers to the objects, such as IDAStaticsPtr, IDATransform3Ptr, IDAGeometryPtr, and so on. When wrapped, calls to COM methods return a behavior object or property value directly, rather than returning an HRESULT with the desired value as one of the method's parameters. See <A HREF="../ref_COM_C++/ComRef.htm#Using_DirectAnimation_from_C++">Using DirectAnimation from C++</A> for more COM/C++ programming information.

<P>The following sections discuss how to perform various tasks in C++ and script, so you can see how to adapt the Scripting Reference syntax.
<ul>
<li><A HREF="proguide_basics.htm#Initializing_the_Statics_Library">Initializing the Statics Library</A>
<li><A HREF="proguide_basics.htm#Using_Properties">Using Properties</A>
<li><A HREF="proguide_basics.htm#Using_Methods">Using Methods</A>
<li><A HREF="proguide_basics.htm#Spinning_Cube_in_C++_and_Script">Spinning Cube in C++ and Script</A>
</ul>

<H3> <A NAME="Initializing_the_Statics_Library" IDX_CONCEPT="noindex; C++/Script, initializing the Statics Library">Initializing the Statics Library</A></H3>

<p>In scripting, you access the Statics library as follows:
<PRE>
   m = DAControl.PixelLibrary;
</PRE>

<p>You can then use the <A HREF="../ref_script/class/DAStaticsClass.htm">DAStatics</A> class functions and properties by prepending an "m", as shown in the following code.

<PRE>
  myImage = m.SolidColorImage(m.Red);
</PRE>

<p>In C++, if you use <code class="text">#import "danim.dll"</code>, you access View and the Statics library as follows:
<PRE>
CDAViewerCtl::CDAViewerCtl()
    :_view(NULL)
{
    _view.CreateInstance(__uuidof(DAViewerControlWindowed));
}
IDAStaticsPtr e;
e = _view&gt;GetPixelLibrary();

 </pRE>
 
<p>If you are not using <code class="text">#import "danim.dll"</code>, you need to use <B>CoCreateInstance</B> to initialize the View and the Statics library. 
<PRE>
hr = CoCreateInstance(CLSID_DAView, 
      NULL, CLSCTX_INPROC, IID_IDAView, (void**) &amp;_view);
hr = CoCreateInstance(CLSID_DAStatics, 
       NULL, CLSCTX_INPROC, IID_IDAStatics, (void**) &amp;e);
</pRE>

<H3><A NAME="Using_Properties" IDX_CONCEPT="noindex; C++/Script, using properties">Using Properties</A></H3>

<p>After you have a pointer to the Statics library, you can use the <B>DAStatics</B> functions and properties by pointing to them with <code class="text">e-&gt;</code>, as shown in the following code.
<PRE>
IDAImagePtr myImage = e-&gt;SolidColorImage(e-&gt;Red);
</PRE>

<p>If you use <code class="text">#import "danim.dll"</code>, you can access properties directly, as shown with the <B>Black</B> property in the following example, where <I>e</I> is a pointer to the Statics library.
<PRE>
IDAColorPtr col = e-&gt;Black;
</PRE>

<p>If you do not use <code class="text">#import "danim.dll"</code>, you need to prepend get_ or put_ to the property. Use get_<I>PropertyName</I> to retrieve the value of a property, as shown in the following code. 
<PRE>
pCol = NULL;
hr = e-&gt;get_Black( &amp;pCol );
</PRE>

<p>If you use <code class="text">#import "danim.dll"</code>, you can set a property directly, as shown in the following code, where <I>view</I> is a pointer to a <B>DAView</B> object. 
<PRE>
view-&gt;CompositeDirectlyToTarget = TRUE;
</pRE>

<p>If you do not use <code class="text">#import "danim.dll"</code>, use put_<I>PropertyName</I> to set the value of a property, as shown in the following code.
<PRE>
hr = view-&gt;put_CompositeDirectlyToTarget(TRUE);
</PRE>


<H3><A NAME="Using_Methods" IDX_CONCEPT="noindex; C++/Script, using methods">Using Methods</A></H3>

<p>If you use <code class="text">#import "danim.dll"</code>, you can use methods with nearly the same syntax they have when used in script. For example, you can create a rotation in JScript as shown in the following code.
<PRE>
3DXform  = m.Rotate3RateDegrees(m.yVector3, 60);
</PRE>

<p>This same rotation in C++ with <code class="text">#import "danim.dll"</code> included is as follows:
<PRE>
IDATransform3Ptr 3DXform = e-&gt;Rotate3RateDegrees( (e-&gt;yVector3), 60);
</pRE>

<p>This same rotation in C++ without <code class="text">#import "danim.dll"</code> included is as follows:
<PRE>
  yVector3 = NULL;
  p3DXform = NULL;
  hr = e-&gt;get_YVector3( &amp;yVector3 );
  hr = e-&gt;Rotate3RateDegrees( yVector3, 60, &amp;p3DXform );
</PRE>


<H3><A NAME="Spinning_Cube_in_C++_and_Script" IDX_CONCEPT="noindex; C++ and Script, spinning cube example in each">Spinning Cube in C++ and Script</A></H3>
<p>If you include <code class="text">#import "danim.dll"</code>, the correspondence between scripting syntax in the Scripting Reference and the C++ syntax is close and you should be able to adapt the Scripting Reference to C++. 
 
<p>The following table compares how to create and render a spinning cube in JScript and C++. The C++ code assumes you have included <code class="text">#import "danim.dll"</code> in your C++ header file.</p>

<TABLE>
<TR><TH>JScript</TH><TH>C++</TH></TR>
<TR><td><B>Initialize the control</B></TD><td><B>Initialize the control</B></TD></tr>
<TR><TD><PRE>&lt;OBJECT ID="DAControl"
STYLE="width:300;height:300"
CLASSID="CLSID:
B6FFC24C-7E13-11D0-9B47-00C04FC2F51D"&gt;
&lt;/OBJECT&gt;</PRE></TD>
<TD><PRE>CDAViewerCtl::CDAViewerCtl() :_vc(NULL)  {
 _vc.CreateInstance(__uuidof(DAViewerControlWindowed));
 }</PRE></TD></TR>
<TR><td><B>Initialize library</B></TD><td><B>Initialize library</B></TD></tr>
<TR><TD><PRE>m = DAControl.MeterLibrary;</PRE></TD>
<TD><PRE>IDAStaticsPtr e;
e = _vc-&gt;GetMeterLibrary();</PRE></TD></tr>
<TR><td><B>Set media path</B></TD><TD><B>Set media path</B></TD></TR>
<TR><TD><PRE>mediaBase = "..\\..\\..\\media\\";
geoBase = mediaBase + "geometry\\";
imgBase = mediaBase + "image\\";</PRE></TD>
<TD><PRE>TCHAR szMediaBase[_MAX_PATH];
TCHAR szGeo[_MAX_PATH];
TCHAR szImg[_MAX_PATH];
GetModuleFileName(GetModuleHandle(NULL), szMediaBase,sizeof(szMediaBase));
char *pos = strrchr( szMediaBase, (int)'\\' );
int result = pos - szMediaBase + 1;
szMediaBase[result]= NULL;
TCHAR* bin  = NULL;
bin = _tcsstr(szMediaBase, "\\bin\\");
if(bin)
  _tcscat(szMediaBase,_T("../../../media/"));
else
  _tcscat(szMediaBase,_T("../../../../media/"));
_tcscpy(szGeo,szMediaBase);
_tcscpy(szImg,szMediaBase);
_tcscat(szGeo,_T("geometry/"));
_tcscat(szGeo,_T("image/"));</PRE></TD></TR>
<TR><td><B>Import media</B></TD><TD><B>Import media</B></TD></TR>
<TR><TD><PRE>cubeTexture = m.ImportImage("apple.gif");
cubeGeo = m.ImportGeometry(geoBase +
     "cube.x");</PRE></TD>
<TD><PRE>IDAImagePtr cubeTexture = e-&gt;ImportImage((_bstr_t(szImg) + _bstr_t("apple.gif"));	 
IDAGeometryPtr cubeGeo = e-&gt;ImportGeometry(_bstr_t(szGeo) + _bstr_t("cube.x"));</PRE></TD></TR>
<TR><td><B>Create spinning cube</B></TD><TD><B>Create spinning cube</B></TD></TR>	
<TR><TD><PRE>cubeGeo = cubeGeo.TextureImage(cubeTexture);
cubeTransRot = m.Rotate3Rate(m.YVector3, 30);
ubeGeo = cubeGeo.Transform(cubeTransRot);</PRE></TD>
<TD><PRE>cubeGeo = cubeGeo.
       TextureImage(cubeTexture-&gt;MapToUnitSquare());
IDATransform3Ptr cubeTransRot =
       e-&gt;Rotate3Rate(e-&gt;YVector3, 30);
cubeGeo = cubeGeo-&gt;Transform(cubeTransRot);</PRE></TD></TR>
<TR><td><B>Create camera, lights, final image</B></TD><TD><B>Create camera, lights, final image</B></TD></TR>	
<TR><TD><PRE>camera = m.PerspectiveCamera(0.06, 0.033);
light = m.PointLight.Transform(
    m.Translate3(0.015, 0.0075, 0.0225));
finalImg = m.UnionGeometry(cubeGeo, light).
       Render(camera);</PRE></TD>
<TD><PRE>IDACameraPtr camera = e-&gt;PerspectiveCamera(0.06, 0.033);
IDAGeometry light = e-&gt;PointLight-&gt;Transform(e-&gt;Translate3(0.015, 0.0075, 0.0225));
IDAImagePtr finalImg = e-&gt;UnionGeometry(cubeGeo, light)-&gt;Render(camera);</PRE></TD></TR>
<TR><td><B>Render</B></TD><TD><B>Render</B></TD></TR>	
<TR><TD><PRE>DAControl.Image = finalImg;
DAControl.Sound = m.Silence;
DAControl.Start();</PRE></TD>
<TD><PRE>_vc-&gt;PutImage(finalImg);
_vc-&gt;PutSound(e-&gt;Silence);
_vc-&gt;Start();</PRE></TD></TR>
</TABLE>

<H2><A NAME="Transforms" IDX_CONCEPT="DirectX Transform Effects, using; effects with DirectX Transform">Using DirectX Transform Effects</A></H2>
<p>You can access DirectX Transform objects from DirectAnimation to create interesting effects, such as exploding geometries and melting images. To use the 3-D effects, you must have DirectX foundation version 6 or later installed on your computer. To use some of the 2-D effects, you must have optional DLLs installed. You can install these DLLs by choosing "Optional DirectX Transforms" during installation of the DirectX Media SDK. DirectX foundation is included on the DirectX Media SDK CD. For a demonstration of the DirectX Transform effects, see the <A HREF="../demo/wizard_dxtransforms.htm">Interactive DirectX Transform Effect Wizard</A>.

<p>You access the effects through <code class="text">new ActiveXObject("<I>type</I>.<I>creator</I>.<I>name</I>");</code>, where <I>type</I> is the type of transform, <I>creator</I> is the company that created it, and <I>name</I> is the name of the effect. If the effect is a 2-D transform, the <I>type</I> is <code class="text">DXImageTransform</code>; for example, <code class="text">xf=new ActiveXObject("DXImageTransform.Microsoft.Compositor");</code>. If the effect is 3-D, the <I>type</I> is <code class="text">DX3DTransform</code>; for example, <code class="text">xf=new ActiveXObject("DX3DTransform.Microsoft.Explode");</code>. The string <code class="text">"<I>type</I>.<I>creator</I>.<I>name</I>"</code> is the ProgId (programmatic identifier) of the effect.

<p>The following code shows how to use the Wipe effect, which will wipe between two images. First, you import the two images. Then you create the transform object with <code class="text">new ActiveXObject</code>, and then you create an <I>evaluator</I>. The <I>evaluator</I> is usually a set of behaviors that describe how to map the DirectX Transform effect's progress to time. DirectX Transform effects measure progress from 0 to 1, with 1 being complete. In this example, the <I>evaluator</I> is a sequence that holds at 0 for two seconds, moves to 1 over three seconds, holds at 1 for two seconds, and moves back to 0 over three seconds. This means the initial image will be displayed for two seconds. Over the next three seconds, the second image will wipe across the first. The second image will then be displayed for two seconds, and then the first image will wipe across the second image in three seconds. Then the sequence is repeated.
<PRE>
  rawImg1 = m.ImportImage(imageBase + "tigerstripe.jpg");
  rawImg2 = m.ImportImage(imageBase + "metablob.jpg");
  xf = new ActiveXObject("DXImageTransform.Microsoft.Wipe");
  holdTime1 = m.DANumber(0).Duration(2);
  holdTime2 = m.DANumber(1).Duration(2);
  forward = m.Interpolate(0, 1, 3);
  back = m.Interpolate(1, 0, 3);
  evaluator = m.Sequence(holdTime1, m.Sequence(forward, m.Sequence(holdTime2, back))).RepeatForever();
  result = m.ApplyDXTransform(xf, new Array(rawImg1, rawImg2), evaluator);
  realImg = result.OutputBvr;
</PRE>

<p>Note that if you have a pickable image or geometry and you apply a DirectX Transform effect to it, you must make the image or geometry pickable again after the effect is applied. You can see an example of this in the JScript sample Explode.html located in the Samples\Multimedia\danim\JScript\showcase subdirectory, where applying the effect is immediately followed by calling the <B>DAGeometry</B> method <A HREF="../ref_script/class/DAGeometryClass.htm#pickv_g">Pickable</A>.
<PRE>
   explodeCow = simpleApply("DX3DTransform.Microsoft.Explode", unpickedGeo, eval);
   pickCowGeo = explodeCow.Pickable();
</PRE>

<p>The <A HREF="../../dxt/reference/effects/effects.htm" target="_top">DirectX Transform documentation</A> gives the ProgId of each transform and also specifies what software in addition to the DirectX media run time you need to have installed to use the effect, if any.  

<!-- CONTENTS_END -->



<H6><HR size=1></H6>
<P><A CLASS="line" HREF="#pagetop"><IMG src="../art/arrowup1.gif" WIDTH="11" HEIGHT="11" ALIGN="MIDDLE" BORDER=0 ALT="Top of Page">&nbsp;Top of Page</A>
<BR><A CLASS="line" HREF="../../cpyright.htm">&#169; 1998 Microsoft Corporation. All rights reserved. Terms of Use.</A>
<!-- END_PAGE_FOOTER -->


</BLOCKQUOTE>
</BODY>
</HTML>