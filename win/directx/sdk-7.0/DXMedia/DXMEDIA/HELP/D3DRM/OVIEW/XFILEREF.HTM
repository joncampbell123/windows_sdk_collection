<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<HTML>
<HEAD><TITLE>DirectX File Reference</TITLE>
<SCRIPT LANGUAGE="JAVASCRIPT"> var sRelPath = '../' </SCRIPT>

<META NAME="Description" CONTENT="DirectX File Reference">
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; CHARSET=iso8859-1">
<META NAME="MS.LOCALE" CONTENT="EN-US">
<META NAME="ROBOTS" CONTENT="all">

<!-- SNIFF_START -->

<SCRIPT LANGUAGE="JAVASCRIPT">
//<!--
var g_isIE = false, g_isNav = false, g_iMaj = 0, g_sPlat = "";
// -->

</SCRIPT>
<SCRIPT SRC="../ver.js"></SCRIPT>
<SCRIPT SRC="../gloss.js"></SCRIPT>
<!-- SNIFF_END -->


<SCRIPT DEFER SRC="../common.js"></SCRIPT>
<SCRIPT DEFER>
//<!--
function InitPage()
{
	if (g_isIE && g_iMaj >= 4)	
	{

		SetTOC();
	}
}
//-->

</SCRIPT>

<!-- SNIFF_END -->


<!-- STYLE_START -->

<SCRIPT LANGUAGE="JAVASCRIPT">
//<!--
   var sVR = '../'	// Set root for the style sheet
   var sCSS = '<LINK REL="stylesheet" HREF="' + sVR;

   if(g_isIE)
   {
	   if (g_iMaj >= 4) // For MSIE 4.0 or later
	   {
		   sCSS += 'dxm_basicSDKIE4';
		   if (g_sPlat == "Win") // Windows only for now
		   {
			   document.createStyleSheet(sVR + 'dxm_advSDKIE4.css');
		   }
	   }
	   else // For MSIE 3.0 or earlier
	   {
		   sCSS += 'dxm_basicSDKIE3';
	   }
   }
   else if (g_isNav) // For all Nav versions
   {
	   sCSS += 'dxm_basicSDKNAV';
   }
   else
   {
	   sCSS += 'dxm_basicSDKIE3'; // default to IE3 sheet
   }

   sCSS += (sCSS == '' ? '' : '.css" TYPE="text/css">');

   document.write(sCSS);
//-->

</SCRIPT>
<!-- STYLE_END -->


</HEAD>
<BODY onload="InitPage(); if (g_isIE && g_iMaj >= 4){HdgrphControl()}" BGCOLOR="#FFFFFF">
<A NAME="pagetop"></A>

<!-- HEADGRAPH_START -->

<TABLE CLASS="main" BORDER=0 CELLSPACING="0" CELLPADDING="0" WIDTH="*">
<TR>
<TD ROWSPAN="3" VALIGN="TOP" WIDTH="*">
<IMG SRC="../art/header1.gif" WIDTH="107" HEIGHT="110" BORDER=0 ALT="Direct3D Retained Mode Animated Header --DirectX File Reference"></TD>
<TD ROWSPAN="2" VALIGN="TOP" WIDTH="217">
<IMG SRC="../art/HDRd3drm.gif" WIDTH="217" HEIGHT="110" BORDER=0 ALT="Direct3D Retained Mode Animated Header --DirectX File Reference"></TD><TD VALIGN="TOP" WIDTH="383">
<IMG SRC="../art/header3.gif" WIDTH="383" HEIGHT="95" BORDER=0 ALT="Direct3D Retained Mode Animated Header">
</TD>
<TD VALIGN="TOP" WIDTH="100%">
<IMG SRC="../art/spacer1.gif" WIDTH="100%" HEIGHT="94" BORDER=0 ALT="Microsoft Direct3D Retained Mode SDK"></TD></TR>
<!-- HEADGRAPH_END -->

<!-- NAV_LINKS_START -->

<TR><TD VALIGN="TOP"><PRE><IMG ID="TOC_" SRC="../art/yelbtn.gif" WIDTH="11" HEIGHT="11" ALIGN="MIDDLE" BORDER=0 ALT="*"><A STYLE="color:black;font-weight:bold" ID="TOC" HREF="../contents.htm">Contents</A>  <IMG SRC="../art/yelbtn.gif" WIDTH="11" HEIGHT="11" ALIGN="MIDDLE" BORDER=0 ALT="*"><A STYLE="color:black;font-weight:bold" HREF="../index.htm">Index</A>  <IMG SRC="../art/yelbtn.gif" WIDTH="11" HEIGHT="11" ALIGN="MIDDLE" BORDER=0 ALT="*"><A STYLE="color:black;font-weight:bold" HREF="../default.htm">Topic Contents</A>
</PRE></TD></TR>
<TR><TD COLSPAN="2" VALIGN="TOP"><PRE><IMG SRC="../art/yelbtn.gif" WIDTH="11" HEIGHT="11" ALIGN="MIDDLE" BORDER=0 ALT="*"><B>Previous Topic:</B> <A STYLE="color:black" HREF="xfileSamples.htm">DirectX File Samples</A>
<IMG SRC="../art/yelbtn.gif" WIDTH="11" HEIGHT="11" ALIGN="MIDDLE" BORDER=0 ALT="*"><B>Next Topic:</B> <A STYLE="color:black" HREF="../gloss/def_gloss.htm">Glossary</A>
</PRE></TD></TR></TABLE>
<BLOCKQUOTE CLASS="body">
<!-- NAV_LINKS_END -->

<!-- CONTENTS_START -->

<H1><a name="DirectX_File_Reference" IDX_CONCEPT="NOINDEX; DirectX file reference; reference, DirectX file">DirectX File Reference</a></H1>

<p>This section discusses the function, interfaces, objects, and data types introduced with DirectX version 6.0 that are used to write to and read from Microsoft&reg; DirectX&reg; (.x) files. This section also briefly introduces the relationship between the interfaces and provides a hierarchy chart that shows interface inheritance. The DirectX file methods allow reading from and writing to both text and binary files. 

<p>You should be familiar with the format of DirectX files as outlined in <a href="xfilearchitecture.htm">DirectX File Format Architecture</a> before using these interfaces. Understanding the file format will help you better understand the purpose of the interfaces and their methods.

<p>This section contains the following topics.
<ul>
<li><a href="#Introduction">Introduction</a>
<li><a href="#Hierarchy">Hierarchy Chart</a>
<li><a href="#Interfaces">Function and Interfaces</a>
<li><a href="#Data_Types">Data Types</a>
<li><a href="#Return_Values">Return Values</a>
</ul>





<h1><a name="Introduction" IDX_CONCEPT="Introduction to DirectX File Interfaces;noindex">Introduction</a></h1>
<p>The following summary discusses how to load data from a DirectX (.x) file and how to save data to a DirectX file. The DirectX file methods work with both text and binary DirectX files and support loading from various sources, such as files, memory, resources, or URLs. 

<p>To use the DirectX file interfaces, you must first use the <a href="#DirectXFileCreate">DirectXFileCreate</a> function to create an <a href="#IDirectXFile">IDirectXFile</a> object. 

<h2><a name="Loading_a_File" IDX_CONCEPT="DirectX File, Loading;Loading a DirectX File">Loading a File</a></h2>
<p>Use the following procedure to load a DirectX file.
<ol>
<li>Use the <a href="#DirectXFileCreate">DirectXFileCreate</a> function to create an <a href="#IDirectXFile">IDirectXFile</a> object. 
<li>If templates are not present in the DirectX file that you are going to load,
use the <a href="#RegisterTemplates">IDirectXFile::RegisterTemplates</a> method to register those templates.
<li>Use the <a href="#CreateEnumObject">IDirectXFile::CreateEnumObject</a> method to create an
<a href="#IDirectXFileEnumObject">IDirectXFileEnumObject</a> enumerator object.
<li>Loop through the objects in the file. For each object, perform the following steps.

<ol>
<li STYLE="list-style-type='lower-alpha'">Use the <a href="#GetNextDataObject">IDirectXFileEnumObject::GetNextDataObject</a> method to retrieve each <a href="#IDirectXFileData">IDirectXFileData</a> object.
<li STYLE="list-style-type='lower-alpha'">Use the <a href="#GetType">IDirectXFileData::GetType</a> method to retrieve the data's type.
<li STYLE="list-style-type='lower-alpha'">Load the data using the <a href="#GetData">IDirectXFileData::GetData</a> method.
<li STYLE="list-style-type='lower-alpha'">If the object has optional members, retrieve the optional members by calling the <a href="#GetNextObject">IDirectXFileData::GetNextObject</a> method.
</ol>

<li>Release the <a href="#IDirectXFileData">IDirectXFileData</a> object.
<li>Release the <a href="#IDirectXFileEnumObject">IDirectXFileEnumObject</a> object.
<li>Release the <a href="#IDirectXFile">IDirectXFile</a> object.
</ol>

<h2><a name="Saving_a_File" IDX_CONCEPT="DirectX File, Saving;Saving a DirectX File">Saving a File</a></h2>
<p>Use the following procedure to save DirectX file templates and data to a DirectX file.
<ol>
<li>Use the <a href="#DirectXFileCreate">DirectXFileCreate</a> function to create an <a href="#IDirectXFile">IDirectXFile</a> object. 
<li>Use the <a href="#RegisterTemplates">IDirectXFile::RegisterTemplates</a> method
to inform the DirectX file system about any templates that you are going to use.
<li>Use the <a href="#CreateSaveObject">IDirectXFile::CreateSaveObject</a> method
to create an
<a href="#IDirectXFileSaveObject">IDirectXFileSaveObject</a> object.
<li>Use the <a href="#SaveTemplates">IDirectXFileSaveObject::SaveTemplates</a> method
to save templates, if desired.

<li>Loop through the objects to save. For each top-level object, perform the following steps.
<ol>
<li STYLE="list-style-type='lower-alpha'">Use the <a href="#CreateDataObject">IDirectXFileSaveObject::CreateDataObject</a> method 
to create an <a href="#IDirectXFileData">IDirectXFileData</a> object as a top-level object in the file. If the top-level data object has optional child objects, add them to the object by using the appropriate method from the "How to Add" column 
in the next step.
<li STYLE="list-style-type='lower-alpha'">Each <a href="#IDirectXFileData">IDirectXFileData</a> object can have optional child objects if its template allows it. The child objects can be any one of the three types of objects:
<b>IDirectXFileData</b>, <a href="#IDirectXFileDataReference">IDirectXFileDataReference</a>, or <a href="#IDirectXFileBinary">IDirectXFileBinary</a>. Loop through the objects you need to save, adding each optional child member to the object list in the manner appropriate to its type, as shown in the following table.
<table>
<tr>
	<td><b>Object Type</b></td>
	<td><b>How to Add</b></td>
</tr>
<tr>
	<td>Data</td>
	<td>Call the <a href="#CreateDataObject">IDirectXFileSaveObject::CreateDataObject</a> method 
to create an <a href="#IDirectXFileData">IDirectXFileData</a> object, and then call the <a href="#AddDataObject">IDirectXFileData::AddDataObject</a> method 
to add it as a child of the object.</td>
</tr>
<tr>
	<td>Data Reference</td>
	<td>Call the <a href="#AddDataReference">IDirectXFileData::AddDataReference</a> method to create and add the data reference object as a child of the object.</td>
</tr>
<tr>
	<td>Binary</td>
	<td>Call the <a href="#AddBinaryObject">IDirectXFileData::AddBinaryObject</a> method to create and add the binary object as a child of the object.</td>
</tr>
</table>
<li STYLE="list-style-type='lower-alpha'">Call the <a href="#SaveData">IDirectXFileSaveObject::SaveData</a> method 
to save the data object and all of its children.
<li STYLE="list-style-type='lower-alpha'">Release the <a href="#IDirectXFileData">IDirectXFileData</a> object.
</ol>

<li>Release the <a href="#IDirectXFileSaveObject">IDirectXFileSaveObject</a> object.
<li>Release the <a href="#IDirectXFile">IDirectXFile</a> object.
</ol>





<h1><a NAME="Hierarchy" IDX_CONCEPT="DirectX File Interface Hierarchy Chart">Hierarchy Chart</a></h1>

<p>The following diagram shows the relationship between the DirectX file interfaces.

<pre>
 <A HREF="../ref/FurtherReading.htm#_dx5_IUnknown_Interface_dxintro">IUnknown</A>
 |
 +--<a href="#IDirectXFile">IDirectXFile</a>
 |
 +--<a href="#IDirectXFileEnumObject">IDirectXFileEnumObject</a>
 |
 +--<a href="#IDirectXFileObject">IDirectXFileObject</a>
 |  |
 |  +--<a href="#IDirectXFileBinary">IDirectXFileBinary</a>
 |  |
 |  +--<a href="#IDirectXFileData">IDirectXFileData</a>
 |  |
 |  +--<a href="#IDirectXFileDataReference">IDirectXFileDataReference</a>
 |
 +--<a href="#IDirectXFileSaveObject">IDirectXFileSaveObject</a>
</PRE>	






<h1><a name="Interfaces" IDX_CONCEPT="DirectX File Interfaces;noindex">Function and Interfaces</a></h1>

<p>DirectX supplies the following DirectX file function and interfaces.

<ul>
<li><a href="#DirectXFileCreate">DirectXFileCreate</a> function
<li><a href="#IDirectXFile">IDirectXFile</a>
<li><a href="#IDirectXFileBinary">IDirectXFileBinary</a>
<li><a href="#IDirectXFileData">IDirectXFileData</a>
<li><a href="#IDirectXFileDataReference">IDirectXFileDataReference</a>
<li><a href="#IDirectXFileEnumObject">IDirectXFileEnumObject</a>
<li><a href="#IDirectXFileObject">IDirectXFileObject</a>
<li><a href="#IDirectXFileSaveObject">IDirectXFileSaveObject</a>
</ul>

<p>The following table provides the Globally Unique Identifier (GUID) that corresponds with each DirectX File interface. For information about using a GUID with the <b>QueryInterface</b> method to determine a child object's type, see the introduction to the <a href="#IDirectXFileData">IDirectXFileData</a> interface.

<table>
<tr>
	<td><b>Interface</b></td>
	<td><b>GUID</b></td>
</tr>
<tr>
	<td><a href="#IDirectXFile">IDirectXFile</a></td>
	<td>IID_IDirectXFile</td>
</tr>
<tr>
	<td><a href="#IDirectXFileBinary">IDirectXFileBinary</a></td>
	<td>IID_IDirectXFileBinary</td>
</tr>
<tr>
	<td><a href="#IDirectXFileData">IDirectXFileData</a></td>
	<td>IID_IDirectXFileData</td>
</tr>
<tr>
	<td><a href="#IDirectXFileDataReference">IDirectXFileDataReference</a></td>
	<td>IID_IDirectXFileDataReference</td>
</tr>
<tr>
	<td><a href="#IDirectXFileEnumObject">IDirectXFileEnumObject</a></td>
	<td>IID_IDirectXFileEnumObject</td>
</tr>
<tr>
	<td><a href="#IDirectXFileObject">IDirectXFileObject</a></td>
	<td>IID_IDirectXFileObject</td>
</tr>
<tr>
	<td><a href="#IDirectXFileSaveObject">IDirectXFileSaveObject</a></td>
	<td>IID_IDirectXFileSaveObject</td>
</tr>
</table>



<h1><a name="DirectXFileCreate">DirectXFileCreate</a> Function<HR size=1></h1>
<p>The <b>DirectXFileCreate</b> function creates the <a href="#IDirectXFile">IDirectXFile</a> interface.
<P CLASS="ref">Syntax</P>
<BLOCKQUOTE>
<PRE>
STDAPI DirectXFileCreate(LPDIRECTXFILE *ppDirectXFile);
</PRE>
</BLOCKQUOTE>

<P CLASS="ref">Parameters</P>
<BLOCKQUOTE>
<DL>
<DT><I>ppDirectXFile</I></DT>
   <DD>Address of a pointer to receive the created <a href="#IDirectXFile">IDirectXFile</a> interface.</DD>
</DL>
</BLOCKQUOTE>

<P CLASS="ref">Return Value</P>
<BLOCKQUOTE>
<P>Returns one of the following values:
<TABLE CLASS="ref">
<TR><TD><A HREF="#DXFILE_OK">DXFILE_OK</A></TD></TR>
<TR><TD><A HREF="#DXFILEERR_BADALLOC">DXFILEERR_BADALLOC</A></TD></TR>
<TR><TD><A HREF="#DXFILEERR_BADVALUE">DXFILEERR_BADVALUE</A></TD></TR>
</TABLE>
</BLOCKQUOTE>

<P CLASS="ref">Remarks</P>
<BLOCKQUOTE>
<P>After using this function, use the <a href="#IDirectXFile">IDirectXFile</a> methods to: register templates (<a href="#RegisterTemplates">RegisterTemplates</a>), create an enumerator object (<a href="#CreateEnumObject">CreateEnumObject</a>), or create a save object (<a href="#CreateSaveObject">CreateSaveObject</a>).
</BLOCKQUOTE>





<h1><a name="IDirectXFile">IDirectXFile</a></h1>
<p>This interface enables you to create the <a href="#IDirectXFileEnumObject">IDirectXFileEnumObject</a> and <a href="#IDirectXFileSaveObject">IDirectXFileSaveObject</a> objects and to register templates.

<p>Use the <a href="#DirectXFileCreate">DirectXFileCreate</a> function to create an instance of this object.

<p>The <b>IDirectXFile</b> interface provides the following methods.

<ul>
<li><a href="#CreateEnumObject">CreateEnumObject</a>
<li><a href="#CreateSaveObject">CreateSaveObject</a>
<li><a href="#RegisterTemplates">RegisterTemplates</a>
</ul>




<H2><A NAME="CreateEnumObject">IDirectXFile::CreateEnumObject</A><HR size=1></H2>
<A HREF="xfileRef.htm">IDirectXFile</A>
<P>Creates an enumerator object.
<P CLASS="ref">Syntax</P>
<BLOCKQUOTE>
<PRE>
HRESULT CreateEnumObject(
  LPVOID pvSource,
  DXFILELOADOPTIONS dwLoadOptions,
  LPDIRECTXFILEENUMOBJECT * ppEnumObj);
</PRE>
</BLOCKQUOTE>

<P CLASS="ref">Parameters</P>
<BLOCKQUOTE>
<DL>
<DT><I>pvSource</I></DT>
   <DD>Pointer to
data whose contents depend on the value of <I>dwLoadOptions</I> as outlined in the following table.
<table>
<tr>
	<td><b><I>dwLoadOptions</I> value</b></td>
	<td><b>Contents of <I>pvSource</I></b></td>
</tr>
<tr>
	<td><a href="#DXFILELOAD_FROMFILE">DXFILELOAD_FROMFILE</a></td>
	<td>Name of the file</td>
</tr>
<tr>
	<td><a href="#DXFILELOAD_FROMRESOURCE">DXFILELOAD_FROMRESOURCE</a></td>
	<td><a href="#DXFILELOADRESOURCE">DXFILELOADRESOURCE</a> structure</td>
</tr>
<tr>
	<td><a href="#DXFILELOAD_FROMMEMORY">DXFILELOAD_FROMMEMORY</a></td>
	<td><a href="#DXFILELOADMEMORY">DXFILELOADMEMORY</a> structure</td>
</tr>
<tr>
	<td><a href="#DXFILELOAD_FROMURL">DXFILELOAD_FROMURL</a></td>
	<td>Name of the Uniform Resource Locator (URL)</td>
</tr>
</table>
</DD>
<DT><I>dwLoadOptions</I></DT>
   <DD>Value that specifies the source of the data. One of the <A href="#DXFILELOADOPTIONS">DXFILELOADOPTIONS</A> values.</DD>
<DT><I>ppEnumObj</I></DT>
   <DD>Address of a pointer to receive the created <a href="#IDirectXFileEnumObject">IDirectXFileEnumObject</a> interface.</DD>
</DL>
</BLOCKQUOTE>

<P CLASS="ref">Return Value</P>
<BLOCKQUOTE>
<P>Returns one of the following values:<BR>&nbsp;
<TABLE CLASS="ref">
<TR><TD><A HREF="#DXFILE_OK">DXFILE_OK</A></TD></TR>
<TR><TD><A HREF="#DXFILEERR_BADALLOC">DXFILEERR_BADALLOC</A></TD></TR>
<TR><TD><A HREF="#DXFILEERR_BADFILEFLOATSIZE">DXFILEERR_BADFILEFLOATSIZE</A></TD></TR>
<TR><TD><A HREF="#DXFILEERR_BADFILETYPE">DXFILEERR_BADFILETYPE</A></TD></TR>
<TR><TD><A HREF="#DXFILEERR_BADFILEVERSION">DXFILEERR_BADFILEVERSION</A></TD></TR>
<TR><TD><A HREF="#DXFILEERR_BADRESOURCE">DXFILEERR_BADRESOURCE</A></TD></TR>
<TR><TD><A HREF="#DXFILEERR_BADVALUE">DXFILEERR_BADVALUE</A></TD></TR>
<TR><TD><A HREF="#DXFILEERR_FILENOTFOUND">DXFILEERR_FILENOTFOUND</A></TD></TR>
<TR><TD><A HREF="#DXFILEERR_RESOURCENOTFOUND">DXFILEERR_RESOURCENOTFOUND</A></TD></TR>
<TR><TD><A HREF="#DXFILEERR_URLNOTFOUND">DXFILEERR_URLNOTFOUND</A></TD></TR>
</TABLE>
</BLOCKQUOTE>

<P CLASS="ref">Remarks</P>
<BLOCKQUOTE>
<P>After using this method, use one of the <a href="#IDirectXFileEnumObject">IDirectXFileEnumObject</a> methods to retrieve a data object.
</BLOCKQUOTE>




<H2><A NAME="CreateSaveObject">IDirectXFile::CreateSaveObject</A><HR size=1></H2>
<A HREF="xfileRef.htm">IDirectXFile</A>
<P>Creates an instance of an <a href="#IDirectXFileSaveObject">IDirectXFileSaveObject</a> object.

<P CLASS="ref">Syntax</P>
<BLOCKQUOTE>
<PRE>
HRESULT CreateSaveObject(
  LPCSTR szFileName,
  DXFILEFORMAT dwFileFormat,
  LPDIRECTXFILESAVEOBJECT * ppSaveObj);
</PRE>
</BLOCKQUOTE>

<P CLASS="ref">Parameters</P>
<BLOCKQUOTE>
<DL>
<DT><I>szFileName</I></DT>
  <DD>Pointer to the name of the file to use for saving data.</DD>
<DT><I>dwFileFormat</I></DT>
  <DD>File format. One of the <a href="#DXFILEFORMAT">DXFILEFORMAT</a> constants.</DD>
<DT><I>ppSaveObj</I></DT>
  <DD>Address of a pointer to receive the created <a href="#IDirectXFileSaveObject">IDirectXFileSaveObject</a> object.</DD>
</DL>
</BLOCKQUOTE>

<P CLASS="ref">Return Value</P>
<BLOCKQUOTE>
<P>Returns one of the following values:
<TABLE CLASS="ref">
<TR><TD><A HREF="#DXFILE_OK">DXFILE_OK</A></TD></TR>
<TR><TD><A HREF="#DXFILEERR_BADALLOC">DXFILEERR_BADALLOC</A></TD></TR>
<TR><TD><A HREF="#DXFILEERR_BADFILE">DXFILEERR_BADFILE</A></TD></TR>
<TR><TD><A HREF="#DXFILEERR_BADVALUE">DXFILEERR_BADVALUE</A></TD></TR>
</TABLE>
</BLOCKQUOTE>

<P CLASS="ref">Remarks</P>
<BLOCKQUOTE>
<P>After using this method, use methods of the <a href="#IDirectXFileSaveObject">IDirectXFileSaveObject</a> interface to create data objects and to save templates or data. 
</BLOCKQUOTE>



<H2><A NAME="RegisterTemplates">IDirectXFile::RegisterTemplates</A><HR size=1></H2>
<A HREF="xfileRef.htm">IDirectXFile</A>
<P>Registers custom templates.

<P CLASS="ref">Syntax</P>
<BLOCKQUOTE>
<PRE>
HRESULT RegisterTemplates(
  LPVOID pvData,
  DWORD cbSize);
</PRE>
</BLOCKQUOTE>

<P CLASS="ref">Parameters</P>
<BLOCKQUOTE>
<DL>
<DT><I>pvData</I></DT>
<DD>Pointer to a buffer consisting of a DirectX file in text or binary format that contains templates.</DD>
<DT><I>cbSize</I></DT>
<DD>Size of the buffer pointed to by <I>pvData</I>, in bytes.</DD>
</DL>
</BLOCKQUOTE>

<P CLASS="ref">Return Value</P>
<BLOCKQUOTE>
<P>Returns one of the following values:
<TABLE CLASS="ref">
<TR><TD><A HREF="#DXFILE_OK">DXFILE_OK</A></TD></TR>
<TR><TD><A HREF="#DXFILEERR_BADFILEFLOATSIZE">DXFILEERR_BADFILEFLOATSIZE</A></TD></TR>
<TR><TD><A HREF="#DXFILEERR_BADFILETYPE">DXFILEERR_BADFILETYPE</A></TD></TR>
<TR><TD><A HREF="#DXFILEERR_BADFILEVERSION">DXFILEERR_BADFILEVERSION</A></TD></TR>
<TR><TD><A HREF="#DXFILEERR_BADVALUE">DXFILEERR_BADVALUE</A></TD></TR>
<TR><TD><A HREF="#DXFILEERR_PARSEERROR">DXFILEERR_PARSEERROR</A></TD></TR>
</TABLE>
</BLOCKQUOTE>

<P CLASS="ref">Remarks</P>
<BLOCKQUOTE>
<P>The following code fragment provides an example call to <b>RegisterTemplates</b> and example contents for the buffer to which <I>pvData</I> points.

<pre>
IDirectXFile * pDXFile;

char *szTemplates = "xof 0303txt 0032\
    template SimpleData { \
        &lt;2b934580-9e9a-11cf-ab39-0020af71e433&gt; \
        DWORD item1;DWORD item2;DWORD item3;} \
    template ArrayData { \
        &lt;2b934581-9e9a-11cf-ab39-0020af71e433&gt; \
        DWORD cItems; array DWORD aItem[2][cItems]; [...] } \
    template RestrictedData { \
        &lt;2b934582-9e9a-11cf-ab39-0020af71e433&gt; \
        DWORD item; [SimpleData]}";

hr = pDXFile-&gt;RegisterTemplates(szTemplates, strlen(szTemplates));
</pre>

<p>All templates must specify a name and a UUID (Universally Unique Identifier).
</BLOCKQUOTE>





<h1><a name="IDirectXFileBinary">IDirectXFileBinary</a></h1>
<p>This interface enables you to read binary data and to retrieve information about it.



<p>The <b>IDirectXFileBinary</b> interface provides the following methods.

<ul>
<li><a href="#GetMimeType">GetMimeType</a>
<li><a href="#GetSize">GetSize</a>
<li><a href="#Read">Read</a>
</ul>

<p>In addition, <b>IDirectXFileBinary</b> inherits the <a href="#GetId">IDirectXFileObject::GetId</a> and <a href="#GetName">IDirectXFileObject::GetName</a> methods.



<H2><A NAME="GetMimeType">IDirectXFileBinary::GetMimeType</A><HR size=1></H2>
<A HREF="xfileRef.htm">IDirectXFileBinary</A>
<P>Retrieves the mime type for the binary data.

<P CLASS="ref">Syntax</P>
<BLOCKQUOTE>
<PRE>
HRESULT GetMimeType(LPCSTR * pszMimeType);
</PRE>
</BLOCKQUOTE>

<P CLASS="ref">Parameters</P>
<BLOCKQUOTE>
<DL>
<DT><I>pszMimeType</I></DT>
  <DD>Address of a pointer to receive the mime type string.</DD>
</DL>
</BLOCKQUOTE>

<P CLASS="ref">Return Value</P>
<BLOCKQUOTE>
<P>Returns one of the following values:
<TABLE CLASS="ref">
<TR><TD><A HREF="#DXFILE_OK">DXFILE_OK</A></TD></TR>
<TR><TD><A HREF="#DXFILEERR_BADVALUE">DXFILEERR_BADVALUE</A></TD></TR>
</TABLE>
</BLOCKQUOTE>
<P>When there is no Mime type specified in a specified .X file for a binary object, the function will set *pszMimeType to NULL.



<H2><A NAME="GetSize">IDirectXFileBinary::GetSize</A><HR size=1></H2>
<A HREF="xfileRef.htm">IDirectXFileBinary</A>
<P>Retrieves the size of the binary data.
<P CLASS="ref">Syntax</P>
<BLOCKQUOTE>
<PRE>HRESULT GetSize(DWORD * pcbSize);</PRE>
</BLOCKQUOTE>

<P CLASS="ref">Parameters</P>
<BLOCKQUOTE>
<DL>
<DT><I>pcbSize</I></DT>
<DD>Pointer to receive the size of the binary data, in bytes.</DD>
</DL>
</BLOCKQUOTE>

<P CLASS="ref">Return Value</P>
<BLOCKQUOTE>
<P>Returns one of the following values:
<TABLE CLASS="ref">
<TR><TD><A HREF="#DXFILE_OK">DXFILE_OK</A></TD></TR>
<TR><TD><A HREF="#DXFILEERR_BADVALUE">DXFILEERR_BADVALUE</A></TD></TR>
</TABLE>
</BLOCKQUOTE>



<H2><A NAME="Read">IDirectXFileBinary::Read</A><HR size=1></H2>
<A HREF="xfileRef.htm">IDirectXFileBinary</A>


<P>Reads binary data.

<P CLASS="ref">Syntax</P>
<BLOCKQUOTE>
<PRE>
HRESULT Read(
  LPVOID pvData,
  DWORD cbSize,
  LPDWORD pcbRead);
</PRE>
</BLOCKQUOTE>

<P CLASS="ref">Parameters</P>
<BLOCKQUOTE>
<DL>
<DT><I>pvData</I></DT>
  <DD>Pointer to the buffer that receives the data that has been read.</DD>
<DT><I>cbSize</I></DT>
  <DD>Size of the buffer pointed to by <I>pvData</I>, in bytes.</DD>
<DT><I>pcbRead</I></DT>
  <DD>Pointer to
the number of bytes read.</DD>
</DL>
</BLOCKQUOTE>

<P CLASS="ref">Return Value</P>
<BLOCKQUOTE>
<P>Returns one of the following values:
<TABLE CLASS="ref">
<TR><TD><A HREF="#DXFILE_OK">DXFILE_OK</A></TD></TR>
<TR><TD><A HREF="#DXFILEERR_BADVALUE">DXFILEERR_BADVALUE</A></TD></TR>
<TR><TD><A HREF="#DXFILEERR_NOMOREDATA">DXFILEERR_NOMOREDATA</A></TD></TR>
</TABLE>
</BLOCKQUOTE>





<h1><a name="IDirectXFileData">IDirectXFileData</a></h1>
<p>The <b>IDirectXFileData</b> interface provides methods that enable you to build or to access the immediate hierarchy of the data object. Template restrictions determine the hierarchy. Data types allowed by the template are called optional members. The optional members are not required, but an object might miss important information without them. These optional members are saved as children of the data object. The children can be another data object, a reference to an earlier data object, or a binary object.

<p>When saving objects to a DirectX file, use <a href="#AddBinaryObject">AddBinaryObject</a>, <a href="#AddDataObject">AddDataObject</a>, or <a href="#AddDataReference">AddDataReference</a> to add binary objects, data objects, or data reference objects, respectively, to the file. For more information, see <a href="#saving_a_file">Saving a File</a>.

<p>When enumerating objects in an existing DirectX file, use the <a href="#GetData">GetData</a>, <a href="#GetNextObject">GetNextObject</a>, and <a href="#GetType">GetType</a> methods as follows:
<ol>
<li>Use <a href="#GetType">GetType</a> to retrieve the object's template's GUID. For example, for a mesh object <b>GetType</b> retrieves the GUID for the mesh template.
<li>Use <a href="#GetData">GetData</a> to retrieve required members of the object in a contiguous chunk of memory.
<li>For each child object, perform the following steps.

<ol>
<li>Use <a href="#GetNextObject">GetNextObject</a> to retrieve a child object.
<li>Use <b>QueryInterface</b> to determine the child object's type (data, data reference, or binary) by querying for support of the <b>IDirectXFileData</b>, <b>IDirectXFileDataReference</b>, and <b>IDirectXFileBinary</b> interfaces,
 in turn. The interface supported indicates the object's type. The following code fragment determines whether an object is a binary object by determining if it supports <b>IDirectXFileBinary</b>.
<pre>
IDirectXFileObject *DXFileObj;
IDirectXFileBinary *DXFileBinary;

if (FAILED(DXFileObj-&gt;QueryInterface(IID_IDirectXFileBinary,
                                     (LPVOID *)&amp;DXFileBinary))
{
    // Object does not support IDirectXFileBinary and therefore
	// is not a binary object.
}    
else
{
    // Object is binary.
}	
</pre>
<li>After you have determined the child object's type, use methods of the appropriate interface (<a href="#IDirectXFileData">IDirectXFileData</a>, <a href="#IDirectXFileDataReference">IDirectXFileDataReference</a>, or <a href="#IDirectXFileBinary">IDirectXFileBinary</a>) to act upon the child object.
</ol>
</ol>

<p>The <b>IDirectXFileData</b> interface provides the following methods.

<ul>
<li><a href="#AddBinaryObject">AddBinaryObject</a>
<li><a href="#AddDataObject">AddDataObject</a>
<li><a href="#AddDataReference">AddDataReference</a>
<li><a href="#GetData">GetData</a>
<li><a href="#GetNextObject">GetNextObject</a>
<li><a href="#GetType">GetType</a>
</ul>

<p>In addition, <b>IDirectXFileData</b> inherits the <a href="#GetId">IDirectXFileObject::GetId</a>
and <a href="#GetName">IDirectXFileObject::GetName</a> methods.




<H2><A NAME="AddBinaryObject">IDirectXFileData::AddBinaryObject</A><HR size=1></H2>
<A HREF="xfileRef.htm">IDirectXFileData</A>
<P>Creates and adds a binary object as a child object.

<P CLASS="ref">Syntax</P>
<BLOCKQUOTE>
<PRE>HRESULT AddBinaryObject(
  LPCSTR szName,
  const GUID * pguid,
  LPCSTR szMimeType,
  LPVOID pvData,
  DWORD cbSize);</PRE>
</BLOCKQUOTE>

<P CLASS="ref">Parameters</P>
<BLOCKQUOTE>
<DL>
<DT><I>szName</I></DT>
  <DD>Pointer to
 the name of the object. Optional, specify NULL if the object does not need a name.</DD>
<DT><I>pguid</I></DT>
  <DD>Pointer to
the GUID representing the object. Optional, specify NULL if the object does not need a GUID.</DD>
<DT><I>szMimeType</I></DT>
  <DD>Pointer to
the object's mime type.</DD>
<DT><I>pvData</I></DT>
  <DD>Pointer to
the object's data.</DD>
<DT><I>cbSize</I></DT>
  <DD>Size of the buffer pointed to by <I>pvData</I>, in bytes.</DD>
</DL>
</BLOCKQUOTE>

<P CLASS="ref">Return Value</P>
<BLOCKQUOTE>
<P>Returns one of the following values:
<TABLE CLASS="ref">
<TR><TD><A HREF="#DXFILE_OK">DXFILE_OK</A></TD></TR>
<TR><TD><A HREF="#DXFILEERR_BADALLOC">DXFILEERR_BADALLOC</A></TD></TR>
<TR><TD><A HREF="#DXFILEERR_BADVALUE">DXFILEERR_BADVALUE</A></TD></TR>
</TABLE>
</BLOCKQUOTE>

<P CLASS="ref">Remarks</P>
<BLOCKQUOTE>
<P>For more information about saving child objects, see the introduction to this interface, <A HREF="xfileRef.htm">IDirectXFileData</A>.
</BLOCKQUOTE>



<H2><A NAME="AddDataObject">IDirectXFileData::AddDataObject</A><HR size=1></H2>
<A HREF="xfileRef.htm">IDirectXFileData</A>
<P>Adds a data object as a child object.

<P CLASS="ref">Syntax</P>
<BLOCKQUOTE>
<PRE>
HRESULT AddDataObject(LPDIRECTXFILEDATA pDataObj);
</PRE>
</BLOCKQUOTE>

<P CLASS="ref">Parameters</P>
<BLOCKQUOTE>
<DL>
<DT><I>pDataObj</I></DT>
<DD>Pointer to
the <a href="#IDirectXFileData">IDirectXFileData</a> object to add as a child object.</DD>
</DL>
</BLOCKQUOTE>

<P CLASS="ref">Return Value</P>
<BLOCKQUOTE>
<P>Returns one of the following values:
<TABLE CLASS="ref">
<TR><TD><A HREF="#DXFILE_OK">DXFILE_OK</A></TD></TR>
<TR><TD><A HREF="#DXFILEERR_BADALLOC">DXFILEERR_BADALLOC</A></TD></TR>
<TR><TD><A HREF="#DXFILEERR_BADVALUE">DXFILEERR_BADVALUE</A></TD></TR>
</TABLE>
</BLOCKQUOTE>

<P CLASS="ref">Remarks</P>
<BLOCKQUOTE>
<P>Use the <a href="#CreateDataObject">IDirectXFileSaveObject::CreateDataObject</a> method 
to create the <a href="#IDirectXFileData">IDirectXFileData</a> object before calling this method.

<p>For more information about saving objects, see the introduction to this interface, <A HREF="xfileRef.htm">IDirectXFileData</A>.
</BLOCKQUOTE>



<H2><A NAME="AddDataReference">IDirectXFileData::AddDataReference</A><HR size=1></H2>
<A HREF="xfileRef.htm">IDirectXFileData</A>
<P>Creates and adds a data reference object as a child object.

<P CLASS="ref">Syntax</P>
<BLOCKQUOTE>
<PRE>HRESULT AddDataReference(
  LPCSTR szRef,
  const GUID * pguidRef);</PRE>
</BLOCKQUOTE>

<P CLASS="ref">Parameters</P>
<BLOCKQUOTE>
<DL>
<DT><I>szRef</I></DT>
  <DD>Pointer to
the name of the referenced data object. Can be NULL if <I>pguidRef</I> provides a reference to the GUID.</DD>
<DT><I>pguidRef</I></DT>
  <DD>Pointer to
the GUID representing the data. Can be NULL if <I>szRef</I> provides a reference to the name.</DD>
</DL>
</BLOCKQUOTE>

<P CLASS="ref">Return Value</P>
<BLOCKQUOTE>
<P>Returns one of the following values:
<TABLE CLASS="ref">
<TR><TD><A HREF="#DXFILE_OK">DXFILE_OK</A></TD></TR>
<TR><TD><A HREF="#DXFILEERR_BADALLOC">DXFILEERR_BADALLOC</A></TD></TR>
<TR><TD><A HREF="#DXFILEERR_BADVALUE">DXFILEERR_BADVALUE</A></TD></TR>
</TABLE>
</BLOCKQUOTE>

<P CLASS="ref">Remarks</P>
<BLOCKQUOTE>
<P>At least one of the <I>szRef</I> or <I>pguidRef</I> parameters
must be non-NULL.

<p>For more information about saving objects, see the introduction to this interface, <A HREF="xfileRef.htm">IDirectXFileData</A>.
</BLOCKQUOTE>



<H2><A NAME="GetData">IDirectXFileData::GetData</A><HR size=1></H2>
<A HREF="xfileRef.htm">IDirectXFileData</A>
<P>Retrieves the data for one of the object's members or the data for all members.

<P CLASS="ref">Syntax</P>
<BLOCKQUOTE>
<PRE>HRESULT GetData(
  LPCSTR szMember,
  DWORD * pcbSize,
  void ** ppvData);</PRE>
</BLOCKQUOTE>

<P CLASS="ref">Parameters</P>
<BLOCKQUOTE>
<DL>
<DT><I>szMember</I></DT>
<DD>Name of the member for which to retrieve data. Specify NULL to retrieve all required members' data.</DD>
<DT><I>pcbSize</I></DT>
<DD>Pointer to
receive the <I>ppvData</I> buffer size, in bytes.</DD>
<DT><I>ppvData</I></DT>
<DD>Address of a pointer to receive the data associated with <I>szMember</I>. If <I>szMember</I> is NULL, <I>*ppvData</I> is set to point to a buffer containing all required members' data in a contiguous block of memory.</DD>
</DL>
</BLOCKQUOTE>

<P CLASS="ref">Return Value</P>
<BLOCKQUOTE>
<P>Returns one of the following values:
<TABLE CLASS="ref">
<TR><TD><A HREF="#DXFILE_OK">DXFILE_OK</A></TD></TR>
<TR><TD><A HREF="#DXFILEERR_BADARRAYSIZE">DXFILEERR_BADARRAYSIZE</A></TD></TR>
<TR><TD><A HREF="#DXFILEERR_BADDATAREFERENCE">DXFILEERR_BADDATAREFERENCE</A></TD></TR>
<TR><TD><A HREF="#DXFILEERR_BADVALUE">DXFILEERR_BADVALUE</A></TD></TR>
</TABLE>
</BLOCKQUOTE>

<P CLASS="ref">Remarks</P>
<BLOCKQUOTE>
<P>This method retrieves the data for required members of a data object but no data for optional  (child) members. Use <a href="#GetNextObject">GetNextObject</a> to retrieve child objects.

<p>For more information about enumerating objects, see the introduction to this interface, <A HREF="xfileRef.htm">IDirectXFileData</A>.
</BLOCKQUOTE>



<H2><A NAME="GetNextObject">IDirectXFileData::GetNextObject</A><HR size=1></H2>
<A HREF="xfileRef.htm">IDirectXFileData</A>
<P>Retrieves the next child data object, data reference object, or binary object in the DirectX file.
<P CLASS="ref">Syntax</P>
<BLOCKQUOTE>
<PRE>HRESULT GetNextObject(LPDIRECTXFILEOBJECT * ppChildObj);</PRE>
</BLOCKQUOTE>

<P CLASS="ref">Parameters</P>
<BLOCKQUOTE>
<DL>
<DT><I>ppChildObj</I></DT>
<DD>Address to receive a pointer to the child object's <a href="#IDirectXFileObject">IDirectXFileObject</a> interface.</DD>
</DL>
</BLOCKQUOTE>

<P CLASS="ref">Return Value</P>
<BLOCKQUOTE>
<P>Returns one of the following values:
<TABLE CLASS="ref">
<TR><TD><A HREF="#DXFILE_OK">DXFILE_OK</A></TD></TR>
<TR><TD><A HREF="#DXFILEERR_BADVALUE">DXFILEERR_BADVALUE</A></TD></TR>
<TR><TD><A HREF="#DXFILEERR_NOMOREOBJECTS">DXFILEERR_NOMOREOBJECTS</A></TD></TR>
</TABLE>
</BLOCKQUOTE>

<P CLASS="ref">Remarks</P>
<BLOCKQUOTE>
<p>To determine the type of object retrieved, use <B>QueryInterface</B> to query the retrieved object for support of <a href="#IDirectXFileData">IDirectXFileData</a>, <a href="#IDirectXFileDataReference">IDirectXFileDataReference</a>, or <a href="#IDirectXFileBinary">IDirectXFileBinary</a> interfaces.
 The interface supported indicates the type of object (data, data reference, or binary). 
<p>For more information about child objects, enumerating objects and determining the type of object, see the introduction to this interface, <A HREF="xfileRef.htm">IDirectXFileData</A>.
</BLOCKQUOTE>



<H2><A NAME="GetType">IDirectXFileData::GetType</A><HR size=1></H2>
<A HREF="xfileRef.htm">IDirectXFileData</A>

<P>Retrieves the GUID of the object's template.

<P CLASS="ref">Syntax</P>
<BLOCKQUOTE>
<PRE>HRESULT GetType(const GUID ** ppguid);</PRE>
</BLOCKQUOTE>

<P CLASS="ref">Parameters</P>
<BLOCKQUOTE>
<DL>
<DT><I>ppguid</I></DT>
<DD>Address of a pointer to receive the GUID of the object's template.</DD>
</DL>
</BLOCKQUOTE>

<P CLASS="ref">Return Value</P>
<BLOCKQUOTE>
<P>Returns one of the following values:
<TABLE CLASS="ref">
<TR><TD><A HREF="#DXFILE_OK">DXFILE_OK</A></TD></TR>
<TR><TD><A HREF="#DXFILEERR_BADVALUE">DXFILEERR_BADVALUE</A></TD></TR>
</TABLE>
</BLOCKQUOTE>






<h1><a name="IDirectXFileDataReference">IDirectXFileDataReference</a></h1>

<p>The <b>IDirectXFileDataReference</b> interface provides support for data reference objects. A data reference object refers to a data object that is defined earlier in the file. This allows you to use the same object multiple times without repeating it in the file.

<p>After you have determined that an object is a data reference object, use this interface's <a href="#Resolve">Resolve</a> method to get the real object that is defined earlier in the file. For information about how to determine that you have a data reference object, see the <a href="#IDirectXFileData">IDirectXFileData</a> interface.

<p>In addition, <b>IDirectXFileDataReference</b> inherits the <a href="#GetId">IDirectXFileObject::GetId</a> and <a href="#GetName">IDirectXFileObject::GetName</a> methods.



<H2><A NAME="Resolve">IDirectXFileDataReference::Resolve</A><HR size=1></H2>
<A HREF="xfileRef.htm">IDirectXFileDataReference</A>
<P>Resolves data references.

<P CLASS="ref">Syntax</P>
<BLOCKQUOTE>
<PRE>HRESULT Resolve(LPDIRECTXFILEDATA * ppDataObj);</PRE>
</BLOCKQUOTE>

<P CLASS="ref">Parameters</P>
<BLOCKQUOTE>
<DL>
<DT><I>ppDataObj</I></DT>
<DD>Address of a pointer to receive the <a href="#IDirectXFileData">IDirectXFileData</a> object.</DD>
</DL>
</BLOCKQUOTE>

<P CLASS="ref">Return Value</P>
<BLOCKQUOTE>
<P>Returns one of the following values:
<TABLE CLASS="ref">
<TR><TD><A HREF="#DXFILE_OK">DXFILE_OK</A></TD></TR>
<TR><TD><A HREF="#DXFILEERR_BADVALUE">DXFILEERR_BADVALUE</A></TD></TR>
<TR><TD><A HREF="#DXFILEERR_NOTFOUND">DXFILEERR_NOTFOUND</A></TD></TR>
</TABLE>
</BLOCKQUOTE>






<h1><a name="IDirectXFileEnumObject">IDirectXFileEnumObject</a></h1>
<p>This interface enables you to loop through to retrieve all data objects in the file and to retrieve a data object by GUID or by name.

<p>The <b>IDirectXFileEnumObject</b> interface provides the following methods.
<ul>
<li><a href="#GetDataObjectById">GetDataObjectById</a>
<li><a href="#GetDataObjectByName">GetDataObjectByName</a>
<li><a href="#GetNextDataObject">GetNextDataObject</a>
</ul>




<H2><A NAME="GetDataObjectById">IDirectXFileEnumObject::GetDataObjectById</A><HR size=1></H2>
<A HREF="xfileRef.htm">IDirectXFileEnumObject</A>
<P>Retrieves the data object that has the specified GUID.

<P CLASS="ref">Syntax</P>
<BLOCKQUOTE>
<PRE>
HRESULT GetDataObjectById(
  REFGUID rguid,
  LPDIRECTXFILEDATA * ppDataObj);
</PRE>
</BLOCKQUOTE>

<P CLASS="ref">Parameters</P>
<BLOCKQUOTE>
<DL>
<DT><I>rguid</I></DT>
  <DD>Reference to the desired GUID.</DD>
<DT><I>ppDataObj</I></DT>
  <DD>Pointer to
 receive the retrieved <a href="#IDirectXFileData">IDirectXFileData</a> object.</DD>
</DL>
</BLOCKQUOTE>

<P CLASS="ref">Return Value</P>
<BLOCKQUOTE>
<P>Returns one of the following values:
<TABLE CLASS="ref">
<TR><TD><A HREF="#DXFILE_OK">DXFILE_OK</A></TD></TR>
<TR><TD><A HREF="#DXFILEERR_BADVALUE">DXFILEERR_BADVALUE</A></TD></TR>
<TR><TD><A HREF="#DXFILEERR_NOTFOUND">DXFILEERR_NOTFOUND</A></TD></TR>
</TABLE>
</BLOCKQUOTE>



<H2><A NAME="GetDataObjectByName">IDirectXFileEnumObject::GetDataObjectByName</A><HR size=1></H2>
<A HREF="xfileRef.htm">IDirectXFileEnumObject</A>
<P>Retrieves the data object that has the specified name.

<P CLASS="ref">Syntax</P>
<BLOCKQUOTE>
<PRE>
HRESULT GetDataObjectByName(
  LPCSTR szName,
  LPDIRECTXFILEDATA * ppDataObj);
  </PRE>
</BLOCKQUOTE>

<P CLASS="ref">Parameters</P>
<BLOCKQUOTE>
<DL>
<DT><I>szName</I></DT>
  <DD>Pointer to
the desired name.</DD>
<DT><I>ppDataObj</I></DT>
  <DD>Pointer to
receive the retrieved <a href="#IDirectXFileData">IDirectXFileData</a> object.</DD>
</DL>
</BLOCKQUOTE>

<P CLASS="ref">Return Value</P>
<BLOCKQUOTE>
<P>Returns one of the following values:
<TABLE CLASS="ref">
<TR><TD><A HREF="#DXFILE_OK">DXFILE_OK</A></TD></TR>
<TR><TD><A HREF="#DXFILEERR_BADVALUE">DXFILEERR_BADVALUE</A></TD></TR>
<TR><TD><A HREF="#DXFILEERR_NOTFOUND">DXFILEERR_NOTFOUND</A></TD></TR>
</TABLE>
</BLOCKQUOTE>




<H2><A NAME="GetNextDataObject">IDirectXFileEnumObject::GetNextDataObject</A><HR size=1></H2>
<A HREF="xfileRef.htm">IDirectXFileEnumObject</A>
<P>Retrieves the next top-level object in the DirectX file. Top-level objects are always data objects. Data reference objects and binary objects can only be children of data objects.

<P CLASS="ref">Syntax</P>
<BLOCKQUOTE>
<PRE>
HRESULT GetNextDataObject(
  LPDIRECTXFILEDATA * ppDataObj);
  </PRE>
</BLOCKQUOTE>

<P CLASS="ref">Parameters</P>
<BLOCKQUOTE>
<DL>
<DT><I>ppDataObj</I></DT>
  <DD>Pointer to
receive the retrieved <a href="#IDirectXFileData">IDirectXFileData</a> object.</DD>
</DL>
</BLOCKQUOTE>

<P CLASS="ref">Return Value</P>
<BLOCKQUOTE>
<P>Returns one of the following values:
<TABLE CLASS="ref">
<TR><TD><A HREF="#DXFILE_OK">DXFILE_OK</A></TD></TR>
<TR><TD><A HREF="#DXFILEERR_BADVALUE">DXFILEERR_BADVALUE</A></TD></TR>
<TR><TD><A HREF="#DXFILEERR_NOMOREOBJECTS">DXFILEERR_NOMOREOBJECTS</A></TD></TR>
</TABLE>
</BLOCKQUOTE>





<h1><a name="IDirectXFileObject">IDirectXFileObject</a></h1>

<p><b>IDirectXFileObject</b> is the base interface for DirectX file objects. <a href="#IDirectXFileData">IDirectXFileData</a>, <a href="#IDirectXFileDataReference">IDirectXFileDataReference</a> and <a href="#IDirectXFileBinary">IDirectXFileBinary</a> interfaces 
all inherit from this interface.

<p>The <b>IDirectXFileObject</b> interface provides the following methods.

<ul>
<li><a href="#GetId">GetId</a>
<li><a href="#GetName">GetName</a>
</ul>



<H2><A NAME="GetId">IDirectXFileObject::GetId</A><HR size=1></H2>
<A HREF="xfileRef.htm">IDirectXFileObject</A>
<P>Retrieves a pointer to the GUID that identifies a DirectX file object.
<P CLASS="ref">Syntax</P>
<BLOCKQUOTE>
<PRE>
HRESULT GetId (LPGUID <I>pGuid</I>)
</PRE>
</BLOCKQUOTE>

<P CLASS="ref">Parameters</P>
<BLOCKQUOTE>
<DL>
<DT><I>pGuid</I></DT>
  <DD>Pointer to a GUID to receive the object's ID. The function will set the GUID to a NULL GUID if the object does not have an ID.</DD>
</DL>
</BLOCKQUOTE>

<P CLASS="ref">Return Value</P>
<BLOCKQUOTE>
<P>Returns one of the following values.
<TABLE CLASS="ref">
<TR><TD><A HREF="#DXFILE_OK">DXFILE_OK</A></TD></TR>
<TR><TD><A HREF="#DXFILEERR_BADVALUE">DXFILEERR_BADVALUE</A></TD></TR>
</table>
</BLOCKQUOTE>



<H2><A NAME="GetName">IDirectXFileObject::GetName</A><HR size=1></H2>
<A HREF="xfileRef.htm">IDirectXFileObject</A>
<P>Retrieves a pointer to a DirectX file object's name.
<P CLASS="ref">Syntax</P>
<BLOCKQUOTE>
<PRE>
HRESULT GetName (LPSTR <I>pstrNameBuf</I>, <B>LPDWORD</B> <I>pdwBufLen</I>)
</PRE>
</BLOCKQUOTE>

<P CLASS="ref">Parameters</P>
<BLOCKQUOTE>
<DL>
<DT><I>pstrNameBuf</I></DT>
  <DD>Pointer to the buffer in which the DirectX file object's name will be copied. Set to NULL if only the buffer length is needed.</DD>
<DT><I>pdwBufLen</I></DT>
  <DD>Pointer to a DWORD specifying the length of the buffer pointed to by <I>pstrNameBuf</I>.  <I>pdwBufLen</I> will be modified to the buffer length needed to hold the object's name even if <I>pstrNameBuf</I> is NULL. In either case, the function will return DXFILEERR_BADVALUE if the original value of <I>pdwBufLen</I> is not as large as or larger than the length needed to hold the object's name.</DD>
</DL>
</BLOCKQUOTE>

<P CLASS="ref">Return Value</P>
Returns one of the following values.
<BLOCKQUOTE>
<TABLE CLASS="ref">
<TR><TD><A HREF="#DXFILE_OK">DXFILE_OK</A></TD></TR>
<TR><TD><A HREF="#DXFILEERR_BADALLOC">DXFILEERR_BADALLOC</A></TD></TR>
</TABLE>
</BLOCKQUOTE>






<h1><a name="IDirectXFileSaveObject">IDirectXFileSaveObject</a></h1>

<p>This interface enables you to create data objects and to save templates and data objects. Use <a href="#CreateSaveObject">IDirectXFile::CreateSaveObject</a> to create an instance of this object. Then use <a href="#SaveTemplates">SaveTemplates</a> to save the templates. Use <a href="#CreateDataObject">CreateDataObject</a> to create a data object, and use <a href="#SaveData">SaveData</a> to save the data.

<p>Note that templates are not required in every file. For example, you could put all templates in one DirectX file rather than duplicating them in every DirectX file.

<p>The <b>IDirectXFileSaveObject</b> interface provides the following methods.

<ul>
<li><a href="#CreateDataObject">CreateDataObject</a>
<li><a href="#SaveData">SaveData</a>
<li><a href="#SaveTemplates">SaveTemplates</a>
</ul>




<H2><A NAME="CreateDataObject">IDirectXFileSaveObject::CreateDataObject</A><HR size=1></H2>
<A HREF="xfileRef.htm">IDirectXFileSaveObject</A>
<P>Creates a data object.

<P CLASS="ref">Syntax</P>
<BLOCKQUOTE>
<PRE>HRESULT CreateDataObject(
  REFGUID rguidTemplate,
  LPCSTR szName,
  const GUID * pguid,
  DWORD cbSize,
  LPVOID pvData,
  LPDIRECTXFILEDATA * ppDataObj);
  </PRE>
</BLOCKQUOTE>

<P CLASS="ref">Parameters</P>
<BLOCKQUOTE>
<DL>
<DT><I>rguidTemplate</I></DT>
  <DD>GUID representing the data object's template.</DD>
<DT><I>szName</I></DT>
  <DD>Pointer to
the name of the data object. Optional, specify NULL if the object does not have a name.
If the object is going to be referenced by a data reference object, at least one of the <I>szName</I> or <I>pguid</I> parameters 
must be non-NULL.</DD>
<DT><I>pguid</I></DT>
  <DD>Pointer to
a GUID representing the data object. Optional, specify NULL if the object does not have a GUID.
If the object is going to be referenced by a data reference object, at least one of the <I>szName</I> or <I>pguid</I> parameters must be non-NULL.</DD>
<DT><I>cbSize</I></DT>
  <DD>Size of the data object, in bytes.</DD>
<DT><I>pvData</I></DT>
  <DD>Pointer to
a buffer containing all required member's data.</DD>
<DT><I>ppDataObj</I></DT>
  <DD>Address of a pointer to receive the created <a href="#IDirectXFileData">IDirectXFileData</a> object.</DD>
</DL>
</BLOCKQUOTE>

<P CLASS="ref">Return Value</P>
<BLOCKQUOTE>
<P>Returns one of the following values:
<TABLE CLASS="ref">
<TR><TD><A HREF="#DXFILE_OK">DXFILE_OK</A></TD></TR>
<TR><TD><A HREF="#DXFILEERR_BADALLOC">DXFILEERR_BADALLOC</A></TD></TR>
<TR><TD><A HREF="#DXFILEERR_BADVALUE">DXFILEERR_BADVALUE</A></TD></TR>
</TABLE>
</BLOCKQUOTE>

<P CLASS="ref">Remarks</P>
<BLOCKQUOTE>
<P>Save any templates by using the <a href="#SaveTemplates">SaveTemplates</a> method 
before saving the data created by this method. Save the created data by using the <a href="#SaveData">SaveData</a> method.
If you need to save optional data, use the <a href="#AddDataObject">IDirectXFileData::AddDataObject</a> method
after using this method and before using <b>SaveData</b>. If the object has child objects, add them before calling <b>SaveData</b>.
</BLOCKQUOTE>



<H2><A NAME="SaveData">IDirectXFileSaveObject::SaveData</A><HR size=1></H2>
<A HREF="xfileRef.htm">IDirectXFileSaveObject</A>
<P>Saves a data object and its children to a DirectX file.
								 
<P CLASS="ref">Syntax</P>
<BLOCKQUOTE>
<PRE>HRESULT SaveData(
  LPDIRECTXFILEDATA pDataObj);
  </PRE>
</BLOCKQUOTE>

<P CLASS="ref">Parameters</P>
<BLOCKQUOTE>
<DL>
<DT><I>pDataObj</I></DT>
  <DD>Pointer to
the <a href="#IDirectXFileData">IDirectXFileData</a> object to save.</DD>
</DL>
</BLOCKQUOTE>

<P CLASS="ref">Return Value</P>
<BLOCKQUOTE>
<P>Returns one of the following values:
<TABLE CLASS="ref">
<TR><TD><A HREF="#DXFILE_OK">DXFILE_OK</A></TD></TR>
<TR><TD><A HREF="#DXFILEERR_BADARRAYSIZE">DXFILEERR_BADARRAYSIZE</A></TD></TR>
<TR><TD><A HREF="#DXFILEERR_BADVALUE">DXFILEERR_BADVALUE</A></TD></TR>
</TABLE>
</BLOCKQUOTE>



<H2><A NAME="SaveTemplates">IDirectXFileSaveObject::SaveTemplates</A><HR size=1></H2>
<A HREF="xfileRef.htm">IDirectXFileSaveObject</A>
<P>Saves templates to a DirectX file.

<P CLASS="ref">Syntax</P>
<BLOCKQUOTE>
<PRE>HRESULT SaveTemplates(
  DWORD cTemplates,
  const GUID ** ppguidTemplates);
  </PRE>
</BLOCKQUOTE>

<P CLASS="ref">Parameters</P>
<BLOCKQUOTE>
<DL>
<DT><I>cTemplates</I></DT>
<DD>Total number of templates to save.</DD>
<DT><I>ppguidTemplates</I></DT>
<DD>Address of a pointer to an array of the GUIDs for all templates to save.</DD>
</DL>
</BLOCKQUOTE>

<P CLASS="ref">Return Value</P>
<BLOCKQUOTE>
<P>Returns one of the following values:
<TABLE CLASS="ref">
<TR><TD><A HREF="#DXFILE_OK">DXFILE_OK</A></TD></TR>
<TR><TD><A HREF="#DXFILEERR_BADVALUE">DXFILEERR_BADVALUE</A></TD></TR>
</TABLE>
</BLOCKQUOTE>

<P CLASS="ref">Remarks</P>
<BLOCKQUOTE>
<P>The following code fragment provides an example call to <b>SaveTemplates</b> and example contents for the array to which <I>ppuuid</I> points.

<pre>
IDirectXFileSaveObject * pDXFileSaveObject;

const GUID *aIds[] = {
    &amp;DXFILEOBJ_SimpleData,
    &amp;DXFILEOBJ_ArrayData,
    &DXFILEOBJ_RestrictedData};

hr = pDXFileSaveObject-&gt;SaveTemplates(3, aIds);
</pre>

<p>After using this method to save the templates, use the <a href="#CreateDataObject">IDirectXFileSaveObject::CreateDataObject</a> method
to create a data object.
</BLOCKQUOTE>






<h1><a name="Data_Types">Data Types</a></h1>
<p>The DirectX file interfaces use the following constants and structures.
<ul>
<li><A href="#DXFILEFORMAT">DXFILEFORMAT</A> Constants
<li><a href="#DXFILELOADMEMORY">DXFILELOADMEMORY</a> Structure
<li><A href="#DXFILELOADOPTIONS">DXFILELOADOPTIONS</A> Constants
<li><a href="#DXFILELOADRESOURCE">DXFILELOADRESOURCE</a> Structure
</ul>




<H2><A NAME="DXFILEFORMAT">DXFILEFORMAT</A> Constants<HR size=1></H2>
<P>Specifies values used by the <A href="#CreateSaveObject">IDirectXFile::CreateSaveObject</A> method
to indicate the format to use when saving the DirectX file.

<P CLASS="ref">Syntax</P>
<BLOCKQUOTE>
<PRE>typedef DWORD DXFILEFORMAT;
#define DXFILEFORMAT_BINARY     0
#define DXFILEFORMAT_TEXT       1
#define DXFILEFORMAT_COMPRESSED 2</PRE>
</BLOCKQUOTE>

<P CLASS="ref">Values</P>
<BLOCKQUOTE>
<DL>
<DT><B>DXFILEFORMAT_BINARY</B></DT>
  <DD>Indicates a binary file.</DD>
<DT><B>DXFILEFORMAT_TEXT</B></DT>
  <DD>Indicates a text file.</DD>
<DT><B>DXFILEFORMAT_COMPRESSED</B></DT>
  <DD>Indicates a compressed file.</DD>
</DL>

The default value for the file format is DXFILEFORMAT_BINARY. The file format values can be combined together in a logical OR
to create compressed text or compressed binary files. If a file is specified as both binary (0) and text (1), it will be saved as a text file because the value will be indistinguishable from the text file format value (0 + 1 = 1). If you indicate that the file format should be text and compressed, the file will first be written out as text and then commpressed. However, compressed text files are not as effecient as binary text files, so in most cases you will want to indicate binary and compressed. Setting a file to be compressed without specifying a format will result in a binary, compressed file.
</BLOCKQUOTE>



<H2><a name="DXFILELOADMEMORY">DXFILELOADMEMORY</a> Structure<HR size=1></H2>
<P>Identifies a resource to be loaded when an application uses the <A HREF="#CreateEnumObject">IDirectXFile::CreateEnumObject</A> method and specifies <a href="#DXFILELOAD_FROMMEMORY">DXFILELOAD_FROMMEMORY</a>.

<P CLASS="ref">Syntax</P>
<BLOCKQUOTE>
<PRE>typedef struct _DXFILELOADMEMORY {
    LPVOID lpMemory;
    DWORD dSize;
}DXFILELOADMEMORY, *LPDXFILELOADMEMORY;</PRE>
</BLOCKQUOTE>

<P CLASS="ref">Members</P>
<BLOCKQUOTE>
<DL>
<DT><B>lpMemory</B></DT>
  <DD>Pointer to
a block of memory to be loaded.</DD>
<DT><B>dSize</B></DT>
  <DD>Size, in bytes, of the block of memory to be loaded.
</DD>
</DL>
</BLOCKQUOTE>




<H2><A NAME="DXFILELOADOPTIONS">DXFILELOADOPTIONS</A> Constants<HR size=1></H2>
<P>Specifies values used by the <A href="#CreateEnumObject">IDirectXFile::CreateEnumObject</A> method 
to indicate the source of the file data.

<P CLASS="ref">Syntax</P>
<BLOCKQUOTE>
<PRE>typedef DWORD DXFILELOADOPTIONS;
#define DXFILELOAD_FROMFILE  0x00L
#define DXFILELOAD_FROMRESOURCE 0x01L
#define DXFILELOAD_FROMMEMORY 0x02L
#define DXFILELOAD_FROMSTREAM 0x04L
#define DXFILELOAD_FROMURL 0x08L</PRE>
</BLOCKQUOTE>

<P CLASS="ref">Values</P>
<BLOCKQUOTE>
<DL>
<DT><B><a name="DXFILELOAD_FROMFILE" IDX_CONCEPT="DXFILELOAD_FROMFILE">DXFILELOAD_FROMFILE</a></B></DT>
  <DD>Indicates data read from a file.</DD>
<DT><B><a name="DXFILELOAD_FROMRESOURCE" IDX_CONCEPT="DXFILELOAD_FROMRESOURCE">DXFILELOAD_FROMRESOURCE</a></B></DT>
  <DD>Indicates data read from a resource.</DD>
<DT><B><a name="DXFILELOAD_FROMMEMORY" IDX_CONCEPT="DXFILELOAD_FROMMEMORY">DXFILELOAD_FROMMEMORY</a></B></DT>
  <DD>Indicates data read from memory.</DD>
<DT><B><a name="DXFILELOAD_FROMSTREAM" IDX_CONCEPT="DXFILELOAD_FROMSTREAM">DXFILELOAD_FROMSTREAM</a></B></DT>
  <DD>Indicates data read from a stream. Not currently supported.</DD>
<DT><B><a name="DXFILELOAD_FROMURL" IDX_CONCEPT="DXFILELOAD_FROMURL">DXFILELOAD_FROMURL</a></B></DT>
  <DD>Indicates data read from a URL (Uniform Resource Locator).</DD>
</DL>
</BLOCKQUOTE>




<H2><a name="DXFILELOADRESOURCE">DXFILELOADRESOURCE</a> Structure<HR size=1></H2>
<P>Identifies a resource to be loaded when an application uses the <A HREF="#CreateEnumObject">IDirectXFile::CreateEnumObject</A> method and specifies <a href="#DXFILELOAD_FROMRESOURCE">DXFILELOAD_FROMRESOURCE</a>.

<P CLASS="ref">Syntax</P>
<BLOCKQUOTE>
<PRE>typedef struct _DXFILELOADRESOURCE {
    HMODULE hModule;
    LPCTSTR lpName;
    LPCTSTR lpType;
}DXFILELOADRESOURCE, *LPDXFILELOADRESOURCE;</PRE>
</BLOCKQUOTE>

<P CLASS="ref">Members</P>
<BLOCKQUOTE>
<DL>
<DT><B>hModule</B></DT>
  <DD>Handle of the module containing the resource to be loaded. If this member is NULL, the resource must be attached to the executable file that will use it.</DD>
<DT><B>lpName</B></DT>
  <DD>Name of the resource to be loaded. For example, if the resource is a mesh, this member should specify the name of the mesh file.</DD>
<DT><B>lpType</B></DT>
  <DD>User-defined type identifying the resource.</DD>
</DL>
</BLOCKQUOTE>






<h1><a name="Return_Values">Return Values</a></h1>

<P>The methods of the DirectX file Component Object Model (COM) interfaces
can return the following values in addition to standard COM return values.
<DL>

<DT><B><A NAME="DXFILE_OK">DXFILE_OK</A></B></DT>
  <DD>Command completed successfully. Equivalent to <a href="../ref/ReturnValues.htm#dd_ok">DD_OK</a>.</DD>

<DT><B><A NAME="DXFILEERR_BADVALUE">DXFILEERR_BADVALUE</A></B></DT>
  <DD>Parameter is invalid.</DD>
<DT><B><A NAME="DXFILEERR_BADTYPE">DXFILEERR_BADTYPE</A></B></DT>
  <DD>Object type is invalid.</DD>


<DT><B><A NAME="DXFILEERR_BADALLOC">DXFILEERR_BADALLOC</A></B></DT>
  <DD>Memory allocation failed.</DD>
<DT><B><A NAME="DXFILEERR_NOTFOUND">DXFILEERR_NOTFOUND</A></B></DT>
  <DD>Object could not be found.</DD>
<DT><B><A NAME="DXFILEERR_FILENOTFOUND">DXFILEERR_FILENOTFOUND</A></B></DT>
  <DD>File could not be found.</DD>
<DT><B><A NAME="DXFILEERR_RESOURCENOTFOUND">DXFILEERR_RESOURCENOTFOUND</A></B></DT>
  <DD>Resource could not be found.</DD>
<DT><B><A NAME="DXFILEERR_URLNOTFOUND">DXFILEERR_URLNOTFOUND</A></B></DT>
  <DD>URL could not be found.</DD>
<DT><B><A NAME="DXFILEERR_BADRESOURCE">DXFILEERR_BADRESOURCE</A></B></DT>
  <DD>Resource is invalid.</DD>
<DT><B><A NAME="DXFILEERR_BADFILETYPE">DXFILEERR_BADFILETYPE</A></B></DT>
  <DD>File is not a DirectX file.</DD>
<DT><B><A NAME="DXFILEERR_BADFILEVERSION">DXFILEERR_BADFILEVERSION</A></B></DT>
  <DD>File version is not valid.</DD>
<DT><B><A NAME="DXFILEERR_BADFILEFLOATSIZE">DXFILEERR_BADFILEFLOATSIZE</A></B></DT>
  <DD>Floating-point size is invalid.</DD>


<DT><B><A NAME="DXFILEERR_BADFILE">DXFILEERR_BADFILE</A></B></DT>
  <DD>File is invalid.</DD>
<DT><B><A NAME="DXFILEERR_PARSEERROR">DXFILEERR_PARSEERROR</A></B></DT>
  <DD>File could not be parsed.</DD>


<DT><B><A NAME="DXFILEERR_BADARRAYSIZE">DXFILEERR_BADARRAYSIZE</A></B></DT>
  <DD>Array size is invalid.</DD>
<DT><B><A NAME="DXFILEERR_BADDATAREFERENCE">DXFILEERR_BADDATAREFERENCE</A></B></DT>
  <DD>Data reference is invalid.</DD>


<DT><B><A NAME="DXFILEERR_NOMOREOBJECTS">DXFILEERR_NOMOREOBJECTS</A></B></DT>
  <DD>All objects have been enumerated.</DD>




<DT><B><A NAME="DXFILEERR_NOMOREDATA">DXFILEERR_NOMOREDATA</A></B></DT>
  <DD>No further data is available.</DD>


</DL>
<!-- CONTENTS_END -->

<!-- START_PAGE_FOOTER -->


<H5><HR size=1></H5>
<P><A class="line" HREF="#pagetop"><IMG src="../art/arrowup1.gif" WIDTH="11" HEIGHT="11" ALIGN="MIDDLE" BORDER=0 ALT="Top of Page">&nbsp;Top of Page</A>
<BR><A Class="line" HREF="../../cpyright.htm" TARGET="_top">&#169; 1998 Microsoft Corporation. All rights reserved. Terms of Use.</A>
<!-- END_PAGE_FOOTER -->

</BLOCKQUOTE>

<SCRIPT LANGUAGE="JAVASCRIPT">if((g_isIE == true) && (g_iMaj > 3)) {window.self.document.writeln('<SCR' + 'IPT SRC="../tip2.js"></SCR' + 'IPT><IFRAME ID="G_L_S" NAME="SecretBuffer" STYLE="display: none" SRC=""></IFRAME>')}</SCRIPT>
</SCRIPT>
<!-- DACONTROL_START -->

	<DIV ID="HeadGraphAnim"></DIV>
	<SCRIPT LANGUAGE="JAVASCRIPT">if((g_isIE == true) && (g_iMaj > 3)) {window.self.document.writeln('<SCR' + 'IPT SRC="../anim.js"></SCR' + 'IPT>')}</SCRIPT>
<!-- DACONTROL_END -->

</BODY>
</HTML>
