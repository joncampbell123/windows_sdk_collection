<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<HTML>
<HEAD><TITLE>Technical Background</TITLE>
<SCRIPT LANGUAGE="JAVASCRIPT"> var sRelPath = '../' </SCRIPT>


<META NAME="Description" CONTENT="Technical Background">
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; CHARSET=iso8859-1">
<META NAME="MS.LOCALE" CONTENT="EN-US">
<META NAME="ROBOTS" CONTENT="all">

<!-- SNIFF_START -->

<SCRIPT LANGUAGE="JAVASCRIPT">
//<!--
var g_isIE = false, g_isNav = false, g_iMaj = 0, g_sPlat = "";
// -->

</SCRIPT>
<SCRIPT SRC="../ver.js"></SCRIPT>
<SCRIPT SRC="../gloss.js"></SCRIPT>


<SCRIPT DEFER SRC="../common.js"></SCRIPT>
<SCRIPT DEFER>
//<!--
function InitPage()
{
	if (g_isIE && g_iMaj >= 4)	
	{

		SetTOC();
	}
}
//-->

</SCRIPT>

<!-- SNIFF_END -->


<!-- STYLE_START -->

<SCRIPT LANGUAGE="JAVASCRIPT">
//<!--
   var sVR = '../'	// Set root for the style sheet
   var sCSS = '<LINK REL="stylesheet" HREF="' + sVR;

   if(g_isIE)
   {
	   if (g_iMaj >= 4) // For MSIE 4.0 or later
	   {
		   sCSS += 'dxm_basicSDKIE4';
		   if (g_sPlat == "Win") // Windows only for now
		   {
			   document.createStyleSheet(sVR + 'dxm_advSDKIE4.css');
		   }
	   }
	   else // For MSIE 3.0 or earlier
	   {
		   sCSS += 'dxm_basicSDKIE3';
	   }
   }
   else if (g_isNav) // For all Nav versions
   {
	   sCSS += 'dxm_basicSDKNAV';
   }
   else
   {
	   sCSS += 'dxm_basicSDKIE3'; // default to IE3 sheet
   }

   sCSS += (sCSS == '' ? '' : '.css" TYPE="text/css">');

   document.write(sCSS);
//-->

</SCRIPT>
<!-- STYLE_END -->


</HEAD>
<BODY onload="InitPage(); if (g_isIE && g_iMaj >= 4){HdgrphControl()}" BGCOLOR="#FFFFFF">
<A NAME="pagetop"></A><A NAME="rmmath_A_Technical"></A>

<!-- HEADGRAPH_START -->

<TABLE CLASS="main" BORDER=0 CELLSPACING="0" CELLPADDING="0" WIDTH="*">
<TR>
<TD ROWSPAN="3" VALIGN="TOP" WIDTH="*">
<IMG SRC="../art/header1.gif" WIDTH="107" HEIGHT="110" BORDER=0 ALT="Direct3D Retained Mode Animated Header --Technical Background"></TD>
<TD ROWSPAN="2" VALIGN="TOP" WIDTH="217">
<IMG SRC="../art/HDRd3drm.gif" WIDTH="217" HEIGHT="110" BORDER=0 ALT="Direct3D Retained Mode Animated Header --Technical Background"></TD><TD VALIGN="TOP" WIDTH="383">
<IMG SRC="../art/header3.gif" WIDTH="383" HEIGHT="95" BORDER=0 ALT="Direct3D Retained Mode Animated Header">
</TD>
<TD VALIGN="TOP" WIDTH="100%">
<IMG SRC="../art/spacer1.gif" WIDTH="100%" HEIGHT="94" BORDER=0 ALT="Microsoft Direct3D Retained Mode SDK"></TD></TR>
<!-- HEADGRAPH_END -->

<!-- NAV_LINKS_START -->

<TR><TD VALIGN="TOP"><PRE><IMG ID="TOC_" SRC="../art/yelbtn.gif" WIDTH="11" HEIGHT="11" ALIGN="MIDDLE" BORDER=0 ALT="*"><A STYLE="color:black;font-weight:bold" ID="TOC" HREF="../contents.htm">Contents</A>  <IMG SRC="../art/yelbtn.gif" WIDTH="11" HEIGHT="11" ALIGN="MIDDLE" BORDER=0 ALT="*"><A STYLE="color:black;font-weight:bold" HREF="../index.htm">Index</A>  <IMG SRC="../art/yelbtn.gif" WIDTH="11" HEIGHT="11" ALIGN="MIDDLE" BORDER=0 ALT="*"><A STYLE="color:black;font-weight:bold" HREF="../default.htm">Topic Contents</A>
</PRE></TD></TR>
<TR><TD COLSPAN="2" VALIGN="TOP"><PRE><IMG SRC="../art/yelbtn.gif" WIDTH="11" HEIGHT="11" ALIGN="MIDDLE" BORDER=0 ALT="*"><B>Previous Topic:</B> <A STYLE="color:black" HREF="enumdevices.htm">Enumerating Devices: The RMEnum Sample</A>
<IMG SRC="../art/yelbtn.gif" WIDTH="11" HEIGHT="11" ALIGN="MIDDLE" BORDER=0 ALT="*"><B>Next Topic:</B> <A  STYLE="color:black" HREF="Architecture.htm">Direct3D Retained Mode Architecture</A>
</PRE></TD></TR></TABLE>
<!-- NAV_LINKS_END -->

<BLOCKQUOTE CLASS="body">

<!-- CONTENTS_START -->

<H1><A NAME="dx5_A_Technical_Foundation_for_3D_Programming_d3drm" IDX_CONCEPT="3-D Graphics Concepts; Graphics Concepts, 3-D"></A>Technical Background</H1>

<P>The following topics describe some of the technical concepts you need to understand before you write programs that incorporate 3-D graphics. In these sections, you will find a general discussion of coordinate systems and transformations. This is not a discussion of broad architectural details, such as setting up models, lights, and viewing parameters. For more information about these topics, see <A HREF="Architecture.htm#rmobject_Introduction_D3DRM">Direct3D Retained Mode Architecture</A>.

<P>If you are already experienced in producing 3-D graphics, simply scan the following topics for information that is unique to Microsoft&#174; Direct3D&#174; Retained Mode: 
<BLOCKQUOTE>
<UL><LI><A HREF="TechBackgrnd.htm#sec_3D_Coordinate_Systems">3-D Coordinate Systems</A>
<LI><A HREF="TechBackgrnd.htm#rmmath_3D_Transformati">3-D Transformations</A> 
<LI><A HREF="TechBackgrnd.htm#id_Polygons">Polygons</A>
<LI><A HREF="TechBackgrnd.htm#id_tristrips">Triangle Strips and Fans</A> 
<LI><A HREF="TechBackgrnd.htm#rmmath_Vectors_and">Vectors, Vertices, and Quaternions</A> 
<LI><A HREF="TechBackgrnd.htm#rmmath_Floating_point">Floating-Point Precision</A> 
<LI><A HREF="TechBackgrnd.htm#Z_Buffers">Z-Buffers and Overlays</A> 
</UL>
</BLOCKQUOTE>
<H2><A NAME="sec_3D_Coordinate_Systems" IDX_CONCEPT="Coordinate Systems, 3-D">3-D Coordinate Systems</A></H2>
<P>There are two varieties of Cartesian coordinate systems in 3-D graphics: left-handed and right-handed. In both coordinate systems, the positive x-axis points to the right and the positive y-axis points up. You can remember which direction the positive z-axis points by pointing the fingers of either your left or right hand in the positive x-direction and curling them into the positive y-direction. The direction your thumb points, either toward or away from you, is the direction the positive z-axis points for that coordinate system.

<P>This section describes the Direct3D coordinate system and coordinate types that your application can use.
<BLOCKQUOTE>
<UL><LI><A HREF="TechBackgrnd.htm#rmmath_Direct3D_Coor">Direct3D Coordinate System</A>
<LI><A HREF="TechBackgrnd.htm#rmmath_U-_and_V-Coordi">U- and V-Coordinates</A>
</UL>
</BLOCKQUOTE>

<H3><A NAME="rmmath_Direct3D_Coor" IDX_CONCEPT="Right-Handed Geometry; Left-Handed Geometry">Direct3D Coordinate System</A></H3>
<P>Direct3D uses the left-handed coordinate system by default. This means the positive z-axis points away from the viewer, as shown in the following illustration:

<P><IMG SRC="../art/coords.gif" WIDTH="243" HEIGHT="102" ALT="Direct3D coordinate system">

<P>In a left-handed coordinate system, rotations occur clockwise around any axis that is pointed at the viewer.

<P>If you need to work in a right-handed coordinate system&#151;for example, if you are porting an application that relies on right-handedness&#151;you can do so by making two simple changes to the data passed to Direct3D.

<p><b>Note:</b> Beginning with DirectX version 6.0, you can use <a href="../ref/idirect3drm3.htm#setoptions">IDirect3DRM3::SetOptions</a> to instruct Direct3D Retained Mode to use a right-handed coordinate system. If you use <b>IDirect3DRM3::SetOptions</b>, changing data is not necessary.

<BLOCKQUOTE>
<p>Versions of DirectX prior to version 6.0 require the following changes to the data passed to Direct3D Retained Mode to use right-handed coordinates.
<UL><LI>Flip the order of triangle vertices so that the system traverses them clockwise from the front. In other words, if the vertices are v0, v1, v2, pass them to Direct3D as v0, v2, v1. 
<LI>Scale the projection matrix by &#150;1 in the z-direction. To do this, flip the signs of the _13, _23, _33, and _43 members of the <A HREF="../ref/FurtherReading.htm#D3DMATRIX">D3DMATRIX</A> structure. 
</UL>
</BLOCKQUOTE>

<H3><A NAME="rmmath_U-_and_V-Coordi">U- and V-Coordinates</A></H3>
<P>Direct3D also uses <I>texture coordinates</I>. These coordinates (u and v) are used when mapping textures onto an object. The v-vector describes the direction or orientation of the texture and lies along the z-axis. The u-vector (or the <I>up</I> vector) typically lies along the y-axis, with its origin at [0,0,0]. For more information about u- and v-coordinates, see <A HREF="Wraps_face.htm#rmobject_IDirect3DRMWrap_Int">Wraps</A>.

<H2><A NAME="rmmath_3D_Transformati">3-D Transformations</A></H2>
<P>In programs that work with 3-D graphics, you can use geometrical transformations to:
<BLOCKQUOTE>
<UL><LI>Express the location of an object relative to another object.
<LI>Rotate, shear, and size objects.
<LI>Change viewing positions, directions, and perspective.
</UL>
</BLOCKQUOTE>
<P>You can transform any point into another point by using a 4&#215;4 matrix. In the following example, a matrix is used to reinterpret the point (x, y, z), producing the new point (x<SUP>'</SUP>, y<SUP>'</SUP>, z<SUP>'</SUP>):

<P><IMG SRC="../art/matmult.gif" WIDTH="280" HEIGHT="74" ALT="Transformation of a point with a 4&#215;4 matrix">

<P>You perform the following operations on (x, y, z) and the matrix to produce the point (x<SUP>'</SUP>, y<SUP>'</SUP>, z<SUP>'</SUP>):
<P><IMG SRC="../art/matexpnd.gif" WIDTH="342" HEIGHT="51" ALT="Operations within the matrix transformation">




<P>The most common transformations are translation, rotation, and scaling. You can combine the matrices that produce these effects into a single matrix to calculate several transformations at once. For example, you can build a single matrix to translate and rotate a series of points.

<P>Matrices are specified in row order. For example, the following matrix could be represented by an array:
<P><IMG SRC="../art/matrix.gif" WIDTH="72" HEIGHT="70" ALT="Sample matrix that is represented by the array below">
<P>The array for this matrix would look like the following:
<PRE>D3DMATRIX scale = {
    D3DVAL(s),    0,            0,            0,
    0,            D3DVAL(s),    D3DVAL(t),    0,
    0,            0,            D3DVAL(s),    D3DVAL(v),
    0,            0,            0,            D3DVAL(1)
};</PRE>
<P>This section describes the 3-D transformations available to your applications through Direct3D.
<BLOCKQUOTE>
<UL><LI><A HREF="TechBackgrnd.htm#rmmath_Translation">Translation</A>
<LI><A HREF="TechBackgrnd.htm#rmmath_Rotation">Rotation</A>
<LI><A HREF="TechBackgrnd.htm#rmmath_Scaling">Scaling</A>
</UL>
</BLOCKQUOTE>
<P>Other parts of this documentation also discuss transformations. You can find a general discussion of transformations in the section devoted to viewports in Retained Mode, <A HREF="Viewports_face.htm#rmobject_Transformations">Transformations</A>. For a discussion of transformations in frames, see <A HREF="Frames_face.htm#sec_Transformations">Transformations</A>. Although each of these sections discusses Retained Mode API, the architecture and mathematics of the transformations apply to both Retained Mode and Immediate Mode. 


<H3><A NAME="rmmath_Translation">Translation</A></H3>
<P>The following transformation translates the point (x, y, z) to a new point (x<SUP>'</SUP>, y<SUP>'</SUP>, z<SUP>'</SUP>):

<P><IMG SRC="../art/mattrans.gif" WIDTH="208" HEIGHT="72" ALT="Matrix that translates a point">


<H3><A NAME="rmmath_Rotation">Rotation</A></H3>
<P>The transformations described in this section are for left-handed coordinate systems, and so they may be different from transformation matrices you have seen elsewhere.
<P>The following transformation rotates the point (x, y, z) around the x-axis, producing a new point (x<SUP>'</SUP>, y<SUP>'</SUP>, z<SUP>'</SUP>):

<P><IMG SRC="../art/matxrot.gif" WIDTH="257" HEIGHT="70" ALT="Matrix that rotates a point around the x-axis">

<P>The following transformation rotates the point around the y-axis:

<P><IMG SRC="../art/matyrot.gif" WIDTH="256" HEIGHT="68" ALT="Matrix that rotates a point around the y-axis">

<P>The following transformation rotates the point around the z-axis:

<P><IMG SRC="../art/matzrot.gif" WIDTH="277" HEIGHT="68" ALT="Matrix that rotates a point around the z-axis">

<P>Note that in these example matrices, the Greek letter theta stands for the angle of rotation, specified in radians. Angles are measured clockwise when looking along the rotation axis toward the origin.


<H3><A NAME="rmmath_Scaling">Scaling</A></H3>
<P>The following transformation scales the point (x, y, z) by arbitrary values in the x-, y-, and z-directions to a new point (x<SUP>'</SUP>, y<SUP>'</SUP>, z<SUP>'</SUP>):

<P><IMG SRC="../art/matscale.gif" WIDTH="206" HEIGHT="69" ALT="Matrix that scales a point">


<H2><A NAME="id_Polygons">Polygons</A></H2>
<P>Three-dimensional objects in Direct3D are made up of meshes. A mesh is a set of faces, each of which is described by a simple polygon. The fundamental polygon type is the triangle. Although Retained Mode applications can specify polygons with more than three vertices, the system translates these into triangles before the objects are rendered. Immediate Mode applications must use triangles.

<P>This section describes how your applications can use Direct3D polygons.
<BLOCKQUOTE>
<UL><LI><A HREF="TechBackgrnd.htm#rmmath_Geometry_Requir">Geometry Requirements</A>
<LI><A HREF="TechBackgrnd.htm#rmmath_Face_and_Vertex">Face and Vertex Normals</A>
<LI><A HREF="TechBackgrnd.htm#rmmath_Shade_Modes">Shade Modes</A>
<LI><A HREF="TechBackgrnd.htm#rmmath_Triangle_Interp">Interpolated Triangle Characteristics</A>
</UL>
</BLOCKQUOTE>
<H3><A NAME="rmmath_Geometry_Requir">Geometry Requirements</A></H3>
<P>Triangles are the preferred polygon type because they are always convex, and they are always planar&#151;two conditions that are required of polygons by the renderer. A polygon is convex if a line drawn between any two points of the polygon is also inside the polygon.
<P><IMG SRC="../art/cavevex.gif" WIDTH="171" HEIGHT="93" ALT="Diagram of concave and convex polygons">
<P>The three vertices of a triangle always describe a plane, but it is easy to accidentally create a nonplanar polygon by adding another vertex.
<P><IMG SRC="../art/noplanar.gif" WIDTH="304" HEIGHT="107" ALT="Diagram of nonplanar polygon">




<H3><A NAME="rmmath_Face_and_Vertex">Face and Vertex Normals</A></H3>
<P>Each face in a mesh has a perpendicular face <I><A CLASS="Glossary" HREF="javascript:Glossary(sRelPath + 'gloss/gloss_n.htm#normal_vector')">normal vector</A></I> whose direction is determined by the order in which the vertices are defined and by whether the coordinate system is right- or left-handed. If the normal vector of a face is oriented toward the viewer, that side of the face is its front. In Direct3D, only the front side of a face is visible, and a front face is one in which vertices are defined in clockwise order.
<P><IMG SRC="../art/nrmlvect.gif" WIDTH="436" HEIGHT="157" ALT="Diagram of a polygon face's vertices and normal vector">
<P>Direct3D applications do not need to specify face normals; the system calculates them automatically when they are needed. The system uses face normals in the flat shade mode. For Phong and Gouraud shade modes, and for controlling lighting and texturing effects, the system uses vertex normals.

<P><IMG SRC="../art/vertnrml.gif" WIDTH="254" HEIGHT="155" ALT="Diagram of vertex normals and face normals">





<H3><A NAME="rmmath_Shade_Modes">Shade Modes</A></H3>
<P>In the flat shade mode, the system duplicates the color of one vertex across all the other faces of the primitive. In the Gouraud and Phong shade modes, vertex normals are used to give a smooth look to a polygonal object. In Gouraud shading, the color and intensity of adjacent vertices is interpolated across the space that separates them. In Phong shading, the system calculates the appropriate shade value for each pixel on a face. 
<P><B>Note</B>  Phong shading is not currently supported.
<P>Most applications use Gouraud shading because it allows objects to appear smooth and is computationally efficient. However, Gouraud shading can miss details that Phong shading will not. For example, Gouraud and Phong shading would produce very different results as shown by the following illustration, in which a <A CLASS="Glossary" HREF="javascript:Glossary(sRelPath + 'gloss/gloss_s.htm#spotlight')">spotlight</A> is completely contained within a face.
<P><IMG SRC="../art/gouraud.gif" WIDTH="258" HEIGHT="107" ALT="Diagram of a spotlight on a face for comparison of Gouraud and Phong shading">
<P>In this case, the Phong shade mode would calculate the value for each pixel and display the spotlight. The Gouraud shade mode, which interpolates between vertices, would miss the spotlight altogether; the face would be rendered as though the spotlight did not exist.
<P>In the flat shade mode, the following pyramid would be displayed with a sharp edge between adjoining faces; the system would generate automatic face normals. In the Gouraud or Phong shade modes, however, shading values would be interpolated across the edge, and the final appearance would be of a curved surface.
<P><IMG SRC="../art/shade2.gif" WIDTH="269" HEIGHT="174" ALT="A pyramid in the flat shade mode">
<P>If you want to use the Gouraud or Phong shade mode to display curved surfaces, and you also want to include some objects with sharp edges, your application would need to duplicate the vertex normals at any intersection of faces where a sharp edge was required, as shown in the following illustration.
<P><IMG SRC="../art/shade1.gif" WIDTH="242" HEIGHT="164" ALT="Vertex normals needed to retain sharp edge in shading other than flat">
<P>In addition to allowing a single object to have both curved and flat surfaces, the Gouraud shade mode lights flat surfaces more realistically than the flat shade mode. A face in the flat shade mode is a uniform color, but Gouraud shading allows light to fall across a face correctly. This effect is particularly obvious if there is a nearby point source. Gouraud shading is the preferred shade mode for most Direct3D applications.

<H3><A NAME="rmmath_Triangle_Interp" IDX_CONCEPT="Triangle, Interpolated Characteristics">Interpolated Triangle Characteristics</A></H3>
<P>The system interpolates the characteristics of a triangle's vertices across the triangle when it renders a face. The following triangle characteristics are interpolated:
<BLOCKQUOTE>
<UL><LI>Color
<LI>Specular
<LI>Fog
<LI>Alpha
</UL>
</BLOCKQUOTE>
<P>All of the triangle's interpolated characteristics are modified by the current shade mode:
<P>
<TABLE CLASS="main" BORDER=0>
<TR><TD ALIGN=LEFT VALIGN=TOP>Flat
 </TD><TD ALIGN=LEFT VALIGN=TOP>No interpolation is done. Instead, the color of the first vertex in the triangle is applied across the entire face.
</TD></TR><TR><TD ALIGN=LEFT VALIGN=TOP>Gouraud
 </TD><TD ALIGN=LEFT VALIGN=TOP>Linear interpolation is performed between all three vertices.
</TD></TR><TR><TD ALIGN=LEFT VALIGN=TOP>Phong
 </TD><TD ALIGN=LEFT VALIGN=TOP>Vertex parameters are re-evaluated for each pixel in the face, using the current lighting. The Phong shade mode is not currently supported.
</TD></TR></TABLE>
<P>The interpolated color and specular characteristics are treated differently, depending on the color model. In the RGB color model (<A HREF="../ref/FurtherReading.htm#D3DCOLOR_RGB">D3DCOLOR_RGB</A>), the system uses the red, green, and blue color components in the interpolation. In the monochromatic model (<A HREF="../ref/FurtherReading.htm#D3DCOLOR_MONO">D3DCOLOR_MONO</A>), the system uses only the blue component of the vertex color.
<P>For example, if the red component of the color of vertex 1 were 0.8 and the red component of vertex 2 were 0.4, in the Gouraud shade mode and RGB color model the system would use interpolation to assign a red component of 0.6 to the pixel at the midpoint of the line between these vertices.
<P>The alpha component of a color is treated as a separate interpolated characteristic because device drivers can implement transparency in two different ways: by using <A CLASS="Glossary" HREF="javascript:Glossary(sRelPath + 'gloss/gloss_t.htm#texture_blending')">texture blending</A> or by using stippling.
<P>An application can use the <B>dwShadeCaps</B> member of the <A HREF="../ref/FurtherReading.htm#D3DPRIMCAPS">D3DPRIMCAPS</A> structure to determine what forms of interpolation the current device driver supports.

<H2><A NAME="dx5_Triangle_Strips_and_Fans_d3drm"></A><A NAME="id_tristrips">Triangle Strips and Fans</A></H2>
<P>You can use triangle strips and triangle fans to specify an entire surface without having to provide all three vertices for each of the triangles. For example, only seven vertices are required to define the following triangle strip.
<P><IMG SRC="../art/tristrip.gif" WIDTH="269" HEIGHT="141" ALT="Sample triangle strip and its vertices">
<P>The system uses vertices v1, v2, and v3 to draw the first triangle; v2, v4, and v3 to draw the second triangle; v3, v4, and v5 to draw the third; v4, v6, and v5 to draw the fourth; and so on. Notice that the vertices of the second and fourth triangles are out of order. This is required to make sure that all of the triangles are drawn in a clockwise orientation. 

<P>A triangle fan is similar to a triangle strip, except that all of the triangles share one vertex.
<P><IMG SRC="../art/trifan.gif" WIDTH="209" HEIGHT="249" ALT="Diagram of a triangle fan">
<P>The system uses vertices v1, v2, and v3 to draw the first triangle; v3, v4, and v1 to draw the second triangle; v1, v4, and v5 to draw the third triangle; and so on. 
<P>You can use the <B>wFlags</B> member of the <A HREF="../ref/FurtherReading.htm#D3DTRIANGLE">D3DTRIANGLE</A> structure to specify the flags that build triangle strips and fans.



<H2><A NAME="rmmath_Vectors_and">Vectors, Vertices, and Quaternions</A></H2>
<P>Throughout Direct3D, vertices describe position and orientation. Each vertex in a primitive is described by a vector that gives its position, a <A CLASS="Glossary" HREF="javascript:Glossary(sRelPath + 'gloss/gloss_N.htm#normal_vector')">normal vector</A> that gives its orientation, texture coordinates, and a color. (In Retained Mode, the <A HREF="../ref/Structs.htm#D3DRMVERTEX">D3DRMVERTEX</A> structure contains these values.) 

<P>Quaternions add a fourth element to the [<I>x, y, z</I>] values that define a vector. Quaternions are an alternative to the matrix methods that are typically used for 3-D rotations. A quaternion represents an axis in 3-D space and a rotation around that axis. For example, a quaternion could represent a (1,1,2) axis and a rotation of 1 radian. Quaternions carry valuable information, but their true power comes from the two operations that you can perform on them: <I>composition</I> and <I>interpolation</I>.

<P>Performing composition on quaternions is similar to combining them. The composition of two quaternions is notated as follows:

<P><IMG SRC="../art/quateq.gif" WIDTH="75" HEIGHT="27" ALT="Equation showing composition of two quaternions">

<P>The composition of two quaternions applied to a geometry means "rotate the geometry around axis<SUB>2</SUB> by rotation<SUB>2</SUB>, then rotate it around axis<SUB>1</SUB> by rotation<SUB>1</SUB>." In this case, Q represents a rotation around a single axis that is the result of applying q<SUB>2</SUB>, then q<SUB>1</SUB> to the geometry.

<P>Using quaternion interpolation, an application can calculate a smooth and reasonable path from one axis and orientation to another. Therefore, interpolation between q<SUB>1</SUB> and q<SUB>2</SUB> provides a simple way to animate from one orientation to another.

<P>When you use composition and interpolation together, they provide you with a simple way to manipulate a geometry in a manner that appears complex. For example, imagine that you have a geometry that you want to rotate to a given orientation. You know that you want to rotate it r<SUB>2</SUB> degrees around axis<SUB>2</SUB>, then rotate it r<SUB>1</SUB> degrees around axis<SUB>1</SUB>, but you don't know the final quaternion. By using composition, you could combine the two rotations on the geometry to get a single quaternion that is the result. Then, you could interpolate from the original to the composed quaternion to achieve a smooth transition from one to the other.

<P>Direct3D Retained Mode includes some functions that help you work with quaternions. For example, the <A HREF="../ref/Functions.htm#D3DRMQuaternionFromRotation">D3DRMQuaternionFromRotation</A> function adds a rotation value to a vector that defines an axis of rotation, and returns the result in a quaternion defined by a <A HREF="../ref/Structs.htm#D3DRMQUATERNION">D3DRMQUATERNION</A> structure. Additionally, the <A HREF="../ref/Functions.htm#D3DRMQuaternionMultiply">D3DRMQuaternionMultiply</A> function composes quaternions and the <A HREF="../ref/Functions.htm#D3DRMQuaternionSlerp">D3DRMQuaternionSlerp</A> performs spherical linear interpolation between two quaternions.

<P>Retained Mode applications can use the following functions to simplify the task of working with vectors and quaternions:

<BLOCKQUOTE>
<UL><LI><A HREF="../ref/Functions.htm#D3DRMQuaternionFromRotation">D3DRMQuaternionFromRotation</A>
<LI><A HREF="../ref/Functions.htm#D3DRMQuaternionMultiply">D3DRMQuaternionMultiply</A>
<LI><A HREF="../ref/Functions.htm#D3DRMQuaternionSlerp">D3DRMQuaternionSlerp</A>
<LI><A HREF="../ref/Functions.htm#D3DRMVectorAdd">D3DRMVectorAdd</A>
<LI><A HREF="../ref/Functions.htm#D3DRMVectorCrossProduct">D3DRMVectorCrossProduct</A>
<LI><A HREF="../ref/Functions.htm#D3DRMVectorDotProduct">D3DRMVectorDotProduct</A>
<LI><A HREF="../ref/Functions.htm#D3DRMVectorModulus">D3DRMVectorModulus</A>
<LI><A HREF="../ref/Functions.htm#D3DRMVectorNormalize">D3DRMVectorNormalize</A>
<LI><A HREF="../ref/Functions.htm#D3DRMVectorRandom">D3DRMVectorRandom</A>
<LI><A HREF="../ref/Functions.htm#D3DRMVectorReflect">D3DRMVectorReflect</A>
<LI><A HREF="../ref/Functions.htm#D3DRMVectorRotate">D3DRMVectorRotate</A>
<LI><A HREF="../ref/Functions.htm#D3DRMVectorScale">D3DRMVectorScale</A>
<LI><A HREF="../ref/Functions.htm#D3DRMVectorSubtract">D3DRMVectorSubtract</A>
</UL>
</BLOCKQUOTE>
<H2><A NAME="rmmath_Floating_point">Floating-Point Precision</A></H2>
<P>Direct3D, like the rest of the DirectX architecture, uses a floating-point precision of 53 bits. The precision is set in the floating-point control word registry in the floating-point unit (FPU). If your application needs to change this precision for certain calculations, the application must change the precision back to 53 when the calculations are finished. Otherwise, system components that depend on the default value will stop working.

<H2><A NAME="Z_Buffers">Z-Buffers and Overlays</A></H2>
<P>The order in the z-buffer determines the order in which overlays clip each other. Overlays are assumed to be on top of all other screen components. Overlays that do not have a specified z-order behave in unpredictable ways when overlaying the same area on the primary surface. Direct3D Retained Mode does not sort overlays if you do not have a z-buffer. Overlays without a specified z-order are assumed to have a z-order of 0, and will appear in the order they are rendered. The possible z-order of overlays ranges from 0, which is just on top of the primary surface, to 4 billion, which is as close to the viewer as possible. An overlay with a z-order of 2 would obscure an overlay with a z-order of 1. No two overlays can have the same z-order. 


<!-- CONTENTS_END -->

<!-- START_PAGE_FOOTER -->


<H5><HR size=1></H5>
<P><A class="line" HREF="#pagetop"><IMG src="../art/arrowup1.gif" WIDTH="11" HEIGHT="11" ALIGN="MIDDLE" BORDER=0 ALT="Top of Page">&nbsp;Top of Page</A>
<BR><A Class="line" HREF="../../cpyright.htm">&#169; 1998 Microsoft Corporation. All rights reserved. Terms of Use.</A>
<!-- END_PAGE_FOOTER -->

</BLOCKQUOTE>

<SCRIPT LANGUAGE="JAVASCRIPT">if((g_isIE == true) && (g_iMaj > 3)) {window.self.document.writeln('<SCR' + 'IPT SRC="../tip2.js"></SCR' + 'IPT><IFRAME ID="G_L_S" NAME="SecretBuffer" STYLE="display: none" SRC=""></IFRAME>')}</SCRIPT>

<!-- DACONTROL_START -->

	<DIV ID="HeadGraphAnim"></DIV>
	<SCRIPT LANGUAGE="JAVASCRIPT">if((g_isIE == true) && (g_iMaj > 3)) {window.self.document.writeln('<SCR' + 'IPT SRC="../anim.js"></SCR' + 'IPT>')}</SCRIPT>
<!-- DACONTROL_END -->

</BODY>
</HTML>
