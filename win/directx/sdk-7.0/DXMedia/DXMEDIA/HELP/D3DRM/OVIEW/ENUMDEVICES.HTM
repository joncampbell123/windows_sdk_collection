<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<HTML>
<HEAD><TITLE>Enumerating Devices: The RMEnum Sample</TITLE>
<SCRIPT LANGUAGE="JAVASCRIPT"> var sRelPath = '../' </SCRIPT>


<META NAME="Description" CONTENT="Enumerating Devices: The RMEnum Sample">
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; CHARSET=iso8859-1">
<META NAME="MS.LOCALE" CONTENT="EN-US">
<META NAME="ROBOTS" CONTENT="all">

<!-- SNIFF_START -->

<SCRIPT LANGUAGE="JAVASCRIPT">
//<!--
var g_isIE = false, g_isNav = false, g_iMaj = 0, g_sPlat = "";
// -->

</SCRIPT>
<SCRIPT SRC="../ver.js"></SCRIPT>
<SCRIPT SRC="../gloss.js"></SCRIPT>


<SCRIPT DEFER SRC="../common.js"></SCRIPT>
<SCRIPT DEFER>
//<!--
function InitPage()
{
	if (g_isIE && g_iMaj >= 4)	
	{

		SetTOC();
	}
}
//-->

</SCRIPT>

<!-- SNIFF_END -->


<!-- STYLE_START -->

<SCRIPT LANGUAGE="JAVASCRIPT">
//<!--
   var sVR = '../'	// Set root for the style sheet
   var sCSS = '<LINK REL="stylesheet" HREF="' + sVR;

   if(g_isIE)
   {
	   if (g_iMaj >= 4) // For MSIE 4.0 or later
	   {
		   sCSS += 'dxm_basicSDKIE4';
		   if (g_sPlat == "Win") // Windows only for now
		   {
			   document.createStyleSheet(sVR + 'dxm_advSDKIE4.css');
		   }
	   }
	   else // For MSIE 3.0 or earlier
	   {
		   sCSS += 'dxm_basicSDKIE3';
	   }
   }
   else if (g_isNav) // For all Nav versions
   {
	   sCSS += 'dxm_basicSDKNAV';
   }
   else
   {
	   sCSS += 'dxm_basicSDKIE3'; // default to IE3 sheet
   }

   sCSS += (sCSS == '' ? '' : '.css" TYPE="text/css">');

   document.write(sCSS);
//-->

</SCRIPT>
<!-- STYLE_END -->


</HEAD>
<BODY onload="InitPage(); if (g_isIE && g_iMaj >= 4){HdgrphControl()}" BGCOLOR="#FFFFFF">
<A NAME="pagetop"></A>

<!-- HEADGRAPH_START -->

<TABLE CLASS="main" BORDER=0 CELLSPACING="0" CELLPADDING="0" WIDTH="*">
<TR>
<TD ROWSPAN="3" VALIGN="TOP" WIDTH="*">
<IMG SRC="../art/header1.gif" WIDTH="107" HEIGHT="110" BORDER=0 ALT="Direct3D Retained Mode Animated Header --Enumerating Devices -- The RMEnum Sample"></TD>
<TD ROWSPAN="2" VALIGN="TOP" WIDTH="217">
<IMG SRC="../art/HDRd3drm.gif" WIDTH="217" HEIGHT="110" BORDER=0 ALT="Direct3D Retained Mode Animated Header --Enumerating Devices -- The RMEnum Sample"></TD><TD VALIGN="TOP" WIDTH="383">
<IMG SRC="../art/header3.gif" WIDTH="383" HEIGHT="95" BORDER=0 ALT="Direct3D Retained Mode Animated Header">
</TD>
<TD VALIGN="TOP" WIDTH="100%">
<IMG SRC="../art/spacer1.gif" WIDTH="100%" HEIGHT="94" BORDER=0 ALT="Microsoft Direct3D Retained Mode SDK"></TD></TR>
<!-- HEADGRAPH_END -->

<!-- NAV_LINKS_START -->

<TR><TD VALIGN="TOP"><PRE><IMG ID="TOC_" SRC="../art/yelbtn.gif" WIDTH="11" HEIGHT="11" ALIGN="MIDDLE" BORDER=0 ALT="*"><A STYLE="color:black;font-weight:bold" ID="TOC" HREF="../contents.htm">Contents</A>  <IMG SRC="../art/yelbtn.gif" WIDTH="11" HEIGHT="11" ALIGN="MIDDLE" BORDER=0 ALT="*"><A STYLE="color:black;font-weight:bold" HREF="../index.htm">Index</A>  <IMG SRC="../art/yelbtn.gif" WIDTH="11" HEIGHT="11" ALIGN="MIDDLE" BORDER=0 ALT="*"><A STYLE="color:black;font-weight:bold" href="gettingstarted_intro.htm">Topic Contents</A>
</PRE></TD></TR>
<TR><TD COLSPAN="2" VALIGN="TOP"><PRE><IMG SRC="../art/yelbtn.gif" WIDTH="11" HEIGHT="11" ALIGN="MIDDLE" BORDER=0 ALT="*"><B>Previous Topic:</B> <A STYLE="color:black" href="framehierarchy.htm">Frame Hierarchies: The RMBegin2 Sample</a>
<IMG SRC="../art/yelbtn.gif" WIDTH="11" HEIGHT="11" ALIGN="MIDDLE" BORDER=0 ALT="*"><B>Next Topic:</B> <A  STYLE="color:black" href="TechBackgrnd.htm">Technical Background</a>
</PRE></TD></TR></TABLE>
<!-- NAV_LINKS_END -->

<BLOCKQUOTE CLASS="body">

<!-- CONTENTS_START -->


<H1><a name="enumerating_devices" IDX_CONCEPT="RMEnum Sample Walkthrough; Enumerating Devices: The RMEnum Sample">Enumerating Devices: The RMEnum Sample</a></H1>
<P>Device enumeration is one of the fundamental concepts in Microsoft&reg; Direct3D&reg; Retained Mode. You can create a default device without device enumeration
, but enumerating devices provides more flexibility for your application. 




 It enables you to identify the devices present on a given system, and to choose the device that is most appropriate for your needs and can offer more advanced capabilities.

<p>This article walks you through code from the RMEnum sample. RMEnum enumerates the hardware and software devices on the system, makes an intelligent choice about which device to use, and creates the device. It adds the enumerated devices to the application's File menu and enables the user to switch between devices by choosing devices from the menu. Unlike a real-world Direct3D Retained Mode application, RMEnum does not display any three-dimensional (3-D) objects or render any graphics. It focuses on enumeration for the sake of simplicity and clarity.

<p>This article assumes you are an experienced C or C++ programmer and are familiar with beginning Windows programming concepts, such as the message loop, creating a window, and using menus. 

<p>This article contains the following sections.

<ul>
<li><a href="#Dependencies">Dependencies</a>
<li><a href="#Global Declarations">Global Declarations</a>
<li><a href="#Function Summaries">Function Summaries</a>
<li><a href="#Related_Topics">Related Topics</a>
</ul>



<h2><a name="Dependencies" IDX_CONCEPT="noindex">Dependencies</a></h2>
<p>RMEnum links to DDraw.lib and D3DRM.lib. It uses the <B>Msg</B> and <B>D3DRMErrorToString</B> helper functions from Error.c to provide detailed information in case of errors. By default, Error.c resides in the Samples\Misc directory of the Microsoft&reg; DirectX&reg; Software Development Kit (SDK). RMEnum could just as easily use the standard Microsoft&reg; Windows&reg; <b>MessageBox</b> function instead of using these helper functions, but the error reporting would not be as clean or detailed. The sample also links to the menus and other resources provided by RMEnum.rc.

<p>To properly initialize globally unique identifiers (GUIDs), Direct3D




applications must contain




the following definition at the top of their code.

<pre>
#define INITGUID
</pre>

<p>The sample's RMEnum.cpp file includes the following header files.


<PRE>
#include &lt;windows.h>   /* Standard Windows header file */
#include &lt;direct.h>    /* DirectDraw definitions */
#include &lt;d3drmwin.h>  /* D3DRM definitions */
#include "RMEnum.h"    /* Defines constants used in RMEnum.rc */
#include "rmerror.h"   /* Prototypes for error reporting functions in
                             rmerror.c */
</PRE>




<h2><a name="Global Declarations" IDX_CONCEPT="noindex">Global Declarations</a></h2>
<p>The sample defines some constants and global variables to help organize information.

<p>For simplicity, RMEnum.cpp sets an arbitrary limit on the number of drivers it will enumerate. You could enumerate drivers once to count how many are available, and enumerate again to examine each driver's capabilities as this sample does. A real-world same could also maintain a linked list of driver information rather than a fixed size array as RMEnum does.
<pre>
#define MAX_DRIVERS 5  /* Arbitrary limit for the maximum number of  
                            Direct3D drivers expected to be found */
</pre>




<p>The application-defined RELEASE macro releases an object only if the object is not NULL and ensures that an object is initialized to NULL after it has been released. This practice eliminates the problem of trying to release an object that has already been released, which can, in turn, cause undesired results, such as page faults.

<pre>
/* Macro to release an object. */
#define RELEASE(x) if (x != NULL) {x->Release(); x = NULL;} 
</pre>

<p>The myglobs structure collects device and driver information, as well as information about the current application state. The Direct3D Retained Mode and DirectDrawClipper objects are also global (the DirectDrawClipper object restricts drawing to a designated area).
<pre>
/* 
 * GLOBAL VARIABLES
 */
LPDIRECT3DRM lpD3DRM = NULL;            /* Direct3DRM object */
LPDIRECTDRAWCLIPPER lpDDClipper = NULL; /* DirectDrawClipper object */

struct _myglobs {
    /* Direct3DRM device */
    LPDIRECT3DRMDEVICE dev;           

    /* GUIDs of the available Direct3D (D3D) drivers */
    GUID DriverGUID[MAX_DRIVERS];     

    /* names of the available D3D drivers */
    char DriverName[MAX_DRIVERS][50]; 

    /* counter indicating the number of available D3D drivers */
    int  NumDrivers;                  

    /* number of the D3D driver currently being used; set to
     * the preferred driver by enumDeviceFunc */
    int  CurrDriver;                  

    /* program is about to terminate */
    BOOL bQuit;                 

    /* all D3DRM objects have been initialized */
    BOOL bInitialized;          
    
    /* bit depth of the current display mode */
    DWORD BPP;                  
} myglobs;
</pre>




<h2><a name="Function Summaries" IDX_CONCEPT="noindex">Function Summaries</a></h2>

<p>RMEnum.cpp contains the following functions.

<p><a href="#CreateObjects">CreateObjects</a> is the master function that initializes the global variables, uses <a href="#EnumDevices">EnumDevices</a> to enumerate the devices, and creates objects. <b>InitApp</b> uses <b>CreateObjects</b>.
<pre>
BOOL <b>CreateObjects</b>(HWND win);
</pre>

<p><a href="#GetCurrentBitDepth">GetCurrentBitDepth</a> returns the current bit depth to <b>CreateObjects</b>.
<pre>
static DWORD <b>GetCurrentBitDepth</b>(HWND);
</pre>

<p><a href="#EnumDevices">EnumDevices</a> obtains the Direct3D object to use for device enumeration, uses the Immediate Mode <b>IDirect3D2::EnumDevices</b> function, passing the <a href="#enumDeviceFunc">enumDeviceFunc</a> callback function as a parameter, and places the enumerated devices on the File menu. 
<pre>
static BOOL <b>EnumDevices</b>(HWND);
</pre>

<p>The <a href="#enumDeviceFunc">enumDeviceFunc</a> callback function cycles through the available drivers, chooses the usable drivers, and selects a preferred driver.
<pre>
static HRESULT WINAPI <b>enumDeviceFunc</b>(LPGUID,
                                            LPSTR,
                                            LPSTR,
                                            LPD3DDEVICEDESC, 
                                            LPD3DDEVICEDESC,
                                            LPVOID);
</pre>

<p>RMEnum uses <a href="#ChangeDriver">ChangeDriver</a> in response to the user's menu choice
that switches to a differenct available driver.




<pre>
void <b>ChangeDriver</b>(HWND, WPARAM);
</pre>

<p><a href="#CleanUpAndQuit">CleanUpAndQuit</a> releases objects in preparation for application termination.
<pre>
static void <b>CleanUpAndQuit</b>(void);
</pre>

<p>The remaining functions (<a href="#WindowsFunctions">InitApp</a>, <a href="#WindowsFunctions">WinMain</a>, <a href="#WindowsFunctions">AppAbout</a>, and <a href="#WindowsFunctions">WindowProc</a>) are primarily based on the standard Windows functions and contain little code specific to the RMEnum sample.
<pre>
static HWND InitApp(HINSTANCE, int);
int APIENTRY WinMain (HINSTANCE, HINSTANCE, LPSTR, int);
LRESULT CALLBACK AppAbout(HWND, UINT, WPARAM, LPARAM);
LRESULT CALLBACK WindowProc(HWND, UINT, WPARAM, LPARAM);
</pre>

<p>For more information about these functions, see the following topics in this article.
    <ul>
    <li><a href="#CreateObjects">CreateObjects</a>
    <li><a href="#GetCurrentBitDepth">GetCurrentBitDepth</a>
    <li><a href="#EnumDevices">EnumDevices</a>
    <li><a href="#enumDeviceFunc">enumDeviceFunc</a>
    <li><a href="#ChangeDriver">ChangeDriver</a>
    <li><a href="#CleanUpAndQuit">CleanUpAndQuit</a>
    <li><a href="#WindowsFunctions">Standard Windows Functions</a>
    </ul>




<h3><a name="CreateObjects" IDX_CONCEPT="noindex">CreateObjects</a></h3>
<p><b>CreateObjects</b> provides and uses the core code in the RMEnum sample. After initializing global variables and obtaining the current bit depth, it uses <a href="#EnumDevices">EnumDevices</a> to actually enumerate the devices. The <a href="#enumDeviceFunc">enumDeviceFunc</a> callback function later uses the bit depth to determine which drivers support the current bit depth.

<p>After enumerating devices, <b>CreateObjects</b> performs the steps necessary to create a device and associate it with the application's main window as follows:

<ol>
<li>Uses <a href="../ref/functions.htm#direct3drmcreate">Direct3DRMCreate</a> to create a Direct3D Retained Mode object.

<li>Uses the DirectDraw <b>DirectDrawCreateClipper</b> function to create a DirectDrawClipper object.



 

<li>Uses the DirectDrawClipper's <b>SetHWnd</b> method to associate the application's window with the clipper. The DirectDrawClipper object restricts subsequent drawing to a designated area&#151;in this case, to the application window.

<li>Uses the Windows <b>GetClientRect</b> function to obtain the height and width of the application's main window.

<li>Uses the Direct3D Retained Mode object's <a href="../ref/idirect3drm3.htm#createdevicefromclipper">CreateDeviceFromClipper</a> method to create the device, passing the preferred driver selected by the enumeration, and the width and height of the application's window, to the method.

</ol>

<p>The <b>CreateObjects</b> function's source code follows:

<pre>
/*
 * Initialize globals, enumerate devices and create objects. 
 */
BOOL CreateObjects(HWND win)
{
    HRESULT rval; /* Return value */
    RECT rc;      /* Bounding rectangle for main window */

    /*
     * Initialize the global variables. 
     */
    memset(&myglobs, 0, sizeof(myglobs));

    /*
     * Record the current display bit depth.
     */
     myglobs.BPP = GetCurrentBitDepth(win);

    /*
     * Enumerate the D3D drivers and select one.
     */
    if (!EnumDevices(win))
        return FALSE;

    /*
     * Create the Direct3DRM object and the window object.
     */
    rval = Direct3DRMCreate(&lpD3DRM);
    if (rval != D3DRM_OK) {
        Msg("Failed to create Direct3DRM.\n%s", D3DRMErrorToString(rval));
        return FALSE;
    }

    /*
     * Create a DirectDrawClipper object and associate the window with it.
     */
    rval = DirectDrawCreateClipper(0, &lpDDClipper, NULL);
    if (rval != DD_OK) {
        Msg("Failed to create DirectDrawClipper object");
        return FALSE;
    }
    rval = lpDDClipper->SetHWnd(0, win);
    if (rval != DD_OK) {
        Msg("Failed to set the window handle for the DirectDrawClipper");
        return FALSE;
    }
    /*
     * Create the D3DRM device with the selected D3D driver. The GUID can 
     * be NULL to create a default device without enumeration.
     */
    GetClientRect(win, &rc);

    rval = lpD3DRM->CreateDeviceFromClipper(lpDDClipper, 
                           &myglobs.DriverGUID[myglobs.CurrDriver],
                           rc.right, rc.bottom, &myglobs.dev);

    if (rval) {
        Msg("Failed to create the D3DRM device.\n%s", 
            D3DRMErrorToString(rval));
        return FALSE;
    }

    /*
     * Globals are initialized
     */
    myglobs.bInitialized = TRUE;

    return TRUE;
}
</pre>



<h3><a name="GetCurrentBitDepth" IDX_CONCEPT="GetCurrentBitDepth, RMEnum Sample;noindex">GetCurrentBitDepth</a></h3>
<p>The <b>GetCurrentBitDepth</b> function determines the current device's bit depth capabilities and returns that information in the form of a DirectDraw bit depth flag. Bit depth refers to the device's color settings, such as 8-bit, 16-bit, or 24-bit color.
<pre>
/*
 * Retrieve a DirectDraw bit depth flag reflecting the current 
 * display bit depth in bits per pixel (BPP).
 */
static DWORD GetCurrentBitDepth(HWND win) 
{
    HDC hdc;
    int BPP;

    /*
     * Record the current display's BPP.
     */
    hdc = GetDC(win);
    BPP = GetDeviceCaps(hdc, BITSPIXEL);
    ReleaseDC(win, hdc);

    /*
     * Map BPP value to DirectDraw bit depth.
     */
    switch(BPP) {
        case 1:
            return DDBD_1;
        case 2:
            return DDBD_2;
        case 4:
            return DDBD_4;
        case 8:
            return DDBD_8;
        case 16:
            return DDBD_16;
        case 24:
            return DDBD_24;
        case 32:
            return DDBD_32;
        default:
            return 0;
    }
}
</pre>




<h3><a name="EnumDevices" IDX_CONCEPT="noindex">EnumDevices</a></h3>
<p>The RMEnum <b>EnumDevices</b> function performs the following steps to enumerate devices. The steps include variables and code fragments from the sample.

<ol>
<li>Uses the <b>DirectDrawCreate</b> function to create a DirectDraw object.

<pre>
LPDIRECTDRAW lpDD;
HRESULT rval;
rval = DirectDrawCreate(NULL, &lpDD, NULL);
</pre>

<li>Uses the DirectDraw object's <b>QueryInterface</b> method to obtain a Direct3D Immediate Mode object. For more information on Direct3D Immediate Mode, see the DirectX Foundation SDK.

<pre>
LPDIRECT3D lpD3D;
rval = lpDD->QueryInterface(IID_IDirect3D, (void**) &lpD3D);
</pre>

<li>Uses the Direct3D Immediate Mode object's <b>IDirect3D2::EnumDevices</b> function to enumerate the devices on the system. <b>IDirect3D2::EnumDevices</b> passes the <a href="#enumDeviceFunc">enumDeviceFunc</a> callback function as a parameter.

<pre>
rval = lpD3D->EnumDevices(enumDeviceFunc, &myglobs.CurrDriver);
</pre>

<p>The callback function cycles through the available devices and selects the drivers that are compatible with certain criteria.
</ol>

<p>After it has enumerated the drivers, RMEnum's <b>EnumDevices</b> function releases the DirectDraw and Direct3D devices and adds the drivers to the application's File menu.

<pre>
lpD3D->Release();
lpDD->Release();
</pre>

<p>Complete source code for RMEnum's <b>EnumDevices</b> function follows:
<pre>
/*
 * EnumDevices
 * Enumerate the available Direct3D drivers, add them to the file menu, 
 * and choose one to use.
 */
static BOOL EnumDevices(HWND win)
{
    LPDIRECTDRAW lpDD;
    LPDIRECT3D lpD3D;
    HRESULT rval;
    HMENU hmenu;
    int i;

    /*
     * Create a DirectDraw object and query for the Direct3D interface 
     * to use to enumerate the drivers.
     */
    rval = DirectDrawCreate(NULL, &lpDD, NULL);
    if (rval != DD_OK) {
        Msg("Creation of DirectDraw HEL failed.\n%s", 
            D3DRMErrorToString(rval));
        return FALSE;
    }
    rval = lpDD->QueryInterface(IID_IDirect3D, (void**) &lpD3D);
    if (rval != DD_OK) {
        Msg("Creation of Direct3D interface failed.\n%s", 
            D3DRMErrorToString(rval));
        lpDD->Release();
        return FALSE;
    }
    /*
     * Enumerate the drivers. Pass the arbitrary value of -1 as
     * application-defined data. The enumDeviceFunc callback function
     * performs special-case initialization code in response to a -1.
     */
    myglobs.CurrDriver = -1;
    rval = lpD3D->EnumDevices(enumDeviceFunc, &myglobs.CurrDriver);
    if (rval != DD_OK) {
        Msg("Enumeration of drivers failed.\n%s", 
            D3DRMErrorToString(rval));
        return FALSE;
    }
    /*
     * Make sure we found at least one valid driver.
     */
    if (myglobs.NumDrivers == 0) {
        Msg("Could not find a D3D driver that is compatible with this \
            display depth");
        return FALSE;
    }
    lpD3D->Release();
    lpDD->Release();
    /*
     * Add the driver names to the File menu.
     */
    hmenu = GetSubMenu(GetMenu(win), 0);
    for (i = 0; i &lt; myglobs.NumDrivers; i++) {
        InsertMenu(hmenu, 2 + i, MF_BYPOSITION | MF_STRING, 
                   MENU_FIRST_DRIVER + i,
                   myglobs.DriverName[i]);
    }
    return TRUE;
}
</pre>



<h3><a name="enumDeviceFunc" IDX_CONCEPT="noindex">enumDeviceFunc</a></h3>
<p>Direct3D Immediate Mode defines D3DENUMDEVICESCALLBACK as the prototype definition for the callback function to enumerate installed Direct3D
devices. RMEnum provides <b>enumDeviceFunc</b> as this enumeration callback function. Direct3D Immediate Mode calls <b>enumDeviceFunc</b> repeatedly, once for each device on the system, and passes device information to <b>enumDeviceFunc</b> each time. As D3D Immediate Mode
loops through the available drivers, <b>enumDeviceFunc</b> saves information about drivers that can render in the current display bit depth into global variables. <b>enumDeviceFunc</b> chooses hardware drivers over software emulation drivers because hardware drivers
typically render faster and chooses color lights over monochromatic lights for better-looking 3-D lighting. These choices do not actually come into play with this sample, because RMEnum does no rendering, but they do effect real applications and can have a large impact
on the appearance of 3-D graphics.

<p><b>enumDeviceFunc</b>'s parameters include the device's globally unique identifier (GUID), a textual description of the device, and the device name. Other parameters include pointers to two Direct3D Immediate Mode <a href="../ref/furtherreading.htm#d3ddevicedesc">D3DDEVICEDESC</a> structures. The first structure (<i>lpHWDesc</i>) contains the hardware capabilities of the Direct3D device and the other structure (<i>lpHELDesc</i>) contains the Hardware Emulation Layer (HEL) software emulation capabilities of the device. The last parameter is application-defined data passed to this callback function the first time Direct3D Immediate Mode calls it.

<p>Complete source code for RMEnum's <b>enumDeviceFunc</b> callback function follows:

<pre>
/*
 * enumDeviceFunc
 * Callback function which records each usable D3D driver's name and 
 * GUID. It selects the preferred driver on the system by choosing
 * hardware drivers over software drivers, and color lights over 
 * monochrome lights. It sets myglobs.CurrDriver to indicate the 
 * preferred driver.
 */
static HRESULT WINAPI enumDeviceFunc(LPGUID lpGuid, 
                                     LPSTR lpDeviceDescription, 
                                     LPSTR lpDeviceName,
                                     LPD3DDEVICEDESC lpHWDesc, 
                                     LPD3DDEVICEDESC lpHELDesc, 
                                     LPVOID lpContext)
{
    static BOOL hardware = FALSE; /* current start driver is software */
    static BOOL mono = FALSE;     /* current start driver is color */
    LPD3DDEVICEDESC lpDesc;       /* description of current driver */
    
    /* 
     * Data defined by this application that, when it equals -1, 
     * indicates that the current driver is the first to be enumerated 
     */
    int *lpStartDriver = (int *)lpContext; 

    /*
     * Decide which device description to consult. The driver is either
     * hardware (HW) or software. Software drivers provide support
     * through the hardware emulation layer (HEL).
     */
    lpDesc = lpHWDesc->dcmColorModel ? lpHWDesc : lpHELDesc;
    /*
     * If this driver cannot render in the current display bit depth,
     * return D3DENUMRET_OK to skip this driver. Enumeration continues
     * automatically as D3D calls enumDeviceFunc again for the next
     * driver.
     */
    if (!(lpDesc->dwDeviceRenderBitDepth & myglobs.BPP)) 
        return D3DENUMRET_OK;
    /*
     * Record this driver's GUID and name.
     */
    memcpy(&myglobs.DriverGUID[myglobs.NumDrivers], lpGuid, sizeof(GUID));
    lstrcpy(&myglobs.DriverName[myglobs.NumDrivers][0], lpDeviceName);
    /*
     * Choose hardware over software, and color lights over monochrome
     * lights.
     */
    if (*lpStartDriver == (int)-1) {
        /*
         * This is the first valid driver, so record whether this driver
         * is a hardware driver or not, and whether it is limited to 
         * monochrome lights or not.
         */
        myglobs.CurrDriver = myglobs.NumDrivers;
        hardware = lpDesc == lpHWDesc ? TRUE : FALSE;
        mono = lpDesc->dcmColorModel & D3DCOLOR_MONO ? TRUE : FALSE;
    } else if (lpDesc == lpHWDesc && !hardware) {
        /*
         * If this driver is a hardware driver and the start driver is not,
         * then make this driver the new preferred driver and record
         * its hardware and mono capabilities. The next time D3D calls 
         * enumDeviceFunc, that driver will be compared against this 
         * new start driver.
         */
        myglobs.CurrDriver = myglobs.NumDrivers;
        hardware = lpDesc == lpHWDesc ? TRUE : FALSE;
        mono = lpDesc->dcmColorModel & D3DCOLOR_MONO ? TRUE : FALSE;
    } else if ((lpDesc == lpHWDesc && hardware ) || (lpDesc == lpHELDesc
                                                     && !hardware)) {
        if (lpDesc->dcmColorModel == D3DCOLOR_RGB && mono) {
            /*
             * If this driver and the start driver are the same type 
             * (both hardware or both software) and this driver is 
             * color while the start driver is not, then make this driver
             * the new preferred driver and record its capabilities.
             * The next time D3D calls enumDeviceFunc, that driver will 
             * be compared against this new start driver.
             */
            myglobs.CurrDriver = myglobs.NumDrivers;
            hardware = lpDesc == lpHWDesc ? TRUE : FALSE;
            mono = lpDesc->dcmColorModel & D3DCOLOR_MONO ? TRUE : FALSE;
        }
    }
    /* 
     * Increment the current driver number in preparation for the next
     * driver. 
     */
    myglobs.NumDrivers++; 

    /* Maximum number of drivers reached, stop enumeration. */
    if (myglobs.NumDrivers == MAX_DRIVERS)
        return (D3DENUMRET_CANCEL);
    /* 
     * Continue enumerating drivers. D3D will call enumDeviceFunc
     * again with information for the next driver. 
     */
    return (D3DENUMRET_OK);
}
</pre>



<h3><a name="ChangeDriver" IDX_CONCEPT="noindex">ChangeDriver</a></h3>
<p><b>ChangeDriver</b> is not a required function in the RMEnum sample, but it does add flexibility by enabling the user to choose between drivers. <b>ChangeDriver</b> changes the current driver in response to a menu selection. It re-creates the device by using the Direct3D Retained Mode object's <a href="../ref/idirect3drm3.htm#createdevicefromclipper">CreateDeviceFromClipper</a> method, much as RMEnum's <a href="#CreateObjects">CreateObjects</a> function originally created the device.

<p>The <b>ChangeDriver</b> source code follows:
<pre>
/*
 * Release the current device and create the new one.
 */
void ChangeDriver(HWND win, WPARAM wparam)
{
    HRESULT rval;
    RECT rc;

    /* 
     * Save the previous driver selection as LastDriver.
     */
    int LastDriver = myglobs.CurrDriver;

    /*
     * Globals are no longer correct since the selection is changing.
     */
    myglobs.bInitialized = FALSE;

    /* 
     * Release the current device.
     */ 
    RELEASE(myglobs.dev);   

    /* 
     * Set the current driver to the driver selected through the menu.
     */
    myglobs.CurrDriver = LOWORD(wparam)-MENU_FIRST_DRIVER;

    /* 
     * Obtain the window rectangle and create the new current driver
     * for that window using the global DirectDrawClipper object.
     */
    GetClientRect(win, &rc);

    rval = lpD3DRM->CreateDeviceFromClipper(lpDDClipper, 
                             &myglobs.DriverGUID[myglobs.CurrDriver],
                             rc.right, rc.bottom, &myglobs.dev);

    /* 
     * If an error occurred, try to recreate the previous driver.
     */
    if (rval) {
        myglobs.CurrDriver = LastDriver;

        rval = lpD3DRM->CreateDeviceFromClipper(lpDDClipper, 
                                 &myglobs.DriverGUID[myglobs.CurrDriver],
                                 rc.right, rc.bottom, &myglobs.dev);
        if (rval) {
            Msg("Failed to create the D3DRM device.\n%s", 
                D3DRMErrorToString(rval));
            CleanUpAndQuit();
        }
        else {
            Msg("There was not enough video memory available to use the \
            	 3D accelerated hardware device.\nRestoring old software \
            	 device.");
            myglobs.bInitialized = TRUE;
        }
    }
    else {
        /* 
         * Globals are properly initialized again.
         */
        myglobs.bInitialized = TRUE;
    }
}
</pre>



<h3><a name="CleanUpAndQuit" IDX_CONCEPT="noindex">CleanUpAndQuit</a></h3>
<p>The small <b>CleanUpAndQuit</b> function releases global objects and sets the quit flag to TRUE to indicate that the application is ready to quit.

<pre>
void CleanUpAndQuit(void)
{
    myglobs.bInitialized = FALSE;
    RELEASE(myglobs.dev);
    RELEASE(lpD3DRM);
    RELEASE(lpDDClipper);
    myglobs.bQuit = TRUE;
}
</pre>




<h3><a name="WindowsFunctions" IDX_CONCEPT="noindex">Standard Windows Functions</a></h3>
<p><p>The remaining functions in RMEnum.cpp (<b>InitApp</b>, <b>WinMain</b>, <b>AppAbout</b>, and <b>WindowProc</b>) are primarily the standard Windows functions and contain little code that is specific to the RMEnum sample. See the RMEnum sample code for more information.

<ul>
<li><b>InitApp</b> creates the main window and uses the sample's <a href="#CreateObjects">CreateObjects</a> function.

<li><b>WinMain</b> calls the <b>InitApp</b> function.




 It also contains the main Windows message loop that handles messages until the global <i>myglobs.bQuit</i> variable is TRUE. <b>WinMain</b> uses <a href="#CleanUpAndQuit">CleanUpAndQuit</a> in response to the standard Windows WM_QUIT message, indicating that the application is terminating.

<li><b>AppAbout</b> handles messages for the application's About dialog box.

<li><b>WindowProc</b> handles messages for the main application window. It initializes the File menu with the enumerated driver choices and handles the user's driver selection by using the application's <a href="#ChangeDriver">ChangeDriver</a> function. <b>WindowProc</b> uses <a href="#CleanUpAndQuit">CleanUpAndQuit</a> to release resources in response to the standard Windows WM_DESTROY message indicating that Windows is in the process of destroying the application window because the user terminated the application. 
</ul>




<h2><a name="Related_Topics">Related Topics</a></h2>
<p>Now that you are familiar with how to enumerate devices, the code in the Direct3D Retained Mode samples should be easier to understand. Nearly all of these samples use the helper code provided by <A href="samples.htm#RM_samples_misc_rmmain">RMMain</A> to enumerate devices. As a next step, you can look at the <a href="samples.htm#RM_samples_Egg">Egg</a> or the <a href="samples.htm#RM_samples_Globe">Globe</a> sample to see how they perform rendering, knowing that they use device enumeration behind the scenes.

<p>For brief summaries of all of the Retained Mode samples, see <a href="samples.htm">Samples</a>.
<!-- CONTENTS_END -->

<!-- START_PAGE_FOOTER -->


<H5><HR size=1></H5>
<P><A class="line" HREF="#pagetop"><IMG src="../art/arrowup1.gif" WIDTH="11" HEIGHT="11" ALIGN="MIDDLE" BORDER=0 ALT="Top of Page">&nbsp;Top of Page</A>
<BR><A Class="line" HREF="../../cpyright.htm">&#169; 1998 Microsoft Corporation. All rights reserved. Terms of Use.</A>
<!-- END_PAGE_FOOTER -->

</BLOCKQUOTE>

<SCRIPT LANGUAGE="JAVASCRIPT">if((g_isIE == true) && (g_iMaj > 3)) {window.self.document.writeln('<SCR' + 'IPT SRC="../tip2.js"></SCR' + 'IPT><IFRAME ID="G_L_S" NAME="SecretBuffer" STYLE="display: none" SRC=""></IFRAME>')}</SCRIPT>

<!-- DACONTROL_START -->

	<DIV ID="HeadGraphAnim"></DIV>
	<SCRIPT LANGUAGE="JAVASCRIPT">if((g_isIE == true) && (g_iMaj > 3)) {window.self.document.writeln('<SCR' + 'IPT SRC="../anim.js"></SCR' + 'IPT>')}</SCRIPT>
<!-- DACONTROL_END -->

</BODY>
</HTML>
