<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<HTML>
<HEAD><TITLE>Rotating an Object: The RMBegin1 Sample</TITLE>
<SCRIPT LANGUAGE="JAVASCRIPT"> var sRelPath = '../' </SCRIPT>


<META NAME="Description" CONTENT="Rotating an Object: The RMBegin1 Sample">
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; CHARSET=iso8859-1">
<META NAME="MS.LOCALE" CONTENT="EN-US">
<META NAME="ROBOTS" CONTENT="all">

<!-- SNIFF_START -->

<SCRIPT LANGUAGE="JAVASCRIPT">
//<!--
var g_isIE = false, g_isNav = false, g_iMaj = 0, g_sPlat = "";
// -->

</SCRIPT>
<SCRIPT SRC="../ver.js"></SCRIPT>
<SCRIPT SRC="../gloss.js"></SCRIPT>


<SCRIPT DEFER SRC="../common.js"></SCRIPT>
<SCRIPT DEFER>
//<!--
function InitPage()
{
	if (g_isIE && g_iMaj >= 4)	
	{

		SetTOC();
	}
}
//-->

</SCRIPT>

<!-- SNIFF_END -->


<!-- STYLE_START -->

<SCRIPT LANGUAGE="JAVASCRIPT">
//<!--
   var sVR = '../'	// Set root for the style sheet
   var sCSS = '<LINK REL="stylesheet" HREF="' + sVR;

   if(g_isIE)
   {
	   if (g_iMaj >= 4) // For MSIE 4.0 or later
	   {
		   sCSS += 'dxm_basicSDKIE4';
		   if (g_sPlat == "Win") // Windows only for now
		   {
			   document.createStyleSheet(sVR + 'dxm_advSDKIE4.css');
		   }
	   }
	   else // For MSIE 3.0 or earlier
	   {
		   sCSS += 'dxm_basicSDKIE3';
	   }
   }
   else if (g_isNav) // For all Nav versions
   {
	   sCSS += 'dxm_basicSDKNAV';
   }
   else
   {
	   sCSS += 'dxm_basicSDKIE3'; // default to IE3 sheet
   }

   sCSS += (sCSS == '' ? '' : '.css" TYPE="text/css">');

   document.write(sCSS);
//-->

</SCRIPT>
<!-- STYLE_END -->


</HEAD>
<BODY onload="InitPage(); if (g_isIE && g_iMaj >= 4){HdgrphControl()}" BGCOLOR="#FFFFFF">
<A NAME="pagetop"></A>

<!-- HEADGRAPH_START -->

<TABLE CLASS="main" BORDER=0 CELLSPACING="0" CELLPADDING="0" WIDTH="*">
<TR>
<TD ROWSPAN="3" VALIGN="TOP" WIDTH="*">
<IMG SRC="../art/header1.gif" WIDTH="107" HEIGHT="110" BORDER=0 ALT="Direct3D Retained Mode Animated Header --Rotating an Object -- The RMBegin1 Sample"></TD>
<TD ROWSPAN="2" VALIGN="TOP" WIDTH="217">
<IMG SRC="../art/HDRd3drm.gif" WIDTH="217" HEIGHT="110" BORDER=0 ALT="Direct3D Retained Mode Animated Header --Rotating an Object -- The RMBegin1 Sample"></TD><TD VALIGN="TOP" WIDTH="383">
<IMG SRC="../art/header3.gif" WIDTH="383" HEIGHT="95" BORDER=0 ALT="Direct3D Retained Mode Animated Header">
</TD>
<TD VALIGN="TOP" WIDTH="100%">
<IMG SRC="../art/spacer1.gif" WIDTH="100%" HEIGHT="94" BORDER=0 ALT="Microsoft Direct3D Retained Mode SDK"></TD></TR>
<!-- HEADGRAPH_END -->

<!-- NAV_LINKS_START -->

<TR><TD VALIGN="TOP"><PRE><IMG ID="TOC_" SRC="../art/yelbtn.gif" WIDTH="11" HEIGHT="11" ALIGN="MIDDLE" BORDER=0 ALT="*"><A STYLE="color:black;font-weight:bold" ID="TOC" HREF="../contents.htm">Contents</A>  <IMG SRC="../art/yelbtn.gif" WIDTH="11" HEIGHT="11" ALIGN="MIDDLE" BORDER=0 ALT="*"><A STYLE="color:black;font-weight:bold" HREF="../index.htm">Index</A>  <IMG SRC="../art/yelbtn.gif" WIDTH="11" HEIGHT="11" ALIGN="MIDDLE" BORDER=0 ALT="*"><A STYLE="color:black;font-weight:bold" href="gettingstarted_intro.htm">Topic Contents</A>
</PRE></TD></TR>
<TR><TD COLSPAN="2" VALIGN="TOP"><PRE><IMG SRC="../art/yelbtn.gif" WIDTH="11" HEIGHT="11" ALIGN="MIDDLE" BORDER=0 ALT="*"><B>Previous Topic:</B> <A STYLE="color:black" href="roadmap.htm">Documentation Roadmap</a>
<IMG SRC="../art/yelbtn.gif" WIDTH="11" HEIGHT="11" ALIGN="MIDDLE" BORDER=0 ALT="*"><B>Next Topic:</B> <A  STYLE="color:black" href="FrameHierarchy.htm">Frame Hierarchies: The RMBegin2 Sample</a>
</PRE></TD></TR></TABLE>
<!-- NAV_LINKS_END -->

<BLOCKQUOTE CLASS="body">

<!-- CONTENTS_START -->


<H1><a name="RotateObject" IDX_CONCEPT="RMBegin1 Sample Walkthrough">Rotating an Object: The RMBegin1 Sample</a></H1>
<P>Creating a device, building a scene, and moving the scene are fundamental concepts in Microsoft&reg; Direct3D&reg; Retained Mode. The RMBegin1 sample demonstrates these concepts by creating a default device, loading a mesh from a Microsoft DirectX&reg; file, adding color to the object and lights to the scene, and rotating the object. In the process of building the scene, the sample uses a meshbuilder, frames, lights, and a material. The sample also creates a <B>DirectDrawClipper</B> object,
viewport and <A CLASS="Glossary" HREF="javascript:Glossary(sRelPath + 'gloss/gloss_c.htm#camera')">camera</A>.

<p>This article walks you through code from the RMBegin1 sample. The sample source code consists of one self-contained file (RMBegin1.cpp). It does not use any separate header files, except for the standard Microsoft Windows&reg;, DirectDraw&reg;, and Direct3D Retained Mode header files for the sake of simplicity.
It also does not contain any menus, icons, or other resources.

<p>This sample uses the Teapot.x file from the DirectX Foundation Software Development Kit (SDK) to provide the teapot image for the scene. By default when you install the SDK, the SDK's setup program sets an environment variable to point to the SDK's media directory. Teapot.x resides in that directory, allowing the application to locate the file automatically. If you have not installed the SDK and simply run RMBegin1.exe, Teapot.x must be located in the same directory as RMBegin1.exe.

<p>This article assumes you are an experienced C or C++ programmer and are familiar with beginning Windows programming concepts, such as the message loop, creating a window, and using menus. 

<p>This article contains the following sections.

<ul>
<li><a href="#Dependencies">Dependencies</a>
<li><a href="#Global Declarations">Global Declarations</a>
<li><a href="#Function Summaries">Function Summaries</a>
<li><a href="#Related_Topics">Related Topics</a>
</ul>



<h2><a name="Dependencies" IDX_CONCEPT="noindex">Dependencies</a></h2>
<ul>
<li>RMBegin1 links to DDraw.lib and D3DRM.lib. 

<li>RMBegin1 loads the teapot image from Teapot.x, as described in the previous section.

<li>To properly initialize globally unique identifiers (GUIDs), Direct3D applications must contain
the following definition at the top of their code.

<pre>
#define INITGUID
</pre>

<li>The sample's RMBegin1.cpp file includes the following header files.


<PRE>
#include &lt;windows.h>   // Standard Windows header file 
#include &lt;direct.h>    // DirectDraw definitions 
#include &lt;d3drmwin.h>  // Direct3D Retained Mode definitions 
</PRE>
</ul>



<h2><a name="Global Declarations" IDX_CONCEPT="noindex">Global Declarations</a></h2>
<p>The sample defines some constants and global variables to help organize information.

<p>The application-defined RELEASE macro releases an object only if the object is not NULL and ensures that an object is initialized to NULL after it has been released. This practice eliminates the problem of trying to release an object that has already been released, which can cause undesired results, such as page faults.

<pre>
// Macro to release an object. 
#define RELEASE(x) if (x != NULL) {x->Release(); x = NULL;} 
</pre>

<p>The application-defined DISPLAYMSG macro uses the Windows MessageBox function to display information to the user. Using this macro rather than direct calls to MessageBox throughout the sample code makes the code cleaner and easier to read.
<pre>
// Macro to display a message box containing the given string. 
#define DISPLAYMSG(x) MessageBox(NULL, x, "D3DRM Sample", MB_OK);
</pre>

<p>Global variables keep track of the key objects, such as the Direct3D Retained Mode and DirectDrawClipper objects (the DirectDrawClipper object restricts drawing to a designated area). The myglobs structure collects device, viewport, scene, and camera information, as well as information about whether the application is minimized and whether objects have been initialized. 

<pre>
// Global Variables
LPDIRECT3DRM lpD3DRM = NULL;            // Direct3DRM object 
LPDIRECTDRAWCLIPPER lpDDClipper = NULL; // DirectDrawClipper object 

// Global Structure
struct _myglobs {
    
    // Direct3D Retained Mode device. 
    LPDIRECT3DRMDEVICE dev;           

    // Direct3D Retained Mode viewport through which to view the scene. 
    LPDIRECT3DRMVIEWPORT view;  

    // Master frame in which other frames are placed. 
    LPDIRECT3DRMFRAME scene;    

    // Frame describing the user's point of view. 
    LPDIRECT3DRMFRAME camera;   

    // Application is minimized. 
    BOOL bMinimized;            

    // All Direct3D Retained Mode objects have been initialized. 
    BOOL bInitialized;          

} myglobs;
</pre>




<h2><a name="Function Summaries" IDX_CONCEPT="noindex">Function Summaries</a></h2>

<p>RMBegin1.cpp contains the following functions.

<p><a href="#buildscene">BuildScene</a> creates the scene to be rendered. It loads a mesh from the DirectX file, adds color to the mesh, and adds lights to the scene. <b>BuildScene</b> also sets the position of objects and how objects should be rotated. <b>CreateObjects</b>, which initializes global variables and creates default devices, frames, and viewports, uses this function.

<pre>
BOOL <b>BuildScene</b>(LPDIRECT3DRM, LPDIRECT3DRMDEVICE, 
                LPDIRECT3DRMFRAME, LPDIRECT3DRMFRAME);
</pre>

<p><a href="#renderscene">RenderScene</a> draws the scene that <b>BuildScene</b> created. Each time <b>WinMain</b> uses this function, <b>RenderScene</b> moves the scene, giving the effect of a spinning object.
<pre>
static BOOL <b>RenderScene</b>(void);
</pre>

<p><a href="#CreateObjects">CreateObjects</a> initializes the global variables and creates a default device, camera frame, scene frame, and viewport. <b>CreateObjects</b> uses <b>BuildScene</b> to create the scene to be rendered. <b>InitApp</b> uses <b>CreateObjects</b>.
<pre>
BOOL <b>CreateObjects</b>(HWND win);
</pre>

<p><a href="#initapp">InitApp</a> provides standard, Windows application code to create the window class and the application's window. It uses <b>CreateObjects</b> to initialize global objects.
<pre>
static HWND <b>InitApp</b>(HINSTANCE, int);
</pre>

<p><a href="#winmain">WinMain</a> provides the application's message loop. It uses <b>InitApp</b> to initialize the application and uses <b>RenderScene</b> to draw the scene.
<pre>
int APIENTRY <b>WinMain</b>(HINSTANCE, HINSTANCE, LPSTR, int);
</pre>

<p><a href="#windowproc">WindowProc</a> handles messages for the application. It handles cases where the application is minimized or destroyed.
<pre>
LRESULT CALLBACK <b>WindowProc</b>(HWND, UINT, WPARAM, LPARAM);
</pre>

<p>For more information about these functions, see the following topics in this article.
    <ul>
    <li><a href="#BuildScene">BuildScene</a>
    <li><a href="#RenderScene">RenderScene</a>
	<li><a href="#CreateObjects">CreateObjects</a>
	<li><a href="#InitApp">InitApp</a>
	<li><a href="#WinMain">WinMain</a>
	<li><a href="#WindowProc">WindowProc</a>
    </ul>



<h3><a name="BuildScene" IDX_CONCEPT="noindex">BuildScene</a></h3>

<p>The <b>BuildScene</b> function creates the scene to be rendered. All Direct3D Retained Mode applications must create a scene, but the code required depends on the scene. Applications typically create frames and lights, add visuals to the scene, and set the position of objects.

<p>This section of this article provides code fragments from the <b>BuildScene</b> function and presents the steps the RMBegin1 sample performs to build the scene. This section also presents the complete source code for the RMBegin1 sample's <b>BuildScene</b> function. If an error occurs, the code uses <b>goto</b> statements to jump to the end of the function and ensure that all objects are properly released before returning from the function.

<ol>
<li>Load a mesh from a DirectX file by using the <a href="../ref/idirect3drm3.htm#CreateMeshBuilder">IDirect3DRM3::CreateMeshBuilder</a> and <a href="../ref/meshbuilder3.htm#load">IDirect3DRMMeshBuilder3::Load</a> methods.
<pre>
    if (FAILED(lpD3DRM->CreateMeshBuilder(&meshbuilder)))
        goto generic_error;

    rval = meshbuilder->Load("teapot.x", 
                              NULL, D3DRMLOAD_FROMFILE, NULL, NULL);
</pre>

<li>Create a child frame within the scene by using the <a href="../ref/idirect3drm3.htm#CreateFrame">IDirect3DRM3::CreateFrame</a> method.
<pre>
    if (FAILED(lpD3DRM->CreateFrame(scene, &childframe)))
        goto generic_error;
</pre>

<li>Add the loaded mesh into the child frame by using the <a href="../ref/Frame3AtoM.htm#AddVisual">IDirect3DRMFrame3::AddVisual</a> method.
<pre>
    if (FAILED(childframe->AddVisual((LPDIRECT3DRMVISUAL)meshbuilder)))
        goto generic_error;
</pre>

<li>Set the camera position within the scene by using the <a href="../ref/frame3ntoz.htm#SetPosition">IDirect3DRMFrame3::SetPosition</a> method.
<pre>
    rval = camera->SetPosition(scene, D3DVAL(0), D3DVAL(0), -D3DVAL(7));
</pre>

<li>Set the child frame's rotation by using the <a href="../ref/frame3ntoz.htm#SetRotation">IDirect3DRMFrame3::SetRotation</a> method.
<pre>
    if (FAILED(childframe->SetRotation(scene, 
                                       D3DVAL(0), D3DVAL(1), D3DVAL(0), 
                                       D3DVAL(0.03)))) // angle 
        goto generic_error;
</pre>

<li>Create a light frame that is a child of the scene by using the <a href="../ref/idirect3drm3.htm#CreateFrame">IDirect3DRM3::CreateFrame</a> method.
<pre>
    if (FAILED(lpD3DRM->CreateFrame(scene, &lights)))
        goto generic_error;
</pre>

<li>Position the light frame within the scene by using the <a href="../ref/frame3ntoz.htm#SetPosition">IDirect3DRMFrame3::SetPosition</a> method.
<pre>
    if (FAILED(lights->SetPosition(scene, 
                                   D3DVAL(5), D3DVAL(0), -D3DVAL(7))))
        goto generic_error;
</pre>

<li>Create a bright, <A CLASS="Glossary" HREF="javascript:Glossary(sRelPath + 'gloss/gloss_p.htm#parallel_point')">parallel point</A> light and add it to the light frame by using the <a href="../ref/idirect3drm3.htm#CreateLightRGB">IDirect3DRM3::CreateLightRGB</a> and <a href="../ref/frame3atom.htm#AddLight">IDirect3DRMFrame3::AddLight</a> methods.
<pre>
    if (FAILED(lpD3DRM->CreateLightRGB(D3DRMLIGHT_PARALLELPOINT,  
                                       D3DVAL(1.0), D3DVAL(0.8), 
                                       D3DVAL(0.9), &light1)))
        goto generic_error;

    if (FAILED(lights->AddLight(light1)))
        goto generic_error;
</pre>

<li>Create a dim, <A CLASS="Glossary" HREF="javascript:Glossary(sRelPath + 'gloss/gloss_A.htm#ambient')">ambient</A> light and add it to the scene, again by using using the <a href="../ref/idirect3drm3.htm#CreateLightRGB">IDirect3DRM3::CreateLightRGB</a> and <a href="../ref/frame3atom.htm#AddLight">IDirect3DRMFrame3::AddLight</a> methods.
<pre>
    if (FAILED(lpD3DRM->CreateLightRGB(D3DRMLIGHT_AMBIENT, 
                                       D3DVAL(0.1), D3DVAL(0.1), 
                                       D3DVAL(0.1), &light2)))
        goto generic_error;

    if (FAILED(scene->AddLight(light2)))
        goto generic_error;
</pre>

<li>Create a material and set the reflectiveness by using the <a href="../ref/idirect3drm3.htm#CreateMaterial">IDirect3DRM3::CreateMaterial</a> and <a href="../ref/meshbuilder3.htm#SetMaterial">IDirect3DRMMeshBuilder3::SetMaterial</a> methods.
<pre>
    if (FAILED(lpD3DRM->CreateMaterial(D3DVAL(10.0), &mat)))
        goto generic_error;
    
    if (FAILED(meshbuilder->SetMaterial(mat)))
        goto generic_error;
</pre>

<li>Set the mesh color by using the <a href="../ref/meshbuilder3.htm#SetColorRGB">IDirect3DRMMeshBuilder3::SetColorRGB</a> method.
<pre>
    if (FAILED(meshbuilder->SetColorRGB(D3DVAL(0.0),   // red 
                                        D3DVAL(0.7),   // green 
                                        D3DVAL(0.0)))) // blue 
        goto generic_error;
</pre>

<li>Clean up by releasing all of the objects created by this function.
<pre>
    RELEASE(childframe);
    RELEASE(lights);
    RELEASE(meshbuilder);
    RELEASE(light1);
    RELEASE(light2);
    RELEASE(mat);
</pre>
</ol>



<h4><b>BuildScene</b> Function Source Code</h4>
<pre>
// Create the scene to be rendered. 
 
BOOL BuildScene(LPDIRECT3DRM lpD3DRM, 
                LPDIRECT3DRMDEVICE dev, 
                LPDIRECT3DRMFRAME scene, 
                LPDIRECT3DRMFRAME camera)
{
    LPDIRECT3DRMFRAME lights = NULL;
    LPDIRECT3DRMMESHBUILDER meshbuilder = NULL;
    LPDIRECT3DRMFRAME childframe = NULL;
    LPDIRECT3DRMLIGHT light1 = NULL;
    LPDIRECT3DRMLIGHT light2 = NULL;
    LPDIRECT3DRMMATERIAL mat = NULL;
    HRESULT rval;

    // Load a mesh from a DirectX file.
    if (FAILED(lpD3DRM->CreateMeshBuilder(&meshbuilder)))
        goto generic_error;

    rval = meshbuilder->Load("teapot.x", 
                              NULL, D3DRMLOAD_FROMFILE, NULL, NULL);
    if (FAILED(rval)) 
    {
        DISPLAYMSG("Failed to load .x file.");
        goto ret_with_error;
    }

    // Create a child frame within the scene.
    if (FAILED(lpD3DRM->CreateFrame(scene, &childframe)))
        goto generic_error;

    // Add the loaded mesh into the child frame.
    if (FAILED(childframe->AddVisual((LPDIRECT3DRMVISUAL)meshbuilder)))
        goto generic_error;

    // Set up the camera frame's position. Objects with the same x-value and
    // y-value as the camera will appear straight ahead.
    // Negative z-values are farther away, making the object look
    // smaller as the negative numbers increase.
    rval = camera->SetPosition(scene, D3DVAL(0), D3DVAL(0), -D3DVAL(7));
    if (FAILED(rval)) 
    {
        DISPLAYMSG("Failed to position the camera in the frame.");
        goto ret_with_error;
    }

    // Rotate the child mesh around the y-axis (zero x-value and z-value)
    // and use a small rotational angle to rotate slowly.
    if (FAILED(childframe->SetRotation(scene, 
                                       D3DVAL(0), D3DVAL(1), D3DVAL(0), 
                                       D3DVAL(0.03)))) // angle 
        goto generic_error;

    // Initialize the lights in the scene, creating a light frame that
    // is a child of the scene.
    if (FAILED(lpD3DRM->CreateFrame(scene, &lights)))
        goto generic_error;

    // Position the light frame within the scene. This light comes from 
    // the right of the camera. It has a different x-value, but the same 
    // y-value and z-value as the camera position.
    if (FAILED(lights->SetPosition(scene, 
                                   D3DVAL(5), D3DVAL(0), -D3DVAL(7))))
        goto generic_error;

    // Create a bright, parallel point light and add it to the light frame.
    // Color values must be in the range 0.0 (dim) to 1.0 (bright).
    if (FAILED(lpD3DRM->CreateLightRGB(D3DRMLIGHT_PARALLELPOINT,  
                                       D3DVAL(1.0), D3DVAL(0.8), 
                                       D3DVAL(0.9), &light1)))
        goto generic_error;

    if (FAILED(lights->AddLight(light1)))
        goto generic_error;

    // Create a dim, ambient light and add it to the scene frame,
    // applying it to the whole scene. Ambient light comes from all 
    // directions, so a bright ambient light would wash out the object.
    if (FAILED(lpD3DRM->CreateLightRGB(D3DRMLIGHT_AMBIENT, 
                                       D3DVAL(0.1), D3DVAL(0.1), 
                                       D3DVAL(0.1), &light2)))
        goto generic_error;

    if (FAILED(scene->AddLight(light2)))
        goto generic_error;

    // Create a material, setting the reflectiveness (5.0 is metallic, 
    // higher is more plastic) on the previously loaded mesh.
    if (FAILED(lpD3DRM->CreateMaterial(D3DVAL(10.0), &mat)))
        goto generic_error;
    
    if (FAILED(meshbuilder->SetMaterial(mat)))
        goto generic_error;

    // Set the mesh color (bright green in this case). 
    if (FAILED(meshbuilder->SetColorRGB(D3DVAL(0.0),   // red 
                                        D3DVAL(0.7),   // green 
                                        D3DVAL(0.0)))) // blue 
        goto generic_error;

    // Clean up.
    RELEASE(childframe);
    RELEASE(lights);
    RELEASE(meshbuilder);
    RELEASE(light1);
    RELEASE(light2);
    RELEASE(mat);
    return TRUE;

generic_error:
    DISPLAYMSG("A failure occured while building the scene.");
ret_with_error:
    RELEASE(childframe);
    RELEASE(lights);
    RELEASE(meshbuilder);
    RELEASE(light1);
    RELEASE(light2);
    RELEASE(mat);
    return FALSE;
}
</pre>



<h3><a name="RenderScene" IDX_CONCEPT="noindex">RenderScene</a></h3>

<p><b>RenderScene</b> performs the actual drawing to the screen. It draws the scene that <b>BuildScene</b> created by performing the following steps.
<ol>
<li>Move the scene by using <a href="../ref/frame3atom.htm#move">IDirect3DRMFrame3::Move</a>.
<li>Clear the viewport by using <a href="../ref/viewport2.htm#Clear">IDirect3DRMViewport2::Clear</a>.
<li>Render the scene by using <a href="../ref/viewport2.htm#Render">IDirect3DRMViewport2::Render</a>.
<li>Update the window by using <a href="../ref/device3.htm#update">IDirect3DRMDevice3::Update</a>.
</ol>



<h4><b>RenderScene</b> Function Source Code</h4>

<pre>
// Clear the viewport, render the next frame, and update the window.
 
static BOOL RenderScene()
{
    HRESULT rval;

    // Move the scene.
    rval = myglobs.scene->Move(D3DVAL(1.0));
    if (FAILED(rval)) 
    {
        DISPLAYMSG("Moving scene failed.");
        return FALSE;
    }

    // Clear the viewport.
    rval = myglobs.view->Clear();
    if (FAILED(rval)) 
    {
        DISPLAYMSG("Clearing viewport failed.");
        return FALSE;
    }

    // Render the scene to the viewport.
    rval = myglobs.view->Render(myglobs.scene);
    if (FAILED(rval)) 
    {
        DISPLAYMSG("Rendering scene failed.");
        return FALSE;
    }

    // Update the window.
    rval = myglobs.dev->Update();
    if (FAILED(rval)) 
    {
        DISPLAYMSG("Updating device failed.");
        return FALSE;
    }
    return TRUE;
}
</pre>



<h3><a name="CreateObjects" IDX_CONCEPT="noindex">CreateObjects</a></h3>

<p><b>CreateObjects</b> initializes the sample's global variables and creates objects. After initializing global variables, <b>CreateObjects</b> performs the steps necessary to create a device, associate it with the application's main window, and create the master scene frame, the camera frame, and the viewport as follows:

<ol>
<li>Use the DirectDraw <b>DirectDrawCreateClipper</b> function to create a DirectDrawClipper object.

<li>Use the DirectDrawClipper's <b>SetHWnd</b> method to associate the application's window with the DirectDrawClipper. The DirectDrawClipper object restricts subsequent drawing to a designated area&#151;in this case, the application window.

<li>Use the <a href="../ref/functions.htm#direct3drmcreate">Direct3DRMCreate</a> function to create a Direct3D Retained Mode object.

<li>Use the Windows <b>GetClientRect</b> function to obtain the height and width of the application's main window.

<li>Use the Direct3D Retained Mode object's <a href="../ref/idirect3drm3.htm#createdevicefromclipper">CreateDeviceFromClipper</a> method to create a device, passing NULL to create a default device, and passing the width and height of the application's window to the method.

<li>Create the master scene frame by using <a href="../ref/idirect3drm3.htm#createframe">IDirect3DRM3::CreateFrame</a>.

<li>Create the camera frame by using <a href="../ref/idirect3drm3.htm#createframe">IDirect3DRM3::CreateFrame</a>.

<li>Create the Direct3D Retained Mode viewport by using <a href="../ref/idirect3drm3.htm#createviewport">IDirect3DRM3::CreateViewport</a>.

<li>Use <a href="#BuildScene">BuildScene</a> to create the scene.
</ol>



<h4><b>CreateObjects</b> Function Source Code</h4>

<pre>
// Initialize globals, create the device and objects. 
 
BOOL CreateObjects(HWND win)
{
    HRESULT rval; // Return value 
    RECT rc;      // Bounding rectangle for main window 
    int width;    // Device's width 
    int height;   // Device's height 


    // Initialize the entire global variable structure to zero. 
    memset(&myglobs, 0, sizeof(myglobs));

    // Create a DirectDrawClipper object and associate the window with it.
    rval = DirectDrawCreateClipper(0, &lpDDClipper, NULL);
    if (FAILED(rval)) 
    {
        DISPLAYMSG("Failed to create DirectDrawClipper object");
        return FALSE;
    }

    rval = lpDDClipper->SetHWnd(0, win);
    if (FAILED(rval)) 
    {
        DISPLAYMSG("Failed to set the window handle for the DirectDrawClipper");
        return FALSE;
    }

    // Create the Direct3D Retained Mode object.
    rval = Direct3DRMCreate(&lpD3DRM);
    if (FAILED(rval)) 
    {
        DISPLAYMSG("Failed to create Direct3DRM.");
        return FALSE;
    }
    
    // Create a default Direct3D Retained Mode device.
    GetClientRect(win, &rc);

    rval = lpD3DRM->CreateDeviceFromClipper(lpDDClipper, 
                           NULL, // Default device 
                           rc.right, rc.bottom, &myglobs.dev);
    if (FAILED(rval)) 
    {
        DISPLAYMSG("Failed to create the D3DRM device.");
        return FALSE;
    }

    // Create the master scene frame and the camera frame.
    rval = lpD3DRM->CreateFrame(NULL, &myglobs.scene);
    if (FAILED(rval)) 
    {
        DISPLAYMSG("Failed to create the master scene frame.");
        return FALSE;
    }

    rval = lpD3DRM->CreateFrame(myglobs.scene, &myglobs.camera);
    if (FAILED(rval)) 
    {
        DISPLAYMSG("Failed to create the camera's frame.");
        return FALSE;
    }

    // Create the Direct3D Retained Mode viewport using the device, camera frame,
    // and the device's width and height.
    width = myglobs.dev->GetWidth();
    height = myglobs.dev->GetHeight();

    rval = lpD3DRM->CreateViewport(myglobs.dev, myglobs.camera, 0, 0, 
                                   width, height, &myglobs.view);
    if (FAILED(rval)) 
    {
        myglobs.bInitialized = FALSE;
        RELEASE(myglobs.dev);
        return FALSE;
    }

    // Create the scene to be rendered.
    if (!BuildScene(lpD3DRM, myglobs.dev, myglobs.scene, 
                    myglobs.camera))
        return FALSE;

    // Globals are initialized.
    myglobs.bInitialized = TRUE;

    return TRUE;
}
</pre>



<h3><a name="InitApp" IDX_CONCEPT="noindex">InitApp</a></h3>

<p>The <b>InitApp</b> function creates the main window class and the main window, as is typical of Windows applications. The only Direct3D Retained Mode&#150;related call in <b>InitApp</b> is the call to <a href="#CreateObjects">CreateObjects</a>.



<h4><b>InitApp</b> Function Source Code</h4>

<pre>
// Create the main window and initialize objects. 
 
static HWND InitApp(HINSTANCE this_inst, int cmdshow)
{
    HWND win;     // Main window handle 
    WNDCLASS wc;  // Window class

    // Set up and register the window class.
    wc.style = CS_HREDRAW | CS_VREDRAW;
    wc.lpfnWndProc = WindowProc;
    wc.cbClsExtra = 0;
    wc.cbWndExtra = sizeof(DWORD);
    wc.hInstance = this_inst;
    wc.hIcon = LoadIcon(NULL, IDI_APPLICATION);
    wc.hCursor = LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground = (HBRUSH)GetStockObject(BLACK_BRUSH);
    wc.lpszMenuName = NULL;
    wc.lpszClassName = "D3DRM Example";
    if (!RegisterClass(&wc))
        return FALSE;

    // Create the window.
    win = CreateWindow(   
            "D3DRM Example",                   // class 
            "RMBegin1: Direct3DRM Sample One", // caption 
            WS_OVERLAPPEDWINDOW,               // style 
            CW_USEDEFAULT,                     // init. x pos 
            CW_USEDEFAULT,                     // init. y pos 
            350,                               // init. x size 
            300,                               // init. y size 
            NULL,                              // parent window 
            NULL,                              // menu handle 
            this_inst,                         // program handle 
            NULL);                             // create parms 
        
    if (!win)
        return FALSE;

    // Initialize global variables and create the Direct3D Retained
    // Mode objects.
    if (!CreateObjects(win))
        return FALSE;

    // Display the window.
    ShowWindow(win, cmdshow);
    UpdateWindow(win);

    return win;
}
</pre>


<h3><a name="WinMain" IDX_CONCEPT="noindex">WinMain</a></h3>

<p><b>WinMain</b> provides the main message loop for the application. As long as the global variables are initialized and the application is not minimized, WinMain uses <a href="#RenderScene">RenderScene</a> to draw the scene to the screen.



<h4><b>WinMain</b> Function Source Code</h4>
<pre>
// Initialize the application, process messages, and render the scene.
 
int APIENTRY WinMain (HINSTANCE this_inst, 
                      HINSTANCE prev_inst, 
                      LPSTR cmdline, 
                      int cmdshow)
{
    HWND    hwnd;
    MSG     msg;
    prev_inst;
    cmdline;

    // Create the window and initialize objects. 
    if (!(hwnd = InitApp(this_inst, cmdshow)))
        return 1;

    while (TRUE) 
    {  
        // Monitor the message queue and process messages. PeekMessage 
        // returns control to the application immediately so that the 
        // application can both process messages and continue rendering. 
        // If the message is WM_QUIT, break out of this function
        // because the application is terminating.
        if (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE)) 
        {
            if (msg.message == WM_QUIT) 
                break;
            TranslateMessage(&msg);
            DispatchMessage(&msg);
        }
    
        // If the application is not minimized and the Direct3D Retained 
        // Mode objects are initialized, render.
        if (!myglobs.bMinimized && myglobs.bInitialized) 
        {
            // Render one frame of the scene. If rendering fails, post
            // the WM_DESTROY message, enabling the application to 
            // free resources before terminating the application.
            if (!RenderScene()) 
            {
                DISPLAYMSG("Rendering failed. Aborting execution.");
                PostMessage(NULL, WM_DESTROY, 0, 0);
                break;
            }

        // Yield to other applications if this application is
        // not currently rendering.
        } else 
              WaitMessage();

    }
    return msg.wParam;
}
</pre>



<h3><a name="WindowProc" IDX_CONCEPT="noindex">WindowProc</a></h3>

<p><b>WindowProc</b> handles messages for the main application window. <b>WindowProc</b> sets a flag so that the application stops rendering while minimized. This function also releases objects when the application shuts down.



<h4><b>WindowProc</b> Function Source Code</h4>
<pre>
// Handle messages for the main window.
 
LRESULT CALLBACK WindowProc(HWND win, 
                            UINT msg, 
                            WPARAM wparam, 
                            LPARAM lparam)
{
    switch (msg) 
    {
        case WM_SIZE:
            // Handle minimizing of the window. If the application was 
            // minimized, set a flag so that rendering will stop while 
            // minimized. Otherwise, continue rendering.
            if (SIZE_MINIMIZED == wparam) 
                myglobs.bMinimized = TRUE;
            else
                myglobs.bMinimized = FALSE;
            break;

        case WM_DESTROY:
            // Clear the bInitialized flag, free objects, and post the 
            // WM_QUIT message to terminate the application. Be sure to
            // free the viewport before freeing the device, or a general 
            // protection fault might occur.
            myglobs.bInitialized = FALSE;
            RELEASE(myglobs.view);
            RELEASE(myglobs.dev);
            RELEASE(lpD3DRM);
            RELEASE(lpDDClipper);
            PostQuitMessage(0);
            break;

        default:
            return DefWindowProc(win, msg, wparam, lparam);
    }
    return 0L;
}
</pre>



<h2><a name="Related_Topics">Related Topics</a></h2>
<p>Now that you are familiar with the basics of creating objects and putting something on the screen using Direct3D Retained Mode, the code in the Direct3D Retained Mode samples should be easier to understand. Nearly all of these samples use the helper code provided by <A href="samples.htm#RM_samples_misc_rmmain">RMMain</A> to create a device and render a scene. They each provide their own <b>BuildScene</b> function to create unique scenes.

<p>As a next step, you can look at the <A HREF="FrameHierarchy.htm">RMBegin2</A> sample, which extends the functionality provided by RMBegin1. You could also look at some of the Direct3D Retained Mode samples, such as <a href="samples.htm#RM_samples_Egg">Egg</a> or <a href="samples.htm#RM_samples_Globe">Globe</a>, that provide functionality similar to RMBegin1.

<p>For information about another common task in Direct3D Retained Mode, see <a href="enumdevices.htm">Enumerating Devices: The RMEnum Sample</a>, which provides a walkthrough of the RMEnum sample code. RMEnum focuses on how to enumerate devices.

<p>For brief summaries of all of the Retained Mode samples, see <a href="samples.htm">Samples</a>.
<!-- CONTENTS_END -->

<!-- START_PAGE_FOOTER -->


<H5><HR size=1></H5>
<P><A class="line" HREF="#pagetop"><IMG src="../art/arrowup1.gif" WIDTH="11" HEIGHT="11" ALIGN="MIDDLE" BORDER=0 ALT="Top of Page">&nbsp;Top of Page</A>
<BR><A Class="line" HREF="../../cpyright.htm">&#169; 1998 Microsoft Corporation. All rights reserved. Terms of Use.</A>
<!-- END_PAGE_FOOTER -->

</BLOCKQUOTE>

<SCRIPT LANGUAGE="JAVASCRIPT">if((g_isIE == true) && (g_iMaj > 3)) {window.self.document.writeln('<SCR' + 'IPT SRC="../tip2.js"></SCR' + 'IPT><IFRAME ID="G_L_S" NAME="SecretBuffer" STYLE="display: none" SRC=""></IFRAME>')}</SCRIPT>

<!-- DACONTROL_START -->

	<DIV ID="HeadGraphAnim"></DIV>
	<SCRIPT LANGUAGE="JAVASCRIPT">if((g_isIE == true) && (g_iMaj > 3)) {window.self.document.writeln('<SCR' + 'IPT SRC="../anim.js"></SCR' + 'IPT>')}</SCRIPT>
<!-- DACONTROL_END -->

</BODY>
</HTML>
