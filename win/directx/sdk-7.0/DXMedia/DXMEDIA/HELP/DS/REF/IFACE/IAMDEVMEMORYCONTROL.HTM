<!-- DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN" -->

<HTML>
<HEAD><TITLE>IAMDevMemoryControl Interface</TITLE>
<SCRIPT> var sRelPath = '../../' </SCRIPT>


<META NAME="Description" CONTENT="IAMDevMemoryControl Interface">
<META NAME="Description" CONTENT="IAMDevMemoryControl::GetDevId">
<META NAME="Description" CONTENT="IAMDevMemoryControl::QueryWriteSync">
<META NAME="Description" CONTENT="IAMDevMemoryControl::WriteSync">
<META NAME="Description" CONTENT="GetDevId (IAMDevMemoryControl)">
<META NAME="Description" CONTENT="QueryWriteSync (IAMDevMemoryControl)">
<META NAME="Description" CONTENT="WriteSync (IAMDevMemoryControl)">
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; CHARSET=iso8859-1">
<META NAME="MS.LOCALE" CONTENT="EN-US">
<META NAME="ROBOTS" CONTENT="all">

<!-- SNIFF_START -->

<SCRIPT LANGUAGE="JAVASCRIPT">
//<!--
var g_isIE = false, g_isNav = false, g_iMaj = 0, g_sPlat = "";
// -->

</SCRIPT>
<SCRIPT SRC="../../ver.js"></SCRIPT>
<SCRIPT SRC="../../gloss.js"></SCRIPT>

<!-- SNIFF_END -->


<SCRIPT DEFER SRC="../../common.js"></SCRIPT>
<SCRIPT DEFER>
//<!--
function InitPage()
{
	if (g_isIE && g_iMaj >= 4)	
	{

		SetTOC();
	}
}
//-->

</SCRIPT>

<!-- SNIFF_END -->


<!-- STYLE_START -->

<SCRIPT LANGUAGE="JAVASCRIPT">
//<!--
   var sVR = '../../'	// Set root for the style sheet
   var sCSS = '<LINK REL="stylesheet" HREF="' + sVR;

   if(g_isIE)
   {
	   if (g_iMaj >= 4) // For MSIE 4.0 or later
	   {
		   sCSS += 'dxm_basicsdkIE4';
		   if (g_sPlat == "Win") // Windows only for now
		   {
			   document.createStyleSheet(sVR + 'dxm_advSDKIE4.css');
		   }
	   }
	   else // For MSIE 3.0 or earlier
	   {
		   sCSS += 'dxm_basicsdkIE3';
	   }
   }
   else if (g_isNav) // For all Nav versions
   {
	   sCSS += 'dxm_basicsdkNAV';
   }
   else
   {
	   sCSS += 'dxm_basicsdkIE3'; // default to IE3 sheet
   }

   sCSS += (sCSS == '' ? '' : '.css" TYPE="text/css">');

   document.write(sCSS);
//-->

</SCRIPT>
<!-- STYLE_END -->


</HEAD>
<BODY onload="InitPage(); if (g_isIE && g_iMaj >= 4){HdgrphControl()}" BGCOLOR="#FFFFFF">
<A NAME="pagetop"></A><A NAME="IAMDevMemoryControl"></A>

<!-- HEADGRAPH_START -->

<TABLE CLASS="main" BORDER=0 CELLSPACING="0" CELLPADDING="0" WIDTH="*">
<TR>
<TD ROWSPAN="3" VALIGN="TOP" WIDTH="*">
<IMG SRC="../../art/header1.gif" WIDTH="107" HEIGHT="110" BORDER=0 ALT="DirectShow Animated Header"></TD>
<TD ROWSPAN="2" VALIGN="TOP" WIDTH="217"><IMG SRC="../../art/hdrdshow.gif" WIDTH="217" HEIGHT="110" BORDER=0 ALT="DirectShow Animated Header"></TD>
<TD VALIGN="TOP" WIDTH="383">
<IMG SRC="../../art/header3.gif" WIDTH="383" HEIGHT="95" BORDER=0 ALT="DirectShow Animated Header">
</TD>
<TD VALIGN="TOP" WIDTH="100%">
<IMG SRC="../../art/spacer1.gif" WIDTH="100%" HEIGHT="94" BORDER=0 ALT="Microsoft DirectShow SDK">
</TD>
</TR>
<!-- HEADGRAPH_END -->

<!-- NAV_LINKS_START -->

<TR><TD VALIGN="TOP"><PRE><IMG ID="TOC_" SRC="../../art/yelbtn.gif" WIDTH="11" HEIGHT="11" ALIGN="MIDDLE" BORDER=0 ALT="*"><A STYLE="color:black;font-weight:bold" ID="TOC" HREF="../../contents.htm">Contents</A>  <IMG SRC="../../art/yelbtn.gif" WIDTH="11" HEIGHT="11" ALIGN="MIDDLE" BORDER=0 ALT="*"><A STYLE="color:black;font-weight:bold" HREF="../../index.htm">Index</A>  <IMG SRC="../../art/yelbtn.gif" WIDTH="11" HEIGHT="11" ALIGN="MIDDLE" BORDER=0 ALT="*"><A STYLE="color:black;font-weight:bold" HREF="ifaces_intro.htm">Topic Contents</A>
</PRE></TD></TR>
<TR><TD COLSPAN="2" VALIGN="TOP"><PRE><IMG SRC="../../art/yelbtn.gif" WIDTH="11" HEIGHT="11" ALIGN="MIDDLE" BORDER=0 ALT="*"><B>Previous Topic:</B> <A STYLE="color:black" HREF="IAMDevMemoryAllocator.htm">IAMDevMemoryAllocator Interface</A>
<IMG SRC="../../art/yelbtn.gif" WIDTH="11" HEIGHT="11" ALIGN="MIDDLE" BORDER=0 ALT="*"><B>Next Topic:</B> <A  STYLE="color:black" HREF="IAMDirectSound.htm">IAMDirectSound Interface</A>
</PRE></TD></TR></TABLE>
<!-- NAV_LINKS_END -->


<BLOCKQUOTE CLASS="body">


<!-- CONTENTS_START -->

<H1>IAMDevMemoryControl Interface</H1>

<P>The <B>IAMDevMemoryControl</B> interface controls and identifies the on-board memory of <A CLASS="Glossary" HREF="javascript:Glossary(sRelPath + 'gloss/gloss_C.htm#codec')">codecs</A>. A device memory control object supports this interface. This object is aggregated with an <A HREF="IMemAllocator.htm">IMemAllocator</A> object that is used in the connection. Typically, <A CLASS="Glossary" HREF="javascript:Glossary(sRelPath + 'gloss/gloss_f.htm#filter')">filters</A> will call the <A HREF="IAMDevMemoryAllocator.htm#GetDevMemoryObject">IAMDevMemoryAllocator::GetDevMemoryObject</A> method to obtain a pointer to this interface.

<P CLASS="ref"><A NAME="When_to_Implement">When to Implement</A></P>

<P>Implement this interface with the <A HREF="IAMDevMemoryAllocator.htm">IAMDevMemoryAllocator</A> interface when pins need to have greater control of memory allocation.


<P CLASS="ref"><A NAME="When_to_Use">When to Use</A></P>

<P>Use this interface to synchronize the completion of writing data to a memory allocator, and to get the device ID of the on-board memory allocator.

<P CLASS="ref"><A NAME="Methods_in_Vtable_Or">Methods in Vtable Order</A></P>

<TABLE>
<TR><TH>IUnknown methods</TH><TH>Description</TH></TR><TR><TD><A HREF="IUnknown.htm#QueryInterface">QueryInterface</A>
 </TD><TD>Retrieves pointers to supported interfaces.
 </TD></TR><TR><TD><A HREF="IUnknown.htm#AddRef">AddRef</A>
 </TD><TD>Increments the reference count.
 </TD></TR><TR><TD><A HREF="IUnknown.htm#Release">Release</A>
 </TD><TD>Decrements the reference count.
</TD></TR><TR></TR>
<TR><TH>IAMDevMemoryControl methods</TH><TH>Description</TH></TR>
<TR><TD><A HREF="IAMDevMemoryControl.htm#QueryWriteSync">QueryWriteSync</A>
 </TD><TD>Checks if the memory supported by the allocator requires the use of the <A HREF="IAMDevMemoryControl.htm#WriteSync">WriteSync</A> method.
 </TD></TR><TR><TD><A HREF="IAMDevMemoryControl.htm#WriteSync">WriteSync</A>
 </TD><TD>Used to synchronize with the completed write operation by returning when any data being written to the specified allocator region is fully written into the memory.
 </TD></TR><TR><TD><A HREF="IAMDevMemoryControl.htm#GetDevId">GetDevId</A>
 </TD><TD>Retrieves the device ID of the on-board memory allocator.
</TD></TR></TABLE>



<H1><A NAME="GetDevId">IAMDevMemoryControl::GetDevId</A><HR size=1></H1>
<A HREF="IAMDevMemoryControl.htm">IAMDevMemoryControl Interface</A>
<P>Retrieves the device ID of the on-board memory allocator.

<P CLASS="ref">Syntax</P><BLOCKQUOTE><PRE><P><B>HRESULT</B> <B>GetDevId</B><B>(</B><BR>&nbsp;&nbsp;<B>DWORD</B> <I>*pdwDevId</I><BR>&nbsp;&nbsp;<B>)</B><B>;</B><BR></PRE></BLOCKQUOTE>

<P CLASS="ref">Parameters</P>
<BLOCKQUOTE><DL><DT><I>pdwDevId</I>
 </DT><DD>[out] Pointer to the device ID.
</DD></DL></BLOCKQUOTE>

<P CLASS="ref">Return Value</P>
<BLOCKQUOTE><P>Returns an <A HREF="../Error_Success_Codes.htm#HRESULT">HRESULT</A> value that depends on the implementation of the interface.</BLOCKQUOTE>


<P CLASS="ref">Remarks</P>
<BLOCKQUOTE><P>This method retrieves a unique ID that the hardware filter can use to verify that the specified allocator passed uses its on-board memory (because there can be more than one). The ID will be the same one as used to create the allocator object (using <B>CoCreateInstance</B>). For another filter to be able to use the on-board memory, it must have the same device ID as the on-board memory allocator.</BLOCKQUOTE>



<H1><A NAME="QueryWriteSync">IAMDevMemoryControl::QueryWriteSync</A><HR size=1></H1>
<A HREF="IAMDevMemoryControl.htm">IAMDevMemoryControl Interface</A>
<P>Checks if the memory supported by the allocator requires the use of the <A HREF="IAMDevMemoryControl.htm#WriteSync">IAMDevMemoryControl::WriteSync</A> method.

<P CLASS="ref">Syntax</P><BLOCKQUOTE><PRE><P><B>HRESULT</B> <B>QueryWriteSync</B><B>(</B> <B>)</B><B>;</B><BR></PRE></BLOCKQUOTE>
<P CLASS="ref">Return Value</P>
<BLOCKQUOTE><P>Returns S_OK if the method is required, or S_FALSE otherwise.</BLOCKQUOTE>


<P CLASS="ref">Remarks</P>
<BLOCKQUOTE><P>Not all on-board memory needs to have <A HREF="IAMDevMemoryControl.htm#WriteSync">WriteSync</A> called to synchronize with the completed write. This method is used to check if the call is necessary.</BLOCKQUOTE>


<H1><A NAME="WriteSync">IAMDevMemoryControl::WriteSync</A><HR size=1></H1>
<A HREF="IAMDevMemoryControl.htm">IAMDevMemoryControl Interface</A>
<P>Used to synchronize with the completed write. This method returns when any data being written to the particular allocator region is fully written into the memory.

<P CLASS="ref">Syntax</P><BLOCKQUOTE><PRE><P><B>HRESULT</B> <B>WriteSync</B><B>(</B> <B>)</B><B>;</B><BR></PRE></BLOCKQUOTE>
<P CLASS="ref">Return Value</P>
<BLOCKQUOTE><P>Returns an <A HREF="../Error_Success_Codes.htm#HRESULT">HRESULT</A> value that depends on the implementation of the interface. Common return values include:
<TABLE>
<TR><TD>E_FAIL</TD><TD>A time-out has occurred without this method confirming that data was written.
</TD></TR><TR><TD>S_OK </TD><TD>The data was successfully written into memory.
</TD></TR><TR><TD><A HREF="../Error_Success_Codes.htm#VFW_E_NOT_COMMITTED">VFW_E_NOT_COMMITTED</A>
 </TD><TD>The allocator hasn't called the <A HREF="IMemAllocator.htm#Commit">IMemAllocator::Commit</A> method.
</TD></TR></TABLE></BLOCKQUOTE>


<P CLASS="ref">Remarks</P>
<BLOCKQUOTE><P>This method guarantees that all prior write operations to allocated memory have succeeded. Subsequent memory write operations require another call to <B>WriteSync</B>.

<P>This method is implementation dependent, and is used (when necessary) to synchronize memory write operations to the memory. The driver of the on-board memory provides the implementation.

<P>The <A HREF="IAMDevMemoryControl.htm">IAMDevMemoryControl</A> interface is typically found on memory that is accessed through a Peripheral Component Interconnect (PCI) bridge. (A PCI is a local bus for personal computers that provides a high-speed data path between the processor and peripheral devices.) Memory behind a PCI bridge must be synchronized after a memory write operation completes, if another device will access that memory from behind the PCI bridge. This is because the host access to the memory is buffered through the PCI bridge FIFO (first in first out), and the host will assume the write is completed before the bridge actually writes the data. A subsequent action by a device behind the bridge, such as a SCSI controller, might read the memory before the write is completed, if the <B>IAMDevMemoryControl::WriteSync</B> method is not called.</BLOCKQUOTE> 

<!-- CONTENTS_END -->

<!-- START_PAGE_FOOTER -->


<H6><HR size=1></H6>
<P><A Class="line" HREF="#pagetop"><IMG src="../../art/arrowup1.gif" WIDTH="11" HEIGHT="11" ALIGN="MIDDLE" BORDER=0 ALT="Top of Page">&nbsp;Top of Page</A>
<BR><A Class="line" HREF="../../../cpyright.htm">&#169; 1998 Microsoft Corporation. All rights reserved. Terms of Use.</A>
<!-- END_PAGE_FOOTER -->

</BLOCKQUOTE>

<SCRIPT>if((g_isIE == true) && (g_iMaj > 3)) {window.self.document.writeln('<SCR' + 'IPT SRC="../../tip2.js"></SCR' + 'IPT><IFRAME ID="G_L_S" NAME="SecretBuffer" STYLE="display: none" SRC=""></IFRAME>')}</SCRIPT>

<!-- DACONTROL_START -->

	<DIV ID="HeadGraphAnim"></DIV>
	<SCRIPT>if((g_isIE == true) && (g_iMaj > 3)) {window.self.document.writeln('<SCR' + 'IPT SRC="../../anim.js"></SCR' + 'IPT>')}</SCRIPT>
<!-- DACONTROL_END -->

</BODY>
</HTML>
