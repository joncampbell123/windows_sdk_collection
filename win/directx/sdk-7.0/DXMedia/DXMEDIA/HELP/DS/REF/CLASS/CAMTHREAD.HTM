<!-- DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN" -->

<HTML>
<HEAD><TITLE>CAMThread Class</TITLE>
<SCRIPT> var sRelPath = '../../' </SCRIPT>


<META NAME="Description" CONTENT="CAMThread Class">
<META NAME="Description" CONTENT="CallWorker (CAMThread)">
<META NAME="Description" CONTENT="CAMThread::CallWorker">
<META NAME="Description" CONTENT="CAMThread (CAMThread)">
<META NAME="Description" CONTENT="CAMThread::CAMThread">
<META NAME="Description" CONTENT="CheckRequest (CAMThread)">
<META NAME="Description" CONTENT="CAMThread::CheckRequest">
<META NAME="Description" CONTENT="Close (CAMThread)">
<META NAME="Description" CONTENT="CAMThread::Close">
<META NAME="Description" CONTENT="Create (CAMThread)">
<META NAME="Description" CONTENT="CAMThread::Create">
<META NAME="Description" CONTENT="GetRequest (CAMThread)">
<META NAME="Description" CONTENT="CAMThread::GetRequest">
<META NAME="Description" CONTENT="GetRequestHandle (CAMThread)">
<META NAME="Description" CONTENT="CAMThread::GetRequestHandle">
<META NAME="Description" CONTENT="GetRequestParam (CAMThread)">
<META NAME="Description" CONTENT="CAMThread::GetRequestParam">
<META NAME="Description" CONTENT="InitialThreadProc (CAMThread)">
<META NAME="Description" CONTENT="CAMThread::InitialThreadProc">
<META NAME="Description" CONTENT="Reply (CAMThread)">
<META NAME="Description" CONTENT="CAMThread::Reply">
<META NAME="Description" CONTENT="ThreadExists (CAMThread)">
<META NAME="Description" CONTENT="CAMThread::ThreadExists">
<META NAME="Description" CONTENT="ThreadProc (CAMThread)">
<META NAME="Description" CONTENT="CAMThread::ThreadProc">
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; CHARSET=iso8859-1">
<META NAME="MS.LOCALE" CONTENT="EN-US">
<META NAME="ROBOTS" CONTENT="all">

<!-- SNIFF_START -->

<SCRIPT>
//<!--
var g_isIE = false, g_isNav = false, g_iMaj = 0, g_sPlat = "";
// -->

</SCRIPT>
<SCRIPT SRC="../../ver.js"></SCRIPT>
<SCRIPT SRC="../../gloss.js"></SCRIPT>

<!-- SNIFF_END -->


<SCRIPT DEFER SRC="../../common.js"></SCRIPT>
<SCRIPT DEFER>
//<!--
function InitPage()
{
	if (g_isIE && g_iMaj >= 4)	
	{

		SetTOC();
	}
}
//-->

</SCRIPT>

<!-- SNIFF_END -->


<!-- STYLE_START -->

<SCRIPT>
//<!--
   var sVR = '../../'	// Set root for the style sheet
   var sCSS = '<LINK REL="stylesheet" HREF="' + sVR;

   if(g_isIE)
   {
	   if (g_iMaj >= 4) // For MSIE 4.0 or later
	   {
		   sCSS += 'dxm_basicsdkIE4';
		   if (g_sPlat == "Win") // Windows only for now
		   {
			   document.createStyleSheet(sVR + 'dxm_advSDKIE4.css');
		   }
	   }
	   else // For MSIE 3.0 or earlier
	   {
		   sCSS += 'dxm_basicsdkIE3';
	   }
   }
   else if (g_isNav) // For all Nav versions
   {
	   sCSS += 'dxm_basicsdkNAV';
   }
   else
   {
	   sCSS += 'dxm_basicsdkIE3'; // default to IE3 sheet
   }

   sCSS += (sCSS == '' ? '' : '.css" TYPE="text/css">');

   document.write(sCSS);
//-->

</SCRIPT>
<!-- STYLE_END -->


</HEAD>
<BODY onload="InitPage(); if (g_isIE && g_iMaj >= 4){HdgrphControl()}" BGCOLOR="#FFFFFF">
<A NAME="pagetop"></A><A NAME="CAMThread"></A>

<!-- HEADGRAPH_START -->

<TABLE CLASS="main" BORDER=0 CELLSPACING="0" CELLPADDING="0" WIDTH="*">
<TR>
<TD ROWSPAN="3" VALIGN="TOP" WIDTH="*">
<IMG SRC="../../art/header1.gif" WIDTH="107" HEIGHT="110" BORDER=0 ALT="DirectShow Animated Header"></TD>
<TD ROWSPAN="2" VALIGN="TOP" WIDTH="217"><IMG SRC="../../art/hdrdshow.gif" WIDTH="217" HEIGHT="110" BORDER=0 ALT="DirectShow Animated Header"></TD>
<TD VALIGN="TOP" WIDTH="383">
<IMG SRC="../../art/header3.gif" WIDTH="383" HEIGHT="95" BORDER=0 ALT="DirectShow Animated Header">
</TD>
<TD VALIGN="TOP" WIDTH="100%">
<IMG SRC="../../art/spacer1.gif" WIDTH="100%" HEIGHT="94" BORDER=0 ALT="Microsoft DirectShow SDK">
</TD>
</TR>
<!-- HEADGRAPH_END -->

<!-- NAV_LINKS_START -->

<TR><TD VALIGN="TOP"><PRE><IMG ID="TOC_" SRC="../../art/yelbtn.gif" WIDTH="11" HEIGHT="11" ALIGN="MIDDLE" BORDER=0 ALT="*"><A STYLE="color:black;font-weight:bold" ID="TOC" HREF="../../contents.htm">Contents</A>  <IMG SRC="../../art/yelbtn.gif" WIDTH="11" HEIGHT="11" ALIGN="MIDDLE" BORDER=0 ALT="*"><A STYLE="color:black;font-weight:bold" HREF="../../index.htm">Index</A>  <IMG SRC="../../art/yelbtn.gif" WIDTH="11" HEIGHT="11" ALIGN="MIDDLE" BORDER=0 ALT="*"><A STYLE="color:black;font-weight:bold" HREF="Classes_intro.htm">Topic Contents</A>
</PRE></TD></TR>
<TR><TD COLSPAN="2" VALIGN="TOP"><PRE><IMG SRC="../../art/yelbtn.gif" WIDTH="11" HEIGHT="11" ALIGN="MIDDLE" BORDER=0 ALT="*"><B>Previous Topic:</B> <A STYLE="color:black" HREF="CAMSchedule.htm">CAMSchedule Class</A>
<IMG SRC="../../art/yelbtn.gif" WIDTH="11" HEIGHT="11" ALIGN="MIDDLE" BORDER=0 ALT="*"><B>Next Topic:</B> <A  STYLE="color:black" HREF="CAutoLock.htm">CAutoLock Class</A>
</PRE></TD></TR></TABLE>
<!-- NAV_LINKS_END -->


<BLOCKQUOTE CLASS="body">


<!-- CONTENTS_START -->

<H1>CAMThread Class</H1>

<P><IMG SRC="../../art/util04.gif" WIDTH="179" HEIGHT="24" ALT="CAMThread class hierarchy">

<P><B>CAMThread</B> is an abstract class, a worker thread class that provides creation,
synchronization, and communication with a worker thread. The worker thread can be
accessed from several client threads.
The class provides member functions to create the thread, pass commands to it,
and wait for it to exit.

<P>Use a <A HREF="CCritSec.htm">CCritSec</A> object to ensure that only one thread can make a request at a time.
Use two <A HREF="CAMEvent.htm">CAMEvent</A> objects: one to signal to the worker that a request is
outstanding, and the other to signal to the client thread that the request
has been completed. A nonblocking <A HREF="CAMThread.htm#CheckRequest">CAMThread::CheckRequest</A>
member function allows the worker
thread to check for new requests while working asynchronously.

<P>Derive from this class to provide your own thread member function. You might also want to
provide type-safe
signaling member functions that package parameters and return values using the <A HREF="CAMThread.htm#CallWorker">CAMThread::CallWorker</A> member function.

<P>Thread creation is independent of object creation. Create a member variable derived from <B>CAMThread</B>,
and then use the member functions to start and stop the thread when needed.

<P CLASS="ref"><A NAME="Data_Members"></A>Data Members</P>

<TABLE><TR><TD><B><A NAME="m_AccessLock">m_AccessLock</A></B>
 </TD><TD>Critical section object that locks access by client threads.
</TD></TR><TR><TD><B><A NAME="m_WorkerLock">m_WorkerLock</A></B>
 </TD><TD>Critical section object that locks access to shared objects.
</TD></TR></TABLE>
<A NAME="Member_Functions"></A><P CLASS="ref">Member Functions</P>

<TABLE><TR><TD><A HREF="CAMThread.htm#CallWorker">CallWorker</A>
 </TD><TD>Makes a request to the worker thread.
</TD></TR><TR><TD><A HREF="CAMThread.htm#CAMThread_CAMThread">CAMThread</A>
 </TD><TD>Constructs a <A HREF="CAMThread.htm">CAMThread</A> object.
</TD></TR><TR><TD><A HREF="CAMThread.htm#CheckRequest">CheckRequest</A>
 </TD><TD>Determines if there is an outstanding request. This is a nonblocking member function.
</TD></TR><TR><TD><A HREF="CAMThread.htm#Close">Close</A>
 </TD><TD>Blocks until the thread has exited and released its resources.
</TD></TR><TR><TD><A HREF="CAMThread.htm#Create">Create</A>
 </TD><TD>Starts the thread running.
</TD></TR><TR><TD><A HREF="CAMThread.htm#GetRequest">GetRequest</A>
 </TD><TD>Blocks until the next request is made and then returns a <A HREF="../../appendixes/Further_Reading.htm#DWORD">DWORD</A> value.
</TD></TR><TR><TD><A HREF="CAMThread.htm#GetRequestHandle">GetRequestHandle</A>
 </TD><TD>Retrieves an event handle.
</TD></TR><TR><TD><A HREF="CAMThread.htm#GetRequestParam">GetRequestParam</A>
 </TD><TD>Retrieves the latest request.
</TD></TR><TR><TD><A HREF="CAMThread.htm#InitialThreadProc">InitialThreadProc</A>
 </TD><TD>Retrieves a <B>this</B> pointer. Carry out this member function before calling the <A HREF="CAMThread.htm#ThreadProc">CAMThread::ThreadProc</A> member function.
</TD></TR><TR><TD><A HREF="CAMThread.htm#Reply">Reply</A>
 </TD><TD>Retrieves a <A HREF="../../appendixes/Further_Reading.htm#DWORD">DWORD</A> value to the requesting thread and releases it, signaling
 completion of the request.
</TD></TR><TR><TD><A HREF="CAMThread.htm#ThreadExists">ThreadExists</A>
 </TD><TD>Determines whether a thread exists or has exited.
</TD></TR><TR><TD><A HREF="CAMThread.htm#ThreadProc">ThreadProc</A>
 </TD><TD>Indicates a pure virtual member function that is called on the worker thread.
</TD></TR></TABLE>



<H1><A NAME="CallWorker">CAMThread::CallWorker</A><HR size=1></H1>
<A HREF="CAMThread.htm">CAMThread Class</A>
<P>Makes a request to the worker thread and blocks for a response.

<P CLASS="ref">Syntax</P><BLOCKQUOTE><PRE><P><B>DWORD</B> <B>CallWorker</B><B>(</B><BR>&nbsp;&nbsp;<B>DWORD</B> <I>dw</I><BR>&nbsp;&nbsp;<B>)</B><B>;</B><BR></PRE></BLOCKQUOTE>

<P CLASS="ref">Parameters</P>
<BLOCKQUOTE>
<DL><DT><I>dw</I>
 </DT><DD>Derived class defines the meaning of the parameter.
</DD></DL>
</BLOCKQUOTE>

<P CLASS="ref">Return Value</P>
<BLOCKQUOTE>
<P>Returns a value that is defined by the derived class.

</BLOCKQUOTE>

<P CLASS="ref">Remarks</P>
<BLOCKQUOTE>
<P>This member function uses a <A HREF="CCritSec.htm">CCritSec</A> object to ensure that only one request is made at a time.
It is therefore not valid to call the <B>CAMThread::CallWorker</B> member function from the thread
itself or from
any member function that is executing in the context of the thread.

</BLOCKQUOTE>


<H1><A NAME="CAMThread_CAMThread">CAMThread::CAMThread</A><HR size=1></H1>
<A HREF="CAMThread.htm">CAMThread Class</A>
<P>Constructs a <A HREF="CAMThread.htm">CAMThread</A> object.

<P CLASS="ref">Syntax</P><BLOCKQUOTE><PRE><P><B>CAMThread</B><B>(</B> <B>)</B><B>;</B><BR></PRE></BLOCKQUOTE>

<P CLASS="ref">Return Value</P>
<BLOCKQUOTE>
<P>No return value.
</BLOCKQUOTE>

<P CLASS="ref">Remarks</P>
<BLOCKQUOTE>
<P>Creates a <A HREF="CAMThread.htm">CAMThread</A> object but does not create an actual thread. You call the <A HREF="CAMThread.htm#Create">CAMThread::Create</A> member function to create a thread.

</BLOCKQUOTE>


<H1><A NAME="CheckRequest">CAMThread::CheckRequest</A><HR size=1></H1>
<A HREF="CAMThread.htm">CAMThread Class</A>
<P>Determines if there is an outstanding request. This is a nonblocking member function.

<P CLASS="ref">Syntax</P><BLOCKQUOTE><PRE><P><B>BOOL</B> <B>CheckRequest</B><B>(</B><BR>&nbsp;&nbsp;<B>DWORD</B> <I>*pParam</I><BR>&nbsp;&nbsp;<B>)</B><B>;</B><BR></PRE></BLOCKQUOTE>

<P CLASS="ref">Parameters</P>
<BLOCKQUOTE>
<DL><DT><I>pParam</I>
 </DT><DD>Parameter that assumes the value passed by the last call to the 
<A HREF="CAMThread.htm#CallWorker">CAMThread::CallWorker</A> member function.
</DD></DL>
</BLOCKQUOTE>

<P CLASS="ref">Return Value</P>
<BLOCKQUOTE>
<P>Returns TRUE if an outstanding request is still active, or FALSE is no request is active.

</BLOCKQUOTE>

<P CLASS="ref">Remarks</P>
<BLOCKQUOTE>
<P>If there is an outstanding request, the requesting thread will block until the <A HREF="CAMThread.htm#GetRequest">CAMThread::GetRequest</A> member function is called. The request remains outstanding (that is, this member function continues to return TRUE) until either the <A HREF="CAMThread.htm#Reply">CAMThread::Reply</A> or <B>CAMThread::GetRequest</B> member function is called.
</BLOCKQUOTE>


<H1><A NAME="Close">CAMThread::Close</A><HR size=1></H1>
<A HREF="CAMThread.htm">CAMThread Class</A>
<P>Blocks until the thread has exited and released its resources.

<P CLASS="ref">Syntax</P><BLOCKQUOTE><PRE><P><B>void</B> <B>Close</B><B>(</B><B>void</B><B>)</B><B>;</B><BR></PRE></BLOCKQUOTE>

<P CLASS="ref">Return Value</P>
<BLOCKQUOTE>
<P>No return value.
</BLOCKQUOTE>

<P CLASS="ref">Remarks</P>
<BLOCKQUOTE>
<P>You must instruct the thread to exit by some other means; for example, call the <A HREF="CAMThread.htm#CallWorker">CAMThread::CallWorker</A> member function with a request that is
interpreted by the derived class to mean complete and exit.

<P>If the thread is still running when the <A HREF="CAMThread.htm">CAMThread</A> object is destroyed, the <B>CAMThread::Close</B> member function is called internally.

</BLOCKQUOTE>


<H1><A NAME="Create">CAMThread::Create</A><HR size=1></H1>
<A HREF="CAMThread.htm">CAMThread Class</A>
<P>Starts the thread running.

<P CLASS="ref">Syntax</P><BLOCKQUOTE><PRE><P><B>BOOL</B> <B>Create</B><B>(</B><B>void</B><B>)</B><B>;</B><BR></PRE></BLOCKQUOTE>

<P CLASS="ref">Return Value</P>
<BLOCKQUOTE>
<P>Returns TRUE if the thread started successfully, or FALSE if the thread is already running.

</BLOCKQUOTE>

<P CLASS="ref">Remarks</P>
<BLOCKQUOTE>
<P>This member function creates the thread and calls the <A HREF="CAMThread.htm#ThreadProc">CAMThread::ThreadProc</A> member function from the derived class.
</BLOCKQUOTE>


<H1><A NAME="GetRequest">CAMThread::GetRequest</A><HR size=1></H1>
<A HREF="CAMThread.htm">CAMThread Class</A>
<P>Blocks until the next request is made.

<P CLASS="ref">Syntax</P><BLOCKQUOTE><PRE><P><B>DWORD</B> <B>GetRequest</B><B>(</B> <B>)</B><B>;</B><BR></PRE></BLOCKQUOTE>

<P CLASS="ref">Return Value</P>
<BLOCKQUOTE>
<P>Returns a value that is defined by the derived class.

</BLOCKQUOTE>

<P CLASS="ref">Remarks</P>
<BLOCKQUOTE>
<P>This member function blocks the requesting thread until the <A HREF="CAMThread.htm#Reply">CAMThread::Reply</A> function is called.

</BLOCKQUOTE>


<H1><A NAME="GetRequestHandle">CAMThread::GetRequestHandle</A><HR size=1></H1>
<A HREF="CAMThread.htm">CAMThread Class</A>
<P>Retrieves an event handle for performance improvements.

<P CLASS="ref">Syntax</P><BLOCKQUOTE><PRE><P><B>HANDLE</B> <B>GetRequestHandle</B><B>(</B> <B>)</B> <B>const;</B><BR></PRE></BLOCKQUOTE>

<P CLASS="ref">Return Value</P>
<BLOCKQUOTE>
<P>Returns an event handle.


</BLOCKQUOTE>

<P CLASS="ref">Remarks</P>
<BLOCKQUOTE>
<P>To use the Microsoft Win32 <A HREF="../../appendixes/Further_Reading.htm#WaitForMultipleObjec">WaitForMultipleObjects</A> function, you will need
this handle in the thread's wait list or the thread will not be responsive.

</BLOCKQUOTE>


<H1><A NAME="GetRequestParam">CAMThread::GetRequestParam</A><HR size=1></H1>
<A HREF="CAMThread.htm">CAMThread Class</A>
<P>Retrieves the most recent request.

<P CLASS="ref">Syntax</P><BLOCKQUOTE><PRE><P><B>DWORD</B> <B>GetRequestParam</B><B>(</B> <B>)</B> <B>const;</B><BR></PRE></BLOCKQUOTE>

<P CLASS="ref">Return Value</P>
<BLOCKQUOTE>
<P>Returns a <A HREF="../../appendixes/Further_Reading.htm#DWORD">DWORD</A> value that indicates the request made previously by the <A HREF="CAMThread.htm#GetRequest">CAMThread::GetRequest</A> member function.

</BLOCKQUOTE>


<H1><A NAME="InitialThreadProc">CAMThread::InitialThreadProc</A><HR size=1></H1>
<A HREF="CAMThread.htm">CAMThread Class</A>
<P>Receives a <B>this</B> pointer and calls the <A HREF="CAMThread.htm#ThreadProc">CAMThread::ThreadProc</A> member function.
<P CLASS="ref">Syntax</P><BLOCKQUOTE><PRE>
<P><B>DWORD</B> <B>InitialThreadProc</B><B>(</B><BR>&nbsp;&nbsp;<B>LPVOID</B> <I>pv</I><BR>&nbsp;&nbsp;<B>)</B><B>;</B><BR></PRE></BLOCKQUOTE>

<P CLASS="ref">Parameters</P>
<BLOCKQUOTE>
<DL><DT><I>pv</I>
 </DT><DD>The <B>this</B> pointer.
</DD></DL>
</BLOCKQUOTE>

<P CLASS="ref">Return Value</P>
<BLOCKQUOTE>
<P>Returns the <A HREF="../../appendixes/Further_Reading.htm#DWORD">DWORD</A> returned by <A HREF="CAMThread.htm#ThreadProc">CAMThread::ThreadProc</A>. This <B>DWORD</B>
is not defined by this class.


</BLOCKQUOTE>


<H1><A NAME="Reply">CAMThread::Reply</A><HR size=1></H1>
<A HREF="CAMThread.htm">CAMThread Class</A>
<P>Retrieves a <A HREF="../../appendixes/Further_Reading.htm#DWORD">DWORD</A> value to the requesting thread and releases it, signaling completion of the request.

<P CLASS="ref">Syntax</P><BLOCKQUOTE><PRE><P><B>void</B> <B>Reply</B><B>(</B><BR>&nbsp;&nbsp;<B>DWORD</B> <I>dw</I><BR>&nbsp;&nbsp;<B>)</B><B>;</B><BR></PRE></BLOCKQUOTE>

<P CLASS="ref">Parameters</P>
<BLOCKQUOTE>
<DL><DT><I>dw</I>
 </DT><DD>Value returned by the <A HREF="CAMThread.htm#CallWorker">CAMThread::CallWorker</A> member function on the client side.
</DD></DL>
</BLOCKQUOTE>

<P CLASS="ref">Return Value</P>
<BLOCKQUOTE>
<P>No return value.
</BLOCKQUOTE>


<H1><A NAME="ThreadExists">CAMThread::ThreadExists</A><HR size=1></H1>
<A HREF="CAMThread.htm">CAMThread Class</A>
<P>Determines whether the thread has been created and has not yet exited.

<P CLASS="ref">Syntax</P><BLOCKQUOTE><PRE><P><B>BOOL</B> <B>ThreadExists</B><B>(</B> <B>)</B><B>;</B><BR></PRE></BLOCKQUOTE>

<P CLASS="ref">Return Value</P>
<BLOCKQUOTE>
<P>Returns TRUE if the thread exists and hasn't exited, or FALSE if the thread doesn't exist.

</BLOCKQUOTE>


<H1><A NAME="ThreadProc">CAMThread::ThreadProc</A><HR size=1></H1>
<A HREF="CAMThread.htm">CAMThread Class</A>
<P>Overridden member function in which to implement a thread.

<P CLASS="ref">Syntax</P><BLOCKQUOTE><PRE><P><B>virtual</B> <B>DWORD</B> <B>ThreadProc</B><B>(</B> <B>)</B><B>;</B><BR></PRE></BLOCKQUOTE>

<P CLASS="ref">Return Value</P>
<BLOCKQUOTE>
<P>The meaning of this return value is not defined by the <A HREF="CAMThread.htm">CAMThread</A> class.

</BLOCKQUOTE>

<P CLASS="ref">Remarks</P>
<BLOCKQUOTE>
<P>The thread calls this member function upon startup. Derived classes must override this member function.
When this member function returns, the thread terminates.
This member function is protected.

</BLOCKQUOTE>
<!-- CONTENTS_END -->

<!-- START_PAGE_FOOTER -->


<H6><HR size=1></H6>
<P><A Class="line" HREF="#pagetop"><IMG src="../../art/arrowup1.gif" WIDTH="11" HEIGHT="11" ALIGN="MIDDLE" BORDER=0 ALT="Top of Page">&nbsp;Top of Page</A>
<BR><A Class="line" HREF="../../../cpyright.htm">&#169; 1998 Microsoft Corporation. All rights reserved. Terms of Use.</A>
<!-- END_PAGE_FOOTER -->

</BLOCKQUOTE>

<SCRIPT>if((g_isIE == true) && (g_iMaj > 3)) {window.self.document.writeln('<SCR' + 'IPT SRC="../../tip2.js"></SCR' + 'IPT><IFRAME ID="G_L_S" NAME="SecretBuffer" STYLE="display: none" SRC=""></IFRAME>')}</SCRIPT>

<!-- DACONTROL_START -->

	<DIV ID="HeadGraphAnim"></DIV>
	<SCRIPT>if((g_isIE == true) && (g_iMaj > 3)) {window.self.document.writeln('<SCR' + 'IPT SRC="../../anim.js"></SCR' + 'IPT>')}</SCRIPT>
<!-- DACONTROL_END -->

</BODY>
</HTML>
