<!-- DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN" -->

<HTML>
<HEAD><TITLE>Structures</TITLE>
<SCRIPT> var sRelPath = '../' </SCRIPT>


<META NAME="Description" CONTENT="Structures">
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; CHARSET=iso8859-1">
<META NAME="MS.LOCALE" CONTENT="EN-US">
<META NAME="ROBOTS" CONTENT="all">

<!-- SNIFF_START -->

<SCRIPT>
//<!--
var g_isIE = false, g_isNav = false, g_iMaj = 0, g_sPlat = "";
// -->

</SCRIPT>
<SCRIPT SRC="../ver.js"></SCRIPT>
<SCRIPT SRC="../gloss.js"></SCRIPT>

<!-- SNIFF_END -->


<SCRIPT DEFER SRC="../common.js"></SCRIPT>
<SCRIPT DEFER>
//<!--
function InitPage()
{
	if (g_isIE && g_iMaj >= 4)	
	{

		SetTOC();
	}
}
//-->

</SCRIPT>

<!-- SNIFF_END -->


<!-- STYLE_START -->

<SCRIPT>
//<!--
   var sVR = '../'	// Set root for the style sheet
   var sCSS = '<LINK REL="stylesheet" HREF="' + sVR;

   if(g_isIE)
   {
	   if (g_iMaj >= 4) // For MSIE 4.0 or later
	   {
		   sCSS += 'dxm_basicsdkIE4';
		   if (g_sPlat == "Win") // Windows only for now
		   {
			   document.createStyleSheet(sVR + 'dxm_advSDKIE4.css');
		   }
	   }
	   else // For MSIE 3.0 or earlier
	   {
		   sCSS += 'dxm_basicsdkIE3';
	   }
   }
   else if (g_isNav) // For all Nav versions
   {
	   sCSS += 'dxm_basicsdkNAV';
   }
   else
   {
	   sCSS += 'dxm_basicsdkIE3'; // default to IE3 sheet
   }

   sCSS += (sCSS == '' ? '' : '.css" TYPE="text/css">');

   document.write(sCSS);
//-->

</SCRIPT>
<!-- STYLE_END -->


</HEAD>
<BODY onload="InitPage(); if (g_isIE && g_iMaj >= 4){HdgrphControl()}" BGCOLOR="#FFFFFF">
<A NAME="pagetop"></A><A NAME="Structures_grp"></A>

<!-- HEADGRAPH_START -->

<TABLE CLASS="main" BORDER=0 CELLSPACING="0" CELLPADDING="0" WIDTH="*">
<TR>
<TD ROWSPAN="3" VALIGN="TOP" WIDTH="*">
<IMG SRC="../art/header1.gif" WIDTH="107" HEIGHT="110" BORDER=0 ALT="DirectShow Animated Header -- Structures"></TD>
<TD ROWSPAN="2" VALIGN="TOP" WIDTH="217"><IMG SRC="../art/hdrdshow.gif" WIDTH="217" HEIGHT="110" BORDER=0 ALT="DirectShow Animated Header -- Structures"></TD>
<TD VALIGN="TOP" WIDTH="383">
<IMG SRC="../art/header3.gif" WIDTH="383" HEIGHT="95" BORDER=0 ALT="DirectShow Animated Header">
</TD>
<TD VALIGN="TOP" WIDTH="100%">
<IMG SRC="../art/spacer1.gif" WIDTH="100%" HEIGHT="94" BORDER=0 ALT="Microsoft DirectShow SDK">
</TD>
</TR>
<!-- HEADGRAPH_END -->

<!-- NAV_LINKS_START -->

<TR><TD VALIGN="TOP"><PRE><IMG ID="TOC_" SRC="../art/yelbtn.gif" WIDTH="11" HEIGHT="11" ALIGN="MIDDLE" BORDER=0 ALT="*"><A STYLE="color:black;font-weight:bold" ID="TOC" HREF="../contents.htm">Contents</A>  <IMG SRC="../art/yelbtn.gif" WIDTH="11" HEIGHT="11" ALIGN="MIDDLE" BORDER=0 ALT="*"><A STYLE="color:black;font-weight:bold" HREF="../index.htm">Index</A>  <IMG SRC="../art/yelbtn.gif" WIDTH="11" HEIGHT="11" ALIGN="MIDDLE" BORDER=0 ALT="*"><A STYLE="color:black;font-weight:bold" HREF="cref_intro.htm">Topic Contents</A>
</PRE></TD></TR>
<TR><TD COLSPAN="2" VALIGN="TOP"><PRE><IMG SRC="../art/yelbtn.gif" WIDTH="11" HEIGHT="11" ALIGN="MIDDLE" BORDER=0 ALT="*"><B>Previous Topic:</B> <A STYLE="color:black" HREF="debug/debug_output_location.htm">Debug Output Location</A>
<IMG SRC="../art/yelbtn.gif" WIDTH="11" HEIGHT="11" ALIGN="MIDDLE" BORDER=0 ALT="*"><B>Next Topic:</B> <A  STYLE="color:black" HREF="dtypes.htm">Data Types</A>
</PRE></TD></TR></TABLE>
<!-- NAV_LINKS_END -->


<BLOCKQUOTE CLASS="body">


<!-- CONTENTS_START -->

<H1>Structures</H1>

<P>This section describes the Microsoft&#174; DirectShow&#153; structures.</P>

<BLOCKQUOTE><TABLE CLASS="ref">
<TR><TH>Structure</TH><TH>Description</TH></TR>

<TR><TD><A HREF="structs.htm#ALLOCATOR_PROPERTIES">ALLOCATOR_PROPERTIES</A> </TD><TD>Contains the allocator's count, size, alignment, and prefix properties.</TD></TR>

<TR><TD><A HREF="structs.htm#AM_DVD_RENDERSTATUS">AM_DVD_RENDERSTATUS</A></TD><TD>Contains codes indicating the status of DVD-Video playback. These codes are used in the <A HREF="iface/IDvdGraphBuilder.htm#RenderDvdVideoVolume">IDvdGraphBuilder::RenderDvdVideoVolume</A> method.
</TD></TR><TR><TD><A HREF="structs.htm#AM_MEDIA_TYPE">AM_MEDIA_TYPE</A> </TD><TD>Describes a media sample type.
</TD></TR><TR><TD><A HREF="structs.htm#AM_SAMPLE2_PROPERTIES">AM_SAMPLE2_PROPERTIES</A> </TD><TD>Describes the properties of a generic media sample. 
</TD></TR><TR><TD><A HREF="structs.htm#AMOVIESETUP_FILTER">AMOVIESETUP_FILTER</A> </TD><TD>Contains <A CLASS="Glossary" HREF="javascript:Glossary(sRelPath + 'gloss/gloss_f.htm#filter')">filter</A> information for registering a filter.
</TD></TR><TR><TD><A HREF="structs.htm#AMOVIESETUP_MEDIATYPE">AMOVIESETUP_MEDIATYPE</A> </TD><TD>Contains media type information for registering a filter.
</TD></TR><TR><TD><A HREF="structs.htm#AMOVIESETUP_PIN">AMOVIESETUP_PIN</A> </TD><TD>Contains <A CLASS="Glossary" HREF="javascript:Glossary(sRelPath + 'gloss/gloss_P.htm#pin')">pin</A> information for registering a filter.
</TD></TR><TR><TD><A HREF="structs.htm#AM_STREAM_INFO">AM_STREAM_INFO</A> </TD><TD>Contains start and stop information given to a pin.
</TD></TR><TR><TD><A HREF="structs.htm#AMVPDATAINFO">AMVPDATAINFO</A> </TD><TD>Specifies the data-specific characteristics of the VP input stream. 
</TD></TR><TR><TD><A HREF="structs.htm#AMVPDIMINFO">AMVPDIMINFO</A> </TD><TD>Specifies the dimensional characteristics of the VP input stream.
</TD></TR><TR><TD><A HREF="structs.htm#AMVPSIZE">AMVPSIZE</A> </TD><TD>Specifies the width and height for a VP image.
</TD></TR><TR><TD><A HREF="structs.htm#DVD_ATR">DVD_ATR</A> </TD><TD>Specifies DVD attributes.
</TD></TR><TR><TD><A HREF="structs.htm#DVD_PLAYBACK_LOCATION">DVD_PLAYBACK_LOCATION</A> </TD><TD>Contains the DVD playback location.
</TD></TR><TR><TD><A HREF="structs.htm#DVD_TIMECODE">DVD_TIMECODE</A> </TD><TD>Contains DVD <A CLASS="Glossary" HREF="javascript:Glossary(sRelPath + 'gloss/gloss_T.htm#timecode')">timecode</A> in hours, minutes, seconds, and frames. 
</TD></TR><TR><TD><A HREF="structs.htm#FILTER_INFO">FILTER_INFO</A> </TD><TD>Contains information about a filter.
</TD></TR><TR><TD><A HREF="structs.htm#PIN_INFO">PIN_INFO</A> </TD><TD>Contains information about a pin.
</TD></TR><TR><TD><A HREF="structs.htm#POSITION">POSITION</A> </TD><TD>Placeholder for linked lists.
</TD></TR><TR><TD><A HREF="structs.htm#Quality">Quality</A> </TD><TD>Describes a quality message by indicating Flood or Famine in the <A CLASS="Glossary" HREF="javascript:Glossary(sRelPath + 'gloss/gloss_R.htm#renderer')">renderer</A> and specifying the percentage of frames to drop or add to optimize the renderer's performance.
</TD></TR><TR><TD><A HREF="structs.htm#REGFILTER">REGFILTER</A> </TD><TD>Describes a filter in the registry.
</TD></TR><TR><TD><A HREF="structs.htm#REGFILTER2">REGFILTER2</A> </TD><TD>Describes a filter for registration through the <A HREF="iface/IFilterMapper2.htm">IFilterMapper2</A> interface.
</TD></TR><TR><TD><A HREF="structs.htm#REGFILTERPINS">REGFILTERPINS</A> </TD><TD>Contains pin information for registering a filter.
</TD></TR><TR><TD><A HREF="structs.htm#REGFILTERPINS2">REGFILTERPINS2</A> </TD><TD>Contains information for registering a filter through the <A HREF="iface/IFilterMapper2.htm">IFilterMapper2</A> interface.
</TD></TR><TR><TD><A HREF="structs.htm#REGPINMEDIUM">REGPINMEDIUM</A> </TD><TD>Describes a pin medium (as defined in the Microsoft Windows&reg; NT DDK) for registration through the <A HREF="iface/IFilterMapper2.htm">IFilterMapper2</A> interface.
</TD></TR><TR><TD><A HREF="structs.htm#REGPINTYPES">REGPINTYPES</A> </TD><TD>Contains media type information for registering a filter.
</TD></TR></TABLE></BLOCKQUOTE>

<P>The following structure maintains information about graphics device interface (GDI) bitmaps and device-independent bitmaps (DIBs). This is used solely by the <A HREF="class/CImageAllocator.htm">CImageAllocator</A>, <A HREF="class/CImageSample.htm">CImageSample</A>, and <A HREF="class/CDrawImage.htm">CDrawImage</A> window utility classes.</P>

<BLOCKQUOTE><TABLE CLASS="ref">
<TR><TH>Structure</TH><TH>Description</TH></TR>
<TR><TD><A HREF="structs.htm#DIBDATA">DIBDATA</A> </TD><TD>Contains information about each DIB.
</TD></TR></TABLE></BLOCKQUOTE>

<P>The following structures maintain information about video, as well as video capture and compression.</P>

<BLOCKQUOTE><TABLE CLASS="ref">
<TR><TH>Structure</TH><TH>Description</TH></TR>

<TR><TD><A HREF="structs.htm#TRUECOLORINFO_structure">TRUECOLORINFO</A> </TD><TD>Maintains color information.
</TD></TR><TR><TD><A HREF="structs.htm#ANALOGVIDEOINFO">ANALOGVIDEOINFO</A> </TD><TD>Maintains information about the format of the analog video signal. 
</TD></TR><TR><TD><A HREF="structs.htm#AUDIO_STREAM_CONFIG_CAPS">AUDIO_STREAM_CONFIG_CAPS</A> </TD><TD>Contains information about all possible audio formats supported.
</TD></TR><TR><TD><A HREF="structs.htm#COLORKEY">COLORKEY</A> </TD><TD>Communicates color key information between the renderer and another filter.
</TD></TR><TR><TD><A HREF="structs.htm#MPEG1VIDEOINFO">MPEG1VIDEOINFO</A> </TD><TD>Contains additional MPEG-1 video system information.
</TD></TR><TR><TD><A HREF="structs.htm#MPEG2VIDEOINFO">MPEG2VIDEOINFO</A> </TD><TD>Contains additional MPEG-2 video system information.
</TD></TR><TR><TD><A HREF="structs.htm#TIMECODE">TIMECODE</A> </TD><TD>Contains basic timecode frame count information.
</TD></TR><TR><TD><A HREF="structs.htm#TIMECODE_SAMPLE">TIMECODE_SAMPLE</A> </TD><TD>Contains complete timecode information.
</TD></TR><TR><TD><A HREF="structs.htm#VIDEO_STREAM_CONFIG_CAPS">VIDEO_STREAM_CONFIG_CAPS</A> </TD><TD>Contains information about possible connections.
</TD></TR><TR><TD><A HREF="structs.htm#VIDEOINFO">VIDEOINFO</A> </TD><TD>Contains information that specifies a video image and its color palette and bitmasks.
</TD></TR><TR><TD><A HREF="structs.htm#VIDEOINFOHEADER">VIDEOINFOHEADER</A> </TD><TD>Describes the bitmap and color information for a video image.
</TD></TR><TR><TD><A HREF="structs.htm#VIDEOINFOHEADER2">VIDEOINFOHEADER2</A> </TD><TD>Describes the bitmap and color information for a video image, including <A CLASS="Glossary" HREF="javascript:Glossary(sRelPath + 'gloss/gloss_I.htm#interlace')">interlace</A>, copy protection, and pixel aspect ratio information.
</TD></TR></TABLE></BLOCKQUOTE>

<H1><A NAME="ALLOCATOR_PROPERTIES">ALLOCATOR_PROPERTIES</A><HR size=1></H1>
<A HREF="structs.htm">Structures</A>
<P>Contains the allocator's count, size, alignment, and prefix properties.
<P CLASS="ref">Syntax</P>
<BLOCKQUOTE><PRE>typedef struct _AllocatorProperties {
&#009;long cBuffers;
&#009;long cbBuffer;
&#009;long cbAlign;
&#009;long cbPrefix;
} ALLOCATOR_PROPERTIES;
</PRE></BLOCKQUOTE>
<P CLASS="ref">Members</P>
<BLOCKQUOTE>
<DL><DT><B><A NAME="cBuffers">cBuffers</A></B>
 </DT><DD>Count of buffers at this allocator.
</DD><DT><B><A NAME="cbBuffer">cbBuffer</A></B>
 </DT><DD>Size of each buffer in bytes, excluding any prefix.
</DD><DT><B><A NAME="cbAlign">cbAlign</A></B>
 </DT><DD>Alignment of the buffer; buffer start will be aligned on a multiple of this value.
</DD><DT><B><A NAME="cbPrefix">cbPrefix</A></B>
 </DT><DD>Each buffer is preceded by a prefix of this many bytes.
</DD></DL>
</BLOCKQUOTE>
<P CLASS="ref">Remarks</P><BLOCKQUOTE>
<P>The <A HREF="class/CMediaSample.htm#GetPointer">CMediaSample::GetPointer</A> member function points to the beginning of the
buffer, not including the prefix bytes designated by <B>cbPrefix</B>.

<P>The alignment is applied to the prefix data, if any. If a nonzero prefix is used, the beginning of the prefix is aligned according to <A HREF="structs.htm#cbAlign">cbAlign</A>. Since the buffer pointer returned by <A HREF="iface/IMediaSample.htm#GetPointer">IMediaSample::GetPointer</A> points to the area immediately following the prefix, the <B>cbPrefix</B> address (the value returned by <B>IMediaSample::GetPointer</B> 
minus <B>cbPrefix</B>) should be aligned on an address that is a multiple of <B>cbAlign</B> bytes.
</BLOCKQUOTE>

<H1><A NAME="AM_DVD_RENDERSTATUS">AM_DVD_RENDERSTATUS</A><HR size=1></H1>
<A HREF="structs.htm">Structures</A>

<P>Contains codes indicating the status of DVD-Video playback. These codes are used in the <A HREF="iface/IDvdGraphBuilder.htm#RenderDvdVideoVolume">IDvdGraphBuilder::RenderDvdVideoVolume</A> method.

<P CLASS="ref">Syntax</P>
<BLOCKQUOTE><PRE>
typedef struct {
    HRESULT hrVPEStatus;
    BOOL    bVPEFailed;          
    BOOL    bDVDVolInvalid;      
    BOOL    bDVDVolUnknown;      
    BOOL    bNoLine21In;
    BOOL    bNoLine21Out;           
    int     iNumStreams;         
    int     iNumStreamsFailed;   
    DWORD   dwFailedStreamsFlag; 
} AM_DVD_RENDERSTATUS;
</PRE></BLOCKQUOTE>

<P CLASS="ref">Members</P>
<BLOCKQUOTE>
<DL><DT><B><A NAME="hrVPEStatus">hrVPEStatus</A></B>
 </DT><DD>Overlay/<A CLASS="Glossary" HREF="javascript:Glossary(sRelPath + 'gloss/gloss_V.htm#VPE')">VPE</A> error code. Zero indicates success; any other value is failure.
</DD><DT><B><A NAME="bDVDVolInvalid">bDVDVolInvalid</A></B>
 </DT><DD>TRUE if the specified DVD volume to be played does not exist; FALSE otherwise.
</DD><DT><B><A NAME="bDVDVolUnknown">bDVDVolUnknown</A></B>
 </DT><DD>TRUE if no DVD volume is specified or if it isn't found; FALSE otherwise.
</DD><DT><B><A NAME="bNoLine21In">bNoLine21In</A></B>
 </DT><DD>TRUE if the video decoder doesn't produce line 21 (closed captioning) data; FALSE otherwise.
</DD><DT><B><A NAME="bNoLine21Out">bNoLine21Out</A></B>
 </DT><DD>TRUE if the video decoder can't be shown as closed captioning on video due to a problem with graph building; FALSE otherwise. 
</DD><DT><B><A NAME="iNumStreams">iNumStreams</A></B>
 </DT><DD>Number of DVD streams to render.
</DD><DT><B><A NAME="iNumStreamsFailed">iNumStreamsFailed</A></B>
 </DT><DD>Number of streams that failed to render.
</DD><DT><B><A NAME="dwFailedStreamsFlag">dwFailedStreamsFlag</A></B>
 </DT><DD>Combination of <A HREF="dtypes.htm#AM_DVD_STREAM_FLAGS">AM_DVD_STREAM_FLAGS</A> flags indicating which streams failed.
</DD></DL>
</BLOCKQUOTE>

<P CLASS="ref">See Also</P>
<BLOCKQUOTE>
<P><A HREF="iface/IDvdGraphBuilder.htm#RenderDvdVideoVolume">IDvdGraphBuilder::RenderDvdVideoVolume</A>
</BLOCKQUOTE>

<H1><A NAME="AM_MEDIA_TYPE">AM_MEDIA_TYPE</A><HR size=1></H1>
<A HREF="structs.htm">Structures</A>
<P>Describes a media sample type.
<P CLASS="ref">Syntax</P>
<BLOCKQUOTE><PRE>typedef struct  _MediaType
    {
    GUID      majortype;
    GUID      subtype;
    BOOL      bFixedSizeSamples;
    BOOL      bTemporalCompression;
    ULONG     lSampleSize;
    GUID      formattype;
    IUnknown  *pUnk;
    ULONG     cbFormat;
    /* [size_is] */ BYTE __RPC_FAR *pbFormat;
    } AM_MEDIA_TYPE;
</PRE></BLOCKQUOTE>
<P CLASS="ref">Members</P>
<BLOCKQUOTE>
<DL><DT><B><A NAME="majortype">majortype</A></B>
 </DT><DD><A CLASS="Glossary" HREF="javascript:Glossary(sRelPath + 'gloss/gloss_M.htm#major_type')">Major type</A> of the media sample.
</DD><DT><B><A NAME="AM_MEDIA_TYPE_subtype">subtype</A></B>
 </DT><DD>Subtype of the media sample.
</DD><DT><B><A NAME="bFixedSizeSamples">bFixedSizeSamples</A></B>
 </DT><DD>If TRUE, samples are of a fixed size.
</DD><DT><B><A NAME="bTemporalCompression">bTemporalCompression</A></B>
 </DT><DD>If TRUE, samples are compressed.
</DD><DT><B><A NAME="lSampleSize">lSampleSize</A></B>
 </DT><DD>Size of the sample in bytes.
</DD><DT><B><A NAME="formattype">formattype</A></B>
 </DT><DD>Registered (<A CLASS="Glossary" HREF="javascript:Glossary(sRelPath + 'gloss/gloss_G.htm#GUID')">GUID</A>) <A CLASS="Glossary" HREF="javascript:Glossary(sRelPath + 'gloss/gloss_F.htm#format_type')">format type</A>.
</DD><DT><B><A NAME="pUnk">pUnk</A></B>
 </DT><DD>Pointer to the <A HREF="iface/IUnknown.htm">IUnknown</A> interface.
</DD><DT><B><A NAME="cbFormat">cbFormat</A></B>
 </DT><DD>Size of the format section of the media type.
</DD><DT><B><A NAME="pbFormat">pbFormat</A></B>
 </DT><DD>Pointer to the format section of the media type. The layout of
this is determined by the format type <A CLASS="Glossary" HREF="javascript:Glossary(sRelPath + 'gloss/gloss_G.htm#GUID')">GUID</A>. <B><A NAME="Format_types">Format types</A></B> include the following:
<TABLE>
<TR><TH>Format type</TH><TH>Structure pointed to</TH></TR>

 <TR><TD>FORMAT_MPEGVideo </TD><TD><A HREF="structs.htm#MPEG1VIDEOINFO">MPEG1VIDEOINFO</A>
 </TD></TR><TR><TD>FORMAT_VideoInfo </TD><TD><A HREF="structs.htm#VIDEOINFOHEADER">VIDEOINFOHEADER</A>
 </TD></TR><TR><TD>FORMAT_WaveFormatEx </TD><TD><A HREF="../filtdev/DV_Data_AVI_File_Format.htm#WAVEFORMATEX_AVI">WAVEFORMATEX</A> 
 </TD></TR><TR><TD>FORMAT_MPEG2Video </TD><TD><A HREF="structs.htm#MPEG2VIDEOINFO">MPEG2VIDEOINFO</A>
 </TD></TR><TR><TD>FORMAT_VideoInfo2 </TD><TD><A HREF="structs.htm#VIDEOINFOHEADER2">VIDEOINFOHEADER2</A>
</TD></TR></TABLE>
</DD></DL>
</BLOCKQUOTE>

<H1><A NAME="AM_SAMPLE2_PROPERTIES">AM_SAMPLE2_PROPERTIES</A><HR size=1></H1>
<A HREF="structs.htm">Structures</A>
<P>Describes the properties of a generic media sample.
<P CLASS="ref">Syntax</P>
<BLOCKQUOTE><PRE>typedef struct tagAM_SAMPLE2_PROPERTIES {
    DWORD    cbData;
    DWORD    dwTypeSpecificFlags;
    DWORD    dwSampleFlags;
    LONG     lActual;
    REFERENCE_TIME tStart;
    REFERENCE_TIME tStop;
    DWORD    dwStreamId;
    AM_MEDIA_TYPE *pMediaType;
    BYTE    *pbBuffer;
    LONG     cbBuffer;
} AM_SAMPLE2_PROPERTIES;
</PRE></BLOCKQUOTE>
<P CLASS="ref">Members</P>
<BLOCKQUOTE>
<DL><DT><B><A NAME="cbData">cbData</A></B>
</DT><DD>Length of property data for extensibility; number of bytes including this <A CLASS="Glossary" HREF="javascript:Glossary(sRelPath + 'gloss/gloss_f.htm#field')">field</A>.
</DD><DT><B><A NAME="dwTypeSpecificFlags">dwTypeSpecificFlags</A></B>
</DT><DD>Type-specific flag data. These flags are defined separately for each media type. Default is zero.
</DD><DT><B><A NAME="dwSampleFlags">dwSampleFlags</A></B>
</DT><DD>Flags bits defined by the <A HREF="dtypes.htm#AM_SAMPLE_PROPERTY_FLAGS">AM_SAMPLE_PROPERTY_FLAGS</A> enumerated data type or by the defined constants described in <B>Remarks</B>. All undefined bits are reserved (set them to zero, and do not copy them).
</DD><DT><B><A NAME="lActual">lActual</A></B>
</DT><DD>Length of data in the buffer pointed to by the <B>pbBuffer</B> member.
</DD><DT><B><A NAME="tStart">tStart</A></B>
</DT><DD>Start time if valid.
</DD><DT><B><A NAME="tStop">tStop</A></B>
</DT><DD>Stop time if valid.
</DD><DT><B><A NAME="dwStreamId">dwStreamId</A></B>
</DT><DD>Stream identifier. Stream 0 is the normal media <A CLASS="Glossary" HREF="javascript:Glossary(sRelPath + 'gloss/gloss_T.htm#transport')">transport</A>. Stream 1 is control. Currently, only Stream 0 is used. Filters should pass any other stream ID directly to their <A CLASS="Glossary" HREF="javascript:Glossary(sRelPath + 'gloss/gloss_O.htm#output_pin')">output pins</A> without processing.
</DD><DT><B><A NAME="pMediaType">pMediaType</A></B>
</DT><DD>Copy of the media type. It becomes invalid after the sample has been released.
</DD><DT><B><A NAME="pbBuffer">pbBuffer</A></B>
</DT><DD>Pointer to the buffer. The pointer becomes invalid after the sample is released.
</DD><DT><B><A NAME="cbBuffer">cbBuffer</A></B>
</DT><DD>Total length of the buffer pointed to by <B>pbBuffer</B>, in bytes.
</DD></DL>
</BLOCKQUOTE>

<P CLASS="ref">Remarks</P><BLOCKQUOTE>
<P>The <A HREF="iface/IMediaSample2.htm">IMediaSample2</A> interface uses this structure.
<P>The <I>dwSampleFlags</I> parameter can take values from the <B>AM_SAMPLE_PROPERTY_FLAGS</B> enumerated data type or one or more of the following defined constants. High-end video is typically formatted as alternate scan lines rather than as whole frames. Thus, the first field of a high-end video sample often contains odd lines of the video (lines 1, 3, 5, and so on) while the second field of the sample often contains the even lines of the video (lines 2, 4, 6, and so on). Many of the following constants describe the samples of high-end video: whether the sample is a field1, field2, or frame, and how the sample should be displayed.
<DL>
<DT><B><A NAME="AM_VIDEO_FLAG_FIELD_MASK" IDX_CONCEPT="AM_VIDEO_FLAG_FIELD_MASK">AM_VIDEO_FLAG_FIELD_MASK</A></B></DT>
<DD>Used to check whether the sample is a field1, field2, or frame.</DD>
<DT><B><A NAME="AM_VIDEO_FLAG_INTERLEAVED_FRAME" IDX_CONCEPT="AM_VIDEO_FLAG_INTERLEAVED_FRAME">AM_VIDEO_FLAG_INTERLEAVED_FRAME</A></B></DT>
<DD>specifies this sample is a frame (use AM_VIDEO_FLAG_FIELD_MASK when using this).</DD>
<DT><B><A NAME="AM_VIDEO_FLAG_FIELD1" IDX_CONCEPT="AM_VIDEO_FLAG_FIELD1">AM_VIDEO_FLAG_FIELD1</A></B></DT>
<DD>specifies this sample is the field1 (use AM_VIDEO_FLAG_FIELD_MASK when using this).</DD>
<DT><B><A NAME="AM_VIDEO_FLAG_FIELD2" IDX_CONCEPT="AM_VIDEO_FLAG_FIELD2">AM_VIDEO_FLAG_FIELD2</A></B></DT>
<DD>specifies this sample is the field2 (use AM_VIDEO_FLAG_FIELD_MASK when using this).</DD>
<DT><B><A NAME="AM_VIDEO_FLAG_FIELD1FIRST" IDX_CONCEPT="AM_VIDEO_FLAG_FIELD1FIRST">AM_VIDEO_FLAG_FIELD1FIRST</A></B></DT>
<DD>specifies display field1 first, else display field2 first. This bit is ignored for 1FieldPerSample mode.</DD>
<DT><B><A NAME="AM_VIDEO_FLAG_WEAVE" IDX_CONCEPT="AM_VIDEO_FLAG_WEAVE">AM_VIDEO_FLAG_WEAVE</A></B></DT>
<DD>if set, use <A CLASS="Glossary" HREF="javascript:Glossary(sRelPath + 'gloss/gloss_W.htm#weave')">weave</A> display mode, otherwise use the <A CLASS="Glossary" HREF="javascript:Glossary(sRelPath + 'gloss/gloss_B.htm#bob')">bob</A> display mode.</DD>
<DT><B><A NAME="AM_VIDEO_FLAG_IPB_MASK" IDX_CONCEPT="AM_VIDEO_FLAG_IPB_MASK">AM_VIDEO_FLAG_IPB_MASK</A></B></DT>
<DD>use this sample to set whether the sample is I, P, or B (see next 3 flags).</DD>
<DT><B><A NAME="AM_VIDEO_FLAG_I_SAMPLE" IDX_CONCEPT="AM_VIDEO_FLAG_I_SAMPLE">AM_VIDEO_FLAG_I_SAMPLE</A></B></DT>
<DD>specifies to use the <I>Intra</I> encoded method of MPEG frame compression. Use AM_VIDEO_FLAG_IPB_MASK when using this.</DD>
<DT><B><A NAME="AM_VIDEO_FLAG_P_SAMPLE" IDX_CONCEPT="AM_VIDEO_FLAG_P_SAMPLE">AM_VIDEO_FLAG_P_SAMPLE</A></B></DT>
<DD>specifies to use the <I>Predicted</I> encoded method of MPEG frame compression. Use AM_VIDEO_FLAG_IPB_MASK when using this.</DD>
<DT><B><A NAME="AM_VIDEO_FLAG_B_SAMPLE" IDX_CONCEPT="AM_VIDEO_FLAG_B_SAMPLE">AM_VIDEO_FLAG_B_SAMPLE</A></B></DT>
<DD>specifies to use the <I>Bidirectional</I> encoded method of MPEG frame compression. Use AM_VIDEO_FLAG_IPB_MASK when using this.</DD>
<DT><B><A NAME="AM_VIDEO_FLAG_REPEAT_FIELD" IDX_CONCEPT="AM_VIDEO_FLAG_REPEAT_FIELD">AM_VIDEO_FLAG_REPEAT_FIELD</A></B></DT>
<DD>specifies to display the first image displayed, after displaying both of the images. This bit is ignored for 1FieldPerSample mode.</DD>
</DL>
</BLOCKQUOTE>

<H1><A NAME="AMOVIESETUP_FILTER">AMOVIESETUP_FILTER</A><HR size=1></H1>
<A HREF="structs.htm">Structures</A>
<P>Contains filter information for registering a filter.
<P CLASS="ref">Syntax</P>
<BLOCKQUOTE><PRE>typedef struct _AMOVIESETUP_FILTER
{
    const CLSID * clsID;
    LPWSTR     strName;
    DWORD      dwMerit;
    UINT       nPins;
    LPAMOVIESETUP_PIN lpPin;
}
AMOVIESETUP_FILTER
</PRE></BLOCKQUOTE>
<P CLASS="ref">Members</P>
<BLOCKQUOTE>
<DL><DT><B><A NAME="clsID">clsID</A></B>
 </DT><DD>Class identifier of the filter.
</DD><DT><B><A NAME="strName">strName</A></B>
 </DT><DD>Name of the filter.
</DD><DT><B><A NAME="dwMerit">dwMerit</A></B>
 </DT><DD><A CLASS="Glossary" HREF="javascript:Glossary(sRelPath + 'gloss/gloss_M.htm#merit')">Merit</A> used by the <A HREF="iface/IGraphBuilder.htm">IGraphBuilder</A> interface when constructing a <A CLASS="Glossary" HREF="javascript:Glossary(sRelPath + 'gloss/gloss_F.htm#filter_graph')">filter graph</A>.
</DD><DT><B><A NAME="nPins">nPins</A></B>
 </DT><DD>Number of pins on the filter.
</DD><DT><B><A NAME="lpPin">lpPin</A></B>
 </DT><DD><A HREF="structs.htm#AMOVIESETUP_PIN">AMOVIESETUP_PIN</A> structure providing pin information.
</DD></DL>
</BLOCKQUOTE>

<H1><A NAME="AMOVIESETUP_MEDIATYPE">AMOVIESETUP_MEDIATYPE</A><HR size=1></H1>
<A HREF="structs.htm">Structures</A>
<P>Media type information for registering a filter.
<P CLASS="ref">Syntax</P>
<BLOCKQUOTE><PRE>typedef struct _AMOVIESETUP_MEDIATYPE
{
    const CLSID * clsMajorType;
    const CLSID * clsMinorType;
} AMOVIESETUP_MEDIATYPE;
</PRE></BLOCKQUOTE>
<P CLASS="ref">Members</P>
<BLOCKQUOTE>
<DL><DT><B><A NAME="clsMajorType">clsMajorType</A></B>
 </DT><DD>Major media type supported by the filter.
</DD><DT><B><A NAME="clsMinorType">clsMinorType</A></B>
 </DT><DD>Minor media type supported by the filter.
</DD></DL>
</BLOCKQUOTE>

<H1><A NAME="AMOVIESETUP_PIN">AMOVIESETUP_PIN</A><HR size=1></H1>
<A HREF="structs.htm">Structures</A>
<P>Pin information for registering a filter.
<P CLASS="ref">Syntax</P>
<BLOCKQUOTE><PRE>typedef struct _AMOVIESETUP_PIN
{
    LPWSTR           strName;
    BOOL             bRendered;
    BOOL             bOutput;
    BOOL             bZero;
    BOOL             bMany;
    const CLSID *    clsConnectsToFilter;
    LPWSTR           strConnectsToPin;
    UINT             nMediaTypes;
    LPAMOVIESETUP_MEDIATYPE lpMediaType;
}
AMOVIESETUP_PIN;
</PRE></BLOCKQUOTE>
<P CLASS="ref">Members</P>
<BLOCKQUOTE>
<DL><DT><B><A NAME="strName">strName</A></B>
 </DT><DD>Name of the pin.
</DD><DT><B><A NAME="bRendered">bRendered</A></B>
 </DT><DD>Set to TRUE if the filter renders this input; otherwise, set to FALSE.
</DD><DT><B><A NAME="bOutput">bOutput</A></B>
 </DT><DD>Flag to indicate if this pin is an output pin.
</DD><DT><B><A NAME="bZero">bZero</A></B>
 </DT><DD>If the filter has zero instances of this pin, set this to TRUE; otherwise,
set to FALSE. For example, a decompression filter might choose not to 
create a sound output pin for a movie without a sound track.
</DD><DT><B><A NAME="bMany">bMany</A></B>
 </DT><DD>If the filter has many instances of this pin, set this to TRUE; otherwise,
set to FALSE. For example, a mixer might have multiple instances of its <A CLASS="Glossary" HREF="javascript:Glossary(sRelPath + 'gloss/gloss_I.htm#input_pin')">input pin</A>.
</DD><DT><B><A NAME="clsConnectsToFilter">clsConnectsToFilter</A></B>
 </DT><DD>CLSID of the filter to which this filter connects in a filter graph.
</DD><DT><B><A NAME="strConnectsToPin">strConnectsToPin</A></B>
 </DT><DD>Name of the pin to which this pin connects in a filter graph.
</DD><DT><B><A NAME="nMediaTypes">nMediaTypes</A></B>
 </DT><DD>Number of media types supported by this pin.
</DD><DT><B><A NAME="lpMediaType">lpMediaType</A></B>
 </DT><DD><A HREF="structs.htm#AMOVIESETUP_MEDIATYPE">AMOVIESETUP_MEDIATYPE</A> structure providing media type information.
</DD></DL>
</BLOCKQUOTE>

<H1><A NAME="AM_STREAM_INFO">AM_STREAM_INFO</A><HR size=1></H1>
<A HREF="structs.htm">Structures</A>
<P>Contains start and stop information given to a pin.
<P CLASS="ref">Syntax</P>
<BLOCKQUOTE><PRE>typedef struct {
    REFERENCE_TIME tStart;
    REFERENCE_TIME tStop;
    DWORD dwStartCookie;
    DWORD dwStopCookie;
    DWORD dwFlags;
} AM_STREAM_INFO;
</PRE></BLOCKQUOTE>
<P CLASS="ref">Members</P>
<BLOCKQUOTE>
<DL><DT><B><A NAME="tStart">tStart</A></B>
 </DT><DD>Time at which streaming will start.
</DD><DT><B><A NAME="tStop">tStop</A></B>
 </DT><DD>Time at which streaming will stop. 
</DD><DT><B><A NAME="dwStartCookie">dwStartCookie</A></B>
 </DT><DD>Number that will be given to the application that ordered the start, when the event occurs.
</DD><DT><B><A NAME="dwStopCookie">dwStopCookie</A></B>
 </DT><DD>Number that will be given to the application that ordered the stop, when the event occurs.
</DD><DT><B><A NAME="dwFlags">dwFlags</A></B>
 </DT><DD><A HREF="dtypes.htm#AM_STREAM_INFO_FLAGS">AM_STREAM_INFO_FLAGS</A> enumeration type flag.
</DD></DL>
</BLOCKQUOTE>

<P CLASS="ref">Remarks</P><BLOCKQUOTE>
<P>Access this structure through the <A HREF="iface/IAMStreamControl.htm">IAMStreamControl</A> interface.
</BLOCKQUOTE>

<H1><A NAME="AMVPDATAINFO">AMVPDATAINFO</A><HR size=1></H1>
<A HREF="structs.htm">Structures</A>
<P>Specifies the data-specific characteristics of the VP input stream.
<P CLASS="ref">Syntax</P>
<BLOCKQUOTE><PRE>typedef struct _AMVPDATAINFO{
    DWORD dwSize; 
    DWORD dwMicrosecondsPerField; 
    AMVPDIMINFO amvpDimInfo; 
    DWORD dwPictAspectRatioX;
    DWORD dwPictAspectRatioY;
    BOOL bEnableDoubleClock;
    BOOL bEnableVACT;&#009;
    BOOL bDataIsInterlaced;
    LONG lHalfLinesOdd;
    BOOL bFieldPolarityInverted;
    DWORD dwNumLinesInVREF;
    LONG lHalfLinesEven;
    DWORD dwReserved1;
} AMVPDATAINFO, *LPAMVPDATAINFO;
</PRE></BLOCKQUOTE>
<P CLASS="ref">Members</P>
<BLOCKQUOTE>
<DL><DT><B><A NAME="dwSize">dwSize</A></B> 
 </DT><DD>Size of the structure, in bytes.
</DD><DT><B><A NAME="dwMicrosecondsPerFie">dwMicrosecondsPerField</A></B>
 </DT><DD>Time taken by each field.
</DD><DT><B><A NAME="amvpDimInfo">amvpDimInfo</A></B>
 </DT><DD>Dimensional information.
</DD><DT><B><A NAME="dwPictAspectRatioX">dwPictAspectRatioX</A></B>
 </DT><DD>The X dimension of picture aspect ratio.
</DD><DT><B><A NAME="dwPictAspectRatioY">dwPictAspectRatioY</A></B>
 </DT><DD>The Y dimension of picture aspect ratio.
</DD><DT><B><A NAME="bEnableDoubleClock">bEnableDoubleClock</A></B>
 </DT><DD>Video port should enable double clocking.
</DD><DT><B><A NAME="bEnableVACT">bEnableVACT</A></B>
 </DT><DD>Video port should use an external VACT signal.
 

</DD><DT><B><A NAME="bDataIsInterlaced">bDataIsInterlaced</A></B>
 </DT><DD>Indicates that the signal is interlaced.
</DD><DT><B><A NAME="lHalfLinesOdd">lHalfLinesOdd</A></B>
 </DT><DD>Number of half lines in the odd field.
</DD><DT><B><A NAME="bFieldPolarityInvert">bFieldPolarityInverted</A></B>
 </DT><DD>Video port should invert the field polarity.
</DD><DT><B><A NAME="dwNumLinesInVREF">dwNumLinesInVREF</A></B>
 </DT><DD>Number of lines of data in VREF.
</DD><DT><B><A NAME="lHalfLinesEven">lHalfLinesEven</A></B>
 </DT><DD>Number of half lines in the even field.
</DD><DT><B><A NAME="dwReserved1">dwReserved1</A></B>
 </DT><DD>Reserved for future use.
</DD></DL>
</BLOCKQUOTE>

<H1><A NAME="AMVPDIMINFO">AMVPDIMINFO</A><HR size=1></H1>
<A HREF="structs.htm">Structures</A>
<P>Specifies the dimensional characteristics of the VP input stream.
<P CLASS="ref">Syntax</P>
<BLOCKQUOTE><PRE>typedef struct _AMVPDIMINFO{
    DWORD dwFieldWidth;
    DWORD dwFieldHeight;
    DWORD dwVBIWidth;
    DWORD dwVBIHeight;
    RECT rcValidRegion;
} AMVPDIMINFO, *LPAMVPDIMINFO;
</PRE></BLOCKQUOTE>
<P CLASS="ref">Members</P>
<BLOCKQUOTE>
<DL><DT><B><A NAME="dwFieldWidth">dwFieldWidth</A></B>
 </DT><DD>Field width of the data.
</DD><DT><B><A NAME="dwFieldHeight">dwFieldHeight</A></B>
 </DT><DD>Field height of the data.
</DD><DT><B><A NAME="dwVBIWidth">dwVBIWidth</A></B>
 </DT><DD>Width of the VBI data.
</DD><DT><B><A NAME="dwVBIHeight">dwVBIHeight</A></B>
 </DT><DD>Height of the VBI data.
</DD><DT><B><A NAME="rcValidRegion">rcValidRegion</A></B>
 </DT><DD>Valid rectangle, used for cropping.
</DD></DL>
</BLOCKQUOTE>

<H1><A NAME="AMVPSIZE">AMVPSIZE</A><HR size=1></H1>
<A HREF="structs.htm">Structures</A>
<P>Specifies the width and height for a VP image. 
<P CLASS="ref">Syntax</P>
<BLOCKQUOTE><PRE>typedef struct _AMVPSIZE{
DWORD dwWidth;
DWORD dwHeight;
} AMVPSIZE, *LPAMVPSIZE;
</PRE></BLOCKQUOTE>
<P CLASS="ref">Members</P>
<BLOCKQUOTE>
<DL><DT><B><A NAME="dwWidth">dwWidth</A></B>
 </DT><DD>Width, in pixels.
</DD><DT><B><A NAME="dwHeight">dwHeight</A></B>
 </DT><DD>Height.
</DD></DL>
</BLOCKQUOTE>

<P CLASS="ref">Remarks</P><BLOCKQUOTE>
<P>The context could be anything such as scaling, cropping, and so on.
</BLOCKQUOTE>

<H1><A NAME="ANALOGVIDEOINFO">ANALOGVIDEOINFO</A><HR size=1></H1>
<A HREF="structs.htm">Structures</A>
<P>Maintains information about the format of the analog video signal. 
<P CLASS="ref">Syntax</P>
<BLOCKQUOTE><PRE>typedef struct tagAnalogVideoInfo {
    RECT            rcSource;           
    RECT            rcTarget;           
    DWORD           dwActiveWidth;      
    DWORD           dwActiveHeight;     
    REFERENCE_TIME  AvgTimePerFrame;    
} ANALOGVIDEOINFO;
</PRE></BLOCKQUOTE>
<P CLASS="ref">Members</P>
<BLOCKQUOTE>
<DL><DT><B><A NAME="rcSource">rcSource</A></B>
 </DT><DD>Source video rectangle.
</DD><DT><B><A NAME="rcTarget">rcTarget</A></B>
 </DT><DD>Destination target rectangle. 
</DD><DT><B><A NAME="dwActiveWidth">dwActiveWidth</A></B>
 </DT><DD>Source video width.
</DD><DT><B><A NAME="dwActiveHeight">dwActiveHeight</A></B>
 </DT><DD>Source video height (483 for <A CLASS="Glossary" HREF="javascript:Glossary(sRelPath + 'gloss/gloss_N.htm#NTSC')">NTSC</A>, 575 for <A CLASS="Glossary" HREF="javascript:Glossary(sRelPath + 'gloss/gloss_P.htm#PAL')">PAL</A>/<A CLASS="Glossary" HREF="javascript:Glossary(sRelPath + 'gloss/gloss_S.htm#SECAM')">SECAM</A>).
</DD><DT><B><A NAME="AvgTimePerFrame">AvgTimePerFrame</A></B>
 </DT><DD>Average time per frame in 100-nanosecond units.
</DD></DL>
</BLOCKQUOTE>

<P CLASS="ref">Remarks</P>
<BLOCKQUOTE>
<P>Filters using this format usually pass the video signal using a hardware-based
connection rather than using memory-based transports. 

<P>An example of a definition of an analog video media type connection would be a
connection of NTSC video using "M" color encoding. This would use a major media type
of MEDIATYPE_AnalogVideo, a subtype of MEDIASUBTYPE_AnalogVideo_NTSC_M, and a 
format type of FORMAT_AnalogVideo. 
</BLOCKQUOTE>

<H1><A NAME="AUDIO_STREAM_CONFIG_CAPS">AUDIO_STREAM_CONFIG_CAPS</A><HR size=1></H1>
<A HREF="structs.htm">Structures</A>
<P>Contains information about all possible audio formats supported.

<P CLASS="ref">Syntax</P>
<BLOCKQUOTE><PRE>
typedef struct _AUDIO_STREAM_CONFIG_CAPS {
        GUID guid;
        ULONG MinimumChannels;
        ULONG MaximumChannels;
        ULONG ChannelsGranularity;
        ULONG MinimumBitsPerSample;
        ULONG MaximumBitsPerSample;
        ULONG BitsPerSampleGranularity;
        ULONG MinimumSampleFrequency;
        ULONG MaximumSampleFrequency;
        ULONG SampleFrequencyGranularity;
    } AUDIO_STREAM_CONFIG_CAPS;
</PRE></BLOCKQUOTE>
<P CLASS="ref">Members</P>
<BLOCKQUOTE>
<DL><DT><B><A NAME="guid">guid</A></B>
 </DT><DD>Will be set to MEDIATYPE_Audio to indicate an audio sample.
</DD><DT><B><A NAME="MinimumChannels">MinimumChannels</A></B>
 </DT><DD>Minimum number of channels this pin supports.
</DD><DT><B><A NAME="MaximumChannels">MaximumChannels</A></B>
</DT><DD>Maximum number of channels this pin supports (for example, 2 for stereo).
</DD><DT><B><A NAME="ChannelsGranularity">ChannelsGranularity</A></B>
 </DT><DD>Granularity of the channels. For example, you could specify channels 2 through 4 in steps of 2.
</DD><DT><B><A NAME="MinimumBitsPerSample">MinimumBitsPerSample</A></B>
 </DT><DD>Minimum bits per sample.
</DD><DT><B><A NAME="MaximumBitsPerSample">MaximumBitsPerSample</A></B>
 </DT><DD>Maximum bits per sample.
</DD><DT><B><A NAME="BitsPerSampleGranula">BitsPerSampleGranularity</A></B>
 </DT><DD>Granularity of the bits. For example, you could specify 8 bits or 32 bits in steps of 8.
</DD><DT><B><A NAME="MinimumSampleFrequen">MinimumSampleFrequency</A></B>
 </DT><DD>Minimum frequency allowed.
</DD><DT><B><A NAME="MaximumSampleFrequen">MaximumSampleFrequency</A></B>
 </DT><DD>Maximum frequency allowed.
</DD><DT><B><A NAME="SampleFrequencyGranu">SampleFrequencyGranularity</A></B>
 </DT><DD>Granularity of the frequency. For example, you could specify 11025 Hz to 44100 Hz in steps of 11025 Hz.
</DD></DL>
</BLOCKQUOTE>

<P CLASS="ref">Remarks</P>
<BLOCKQUOTE>
<P>This structure is returned by an audio capture or <A CLASS="Glossary" HREF="javascript:Glossary(sRelPath + 'gloss/gloss_C.htm#compression_filter')">compression filter</A>.
</BLOCKQUOTE>
<P CLASS="ref">See Also</P>
<BLOCKQUOTE>
<P><A HREF="iface/IAMStreamConfig.htm#GetStreamCaps">IAMStreamConfig::GetStreamCaps</A>
</BLOCKQUOTE>

<H1><A NAME="COLORKEY">COLORKEY</A><HR size=1></H1>
<A HREF="structs.htm">Structures</A>
<P>Communicates color key information between the renderer and another filter. 
<P CLASS="ref">Syntax</P>
<BLOCKQUOTE><PRE>
typedef struct tagCOLORKEY
    {
    DWORD           KeyType;
    DWORD           PaletteIndex;
    COLORREF        LowColorValue;
    COLORREF        HighColorValue;
    }    COLORKEY;
</PRE></BLOCKQUOTE>
<P CLASS="ref">Members</P>
<BLOCKQUOTE>
<DL><DT><B><A NAME="KeyType">KeyType</A></B>
 </DT><DD>Key type. Can be <B><A NAME="CK_NOCOLORKEY">CK_NOCOLORKEY</A></B>, <B><A NAME="CK_INDEX">CK_INDEX</A></B>, or <B><A NAME="CK_RGB">CK_RGB</A></B>. <A HREF="structs.htm#CK_INDEX">CK_INDEX</A> and <B>CK_RGB</B> can be logically combined.
</DD><DT><B><A NAME="PaletteIndex">PaletteIndex</A></B>
 </DT><DD>Palette index.
</DD><DT><B><A NAME="LowColorValue">LowColorValue</A></B>
 </DT><DD>Lowest RGB color value.
</DD><DT><B><A NAME="HighColorValue">HighColorValue</A></B>
 </DT><DD>Highest RGB color value.
</DD></DL>
</BLOCKQUOTE>

<P CLASS="ref">Remarks</P>
<BLOCKQUOTE>
<P>The video renderer supports a data transport accessed through the <A HREF="iface/IOverlay.htm">IOverlay</A> interface. This will typically be used by hardware decoder filters that need the renderer to communicate where to put the data rather than requiring the renderer to draw the data. One mechanism for communicating where to put the images is by using a color key. This structure is used by a filter (typically a hardware decoder) to describe color key requirements to the video renderer.
</BLOCKQUOTE>

<H1><A NAME="DIBDATA">DIBDATA</A><HR size=1></H1>
<A HREF="structs.htm">Structures</A>
<P>Maintains information about each GDI DIB. 

<P CLASS="ref">Syntax</P>
<BLOCKQUOTE><PRE>typedef struct tagDIBDATA {
    LONG        PaletteVersion;  
    DIBSECTION  DibSection;     
    HBITMAP     hBitmap;        
    HANDLE      hMapping;      
    BYTE        *pBase;         
} DIBDATA;
</PRE></BLOCKQUOTE>
<P CLASS="ref">Members</P><BLOCKQUOTE>
<DL><DT><B><A NAME="PaletteVersion">PaletteVersion</A></B>
 </DT><DD>Current palette version in use.
</DD><DT><B><A NAME="DibSection">DibSection</A></B>
 </DT><DD>Details of DIB section allocated.
</DD><DT><B><A NAME="hBitmap">hBitmap</A></B>
 </DT><DD>Handle to bitmap for drawing.
</DD><DT><B><A NAME="hMapping">hMapping</A></B>
 </DT><DD>Handle to shared memory block.
</DD><DT><B><A NAME="pBase">pBase</A></B>
 </DT><DD>Pointer to base memory address.
</DD></DL>
</BLOCKQUOTE>

<P CLASS="ref">Remarks</P>
<BLOCKQUOTE>
<P>When the allocator creates a sample, it allocates a <A HREF="../appendixes/Further_Reading.htm#DIBSECTION">DIBSECTION</A> to the sample. When a window receives a sample, it can call the Win32 <A HREF="../appendixes/Further_Reading.htm#BitBlt">BitBlt</A> function to pass the sample from one device context to another device context. This is a mechanism for the image allocator, an image sample, and the draw class to pass bitmap information to each other.
</BLOCKQUOTE>

<H1><A NAME="DVD_ATR">DVD_ATR</A><HR size=1></H1>
<A HREF="structs.htm">Structures</A>
<P>Specifies DVD attributes.
<P CLASS="ref">Syntax</P>
<BLOCKQUOTE><PRE>
typedef struct tagDVD_ATR 
{
    ULONG    ulCAT;     
    BYTE    pbATRI[768];
} DVD_ATR;
</PRE></BLOCKQUOTE>
<P CLASS="ref">Members</P><BLOCKQUOTE>
<DL><DT><B><A NAME="ulCAT">ulCAT</A></B>
 </DT><DD>VMG_CAT if this is for a volume; or VTS_CAT if this is for a Video Title Set (VTS) 
</DD><DT><B><A NAME="pbATRI">pbATRI</A></B>
 </DT><DD>All stream attributes for menu and title from bytes 256 to 1023 of VMGI or VTSI.
</DD></DL></BLOCKQUOTE>
<P CLASS="ref">Remarks</P>
<BLOCKQUOTE>
<P>Refer to the <A HREF="iface/IDvdControl.htm#DVD_Video_specificat">DVD-Video specification</A> to parse these structures.
</BLOCKQUOTE>

<H1><A NAME="DVD_PLAYBACK_LOCATION">DVD_PLAYBACK_LOCATION</A><HR size=1></H1>
<A HREF="structs.htm">Structures</A>
<P>Indicates DVD playback location.
<P CLASS="ref">Syntax</P>
<BLOCKQUOTE><PRE>
typedef struct tagDVD_PLAYBACK_LOCATION 
{
ULONG   TitleNum;   
    ULONG   ChapterNum; 
    ULONG   TimeCode;  
} DVD_PLAYBACK_LOCATION;
</PRE></BLOCKQUOTE>

<P CLASS="ref">Members</P><BLOCKQUOTE>
<DL><DT><B><A NAME="TitleNum">TitleNum</A></B>
 </DT><DD>Title number for the whole disc; Title Track Number (TTN) not Video Title Set_Title Track Number (VTS_TTN).
</DD><DT><B><A NAME="ChapterNum">ChapterNum</A></B>
 </DT><DD>Part-of-title number with title. 0xffffffff if not a simple linear movie.
</DD><DT><B>TimeCode</B>
 </DT><DD>Timecode. Use <A HREF="structs.htm#DVD_TIMECODE">DVD_TIMECODE</A> for current playback time. 0xffffffff if not a simple linear movie.
</DD></DL></BLOCKQUOTE>
<P CLASS="ref">Remarks</P>
<BLOCKQUOTE>
<P><A HREF="structs.htm#TitleNum">TitleNum</A> and <B>ChapterNum</B> or <B>TitleNum</B> and <B>TimeCode</B> are sufficient to save the playback location for simple linear movies.
</BLOCKQUOTE>

<H1><A NAME="DVD_TIMECODE">DVD_TIMECODE</A><HR size=1></H1>
<A HREF="structs.htm">Structures</A>
<P>Contains DVD timecode in hours, minutes, seconds, and frames. 
<P CLASS="ref">Syntax</P>
<BLOCKQUOTE><PRE>
typedef struct tagDVD_TIMECODE")
{
   ULONG Hours1   :4; 
   ULONG Hours10  :4; 

   ULONG Minutes1 :4; 
   ULONG Minutes10:4; 

   ULONG Seconds1 :4; 
   ULONG Seconds10:4; 

   ULONG Frames1  :4; 
   ULONG Frames10 :2; 

   ULONG FrameRateCode:2; 
} DVD_TIMECODE;
</PRE></BLOCKQUOTE>
<P CLASS="ref">Members</P><BLOCKQUOTE>
<DL><DT><B><A NAME="Hours1">Hours1</A></B>
 </DT><DD>Hours.
</DD><DT><B><A NAME="Hours10">Hours10</A></B>
 </DT><DD>Tens of hours.
</DD><DT><B><A NAME="Minutes1">Minutes1</A></B>
 </DT><DD>Minutes.
</DD><DT><B><A NAME="Minutes10">Minutes10</A></B>
 </DT><DD>Tens of minutes.
</DD><DT><B><A NAME="Seconds1">Seconds1</A></B>
 </DT><DD>Seconds.
</DD><DT><B><A NAME="Seconds10">Seconds10</A></B>
 </DT><DD>Tens of seconds.
</DD><DT><B><A NAME="Frames1">Frames1</A></B>
 </DT><DD>Frames.
</DD><DT><B><A NAME="Frames10">Frames10</A></B>
 </DT><DD>Tens of frames.
</DD><DT><B><A NAME="FrameRateCode">FrameRateCode</A></B>
 </DT><DD>Frames per second dropped and not dropped as indicated by <A HREF="dtypes.htm#DVD_FRAMERATE">DVD_FRAMERATE</A>.
</DD></DL></BLOCKQUOTE>
<P CLASS="ref">Remarks</P>
<BLOCKQUOTE>
<P>DVD Timecode is binary coded decimal (BCD) encoded in the format 0xHhMmSsFf, where:
<UL>
<LI>H is tens of hours
<LI>h is hours
<LI>M is tens of minutes
<LI>m is minutes
<LI>S is tens of seconds
<LI>s is seconds
<LI>F is tens of frames
<LI>f is frames
</UL>
</BLOCKQUOTE>

<H1><A NAME="FILTER_INFO">FILTER_INFO</A><HR size=1></H1>
<A HREF="structs.htm">Structures</A>
<P>Contains information about a filter.
<P CLASS="ref">Syntax</P>
<BLOCKQUOTE><PRE>
typedef struct  _FilterInfo
    {
    WCHAR achName[ 128 ];
    IFilterGraph __RPC_FAR *pGraph;
    }     FILTER_INFO;
</PRE></BLOCKQUOTE>

<P CLASS="ref">Members</P><BLOCKQUOTE>
<DL><DT><B><A NAME="achName">achName</A></B>
 </DT><DD>Name of the filter.
</DD><DT><B><A NAME="pGraph">pGraph</A></B>
 </DT><DD>Pointer to the <A HREF="iface/IFilterGraph.htm">IFilterGraph</A> interface to which the filter is connected.
</DD></DL></BLOCKQUOTE>

<H1><A NAME="MPEG1VIDEOINFO">MPEG1VIDEOINFO</A><HR size=1></H1>
<A HREF="structs.htm">Structures</A>
<P>Describes an MPEG-1 video stream.
<P CLASS="ref">Syntax</P>
<BLOCKQUOTE><PRE>
typedef struct tagMPEG1VIDEOINFO {
    VIDEOINFOHEADER hdr;
    DWORD           dwStartTimeCode;
    DWORD           cbSequenceHeader;
    BYTE            bSequenceHeader[1];
} MPEG1VIDEOINFO;
</PRE></BLOCKQUOTE>
<P CLASS="ref">Members</P><BLOCKQUOTE>
<DL><DT><B><A NAME="hdr">hdr</A></B>
 </DT><DD>Compatible with <A HREF="structs.htm#VIDEOINFOHEADER">VIDEOINFOHEADER</A>.
</DD><DT><B><A NAME="dwStartTimeCode">dwStartTimeCode</A></B>
 </DT><DD>25-bit "group-of-pictures" time code at start of data. 
</DD><DT><B><A NAME="cbSequenceHeader">cbSequenceHeader</A></B>
 </DT><DD>Length in bytes of <A HREF="structs.htm#bSequenceHeader">bSequenceHeader</A>.
</DD><DT><B><A NAME="bSequenceHeader">bSequenceHeader</A></B>
 </DT><DD>Sequence header including quantization matrices, if any.
</DD></DL></BLOCKQUOTE>

<H1><A NAME="MPEG2VIDEOINFO">MPEG2VIDEOINFO</A><HR size=1></H1>
<A HREF="structs.htm">Structures</A>
<P>Describes an MPEG-2 video stream.
<P CLASS="ref">Syntax</P>
<BLOCKQUOTE><PRE>
typedef struct tagMPEG2VIDEOINFO {
    VIDEOINFOHEADER2    hdr;
    DWORD               dwStartTimeCode;   
    DWORD               cbSequenceHeader;     
    DWORD               dwProfile;     
    DWORD               dwLevel;            
    DWORD               dwFlags;            
    DWORD               dwSequenceHeader[1];     
} MPEG2VIDEOINFO;
</PRE></BLOCKQUOTE>
<P CLASS="ref">Members</P><BLOCKQUOTE>
<DL><DT><B><A NAME="hdr">hdr</A></B>
 </DT><DD>Compatible with <A HREF="structs.htm#VIDEOINFOHEADER2">VIDEOINFOHEADER2</A>. 
</DD><DT><B><A NAME="dwStartTimeCode">dwStartTimeCode</A></B>
 </DT><DD>25-bit "group-of-pictures" time code at start of data (not used for DVD).
</DD><DT><B><A NAME="cbSequenceHeader">cbSequenceHeader</A></B>
 </DT><DD>Length in bytes of <A HREF="structs.htm#dwSequenceHeader">dwSequenceHeader</A> (zero for DVD). 
</DD><DT><B><A NAME="dwProfile">dwProfile</A></B>
 </DT><DD><A HREF="dtypes.htm#MPEG2Profile">MPEG2Profile</A> enumerated type member.
</DD><DT><B><A NAME="dwLevel">dwLevel</A></B>
 </DT><DD><A HREF="dtypes.htm#MPEG2Level">MPEG2Level</A> enumerated type member.
</DD><DT><B><A NAME="dwFlags">dwFlags</A></B>
 </DT><DD>Flag indicating preferences. Set one or a combination of the following values.
<TABLE>
<TR><TD>AMMPEG2_DoPanScan </TD><TD>If set, the MPEG-2 video decoder should crop the output image based on <A CLASS="Glossary" HREF="javascript:Glossary(sRelPath + 'gloss/gloss_P.htm#pan_scan')">pan-scan</A> vectors in the picture display extension and change the picture aspect ratio accordingly.
 </TD></TR><TR><TD>AMMPEG2_DVDLine21Field1 </TD><TD>If set, the MPEG-2 decoder must be able to produce an output pin for DVD style closed-captioned data found in the Group Of Pictures (GOP) layer of field 1.
 </TD></TR><TR><TD>AMMPEG2_DVDLine21Field2 </TD><TD>If set, the MPEG-2 decoder must be able to produce an output pin for DVD style closed-captioned data found in the GOP layer of field 2.
 </TD></TR><TR><TD>AMMPEG2_SourceIsLetterboxed </TD><TD>If set, indicates that black bars have been encoded in the top and bottom of the video.
 </TD></TR><TR><TD>AMMPEG2_FilmCameraMode </TD><TD>If set, indicates "film mode" used for the 625/50 (line/field)






 content. If cleared, indicates that "camera mode" was used.
</TD></TR></TABLE>
</DD><DD>Set undefined flags to zero or connection will be rejected.
</DD>
<DT><B><A NAME="dwSequenceHeader">dwSequenceHeader</A></B>
 </DT><DD>Sequence header including quantization matrices, if any.
</DD></DL></BLOCKQUOTE>



<H1><A NAME="PIN_INFO">PIN_INFO</A><HR size=1></H1>
<A HREF="structs.htm">Structures</A>
<P>Contains information about a pin.
<P CLASS="ref">Syntax</P>
<BLOCKQUOTE><PRE>typedef struct  _PinInfo
    {
    IBaseFilter  *pFilter;
    PIN_DIRECTION dir;
    WCHAR achName[ 128 ];
    }        PIN_INFO;
</PRE></BLOCKQUOTE>
<P CLASS="ref">Members</P><BLOCKQUOTE>
<DL><DT><B><A NAME="pFilter">pFilter</A></B>
 </DT><DD>Pointer to the <A HREF="iface/IBaseFilter.htm">IBaseFilter</A> interface of the owning filter.
</DD><DT><B><A NAME="dir">dir</A></B>
 </DT><DD>Direction of the pin (input or output).
</DD><DT><B><A NAME="achName">achName</A></B>
 </DT><DD>Name of the pin.
</DD></DL></BLOCKQUOTE>

<H1><A NAME="POSITION">POSITION</A><HR size=1></H1>
<A HREF="structs.htm">Structures</A>
<P>Placeholder for a linked list.
<P CLASS="ref">Syntax</P>
<BLOCKQUOTE><PRE>
struct __POSITION { int unused; };
typedef __POSITION* POSITION;
</PRE></BLOCKQUOTE>
<P CLASS="ref">Members</P><BLOCKQUOTE>
<DL><DT><B><A NAME="unused">unused</A></B>
 </DT><DD>Integer value that specifies the location of an item in a linked list.
</DD></DL></BLOCKQUOTE>
<P CLASS="ref">Remarks</P>
<BLOCKQUOTE>
<P>This structure can point to any element in a linked list, including null elements (such as an end-of-list marker). This structure will, however, become invalid if you delete the item it points to.

<P>When you perform operations that return a <B>POSITION</B> pointer on a single list element, a successful operation sets it to an appropriate non-null value, while NULL indicates that the items position could not be found. When you perform operations on the entire list, the pointer represents a Win32 BOOLEAN value, where TRUE indicates success and FALSE indicates failure.
</BLOCKQUOTE>

<P CLASS="ref">See Also</P>
<BLOCKQUOTE>
<P><A HREF="class/CBaseList.htm#GetHeadPositionI">CBaseList::GetHeadPositionI</A>, <A HREF="class/CBaseList.htm#GetTailPositionI">CBaseList::GetTailPositionI</A>
</BLOCKQUOTE>

<H1><A NAME="Quality">Quality</A><HR size=1></H1>
<A HREF="structs.htm">Structures</A>
<P>Describes a quality message by indicating Flood or Famine in the renderer and specifying the percentage of frames to drop or add to optimize the renderer's performance.
<P CLASS="ref">Syntax</P>
<BLOCKQUOTE><PRE>typedef struct{
    QualityMessageType Type;
    long                Proportion;
    REFERENCE_TIME       Late;
    REFERENCE_TIME       TimeStamp;
                           } Quality;
</PRE></BLOCKQUOTE>
<P CLASS="ref">Members</P><BLOCKQUOTE>
<DL><DT><B><A NAME="Type_member">Type</A></B>
 </DT><DD>Either <A HREF="dtypes.htm#Famine">Famine</A> or <A HREF="dtypes.htm#Flood">Flood</A>, indicating that a <A CLASS="Glossary" HREF="javascript:Glossary(sRelPath + 'gloss/gloss_D.htm#downstream_filter')">downstream filter</A> needs more or less data.
</DD><DT><B><A NAME="Proportion">Proportion</A></B>
 </DT><DD>Value that specifies the rate at which DirectShow should continue to send media samples. The base value is 1000, which indicates there should be no change. A percentage increase or decrease from 1000 indicates the percentage of frames to add or drop. If this value is 800, for example, DirectShow will drop 20 percent of the incoming frames to match the renderer's speed.
</DD><DT><B><A NAME="Late">Late</A></B>
 </DT><DD>If a famine exists downstream, this is the amount of time by which the stream is lagging.
</DD><DT><B><A NAME="TimeStamp">TimeStamp</A></B>
 </DT><DD>Value that specifies the time when DirectShow created this structure, which is usually the start time on a video sample.
</DD></DL></BLOCKQUOTE>

<H1><A NAME="REGFILTER">REGFILTER</A><HR size=1></H1>
<A HREF="structs.htm">Structures</A>
<P>Identifies a filter in the registry.
<P CLASS="ref">Syntax</P>
<BLOCKQUOTE><PRE>
typedef struct {
    CLSID Clsid;             
    LPWSTR Name;           
} REGFILTER;
</PRE></BLOCKQUOTE>
<P CLASS="ref">Members</P><BLOCKQUOTE>
<DL><DT><B><A NAME="Clsid">Clsid</A></B>
 </DT><DD>Class identifier of the filter.
</DD><DT><B><A NAME="Name">Name</A></B>
 </DT><DD>Name of the filter.
</DD></DL></BLOCKQUOTE>

<H1><A NAME="REGFILTER2">REGFILTER2</A><HR size=1></H1>
<A HREF="structs.htm">Structures</A>
<P>Describes a filter for registration through the <A HREF="iface/IFilterMapper2.htm">IFilterMapper2</A> interface.
<P CLASS="ref">Syntax</P>
<BLOCKQUOTE><PRE>typedef struct
{
    DWORD dwVersion;
    DWORD dwMerit;

    /* unnamed union */
    [switch_is(dwVersion)] [switch_type(DWORD)] union
    {
        [case(1)]

            struct
            {
                ULONG cPins;
                [size_is(cPins)] const REGFILTERPINS *rgPins;
            };

        [case(2)]

            struct
            {
                ULONG cPins2;
                [size_is(cPins2)] const REGFILTERPINS2 *rgPins2;
            };

        [default]
            ;
    } ;

} REGFILTER2;
</PRE></BLOCKQUOTE>


<P CLASS="ref">Members</P><BLOCKQUOTE>
<DL><DT><B><A NAME="dwVersion">dwVersion</A></B>
 </DT><DD>Indicates the filter registration format to use. 
</DD><DT><B><A NAME="dwMerit">dwMerit</A></B>
 </DT><DD>Position in the order of enumeration. Filters or categories with higher merit are enumerated first. 
</DD><DT><B><A NAME="cPins">cPins</A></B>
 </DT><DD>Number of pins (if <B>dwVersion</B> = 1).
</DD><DT><B><A NAME="rgPins">rgPins</A></B>
 </DT><DD>Array of <A HREF="structs.htm#REGFILTERPINS">REGFILTERPINS</A> structures representing each pin to be registered (if <B>dwVersion</B> = 1).
</DD><DT><B><A NAME="cPins2">cPins2</A></B>
 </DT><DD>Number of pins (if <B>dwVersion</B> = 2).
</DD><DT><B><A NAME="rgPins2">rgPins2</A></B>
 </DT><DD>Array of <A HREF="structs.htm#REGFILTERPINS2">REGFILTERPINS2</A> structures representing each pin to be registered (if <B>dwVersion</B> = 2).
</DD></DL></BLOCKQUOTE>
<P CLASS="ref">Remarks</P>
<BLOCKQUOTE>
<P>This structure is passed in to the <A HREF="iface/IFilterMapper2.htm#RegisterFilter">IFilterMapper2::RegisterFilter</A> method. 

<P>Set <B>dwVersion</B> to 1 if you are using the old format, or to 2 if you need mediums and pin categories.
</BLOCKQUOTE>


<H1><A NAME="REGFILTERPINS">REGFILTERPINS</A><HR size=1></H1>
<A HREF="structs.htm">Structures</A>
<P>Contains pin information for registering a filter. 
<P CLASS="ref">Syntax</P>
<BLOCKQUOTE><PRE>typedef struct
{
    LPWSTR           strName;
    BOOL             bRendered;
    BOOL             bOutput;
    BOOL             bZero;
    BOOL             bMany;
    const CLSID *    clsConnectsToFilter;
    const WCHAR *    strConnectsToPin;
    UINT             nMediaTypes;
    const REGPINTYPES * lpMediaType;
} REGFILTERPINS;
</PRE></BLOCKQUOTE>
<P CLASS="ref">Members</P><BLOCKQUOTE>
<DL><DT><B><A NAME="strName">strName</A></B>
 </DT><DD>Name of the pin. 
</DD><DT><B><A NAME="bRendered">bRendered</A></B>
 </DT><DD>Set to TRUE if the filter renders this input; otherwise, set to FALSE. 
</DD><DT><B><A NAME="bOutput">bOutput</A></B>
 </DT><DD>Set to TRUE if this pin is an output pin. 
</DD><DT><B><A NAME="bZero">bZero</A></B>
 </DT><DD>Set to TRUE if the filter has zero instances of this pin; otherwise, set to FALSE.
</DD><DT><B><A NAME="bMany">bMany</A></B>
 </DT><DD>Set to TRUE if the filter has more than one instance of this pin; otherwise, set to FALSE.
</DD><DT><B><A NAME="clsConnectsToFilter">clsConnectsToFilter</A></B>
 </DT><DD>CLSID of the filter to which this filter connects in a filter graph. 
</DD><DT><B><A NAME="strConnectsToPin">strConnectsToPin</A></B>
 </DT><DD>Name of the pin to which this pin connects in a filter graph.
</DD><DT><B><A NAME="nMediaTypes">nMediaTypes</A></B>
 </DT><DD>Number of media types supported by this pin.
</DD><DT><B><A NAME="lpMediaType">lpMediaType</A></B>
 </DT><DD><A HREF="structs.htm#REGPINTYPES">REGPINTYPES</A> structure providing media type information. 
</DD></DL></BLOCKQUOTE>
<P CLASS="ref">Remarks</P>
<BLOCKQUOTE>
<P>This structure is used by the <A HREF="iface/IFilterMapper.htm">IFilterMapper</A> and <A HREF="iface/IFilterMapper2.htm">IFilterMapper2</A> interfaces for filter registration. It is used if the <B>dwVersion</B> member in <A HREF="structs.htm#REGFILTER2">REGFILTER2</A> is 1.

<P>This structure is equivalent to the <A HREF="structs.htm#AMOVIESETUP_PIN">AMOVIESETUP_PIN</A> structure.
</BLOCKQUOTE>

<H1><A NAME="REGFILTERPINS2">REGFILTERPINS2</A><HR size=1></H1>
<A HREF="structs.htm">Structures</A>
<P>Contains information for registering a filter through the <A HREF="iface/IFilterMapper2.htm">IFilterMapper2</A> interface.
<P CLASS="ref">Syntax</P>
<BLOCKQUOTE><PRE>typedef struct
{    
    DWORD dwFlags;
    UINT  cInstances;
    UINT  nMediaTypes; 
	const REGPINTYPES * lpMediaType;
    UINT  nMediums;
    const REGPINMEDIUM *lpMedium;
    const CLSID *clsPinCategory;
} REGFILTERPINS2;
</PRE></BLOCKQUOTE>

<P CLASS="ref">Members</P><BLOCKQUOTE>
<DL><DT><B><A NAME="dwFlags">dwFlags</A></B>
 </DT><DD>Combination of <A HREF="dtypes.htm#REG_PINFLAG">REG_PINFLAG</A> flags.
</DD><DT><B><A NAME="cInstances">cInstances</A></B>
 </DT><DD>Number of instances of the pin, if known.
</DD><DT><B><A NAME="nMediaTypes">nMediaTypes</A></B>
 </DT><DD>Number of media types supported by this pin. 
</DD><DT><B><A NAME="lpMediaType">lpMediaType</A></B>
 </DT><DD>Array of <B>nMediaTypes</B> <A HREF="structs.htm#REGPINTYPES">REGPINTYPES</A> structures providing media type information. 



</DD><DT><B><A NAME="nMediums">nMediums</A></B>
 </DT><DD>Number of mediums.
</DD><DT><B><A NAME="lpMedium">lpMedium</A></B>
 </DT><DD>Array of <A HREF="structs.htm#REGPINMEDIUM">REGPINMEDIUM</A> structures containing medium information for each pin.
</DD><DT><B><A NAME="clsPinCategory">clsPinCategory</A></B>
 </DT><DD>Pin category (for kernel streaming pins) as defined in the Windows NT DDK.
</DD></DL></BLOCKQUOTE>


<H1><A NAME="REGPINMEDIUM">REGPINMEDIUM</A><HR size=1></H1>
<A HREF="structs.htm">Structures</A>
<P>Describes a pin medium (as defined in the Windows NT DDK) for registration through the <A HREF="iface/IFilterMapper2.htm">IFilterMapper2</A> interface.
<P CLASS="ref">Syntax</P>
<BLOCKQUOTE><PRE>typedef struct
{
    CLSID clsMedium;
    DWORD dw1;
    DWORD dw2;
} REGPINMEDIUM;
</PRE></BLOCKQUOTE>
<P CLASS="ref">Members</P><BLOCKQUOTE>
<DL><DT><B><A NAME="clsMedium">clsMedium</A></B>
 </DT><DD>Contains the globally unique set identifier.
</DD><DT><B><A NAME="dw1">dw1</A></B>
 </DT><DD>Contains the set-specific identifier for an item within the set.
</DD><DT><B><A NAME="dw2">dw2</A></B>
 </DT><DD>Used for various set flags. Zero when not used.
</DD></DL></BLOCKQUOTE>
<P CLASS="ref">Remarks</P>
<BLOCKQUOTE>
<P>A <I>medium</I> defines a method of communication (for example, the bus over which the communication occurs). Each ID within that set is used to represent the form of communication. Register mediums for your filter if you need to search for DirectShow filters built on kernel streaming pins, which can connect to each other.
</BLOCKQUOTE>

<H1><A NAME="REGPINTYPES">REGPINTYPES</A><HR size=1></H1>
<A HREF="structs.htm">Structures</A>
<P>Contains media type information for registering a filter.
<P CLASS="ref">Syntax</P>
<BLOCKQUOTE><PRE>typedef struct
{
    const CLSID * clsMajorType;
    const CLSID * clsMinorType;
} REGPINTYPES;
</PRE></BLOCKQUOTE>
<P CLASS="ref">Members</P><BLOCKQUOTE>
<DL><DT><B><A NAME="clsMajorType">clsMajorType</A></B>
 </DT><DD>Major media type supported by the filter. 
</DD><DT><B><A NAME="clsMinorType">clsMinorType</A></B>
 </DT><DD>Minor media type supported by the filter. 
</DD></DL></BLOCKQUOTE>
<P CLASS="ref">Remarks</P>
<BLOCKQUOTE>
<P>This structure is used by the <A HREF="iface/IFilterMapper.htm">IFilterMapper</A> and <A HREF="iface/IFilterMapper2.htm">IFilterMapper2</A> interfaces to identify media types a pin handles and to register filters.
<P>This structure is equivalent to the <A HREF="structs.htm#AMOVIESETUP_MEDIATYPE">AMOVIESETUP_MEDIATYPE</A> structure.
</BLOCKQUOTE>

<H1><A NAME="TIMECODE">TIMECODE</A><HR size=1></H1>
<A HREF="structs.htm">Structures</A>
<P>Contains basic timecode frame count information.
<P CLASS="ref">Syntax</P>
<BLOCKQUOTE><PRE>
typedef struct tagTIMECODE {
    WORD  wFrameRate;
    WORD  wFrameFract;
    DWORD  dwFrames;
}TIMECODE;
</PRE></BLOCKQUOTE>

<P CLASS="ref">Members</P><BLOCKQUOTE>
<DL><DT><B><A NAME="wFrameRate">wFrameRate</A></B>
 </DT><DD>Number of frames per second. Specify with one of the following values.
<TABLE>
<TR><TD>ED_FORMAT_SMPTE_30 </TD><TD>30 frames per second.
 </TD></TR><TR><TD>ED_FORMAT_SMPTE_30DROP </TD><TD>30 frames per second drop frame (actual rate 29.97 fps).
 </TD></TR><TR><TD>ED_FORMAT_SMPTE_25 </TD><TD>25 frames per second.
 </TD></TR><TR><TD>ED_FORMAT_SMPTE_24 </TD><TD>24 frames per second.
</TD></TR></TABLE>
</DD><DT><B><A NAME="wFrameFract">wFrameFract</A></B>
 </DT><DD>Fractional frame. Full scale is 0x1000. 
</DD><DT><B><A NAME="dwFrames">dwFrames</A></B>
 </DT><DD>Timecode value as a binary framecount.


</DD></DL></BLOCKQUOTE>
<P CLASS="ref">Remarks</P>
<BLOCKQUOTE>
<P>Fractional frame can be used to indicate temporal offset into frame when timecode was actually read from an external device; for example, wFrameFract=0x7ff means the timecode value was read from the device at the end of the first video field.

<P><B>Note</B>  Because timecode commonly enters or leaves computer systems as ASCII values, conversion helper methods that convert the ASCII values to and from binary framecounts are supplied in the sample filter.
</BLOCKQUOTE>

<H1><A NAME="TIMECODE_SAMPLE">TIMECODE_SAMPLE</A><HR size=1></H1>
<A HREF="structs.htm">Structures</A>
<P>Contains complete timecode information.
<P CLASS="ref">Syntax</P>
<BLOCKQUOTE><PRE>
typedef struct tagTIMECODE_SAMPLE {
    LONGLONG  qwTick;
    TIMECODE  timecode;
    DWORD  dwUser;
    DWORD  dwFlags;
} TIMECODE_SAMPLE;
</PRE></BLOCKQUOTE>

<P CLASS="ref">Members</P><BLOCKQUOTE>
<DL><DT><B><A NAME="qwTick">qwTick</A></B>
 </DT><DD><A CLASS="Glossary" HREF="javascript:Glossary(sRelPath + 'gloss/gloss_R.htm#reference_time')">reference time</A>, in 100-nanosecond units.
</DD><DT><B><A NAME="timecode">timecode</A></B>
 </DT><DD><A HREF="structs.htm#TIMECODE">TIMECODE</A> structure.
</DD><DT><B><A NAME="dwUser">dwUser</A></B>
 </DT><DD>Packed SMPTE <A CLASS="Glossary" HREF="javascript:Glossary(sRelPath + 'gloss/gloss_U.htm#userbits')">userbits</A>.
</DD><DT><B><A NAME="dwFlags">dwFlags</A></B>
 </DT><DD>Timecode flag masks. Specify one or more of the following values.
<TABLE>
<TR><TD>AM_TIMECODE_FLAG_FCM </TD><TD>Frame code mode; 0 = nondrop; 1 = drop.
</TD></TR><TR><TD>AM_TIMECODE_FLAG_CF </TD><TD>Color frame flag.
</TD></TR><TR><TD>AM_TIMECODE_FLAG_FIELD </TD><TD>Field flag.
</TD></TR><TR><TD>AM_TIMECODE_FLAG_DF </TD><TD>Drop frame flag (from flags in actual timecode on external media).
</TD></TR><TR><TD>AM_TIMECODE_COLORFRAME </TD><TD>Which frame in color sequence.



</TD></TR><TR><TD>AM_TIMECODE_COLORSEQUENCE </TD><TD>Duration in frames of complete sequence.
</TD></TR><TR><TD>AM_TIMECODE_FILMSEQUENCE_TYPE </TD><TD>One of FILM_SEQUENCE_XXX defines.
</TD></TR></TABLE>
</DD></DL></BLOCKQUOTE>
<P CLASS="ref">Remarks</P>
<BLOCKQUOTE>
<P>The upper 16 bits in <B>dwFlags</B> are reserved for future use&#151;set to zero.
 </BLOCKQUOTE>
 
<H1><A NAME="TRUECOLORINFO_structure">TRUECOLORINFO</A><HR size=1></H1>
<A HREF="structs.htm">Structures</A>
<P>Contains color palette and bitmask information for a video image.
<P CLASS="ref">Syntax</P>
<BLOCKQUOTE><PRE>
typedef struct tag_TRUECOLORINFO {
    DWORD dwBitMasks[iMASK_COLORS];
    RGBQUAD bmiColors[iPALETTE_COLORS];
} TRUECOLORINFO;
</PRE></BLOCKQUOTE>
<P CLASS="ref">Members</P><BLOCKQUOTE>
<DL><DT><B><A NAME="dwBitMasks_iMASK_COL">dwBitMasks[iMASK_COLORS]</A></B>
 </DT><DD>Array of color masks (one per color element).
</DD><DT><B><A NAME="bmiColors_iPALETTE_C">bmiColors[iPALETTE_COLORS]</A></B>
 </DT><DD>Array of palette colors.
</DD></DL></BLOCKQUOTE>
<P CLASS="ref">Remarks</P>
<BLOCKQUOTE>
<P>This structure is not used for some RGB formats. For more information about which fields are valid under different circumstances, see the Microsoft Win32&#174; documentation for <A HREF="../filtdev/DV_Data_AVI_File_Format.htm#BITMAPINFO">BITMAPINFO</A>.
</BLOCKQUOTE>
<P CLASS="ref">See Also</P>
<BLOCKQUOTE>
<P><A HREF="structs.htm#VIDEOINFO">VIDEOINFO</A>
</BLOCKQUOTE>

<H1><A NAME="VIDEO_STREAM_CONFIG_CAPS">VIDEO_STREAM_CONFIG_CAPS</A><HR size=1></H1>
<A HREF="structs.htm">Structures</A>
<P>Contains information about possible connections.
<P CLASS="ref">Syntax</P>
<BLOCKQUOTE><PRE>
typedef struct  _VIDEO_STREAM_CONFIG_CAPS
    {
    GUID guid;
    ULONG VideoStandard;
    SIZE InputSize;
    SIZE MinCroppingSize;
    SIZE MaxCroppingSize;
    int CropGranularityX;
    int CropGranularityY;
    int CropAlignX;
    int CropAlignY;
    SIZE MinOutputSize;
    SIZE MaxOutputSize;
    int OutputGranularityX;
    int OutputGranularityY;
    int StretchTapsX;
    int StretchTapsY;
    int ShrinkTapsX;
    int ShrinkTapsY;
    LONGLONG MinFrameInterval;
    LONGLONG MaxFrameInterval;
    LONG MinBitsPerSecond;
    LONG MaxBitsPerSecond;
    }  VIDEO_STREAM_CONFIG_CAPS;
</PRE></BLOCKQUOTE>

<P CLASS="ref">Members</P><BLOCKQUOTE>
<DL><DT><B><A NAME="guid">guid</A></B>
</DT><DD>Will set MEDIATYPE_Video to indicate a video sample.
</DD><DT><B><A NAME="VideoStandard">VideoStandard</A></B>
</DT><DD>The analog video standard supported. Set in the <A HREF="dtypes.htm#AnalogVideoStandard">AnalogVideoStandard</A> enumeration type (0 if not supported).
</DD><DT><B><A NAME="InputSize">InputSize</A></B>
</DT><DD>Size of the incoming signal, expressed through the Win32 <A HREF="../appendixes/Further_Reading.htm#SIZE">SIZE</A> structure as the image rectangle's width and height in pixels. For a compressor, the size is taken from the width and height members of the Win32 <A HREF="../filtdev/DV_Data_AVI_File_Format.htm#BITMAPINFOHEADER_AVI">BITMAPINFOHEADER</A> structure in the input pin's <A HREF="structs.htm#AM_MEDIA_TYPE">AM_MEDIA_TYPE</A> structure. For a capture filter, the size is the largest signal the filter can digitize with every pixel remaining unique.
</DD><DT><B><A NAME="MinCroppingSize">MinCroppingSize</A></B>
</DT><DD>Smallest cropping rectangle allowed, as specified in the <A HREF="structs.htm#VIDEOINFOHEADER">VIDEOINFOHEADER</A> structure's 
<A HREF="structs.htm#VIDEOINFOHEADER_rcSource">rcSource</A> member.
</DD><DT><B><A NAME="MaxCroppingSize">MaxCroppingSize</A></B>
</DT><DD>Largest cropping rectangle allowed, as specified in the <A HREF="structs.htm#VIDEOINFOHEADER">VIDEOINFOHEADER</A> structure's 
<A HREF="structs.htm#VIDEOINFOHEADER_rcSource">rcSource</A> member.
</DD><DT><B><A NAME="CropGranularityX">CropGranularityX</A></B>
</DT><DD>Granularity of the cropping size. For example, you could specify that the only valid widths are an even multiple of four.
</DD><DT><B><A NAME="CropGranularityY">CropGranularityY</A></B>
</DT><DD>Granularity of the cropping size. For example, you could specify that the only valid heights are an even multiple of four.
</DD><DT><B><A NAME="CropAlignX">CropAlignX</A></B>
</DT><DD>Alignment of the cropping rectangle inside <A HREF="structs.htm#InputSize">InputSize</A>. For example, you could specify that rectangles must start on a boundary that is a multiple of four.
</DD><DT><B><A NAME="CropAlignY">CropAlignY</A></B>
</DT><DD>Alignment of the cropping rectangle inside <A HREF="structs.htm#InputSize">InputSize</A>. For example, you could specify that rectangles must start on a boundary that is a multiple of four.
</DD><DT><B><A NAME="MinOutputSize">MinOutputSize</A></B>
</DT><DD>Smallest bitmap this pin can produce.
</DD><DT><B><A NAME="MaxOutputSize">MaxOutputSize</A></B>
</DT><DD>Largest bitmap this pin can produce.
</DD><DT><B><A NAME="OutputGranularityX">OutputGranularityX</A></B>
</DT><DD> Granularity of output bitmap width.
</DD><DT><B><A NAME="OutputGranularityY">OutputGranularityY</A></B>
</DT><DD>Granularity of output bitmap height.
</DD><DT><B><A NAME="StretchTapsX">StretchTapsX</A></B>
</DT><DD>Value indicating how well the filter can stretch the image's width. A value of 0 means the filter can't stretch; 1 means it uses pixel doubling; 2 means it uses interpolation (2 taps); 3 and higher indicate it implements better interpolation.


</DD><DT><B><A NAME="StretchTapsY">StretchTapsY</A></B>
</DT><DD>Value indicating how well the filter can stretch the image's height. A value of 0 means the filter can't stretch; 1 means it uses pixel doubling; 2 means it uses interpolation (2 taps); 3 and higher indicate it implements better interpolation.


</DD><DT><B><A NAME="ShrinkTapsX">ShrinkTapsX</A></B>
</DT><DD>Value indicating how well the filter can shrink the image's width. A value of 0 means the filter can't shrink; 1 means it just eliminates some rows of pixels; 2 means it uses interpolation (2 taps); 3 and higher indicate it implements better interpolation.
</DD><DT><B><A NAME="ShrinkTapsY">ShrinkTapsY</A></B>
</DT><DD>Value indicating how well the filter can shrink the image's height. A value of 0 means the filter can't shrink; 1 means it just eliminates some rows of pixels; 2 means it uses interpolation (2 taps); 3 and higher indicate it implements better interpolation.
</DD><DT><B><A NAME="MinFrameInterval">MinFrameInterval</A></B>
</DT><DD>Minimum frame rate allowed. This applies to the capture filter only.
</DD><DT><B><A NAME="MaxFrameInterval">MaxFrameInterval</A></B>
</DT><DD>Maximum frame rate allowed. This applies to the capture filter only.
</DD><DT><B><A NAME="MinBitsPerSecond">MinBitsPerSecond</A></B>
</DT><DD>Minimum data rate this pin can produce.
</DD><DT><B><A NAME="MaxBitsPerSecond">MaxBitsPerSecond</A></B>
</DT><DD>Maximum data rate this pin can produce.
</DD></DL></BLOCKQUOTE>
<P CLASS="ref">Remarks</P>
<BLOCKQUOTE>
<P>For example, assume the following values for some of the structure members.
<UL><LI><A HREF="structs.htm#MinCroppingSize">MinCroppingSize</A> = (160, 120)
<LI><A HREF="structs.htm#MaxCroppingSize">MaxCroppingSize</A> = (320, 240)
<LI><A HREF="structs.htm#CropGranularityX">CropGranularityX</A> = 4
<LI><A HREF="structs.htm#CropGranularityY">CropGranularityY</A> = 8

</UL>
<P>These values indicate that valid cropping sizes begin at <A HREF="structs.htm#MinCroppingSize">MinCroppingSize</A> and increase in steps in the x-direction by <A HREF="structs.htm#CropGranularityX">CropGranularityX</A> and in the y-direction by <A HREF="structs.htm#CropGranularityY">CropGranularityY</A>. In this case the x-value can be anywhere from 160 to 320 pixels in steps of 4 and the y-value can be anywhere from 120 to 240 pixels in steps of 8.

<P>In this scenario a few of the valid sizes are:
<UL><LI>160 &#215; 120, 164 &#215; 120, 168 &#215; 120, 172 &#215; 120, and so on
<LI>160 &#215; 128, 164 &#215; 128, 168 &#215; 128, 172 &#215; 128, and so on
<LI>160 &#215; 136, 164 &#215; 136, 168 &#215; 136, 172 &#215; 136, and so on
</UL>
<P><A HREF="structs.htm#CropAlignX">CropAlignX</A> and <A HREF="structs.htm#CropAlignY">CropAlignY</A> indicate where the cropping rectangle can be inside the input size rectangle. Given a 160 &#215; 120 sized cropping rectangle and the following:

<UL><LI>CropAlignX = 2
<LI>CropAlignY = 4
</UL>
<P>Some of the valid values for the <A HREF="structs.htm#VIDEOINFOHEADER">VIDEOINFOHEADER</A> structure's <A HREF="structs.htm#VIDEOINFOHEADER_rcSource">rcSource</A> member are:

<UL><LI>(0, 0, 160, 120)
<LI>(2, 0, 162, 120)
<LI>(2, 4, 162, 124)
<LI>(2, 8, 162, 128)
</UL>
<P>For a 320 &#215; 240 cropping rectangle and the same cropping alignment values, (2, 4, 322, 244) is one example of the many legal rectangles.

<P>The structure members discussed in this section work together to specify what values of <A HREF="structs.htm#VIDEOINFOHEADER_rcSource">rcSource</A> are valid for the <A HREF="structs.htm#VIDEOINFOHEADER">VIDEOINFOHEADER</A> structure that describes the output pin's media type. Of the remaining structure members, <A HREF="structs.htm#MinOutputSize">MinOutputSize</A>, <A HREF="structs.htm#MaxOutputSize">MaxOutputSize</A>, <A HREF="structs.htm#OutputGranularityX">OutputGranularityX</A>, and <A HREF="structs.htm#OutputGranularityY">OutputGranularityY</A> describe the <A HREF="../appendixes/Further_Reading.htm#biWidth">biWidth</A> and <A HREF="../appendixes/Further_Reading.htm#biHeight">biHeight</A> members of the <A HREF="../filtdev/DV_Data_AVI_File_Format.htm#BITMAPINFOHEADER_AVI">BITMAPINFOHEADER</A> structure contained in the output pin's media type <B>VIDEOINFOHEADER</B> structure.
</BLOCKQUOTE>

<H1><A NAME="VIDEOINFO">VIDEOINFO</A><HR size=1></H1>
<A HREF="structs.htm">Structures</A>
<P>Describes the bitmap and color information for a video image.
<P CLASS="ref">Syntax</P>
<BLOCKQUOTE><PRE>
typedef struct tagVIDEOINFO {
    RECT            rcSource,
    RECT            rcTarget,
    DWORD           dwBitRate,
    DWORD           dwBitErrorRate,
    REFERENCE_TIME  AvgTimePerFrame;
    BITMAPINFOHEADER    bmiHeader;
union {
        RGBQUAD     bmiColors[iPALETTE_COLORS];
        DWORD       dwBitMasks[iMASK_COLORS];
        TRUECOLORINFO   TrueColorInfo;
    };
} VIDEOINFO;
</PRE></BLOCKQUOTE>
<P CLASS="ref">Members</P><BLOCKQUOTE>
<DL><DT><B><A NAME="rcSource">rcSource</A></B>
 </DT><DD>Portion of the input video to use. See <A  HREF="../filtdev/Rectangles.htm">Source and Target Rectangles in Video Renderers</A> for examples of how this member works.
</DD><DT><B><A NAME="rcTarget">rcTarget</A></B>
 </DT><DD>Where the video should be displayed. See <A  HREF="../filtdev/Rectangles.htm">Source and Target Rectangles in Video Renderers</A> for examples of how this member works.
</DD><DT><B><A NAME="dwBitRate">dwBitRate</A></B>
 </DT><DD>Approximate bit data rate.
</DD><DT><B><A NAME="dwBitErrorRate">dwBitErrorRate</A></B>
 </DT><DD>Bit error rate for this stream.
</DD><DT><B><A NAME="AvgTimePerFrame">AvgTimePerFrame</A></B>
 </DT><DD>Average time per frame, in 100-nanosecond units.
</DD><DT><B><A NAME="bmiHeader">bmiHeader</A></B>
 </DT><DD>Win32 <A HREF="../filtdev/DV_Data_AVI_File_Format.htm#BITMAPINFOHEADER_AVI">BITMAPINFOHEADER</A> structure that contains color and dimension information for a device-independent bitmap.
</DD><DT><B><A NAME="bmiColors">bmiColors</A></B>
 </DT><DD>Array of Win32 <A HREF="../appendixes/Further_Reading.htm#RGBQUAD">RGBQUAD</A> structures that specifies the video's color palette. Each structure represents a single color, which is a combination of red, green, and blue intensities.
</DD><DT><B><A NAME="dwBitMasks">dwBitMasks</A></B>
 </DT><DD>Array of <A HREF="../appendixes/Further_Reading.htm#DWORD">DWORD</A> values that specify true color bitmasks.
</DD><DT><B><A NAME="TrueColorInfo_member">TrueColorInfo</A></B>
 </DT><DD><A HREF="structs.htm#TRUECOLORINFO_structure">TRUECOLORINFO</A> structure that contains both a color palette and an array of color bitmasks.
</DD></DL></BLOCKQUOTE>
<P CLASS="ref">Remarks</P>
<BLOCKQUOTE>
<P>Never use this structure unless you are sure that you will use it only to store standard RGB formats. If you store anything other than standard RGB, the variable size of the <A HREF="structs.htm#bmiHeader">bmiHeader</A> structure will almost certainly cause problems. You should use the <A HREF="structs.htm#VIDEOINFOHEADER">VIDEOINFOHEADER</A> structure instead. If for some reason you find it absolutely necessary to use the <B>VIDEOINFO</B> structure, do not access <B>TrueColorInfo</B>, <A HREF="structs.htm#dwBitMasks">dwBitMasks</A>, and <A HREF="structs.htm#bmiColors">bmiColors</A> directly; use the <A HREF="utilfunct/Bitmap_Functs_Macros_Data.htm#TRUECOLORINFO_MACRO">TRUECOLORINFO</A>, <A HREF="utilfunct/Bitmap_Functs_Macros_Data.htm#COLORS">COLORS</A>, and <A HREF="utilfunct/Bitmap_Functs_Macros_Data.htm#BITMASKS">BITMASKS</A> macros to return the pointers to the color information.

<P>The first five data members are equivalent to a <A HREF="structs.htm#VIDEOINFOHEADER">VIDEOINFOHEADER</A> structure. They are expanded in full simply to reduce the amount of dereferencing needed when dealing with a pointer to a <B>VIDEOINFO</B> structure.

<P>Which of the <B>TrueColorInfo</B>, <A HREF="structs.htm#dwBitMasks">dwBitMasks</A>, and <A HREF="structs.htm#bmiColors">bmiColors</A> fields is valid depends on the contents of the <A HREF="../filtdev/DV_Data_AVI_File_Format.htm#BITMAPINFOHEADER_AVI">BITMAPINFOHEADER</A> structure. 
</BLOCKQUOTE>
<P CLASS="ref">See Also</P>
<BLOCKQUOTE>
<A  HREF="../filtdev/Rectangles.htm">Source and Target Rectangles in Video Renderers</A>
</BLOCKQUOTE>


<H1><A NAME="VIDEOINFOHEADER">VIDEOINFOHEADER</A><HR size=1></H1>
<A HREF="structs.htm">Structures</A>
<P>Describes the bitmap and color information for a video image.
<P CLASS="ref">Syntax</P>
<BLOCKQUOTE><PRE>
typedef struct tagVIDEOINFOHEADER {
    RECT                rcSource,
    RECT                rcTarget;
    DWORD               dwBitRate;
    DWORD               dwBitErrorRate;
    REFERENCE_TIME      AvgTimePerFrame;
    BITMAPINFOHEADER    bmiHeader;
} VIDEOINFOHEADER;
</PRE></BLOCKQUOTE>
<P CLASS="ref">Members</P><BLOCKQUOTE>
<DL><DT><B><A NAME="VIDEOINFOHEADER_rcSource">rcSource</A></B>
 </DT><DD><A HREF="../appendixes/Further_Reading.htm#RECT">RECT</A> structure that specifies the source video window. This structure can be a clipping rectangle, to select a portion of the source video stream. See <A  HREF="../filtdev/Rectangles.htm">Source and Target Rectangles in Video Renderers</A> for examples of how this member works.
</DD><DT><B><A NAME="VIDEOINFOHEADER_rcTarget">rcTarget</A></B>
 </DT><DD><A HREF="../appendixes/Further_Reading.htm#RECT">RECT</A> structure that specifies the destination video window. See <A  HREF="../filtdev/Rectangles.htm">Source and Target Rectangles in Video Renderers</A> for examples of how this member works.
</DD><DT><B><A NAME="VIDEOINFOHEADER_dwBitRate">dwBitRate</A></B>
 </DT><DD><A HREF="../appendixes/Further_Reading.htm#DWORD">DWORD</A> value that specifies the video stream's approximate data rate, in bits per second.
</DD><DT><B><A NAME="dwBitErrorRate">dwBitErrorRate</A></B>
 </DT><DD><A HREF="../appendixes/Further_Reading.htm#DWORD">DWORD</A> value that specifies the video stream's data error rate, in bit errors per second.
</DD><DT><B><A NAME="VIDEOINFOHEADER_AvgTimePerFrame">AvgTimePerFrame</A></B>
 </DT><DD><A HREF="iface/IReferenceClock.htm#REFERENCE_TIME">REFERENCE_TIME</A> value that specifies the video frame's average display time, in 100-nanosecond units.
</DD><DT><B><A NAME="videoinfoheader_bmiheader">bmiHeader</A></B>
 </DT><DD>Win32 <A HREF="../filtdev/DV_Data_AVI_File_Format.htm#BITMAPINFOHEADER_AVI">BITMAPINFOHEADER</A> structure that contains color and dimension information for the video image bitmap.
</DD></DL></BLOCKQUOTE>

<P CLASS="ref">See Also</P>
<BLOCKQUOTE>
<A  HREF="../filtdev/Rectangles.htm">Source and Target Rectangles in Video Renderers</A>
</BLOCKQUOTE>

<H1><A NAME="VIDEOINFOHEADER2">VIDEOINFOHEADER2</A><HR size=1></H1>
<A HREF="structs.htm">Structures</A>
<P>Describes the bitmap and color information for a video image, including interlace, copy protection, and pixel aspect ratio information.
<P CLASS="ref">Syntax</P>
<BLOCKQUOTE><PRE>
typedef struct tagVIDEOINFOHEADER2 {
    RECT                rcSource;
    RECT                rcTarget;
    DWORD               dwBitRate;
    DWORD               dwBitErrorRate;
    REFERENCE_TIME      AvgTimePerFrame;
    DWORD               dwInterlaceFlags;
    DWORD               dwCopyProtectFlags;
    DWORD               dwPictAspectRatioX; 
    DWORD               dwPictAspectRatioY; 
    DWORD               dwReserved1;        
    DWORD               dwReserved2;        
    BITMAPINFOHEADER    bmiHeader;
} VIDEOINFOHEADER2;
</PRE></BLOCKQUOTE>

<P CLASS="ref">Members</P><BLOCKQUOTE>
<DL><DT><B><A NAME="rcSource">rcSource</A></B>
 </DT><DD><A HREF="../appendixes/Further_Reading.htm#RECT">RECT</A> structure that specifies what part of the source stream should be used to fill the destination buffer. The renderers can use this field to ask the decoders to stretch or clip. See <A  HREF="../filtdev/Rectangles.htm">Source and Target Rectangles in Video Renderers</A> for examples of how this member works.
</DD><DT><B><A NAME="rcTarget">rcTarget</A></B>
 </DT><DD><A HREF="../appendixes/Further_Reading.htm#RECT">RECT</A> structure that specifies that specifies what part of the destination buffer should be used. See <A  HREF="../filtdev/Rectangles.htm">Source and Target Rectangles in Video Renderers</A> for examples of how this member works.
</DD><DT><B><A NAME="dwBitRate">dwBitRate</A></B>
 </DT><DD><A HREF="../appendixes/Further_Reading.htm#DWORD">DWORD</A> value that specifies the video stream's approximate data rate.
</DD><DT><B><A NAME="dwBitErrorRate">dwBitErrorRate</A></B>
 </DT><DD><A HREF="../appendixes/Further_Reading.htm#DWORD">DWORD</A> value that specifies the video stream's data error rate.
</DD><DT><B><A NAME="AvgTimePerFrame">AvgTimePerFrame</A></B>
 </DT><DD><A HREF="iface/IReferenceClock.htm#REFERENCE_TIME">REFERENCE_TIME</A> value that specifies the video frame's average display time, in milliseconds.
</DD><DT><B><A NAME="dwInterlaceFlags">dwInterlaceFlags</A></B>
 </DT><DD>Flag set by one of the following values.
<TABLE>
<TR><TD>AMINTERLACE_IsInterlaced </TD><TD>Indicates an interlace stream. If 0, other interlace bits are irrelevant.
 </TD></TR><TR><TD>AMINTERLACE_1FieldPerSample </TD><TD>Indicates one field per media sample. If 0, indicates 2 fields per media sample.
 </TD></TR><TR><TD>AMINTERLACE_Field1First </TD><TD>Indicates Field 1 is first. If 0, indicates Field 2 is first. Top field in <A CLASS="Glossary" HREF="javascript:Glossary(sRelPath + 'gloss/gloss_P.htm#PAL')">PAL</A> is field 1, top field in NTSC is field 2.
 </TD></TR><TR><TD>AMINTERLACE_UNUSED </TD><TD>Unused.
 </TD></TR><TR><TD>AMINTERLACE_FieldPatternMask </TD><TD>Bits used to indicate field pattern.
 </TD></TR><TR><TD>AMINTERLACE_FieldPatField1Only </TD><TD>Stream never contains a Field 2.
 </TD></TR><TR><TD>AMINTERLACE_FieldPatField2Only </TD><TD>Stream never contains a Field 1.
 </TD></TR><TR><TD>AMINTERLACE_FieldPatBothRegular </TD><TD>There will be a Field 2 for every Field 1.
 </TD></TR><TR><TD>AMINTERLACE_FieldPatBothIrregular </TD><TD>Random pattern of Field 1s and Field 2s.
 </TD></TR><TR><TD>AMINTERLACE_DisplayModeMask </TD><TD>Bits used to indicate display mode.
 </TD></TR><TR><TD>AMINTERLACE_DisplayModeBobOnly </TD><TD>Indicates <A CLASS="Glossary" HREF="javascript:Glossary(sRelPath + 'gloss/gloss_B.htm#bob')">Bob</A> display mode only.
 </TD></TR><TR><TD>AMINTERLACE_DisplayModeWeaveOnly </TD><TD>Indicates <A CLASS="Glossary" HREF="javascript:Glossary(sRelPath + 'gloss/gloss_W.htm#weave')">Weave</A> display mode only.
 </TD></TR><TR><TD>AMINTERLACE_DisplayModeBobOrWeave </TD><TD>Indicates either Bob or Weave display mode.
</TD></TR></TABLE>
</DD><DD>Set undefined flags to zero or connection should be rejected.



</DD><DT><B><A NAME="dwCopyProtectFlags">dwCopyProtectFlags</A></B>
 </DT><DD>Flag set with the AMCOPYPROTECT_RestrictDuplication value to indicate duplication of stream should be restricted. If undefined, specify zero or connection should be rejected.
</DD><DT><B><A NAME="dwPictAspectRatioX">dwPictAspectRatioX</A></B>
 </DT><DD>The X dimension of picture aspect ratio, for example, 16 for 16 &#215; 9 display (inches by inches, not pixels by pixels).
</DD><DT><B><A NAME="dwPictAspectRatioY">dwPictAspectRatioY</A></B>
 </DT><DD>The Y dimension of picture aspect ratio, for example, 9 for 16 &#215; 9 display (inches by inches, not pixels by pixels).



</DD><DT><B><A NAME="dwReserved1">dwReserved1</A></B>
 </DT><DD>Reserved for future use. Must be zero; reject connection otherwise
</DD><DT><B><A NAME="dwReserved2">dwReserved2</A></B>
 </DT><DD>Reserved for future use. Must be zero; reject connection otherwise
</DD><DT><B><A NAME="bmiHeader">bmiHeader</A></B>
 </DT><DD>Win32 <A HREF="../filtdev/DV_Data_AVI_File_Format.htm#BITMAPINFOHEADER_AVI">BITMAPINFOHEADER</A> structure that contains color and dimension information for the video image bitmap.

</DD></DL></BLOCKQUOTE>
<P CLASS="ref">See Also</P>
<BLOCKQUOTE>
<A  HREF="../filtdev/Rectangles.htm">Source and Target Rectangles in Video Renderers</A>
</BLOCKQUOTE>


<!-- CONTENTS_END -->

<!-- START_PAGE_FOOTER -->


<H6><HR size=1></H6>
<P><A Class="line" HREF="#pagetop"><IMG src="../art/arrowup1.gif" WIDTH="11" HEIGHT="11" ALIGN="MIDDLE" BORDER=0 ALT="Top of Page">&nbsp;Top of Page</A>
<BR><A HREF="../../cpyright.htm">&#169; 1998 Microsoft Corporation. All rights reserved. Terms of Use.</A>
<!-- END_PAGE_FOOTER -->

</BLOCKQUOTE>

<SCRIPT>if((g_isIE == true) && (g_iMaj > 3)) {window.self.document.writeln('<SCR' + 'IPT SRC="../tip2.js"></SCR' + 'IPT><IFRAME ID="G_L_S" NAME="SecretBuffer" STYLE="display: none" SRC=""></IFRAME>')}</SCRIPT>

<!-- DACONTROL_START -->

	<DIV ID="HeadGraphAnim"></DIV>
	<SCRIPT>if((g_isIE == true) && (g_iMaj > 3)) {window.self.document.writeln('<SCR' + 'IPT SRC="../anim.js"></SCR' + 'IPT>')}</SCRIPT>
<!-- DACONTROL_END -->

</BODY>
</HTML>
