<!-- DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN" -->

<HTML>
<HEAD><TITLE>IMediaControl Interface</TITLE>
<SCRIPT> var sRelPath = '../../' </SCRIPT>


<META NAME="Description" CONTENT="IMediaControl Interface">
<META NAME="Description" CONTENT="IMediaControl::AddSourceFilter">
<META NAME="Description" CONTENT="IMediaControl::get_FilterCollection">
<META NAME="Description" CONTENT="IMediaControl::get_RegFilterCollection">
<META NAME="Description" CONTENT="IMediaControl::GetState">
<META NAME="Description" CONTENT="IMediaControl::Pause">
<META NAME="Description" CONTENT="IMediaControl::RenderFile">
<META NAME="Description" CONTENT="IMediaControl::Run">
<META NAME="Description" CONTENT="IMediaControl::Stop">
<META NAME="Description" CONTENT="IMediaControl::StopWhenReady">
<META NAME="Description" CONTENT="AddSourceFilter (IMediaControl)">
<META NAME="Description" CONTENT="get_FilterCollection (IMediaControl)">
<META NAME="Description" CONTENT="get_RegFilterCollection (IMediaControl)">
<META NAME="Description" CONTENT="GetState (IMediaControl)">
<META NAME="Description" CONTENT="Pause (IMediaControl)">
<META NAME="Description" CONTENT="RenderFile (IMediaControl)">
<META NAME="Description" CONTENT="Run (IMediaControl)">
<META NAME="Description" CONTENT="Stop (IMediaControl)">
<META NAME="Description" CONTENT="StopWhenReady (IMediaControl)">
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; CHARSET=iso8859-1">
<META NAME="MS.LOCALE" CONTENT="EN-US">
<META NAME="ROBOTS" CONTENT="all">

<!-- SNIFF_START -->

<SCRIPT>
//<!--
var g_isIE = false, g_isNav = false, g_iMaj = 0, g_sPlat = "";
// -->

</SCRIPT>
<SCRIPT SRC="../../ver.js"></SCRIPT>
<SCRIPT SRC="../../gloss.js"></SCRIPT>

<!-- SNIFF_END -->


<SCRIPT DEFER SRC="../../common.js"></SCRIPT>
<SCRIPT DEFER>
//<!--
function InitPage()
{
	if (g_isIE && g_iMaj >= 4)	
	{

		SetTOC();
	}
}
//-->

</SCRIPT>

<!-- SNIFF_END -->


<!-- STYLE_START -->

<SCRIPT>
//<!--
   var sVR = '../../'	// Set root for the style sheet
   var sCSS = '<LINK REL="stylesheet" HREF="' + sVR;

   if(g_isIE)
   {
	   if (g_iMaj >= 4) // For MSIE 4.0 or later
	   {
		   sCSS += 'dxm_basicsdkIE4';
		   if (g_sPlat == "Win") // Windows only for now
		   {
			   document.createStyleSheet(sVR + 'dxm_advSDKIE4.css');
		   }
	   }
	   else // For MSIE 3.0 or earlier
	   {
		   sCSS += 'dxm_basicsdkIE3';
	   }
   }
   else if (g_isNav) // For all Nav versions
   {
	   sCSS += 'dxm_basicsdkNAV';
   }
   else
   {
	   sCSS += 'dxm_basicsdkIE3'; // default to IE3 sheet
   }

   sCSS += (sCSS == '' ? '' : '.css" TYPE="text/css">');

   document.write(sCSS);
//-->

</SCRIPT>
<!-- STYLE_END -->


</HEAD>
<BODY onload="InitPage(); if (g_isIE && g_iMaj >= 4){HdgrphControl()}" BGCOLOR="#FFFFFF">
<A NAME="pagetop"></A><A NAME="IMediaControl"></A>

<!-- HEADGRAPH_START -->

<TABLE CLASS="main" BORDER=0 CELLSPACING="0" CELLPADDING="0" WIDTH="*">
<TR>
<TD ROWSPAN="3" VALIGN="TOP" WIDTH="*">
<IMG SRC="../../art/header1.gif" WIDTH="107" HEIGHT="110" BORDER=0 ALT="DirectShow Animated Header -- IMediaControl Interface"></TD>
<TD ROWSPAN="2" VALIGN="TOP" WIDTH="217"><IMG SRC="../../art/hdrdshow.gif" WIDTH="217" HEIGHT="110" BORDER=0 ALT="DirectShow Animated Header -- IMediaControl Interface"></TD>
<TD VALIGN="TOP" WIDTH="383">
<IMG SRC="../../art/header3.gif" WIDTH="383" HEIGHT="95" BORDER=0 ALT="DirectShow Animated Header">
</TD>
<TD VALIGN="TOP" WIDTH="100%">
<IMG SRC="../../art/spacer1.gif" WIDTH="100%" HEIGHT="94" BORDER=0 ALT="Microsoft DirectShow SDK">
</TD>
</TR>
<!-- HEADGRAPH_END -->

<!-- NAV_LINKS_START -->

<TR><TD VALIGN="TOP"><PRE><IMG ID="TOC_" SRC="../../art/yelbtn.gif" WIDTH="11" HEIGHT="11" ALIGN="MIDDLE" BORDER=0 ALT="*"><A STYLE="color:black;font-weight:bold" ID="TOC" HREF="../../contents.htm">Contents</A>  <IMG SRC="../../art/yelbtn.gif" WIDTH="11" HEIGHT="11" ALIGN="MIDDLE" BORDER=0 ALT="*"><A STYLE="color:black;font-weight:bold" HREF="../../index.htm">Index</A>  <IMG SRC="../../art/yelbtn.gif" WIDTH="11" HEIGHT="11" ALIGN="MIDDLE" BORDER=0 ALT="*"><A STYLE="color:black;font-weight:bold" HREF="ifaces_intro.htm">Topic Contents</A>
</PRE></TD></TR>
<TR><TD COLSPAN="2" VALIGN="TOP"><PRE><IMG SRC="../../art/yelbtn.gif" WIDTH="11" HEIGHT="11" ALIGN="MIDDLE" BORDER=0 ALT="*"><B>Previous Topic:</B> <A STYLE="color:black" HREF="IKsPropertySet.htm">IKsPropertySet Interface</A>
<IMG SRC="../../art/yelbtn.gif" WIDTH="11" HEIGHT="11" ALIGN="MIDDLE" BORDER=0 ALT="*"><B>Next Topic:</B> <A  STYLE="color:black" HREF="IMediaEvent.htm">IMediaEvent Interface</A>
</PRE></TD></TR></TABLE>
<!-- NAV_LINKS_END -->


<BLOCKQUOTE CLASS="body">


<!-- CONTENTS_START -->

<H1>IMediaControl Interface</H1>

<P>The <A CLASS="Glossary" HREF="javascript:Glossary(sRelPath + 'gloss/gloss_F.htm#filter_graph')">filter graph</A> exposes the <B>IMediaControl</B> interface to allow applications to
control the streaming of media through the <A CLASS="Glossary" HREF="javascript:Glossary(sRelPath + 'gloss/gloss_f.htm#filter')">filters</A> in the graph. The interface provides <A CLASS="Glossary" HREF="javascript:Glossary(sRelPath + 'gloss/gloss_M.htm#method')">methods</A>
for running, pausing, and stopping the streaming of data. It also provides
applications with a simple method of building graphs to play back media files.


<P CLASS="ref"><A NAME="When_to_Implement">When to Implement</A></P>
<P>This interface is implemented by the <A CLASS="Glossary" HREF="javascript:Glossary(sRelPath + 'gloss/gloss_F.htm#filter_graph_manager')">filter graph manager</A>. Implement this only if
you are writing a <A CLASS="Glossary" HREF="javascript:Glossary(sRelPath + 'gloss/gloss_P.htm#plug_in_distributor')">plug-in distributor</A> that needs to export the control methods. The <A HREF="../class/CMediaControl.htm#CMediaControl">CMediaControl</A> base class implements this interface and handles the <A HREF="../../appendixes/Further_Reading.htm#IDispatch">IDispatch</A> interface.

<P CLASS="ref"><A NAME="When_to_Use">When to Use</A></P>
<P>Use this interface from any application that wants to control the playing
of media through Microsoft&#174; DirectShow&#153; filter graphs. Applications can also use it to
enumerate the filters in the filter graph and all the filters in the registry,
to add a <A CLASS="Glossary" HREF="javascript:Glossary(sRelPath + 'gloss/gloss_S.htm#source_filter')">source filter</A> to the filter graph, and to instruct the filter graph
manager to build a filter graph capable of rendering the media type in a file.

<P CLASS="ref"><A NAME="Methods_in_Vtable_Or">Methods in Vtable Order</A></P>
<TABLE>
<TR><TH>IUnknown methods</TH><TH>Description</TH></TR><TR><TD><A HREF="IUnknown.htm#QueryInterface">QueryInterface</A> </TD><TD>Returns pointers to supported interfaces.
</TD></TR><TR><TD><A HREF="IUnknown.htm#AddRef">AddRef</A> </TD><TD>Increments the reference count.
</TD></TR><TR><TD><A HREF="IUnknown.htm#Release">Release</A> </TD><TD>Decrements the reference count.
</TD></TR><TR></TR>
<TR><TH>IDispatch methods</TH><TH>Description</TH></TR><TR><TD><A HREF="../../appendixes/Further_Reading.htm#IDispatch__GetTypeIn">GetTypeInfoCount</A>
 </TD><TD>Determines whether there is type information available for this dispinterface.
</TD></TR><TR><TD><A HREF="../../appendixes/Further_Reading.htm#IDispatch__GetTypeIn">GetTypeInfo</A>
 </TD><TD>Retrieves the type information for this dispinterface if
 <A HREF="../../appendixes/Further_Reading.htm#IDispatch__GetTypeIn">GetTypeInfoCount</A> returned
successfully.
</TD></TR><TR><TD><A HREF="../../appendixes/Further_Reading.htm#IDispatch__GetIDsOfN">GetIDsOfNames</A>
 </TD><TD>Converts text names of properties and methods (including arguments) to
their corresponding DISPIDs.
</TD></TR><TR><TD><A HREF="../../appendixes/Further_Reading.htm#IDispatch__Invoke">Invoke</A>
 </TD><TD>Calls a method or accesses a property in this dispinterface if given a DISPID
and any other necessary parameters.
</TD></TR><TR></TR>
<TR><TH>IMediaControl methods</TH><TH>Description</TH></TR><TR><TD><A HREF="IMediaControl.htm#Run">Run</A>
 </TD><TD>Switches the entire filter graph into running mode.
</TD></TR><TR><TD><A HREF="IMediaControl.htm#Pause">Pause</A>
 </TD><TD>Pauses all filters in the filter graph.
</TD></TR><TR><TD><A HREF="IMediaControl.htm#Stop">Stop</A>
 </TD><TD>Switches all filters in the filter graph to a stopped state.
</TD></TR><TR><TD><A HREF="IMediaControl.htm#StopWhenReady">StopWhenReady</A>
 </TD><TD>Waits for an operation such as Pause to complete,
 allowing filters to queue up data, then
 stops the filter graph.
</TD></TR><TR><TD><A HREF="IMediaControl.htm#GetState">GetState</A>
 </TD><TD>Retrieves the state of the filter graph.
</TD></TR><TR><TD><A HREF="IMediaControl.htm#RenderFile">RenderFile</A>
 </TD><TD>Adds and connects filters needed to play the specified file.
</TD></TR><TR><TD><A HREF="IMediaControl.htm#AddSourceFilter">AddSourceFilter</A>
 </TD><TD>Adds to the graph the source filter that can read the given file name,
and returns an <A HREF="../../appendixes/Further_Reading.htm#IDispatch">IDispatch</A> interface pointer representing the filter object.
</TD></TR><TR><TD><A HREF="IMediaControl.htm#get_FilterCollection">get_FilterCollection</A>
 </TD><TD>Retrieves a collection of <A HREF="IFilterInfo.htm">IFilterInfo</A> interfaces representing the
filters in the graph.
</TD></TR><TR><TD><A HREF="IMediaControl.htm#get_RegFilterCollection">get_RegFilterCollection</A>
 </TD><TD>Retrieves a collection of <A HREF="IRegFilterInfo.htm">IRegFilterInfo</A> interfaces representing the
filters available in the registry.
</TD></TR></TABLE>



<H1><A NAME="AddSourceFilter">IMediaControl::AddSourceFilter</A><HR size=1></H1>
<A HREF="IMediaControl.htm">IMediaControl Interface</A>
<P>Adds to the graph the source filter that can read the given file name,
and returns an <A HREF="../../appendixes/Further_Reading.htm#IDispatch">IDispatch</A> interface pointer representing the filter.

<P CLASS="ref">Syntax</P><BLOCKQUOTE><PRE>
<P><B>HRESULT</B> <B>AddSourceFilter</B><B>(</B><BR>&nbsp;&nbsp;<B>BSTR</B> <I>strFilename</I><B>,</B><BR>&nbsp;&nbsp;<B>IDispatch</B> <I>**ppUnk</I><BR>&nbsp;&nbsp;<B>)</B><B>;</B></PRE></BLOCKQUOTE>

<P CLASS="ref">Parameters</P>
<BLOCKQUOTE>
<DL><DT><I>strFilename</I>
 </DT><DD>[in] Name of the file containing the source video.
</DD><DT><I>ppUnk</I>
</DT><DD>[out] Pointer to the <A HREF="IFilterInfo.htm">IFilterInfo</A> interface on the filter.
</DD></DL>

</BLOCKQUOTE>
<P CLASS="ref">Return Value</P>
<BLOCKQUOTE>
<P>Returns an <A HREF="../Error_Success_Codes.htm#HRESULT">HRESULT</A> value.


</BLOCKQUOTE>
<P CLASS="ref">Remarks</P>


<BLOCKQUOTE>

<P>This method is primarily for use by Automation clients because it returns an
<A HREF="../../appendixes/Further_Reading.htm#IDispatch">IDispatch</A> interface pointer. C and C++ applications should call the
<A HREF="IGraphBuilder.htm#AddSourceFilter">IGraphBuilder::AddSourceFilter</A> method to perform this operation for maximum
efficiency.
</BLOCKQUOTE>


<H1><A NAME="get_FilterCollection">IMediaControl::get_FilterCollection</A><HR size=1></H1>
<A HREF="IMediaControl.htm">IMediaControl Interface</A>
<P>Retrieves a collection of <A HREF="IFilterInfo.htm">IFilterInfo</A> interfaces representing the
filters in the graph and returns <A HREF="../../appendixes/Further_Reading.htm#IDispatch">IDispatch</A> for an object
that supports the <A HREF="IAMCollection.htm">IAMCollection</A> interface.

<P CLASS="ref">Syntax</P><BLOCKQUOTE><PRE>
<P><B>HRESULT</B> <B>get_FilterCollection</B><B>(</B><BR>&nbsp;&nbsp;<B>IDispatch</B> <I>**ppUnk</I><BR>&nbsp;&nbsp;<B>)</B><B>;</B></PRE></BLOCKQUOTE>

<P CLASS="ref">Parameters</P>
<BLOCKQUOTE>
<DL><DT><I>ppUnk</I>
 </DT><DD>[out, retval] The <A HREF="IAMCollection.htm">IAMCollection</A> interface on a collection of 
 <A HREF="IFilterInfo.htm">IFilterInfo</A> objects.
</DD></DL>

</BLOCKQUOTE>
<P CLASS="ref">Return Value</P>
<BLOCKQUOTE>
<P>Returns an <A HREF="../Error_Success_Codes.htm#HRESULT">HRESULT</A> value.


</BLOCKQUOTE>
<P CLASS="ref">Remarks</P>


<BLOCKQUOTE>

<P>This method is primarily for use by Automation clients because it returns an
<A HREF="../../appendixes/Further_Reading.htm#IDispatch">IDispatch</A> interface pointer. C and C++ applications should call the
<A HREF="IFilterGraph.htm#EnumFilters">IFilterGraph::EnumFilters</A> method to perform this operation for maximum
efficiency.
</BLOCKQUOTE>


<H1><A NAME="get_RegFilterCollection">IMediaControl::get_RegFilterCollection</A><HR size=1></H1>
<A HREF="IMediaControl.htm">IMediaControl Interface</A>
<P>Retrieves a collection of <A HREF="IRegFilterInfo.htm">IRegFilterInfo</A> interfaces representing the
filters available in the registry.

<P CLASS="ref">Syntax</P><BLOCKQUOTE><PRE>
<P><B>HRESULT</B> <B>get_RegFilterCollection</B><B>(</B><BR>&nbsp;&nbsp;<B>IDispatch</B> <I>**ppUnk</I><BR>&nbsp;&nbsp;<B>)</B><B>;</B></PRE></BLOCKQUOTE>

<P CLASS="ref">Parameters</P>
<BLOCKQUOTE>
<DL><DT><I>ppUnk</I>
 </DT><DD>[out, retval] <A HREF="../../appendixes/Further_Reading.htm#IDispatch">IDispatch</A> interface of the <A HREF="IAMCollection.htm">IAMCollection</A> object.
</DD></DL>

</BLOCKQUOTE>
<P CLASS="ref">Return Value</P>
<BLOCKQUOTE>
<P>Returns an <A HREF="../Error_Success_Codes.htm#HRESULT">HRESULT</A> value.


</BLOCKQUOTE>
<P CLASS="ref">Remarks</P>


<BLOCKQUOTE>

<P>This method is primarily for use by Automation clients because it returns an
<A HREF="../../appendixes/Further_Reading.htm#IDispatch">IDispatch</A> interface pointer. C and C++ applications should call the
<A HREF="IFilterMapper.htm#EnumMatchingFilters">IFilterMapper::EnumMatchingFilters</A> method to perform this operation for maximum
efficiency.
</BLOCKQUOTE>


<H1><A NAME="GetState">IMediaControl::GetState</A><HR size=1></H1>
<A HREF="IMediaControl.htm">IMediaControl Interface</A>
<P>Retrieves the state of the filter graph.

<P CLASS="ref">Syntax</P><BLOCKQUOTE><PRE>
<P><B>HRESULT</B> <B>GetState</B><B>(</B><BR>&nbsp;&nbsp;<B>LONG</B> <I>msTimeout</I><B>,</B><BR>&nbsp;&nbsp;<B>OAFilterState*</B> <I>pfs</I><BR>&nbsp;&nbsp;<B>)</B><B>;</B></PRE></BLOCKQUOTE>

<P CLASS="ref">Parameters</P>
<BLOCKQUOTE>
<DL><DT><I>msTimeout</I>
 </DT><DD>[in] Duration of the time-out, in milliseconds. 
</DD><DT><I>pfs</I>
 </DT><DD>[out] Holds the returned state of the filter graph.
</DD></DL>

</BLOCKQUOTE>
<P CLASS="ref">Return Value</P>
<BLOCKQUOTE>
<P>Returns <A HREF="../Error_Success_Codes.htm#VFW_S_STATE_INTERMED">VFW_S_STATE_INTERMEDIATE</A> if the state transition is not complete, or S_OK if it completed successfully. It can also return VFW_S_CANT_CUE if the state is paused, but the source filter does not push data during the paused state (only pushes during the run state). An example of this is a live video capture filter. 


</BLOCKQUOTE>
<P CLASS="ref">Remarks</P>


<BLOCKQUOTE>

<P>Not all state transitions are synchronous. For example, even though the <A HREF="IMediaControl.htm#Pause">IMediaControl::Pause</A> method returns immediately, the filter graph typically does not complete the transition into paused mode until data is ready at the <A CLASS="Glossary" HREF="javascript:Glossary(sRelPath + 'gloss/gloss_R.htm#renderer')">renderer</A>. This method will not return S_OK until the state transition has been completed.

<P>If you specify a nonzero time-out, the method waits up to that number of milliseconds for the filter graph to leave the intermediate state. If the time-out expires before the state transition is complete, the return code will be <A HREF="../Error_Success_Codes.htm#VFW_S_STATE_INTERMED">VFW_S_STATE_INTERMEDIATE</A>, and the returned state will be the state into which the graph is transitioning (either the <A HREF="../dtypes.htm#State_Stopped">State_Stopped</A>, <A HREF="../dtypes.htm#State_Paused">State_Paused</A>, or <A HREF="../dtypes.htm#State_Running">State_Running</A> members of the <A HREF="../dtypes.htm#FILTER_STATE">FILTER_STATE</A> structure).

<P>This method will return an error if there is a call on another thread to change the state while this method is blocked.

<P>Avoid specifying a time-out of INFINITE. Threads cannot process messages while waiting in 
<B>GetState</B>. If you call <B>GetState</B> from the thread that processes Windows&#174; messages, specify only small wait times on the call in order to remain responsive to user input. This is most important when streaming data from a source such as the Internet, because state transitions can take significantly
more time to complete.

<P>If you want to pause a filter graph completely before stopping it, call <A HREF="IMediaControl.htm#Pause">IMediaControl::Pause</A>, and then <A HREF="IMediaControl.htm#StopWhenReady">IMediaControl::StopWhenReady</A> (instead of calling <B>GetState</B> with an INFINITE time-out, and then <A HREF="IMediaControl.htm#Stop">IMediaControl::Stop</A>).

<P>Although <I>pfs</I> is declared as a pointer to an OAFilterState value in 
<B>IMediaControl::GetState</B>, DirectShow implements it as a pointer to a <A HREF="../dtypes.htm#FILTER_STATE">FILTER_STATE</A> value in <A HREF="../class/CBaseFilter.htm#GetState">CBaseFilter::GetState</A> and its derivatives. Since both OAFilterState and 
<B>FILTER_STATE</B> resolve to <A HREF="../../appendixes/Further_Reading.htm#LONG">LONG</A> values, this does not cause an error.
</BLOCKQUOTE>


<H1><A NAME="Pause">IMediaControl::Pause</A><HR size=1></H1>
<A HREF="IMediaControl.htm">IMediaControl Interface</A>
<P>Pauses all the filters in the filter graph.

<P CLASS="ref">Syntax</P><BLOCKQUOTE><PRE>
<P><B>HRESULT</B> <B>Pause</B><B>(</B> <B>)</B><B>;</B><BR>
</PRE></BLOCKQUOTE>
<P CLASS="ref">Return Value</P>
<BLOCKQUOTE>
<P>Returns S_OK if the graph is actually paused.
<p>Returns S_FALSE if the graph is in paused state but some filters have not completed the transition to pause. Call <A HREF="IMediaControl.htm#GetState">GetState</A> to wait for the transition to the paused state to complete or to check if the transition has completed. If the method returns S_FALSE, subsequent calls to <A HREF="IMediaControl.htm#GetState">GetState</A> will return a value of <A HREF="../dtypes.htm#State_Paused">State_Paused</A> when the graph is paused. If the transition to paused is not complete <A HREF="IMediaControl.htm#GetState">GetState</A> can return a return code of VFW_S_STATE_INTERMEDIATE.
<p>Returns an <A HREF="../Error_Success_Codes.htm#HRESULT">HRESULT</A> error code if the graph could not transition to paused state and is now stopped.

</BLOCKQUOTE>
<P CLASS="ref">Remarks</P>


<BLOCKQUOTE>

<P>In the paused state, filters process data but do not render it. Data is pushed down the filter graph and is processed by <A CLASS="Glossary" HREF="javascript:Glossary(sRelPath + 'gloss/gloss_T.htm#transform_filter')">transform filters</A> as far as buffering permits. No data is rendered (except that media types capable of being rendered statically, such as video, have a static, poster frame rendered in paused mode). Therefore, putting a filter graph into a paused state cues the graph for immediate rendering when put into a running state.
</BLOCKQUOTE>


<H1><A NAME="RenderFile">IMediaControl::RenderFile</A><HR size=1></H1>
<A HREF="IMediaControl.htm">IMediaControl Interface</A>
<P>Adds and connects filters needed to play the specified file.

<P CLASS="ref">Syntax</P><BLOCKQUOTE><PRE>
<P><B>HRESULT</B> <B>RenderFile</B><B>(</B><BR>&nbsp;&nbsp;<B>BSTR</B> <I>strFilename</I><BR>&nbsp;&nbsp;<B>)</B><B>;</B></PRE></BLOCKQUOTE>

<P CLASS="ref">Parameters</P>
<BLOCKQUOTE>
<DL><DT><I>strFilename</I>
 </DT><DD>Name of the file to render.
</DD></DL>

</BLOCKQUOTE>
<P CLASS="ref">Return Value</P>
<BLOCKQUOTE>
<P>Returns an <A HREF="../Error_Success_Codes.htm#HRESULT">HRESULT</A> value.



</BLOCKQUOTE>
<P CLASS="ref">Remarks</P>


<BLOCKQUOTE>

<P>This method allows an application to pass the name of a media file that it wants rendered
to the filter graph manager. The filter graph manager will build a graph of the
filters needed to play back this file. This method is Automation-compatible and is
equivalent to <A HREF="IGraphBuilder.htm#RenderFile">IGraphBuilder::RenderFile</A>, which should be used by C and C++ applications.
</BLOCKQUOTE>


<H1><A NAME="Run">IMediaControl::Run</A><HR size=1></H1>
<A HREF="IMediaControl.htm">IMediaControl Interface</A>
<P>Switches the entire filter graph into a running state.

<P CLASS="ref">Syntax</P><BLOCKQUOTE><PRE>
<P><B>HRESULT</B> <B>Run</B><B>(</B> <B>)</B><B>;</B>
</PRE></BLOCKQUOTE>
<P CLASS="ref">Return Value</P>
<BLOCKQUOTE>
<P>Returns S_OK if the graph is actually running.
<p>Returns S_FALSE if the graph is preparing to run (the graph will run automatically when it's ready). Call <A HREF="IMediaControl.htm#GetState">GetState</A> to wait for the transition to the running state to complete or to check if the transition has completed. If the method returns S_FALSE, subsequent calls to <A HREF="IMediaControl.htm#GetState">GetState</A> will return a value of <A HREF="../dtypes.htm#State_Running">State_Running</A> when the graph is actually running. If the transition to the running state is not complete <A HREF="IMediaControl.htm#GetState">GetState</A> can return a return code of VFW_S_STATE_INTERMEDIATE.
<p>Returns an <A HREF="../Error_Success_Codes.htm#HRESULT">HRESULT</A> error code if the graph could not run and is now stopped. 



</BLOCKQUOTE>
<P CLASS="ref">Remarks</P>


<BLOCKQUOTE>

<P>In a running state, data is pushed down the filter graph and rendered.
The graph remains in a running state until it is stopped by the <A HREF="IMediaControl.htm#Pause">IMediaControl::Pause</A> or <A HREF="IMediaControl.htm#Stop">IMediaControl::Stop</A> method. The graph remains in a running state even after notifying the
application of completion (that is, the <A HREF="../Event_Notification_Codes.htm#EC_COMPLETE">EC_COMPLETE</A> notification is sent to the application).
This allows the application to determine whether to pause or stop after completion.

<P>If the filter graph is in the stopped state, this method first pauses the graph before running.

<P>If an error value is returned, some filters within the graph might have successfully entered
the running state. In a multistream graph, entire streams might be playing successfully.
The application must determine whether to stop running or not.
</BLOCKQUOTE>


<H1><A NAME="Stop">IMediaControl::Stop</A><HR size=1></H1>
<A HREF="IMediaControl.htm">IMediaControl Interface</A>
<P>Switches all filters in the filter graph to a stopped state.

<P CLASS="ref">Syntax</P><BLOCKQUOTE><PRE>
<P><B>HRESULT</B> <B>Stop</B><B>(</B> <B>)</B><B>;</B>
</PRE></BLOCKQUOTE>
<P CLASS="ref">Return Value</P>
<BLOCKQUOTE>
<P>Returns an <A HREF="../Error_Success_Codes.htm#HRESULT">HRESULT</A> value.



</BLOCKQUOTE>
<P CLASS="ref">Remarks</P>


<BLOCKQUOTE>

<P>In this mode, filters release resources and no data is processed.
If the filters are in a running state, this method pauses them before stopping them. This allows
video renderers to make a copy of the current frame for poster frame display while stopped.
</BLOCKQUOTE>


<H1><A NAME="StopWhenReady">IMediaControl::StopWhenReady</A><HR size=1></H1>
<A HREF="IMediaControl.htm">IMediaControl Interface</A>
<P>Waits for an operation such as Pause to complete, allowing filters to queue up data, then
stops the filter graph.

<P CLASS="ref">Syntax</P><BLOCKQUOTE><PRE>
<P><B>HRESULT</B> <B>StopWhenReady</B><B>(</B> <B>)</B><B>;</B>
</PRE></BLOCKQUOTE>
<P CLASS="ref">Return Value</P>
<BLOCKQUOTE>
<P>Returns an <A HREF="../Error_Success_Codes.htm#HRESULT">HRESULT</A> value.



</BLOCKQUOTE>
<P CLASS="ref">Remarks</P>


<BLOCKQUOTE>

<P>Changing the current position when stopped will not normally repaint the
video window with the new position. Applications will need to enter Pause mode to do this.
Calling <B>StopWhenReady</B> instead of simply calling <A HREF="IMediaControl.htm#Stop">Stop</A> 
after this pause ensures that the graph is fully paused, and that data has arrived at the video 
renderer and has been displayed before the graph is stopped.

<P>This method is run asynchronously so that the application regains control immediately and can
respond to user input. Use this method rather than calling <A HREF="IMediaControl.htm#GetState">IMediaControl::GetState</A> with an INFINITE time-out, 
followed by <A HREF="IMediaControl.htm#Stop">IMediaControl::Stop</A>.

</BLOCKQUOTE>
<!-- CONTENTS_END -->

<!-- START_PAGE_FOOTER -->


<H6><HR size=1></H6>
<P><A Class="line" HREF="#pagetop"><IMG src="../../art/arrowup1.gif" WIDTH="11" HEIGHT="11" ALIGN="MIDDLE" BORDER=0 ALT="Top of Page">&nbsp;Top of Page</A>
<BR><A Class="line" HREF="../../../cpyright.htm">&#169; 1998 Microsoft Corporation. All rights reserved. Terms of Use.</A>
<!-- END_PAGE_FOOTER -->

</BLOCKQUOTE>

<SCRIPT>if((g_isIE == true) && (g_iMaj > 3)) {window.self.document.writeln('<SCR' + 'IPT SRC="../../tip2.js"></SCR' + 'IPT><IFRAME ID="G_L_S" NAME="SecretBuffer" STYLE="display: none" SRC=""></IFRAME>')}</SCRIPT>

<!-- DACONTROL_START -->

	<DIV ID="HeadGraphAnim"></DIV>
	<SCRIPT>if((g_isIE == true) && (g_iMaj > 3)) {window.self.document.writeln('<SCR' + 'IPT SRC="../../anim.js"></SCR' + 'IPT>')}</SCRIPT>
<!-- DACONTROL_END -->

</BODY>
</HTML>
