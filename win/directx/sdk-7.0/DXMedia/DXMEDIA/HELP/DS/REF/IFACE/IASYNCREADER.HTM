<!-- DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN" -->

<HTML>
<HEAD><TITLE>IAsyncReader Interface</TITLE>
<SCRIPT> var sRelPath = '../../' </SCRIPT>


<META NAME="Description" CONTENT="IAsyncReader Interface">
<META NAME="Description" CONTENT="IAsyncReader::BeginFlush">
<META NAME="Description" CONTENT="IAsyncReader::EndFlush">
<META NAME="Description" CONTENT="IAsyncReader::Length">
<META NAME="Description" CONTENT="IAsyncReader::Request">
<META NAME="Description" CONTENT="IAsyncReader::RequestAllocator">
<META NAME="Description" CONTENT="IAsyncReader::SyncRead">
<META NAME="Description" CONTENT="IAsyncReader::SyncReadAligned">
<META NAME="Description" CONTENT="IAsyncReader::WaitForNext">
<META NAME="Description" CONTENT="BeginFlush (IAsyncReader)">
<META NAME="Description" CONTENT="EndFlush (IAsyncReader)">
<META NAME="Description" CONTENT="Length (IAsyncReader)">
<META NAME="Description" CONTENT="Request (IAsyncReader)">
<META NAME="Description" CONTENT="RequestAllocator (IAsyncReader)">
<META NAME="Description" CONTENT="SyncRead (IAsyncReader)">
<META NAME="Description" CONTENT="SyncReadAligned (IAsyncReader)">
<META NAME="Description" CONTENT="WaitForNext (IAsyncReader)">
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; CHARSET=iso8859-1">
<META NAME="MS.LOCALE" CONTENT="EN-US">
<META NAME="ROBOTS" CONTENT="all">

<!-- SNIFF_START -->

<SCRIPT>
//<!--
var g_isIE = false, g_isNav = false, g_iMaj = 0, g_sPlat = "";
// -->

</SCRIPT>
<SCRIPT SRC="../../ver.js"></SCRIPT>
<SCRIPT SRC="../../gloss.js"></SCRIPT>

<!-- SNIFF_END -->


<SCRIPT DEFER SRC="../../common.js"></SCRIPT>
<SCRIPT DEFER>
//<!--
function InitPage()
{
	if (g_isIE && g_iMaj >= 4)	
	{

		SetTOC();
	}
}
//-->

</SCRIPT>

<!-- SNIFF_END -->


<!-- STYLE_START -->

<SCRIPT>
//<!--
   var sVR = '../../'	// Set root for the style sheet
   var sCSS = '<LINK REL="stylesheet" HREF="' + sVR;

   if(g_isIE)
   {
	   if (g_iMaj >= 4) // For MSIE 4.0 or later
	   {
		   sCSS += 'dxm_basicsdkIE4';
		   if (g_sPlat == "Win") // Windows only for now
		   {
			   document.createStyleSheet(sVR + 'dxm_advSDKIE4.css');
		   }
	   }
	   else // For MSIE 3.0 or earlier
	   {
		   sCSS += 'dxm_basicsdkIE3';
	   }
   }
   else if (g_isNav) // For all Nav versions
   {
	   sCSS += 'dxm_basicsdkNAV';
   }
   else
   {
	   sCSS += 'dxm_basicsdkIE3'; // default to IE3 sheet
   }

   sCSS += (sCSS == '' ? '' : '.css" TYPE="text/css">');

   document.write(sCSS);
//-->

</SCRIPT>
<!-- STYLE_END -->


</HEAD>
<BODY onload="InitPage(); if (g_isIE && g_iMaj >= 4){HdgrphControl()}" BGCOLOR="#FFFFFF">
<A NAME="pagetop"></A><A NAME="IAsyncReader"></A>

<!-- HEADGRAPH_START -->

<TABLE CLASS="main" BORDER=0 CELLSPACING="0" CELLPADDING="0" WIDTH="*">
<TR>
<TD ROWSPAN="3" VALIGN="TOP" WIDTH="*">
<IMG SRC="../../art/header1.gif" WIDTH="107" HEIGHT="110" BORDER=0 ALT="DirectShow Animated Header"></TD>
<TD ROWSPAN="2" VALIGN="TOP" WIDTH="217"><IMG SRC="../../art/hdrdshow.gif" WIDTH="217" HEIGHT="110" BORDER=0 ALT="DirectShow Animated Header"></TD>
<TD VALIGN="TOP" WIDTH="383">
<IMG SRC="../../art/header3.gif" WIDTH="383" HEIGHT="95" BORDER=0 ALT="DirectShow Animated Header">
</TD>
<TD VALIGN="TOP" WIDTH="100%">
<IMG SRC="../../art/spacer1.gif" WIDTH="100%" HEIGHT="94" BORDER=0 ALT="Microsoft DirectShow SDK">
</TD>
</TR>
<!-- HEADGRAPH_END -->

<!-- NAV_LINKS_START -->

<TR><TD VALIGN="TOP"><PRE><IMG ID="TOC_" SRC="../../art/yelbtn.gif" WIDTH="11" HEIGHT="11" ALIGN="MIDDLE" BORDER=0 ALT="*"><A STYLE="color:black;font-weight:bold" ID="TOC" HREF="../../contents.htm">Contents</A>  <IMG SRC="../../art/yelbtn.gif" WIDTH="11" HEIGHT="11" ALIGN="MIDDLE" BORDER=0 ALT="*"><A STYLE="color:black;font-weight:bold" HREF="../../index.htm">Index</A>  <IMG SRC="../../art/yelbtn.gif" WIDTH="11" HEIGHT="11" ALIGN="MIDDLE" BORDER=0 ALT="*"><A STYLE="color:black;font-weight:bold" HREF="ifaces_intro.htm">Topic Contents</A>
</PRE></TD></TR>
<TR><TD COLSPAN="2" VALIGN="TOP"><PRE><IMG SRC="../../art/yelbtn.gif" WIDTH="11" HEIGHT="11" ALIGN="MIDDLE" BORDER=0 ALT="*"><B>Previous Topic:</B> <A STYLE="color:black" HREF="IAMVideoProcAmp.htm">IAMVideoProcAmp Interface</A>
<IMG SRC="../../art/yelbtn.gif" WIDTH="11" HEIGHT="11" ALIGN="MIDDLE" BORDER=0 ALT="*"><B>Next Topic:</B> <A  STYLE="color:black" HREF="IBaseFilter.htm">IBaseFilter Interface</A>
</PRE></TD></TR></TABLE>
<!-- NAV_LINKS_END -->


<BLOCKQUOTE CLASS="body">


<!-- CONTENTS_START -->

<H1>IAsyncReader Interface</H1>
<P>The <B>IAsyncReader</B> interface allows multiple overlapped reads from
different positions in the media stream. This interface is supported by source <A CLASS="Glossary" HREF="javascript:Glossary(sRelPath + 'gloss/gloss_f.htm#filter')">filters</A>.

<P>Note that during connection an <A CLASS="Glossary" HREF="javascript:Glossary(sRelPath + 'gloss/gloss_O.htm#output_pin')">output pin</A> supporting the <B>IAsyncReader</B>
should check whether its <A HREF="IUnknown.htm#QueryInterface">QueryInterface</A> method is called asking for the <B>IAsyncReader</B> interface. If it is not, then the output pin
should fail the connect unless it establishes some other <A CLASS="Glossary" HREF="javascript:Glossary(sRelPath + 'gloss/gloss_T.htm#transport')">transport</A> to use
during the connection.

<P CLASS="ref"><A NAME="When_to_Implement">When to Implement</A></P>
<P>Implement this interface on a <A CLASS="Glossary" HREF="javascript:Glossary(sRelPath + 'gloss/gloss_P.htm#pin')">pin</A> if your filter reads data of media type
MEDIATYPE_Stream from some source.

<P CLASS="ref"><A NAME="When_to_Use">When to Use</A></P>
<P>A parser, such as an Apple&#174; QuickTime&#174; <A CLASS="Glossary" HREF="javascript:Glossary(sRelPath + 'gloss/gloss_P.htm#parser_filter')">parser filter</A>, can use this interface to read from a filter that reads from a file, the network, or memory.

<P CLASS="ref"><A NAME="Methods_in_Vtable_Or">Methods in Vtable Order</A></P>
<TABLE>
<TR><TH>IUnknown methods</TH><TH>Description</TH></TR><TR><TD><A HREF="IUnknown.htm#QueryInterface">QueryInterface</A> </TD><TD>Retrieves pointers to supported interfaces.
</TD></TR><TR><TD><A HREF="IUnknown.htm#AddRef">AddRef</A> </TD><TD>Increments the reference count.
</TD></TR><TR><TD><A HREF="IUnknown.htm#Release">Release</A> </TD><TD>Decrements the reference count.
</TD></TR><TR></TR>
<TR><TH>IAsyncReader methods</TH><TH>Description</TH></TR><TR><TD><A HREF="IAsyncReader.htm#RequestAllocator">RequestAllocator</A>
 </TD><TD>Retrieves the actual allocator to be used.
</TD></TR><TR><TD><A HREF="IAsyncReader.htm#Request">Request</A>
 </TD><TD>Queues a request for data.
</TD></TR><TR><TD><A HREF="IAsyncReader.htm#WaitForNext">WaitForNext</A>
 </TD><TD>Blocks until the next sample is completed or the time-out occurs.
</TD></TR><TR><TD><A HREF="IAsyncReader.htm#SyncReadAligned">SyncReadAligned</A>
 </TD><TD>Performs an aligned synchronized read.
</TD></TR><TR><TD><A HREF="IAsyncReader.htm#SyncRead">SyncRead</A>
 </TD><TD>Performs a synchronized read.
</TD></TR><TR><TD><A HREF="IAsyncReader.htm#Length">Length</A>
 </TD><TD>Retrieves the total length of the stream, and the currently available length.
</TD></TR><TR><TD><A HREF="IAsyncReader.htm#BeginFlush">BeginFlush</A>
 </TD><TD>Causes all outstanding reads to return.
</TD></TR><TR><TD><A HREF="IAsyncReader.htm#EndFlush">EndFlush</A>
 </TD><TD>Ends the flushing operation.
</TD></TR></TABLE>



<H1><A NAME="BeginFlush">IAsyncReader::BeginFlush</A><HR size=1></H1>
<A HREF="IAsyncReader.htm">IAsyncReader Interface</A>
<P>Starts the flushing operation.


<P CLASS="ref">Syntax</P><BLOCKQUOTE><PRE><P><B>HRESULT</B> <B>BeginFlush</B><B>(</B><B>void</B><B>)</B><B>;</B><BR></PRE></BLOCKQUOTE>

<P CLASS="ref">Return Value</P>
<BLOCKQUOTE>
<P>Returns S_OK if successful, S_FALSE otherwise.

</BLOCKQUOTE>

<P CLASS="ref">Remarks</P>
<BLOCKQUOTE>

<P>Causes all outstanding reads to return, possibly with a failure code
(<A HREF="../Error_Success_Codes.htm#VFW_E_TIMEOUT">VFW_E_TIMEOUT</A>), indicating that the outstanding reads were canceled.
Between <B>IAsyncReader::BeginFlush</B> and <A HREF="IAsyncReader.htm#EndFlush">IAsyncReader::EndFlush</A> calls,
<A HREF="IAsyncReader.htm#Request">IAsyncReader::Request</A> calls will fail and <A HREF="IAsyncReader.htm#WaitForNext">IAsyncReader::WaitForNext</A>
calls will always complete immediately.
</BLOCKQUOTE>


<H1><A NAME="EndFlush">IAsyncReader::EndFlush</A><HR size=1></H1>
<A HREF="IAsyncReader.htm">IAsyncReader Interface</A>
<P>Completes the flushing operation.

<P CLASS="ref">Syntax</P><BLOCKQUOTE><PRE><P><B>HRESULT</B> <B>EndFlush</B><B>(</B><B>void</B><B>)</B><B>;</B><BR></PRE></BLOCKQUOTE>

<P CLASS="ref">Return Value</P>
<BLOCKQUOTE>
<P>Returns S_OK if successful, S_FALSE otherwise.
</BLOCKQUOTE>


<P CLASS="ref">Remarks</P>
<BLOCKQUOTE>

<P>Between <A HREF="IAsyncReader.htm#BeginFlush">IAsyncReader::BeginFlush</A> and <B>IAsyncReader::EndFlush</B> calls,
<A HREF="IAsyncReader.htm#Request">IAsyncReader::Request</A> calls will fail and <A HREF="IAsyncReader.htm#WaitForNext">IAsyncReader::WaitForNext</A> calls
will always complete immediately. This method is called so the source thread can wait in the
<B>IAsyncReader::WaitForNext</B> method again.
</BLOCKQUOTE>


<H1><A NAME="Length">IAsyncReader::Length</A><HR size=1></H1>
<A HREF="IAsyncReader.htm">IAsyncReader Interface</A>
<P>Retrieves the stream's total length, and the currently available length.

<P CLASS="ref">Syntax</P><BLOCKQUOTE><PRE><P><B>HRESULT</B> <B>Length</B><B>(</B><BR>&nbsp;&nbsp;<B>LONGLONG*</B> <I>pTotal</I><B>,</B><BR>&nbsp;&nbsp;<B>LONGLONG*</B> <I>pAvailable</I><BR>&nbsp;&nbsp;<B>)</B><B>;</B><BR></PRE></BLOCKQUOTE>
<P CLASS="ref">Parameters</P>
<BLOCKQUOTE>
<DL><DT><I>pTotal</I>
 </DT><DD>Total allocated length.
</DD><DT><I>pAvailable</I>
 </DT><DD>Available length.
</DD></DL>

</BLOCKQUOTE>
<P CLASS="ref">Return Value</P>
<BLOCKQUOTE>
<P>Returns S_OK if successful, E_UNEXPECTED if the file has not been opened.

</BLOCKQUOTE>

<P CLASS="ref">Remarks</P>
<BLOCKQUOTE>

<P>Read operations beyond the available length but within the total length will
normally succeed, but they might block for a long period of time.
</BLOCKQUOTE>


<H1><A NAME="Request">IAsyncReader::Request</A><HR size=1></H1>
<A HREF="IAsyncReader.htm">IAsyncReader Interface</A>
<P>Queues a request for data.

<P CLASS="ref">Syntax</P><BLOCKQUOTE><PRE><P><B>HRESULT</B> <B>Request</B><B>(</B><BR>&nbsp;&nbsp;<B>IMediaSample*</B> <I>pSample</I><B>,</B><BR>&nbsp;&nbsp;<B>DWORD</B> <I>dwUser</I><BR>&nbsp;&nbsp;<B>)</B><B>;</B><BR></PRE></BLOCKQUOTE>
<P CLASS="ref">Parameters</P>
<BLOCKQUOTE>
<DL><DT><I>pSample</I>
 </DT><DD>Media sample being requested.
</DD><DT><I>dwUser</I>
 </DT><DD>[in] User context.
</DD></DL>

</BLOCKQUOTE>
<P CLASS="ref">Return Value</P>
<BLOCKQUOTE>
<P>Returns an <A HREF="../Error_Success_Codes.htm#HRESULT">HRESULT</A> value that depends on the implementation of the interface. Current DirectShow implementation return values include:
<TABLE>
<TR><TD>VFW_E_BADALIGN </TD><TD>An invalid alignment was specified. 
</TD></TR><TR><TD>VFW_E_MEDIA_TIME_NOT_SET </TD><TD>Time has not been set.
</TD></TR><TR><TD>HRESULT_FROM_WIN32 </TD><TD>Request for data past end of file.
</TD></TR><TR><TD>NOERROR </TD><TD>No error.
</TD></TR><TR><TD>S_OK </TD><TD>Success.
</TD></TR></TABLE>
</BLOCKQUOTE>

<P CLASS="ref">Remarks</P>
<BLOCKQUOTE>

<P>Media sample start and stop times contain the requested absolute
byte position (start-inclusive and stop-exclusive).
This method might fail if the sample is not obtained from an agreed allocator or
if the start or stop position does not match the agreed alignment.
The samples allocated from the source pin's allocator might fail
<A HREF="IMediaSample.htm#GetPointer">IMediaSample::GetPointer</A> until after returning from
<A HREF="IAsyncReader.htm#WaitForNext">IAsyncReader::WaitForNext</A>.

<P>The stop position must be aligned, which means it might exceed duration.
On completion, the stop position will be corrected to the unaligned actual data.

<P>The <I>dwUser</I> parameter is used by the caller to identify the sample
that returned from the <A HREF="IAsyncReader.htm#WaitForNext">IAsyncReader::WaitForNext</A> method. It has no
meaning within <A HREF="IAsyncReader.htm">IAsyncReader</A> but could be used to track individual sample
information.
</BLOCKQUOTE>


<H1><A NAME="RequestAllocator">IAsyncReader::RequestAllocator</A><HR size=1></H1>
<A HREF="IAsyncReader.htm">IAsyncReader Interface</A>
<P>Retrieves the actual allocator to be used.

<P CLASS="ref">Syntax</P><BLOCKQUOTE><PRE><P><B>HRESULT</B> <B>RequestAllocator</B><B>(</B><BR>&nbsp;&nbsp;<B>IMemAllocator*</B> <I>pPreferred</I><B>,</B><BR>&nbsp;&nbsp;<B>ALLOCATOR_PROPERTIES*</B> <I>pProps</I><B>,</B><BR>&nbsp;&nbsp;<B>IMemAllocator</B> <B>**</B> <I>ppActual</I><BR>&nbsp;&nbsp;<B>)</B><B>;</B><BR></PRE></BLOCKQUOTE>
<P CLASS="ref">Parameters</P>
<BLOCKQUOTE>
<DL><DT><I>pPreferred</I>
 </DT><DD>[in] Preferred allocator.
</DD><DT><I>pProps</I>
 </DT><DD>[in] Preferred allocator properties (size, count, and alignment).
</DD><DT><I>ppActual</I>
 </DT><DD>[out] Actual allocator used.
</DD></DL>

</BLOCKQUOTE>
<P CLASS="ref">Return Value</P>
<BLOCKQUOTE>
<P>Returns an <A HREF="../Error_Success_Codes.htm#HRESULT">HRESULT</A> value that depends on the implementation of the interface. Current DirectShow implementation return values include:
<TABLE>
<TR><TD>E_FAIL</TD><TD>Failure to initialize an allocator.
</TD></TR><TR><TD>VFW_E_BADALIGN </TD><TD>An invalid alignment was specified. 
</TD></TR><TR><TD>S_OK </TD><TD>Allocator was returned.
</TD></TR></TABLE>
</BLOCKQUOTE>

<P CLASS="ref">Remarks</P>
<BLOCKQUOTE>

<P>The preferred allocator and preferred allocator properties must be passed in.
This method returns the actual allocator to be used.

<P><A HREF="IMemAllocator.htm#GetProperties">IMemAllocator::GetProperties</A> should be called
on the returned allocator to learn the alignment and prefix chosen.
This allocator will not be committed and decommitted by
the asynchronous reader, only by the consumer.
This method must be called before calling <A HREF="IAsyncReader.htm#Request">IAsyncReader::Request</A>.
</BLOCKQUOTE>


<H1><A NAME="SyncRead">IAsyncReader::SyncRead</A><HR size=1></H1>
<A HREF="IAsyncReader.htm">IAsyncReader Interface</A>
<P>Performs a synchronous read.

<P CLASS="ref">Syntax</P><BLOCKQUOTE><PRE><P><B>HRESULT</B> <B>SyncRead</B><B>(</B><BR>&nbsp;&nbsp;<B>LONGLONG</B> <I>llPosition</I><B>,</B><BR>&nbsp;&nbsp;<B>LONG</B> <I>lLength</I><B>,</B><BR>&nbsp;&nbsp;<B>BYTE*</B> <I>pBuffer</I><BR>&nbsp;&nbsp;<B>)</B><B>;</B><BR></PRE></BLOCKQUOTE>
<P CLASS="ref">Parameters</P>
<BLOCKQUOTE>
<DL><DT><I>llPosition</I>
 </DT><DD>[in] Absolute file position.
</DD><DT><I>lLength</I>
 </DT><DD>[in] Number of bytes required.
</DD><DT><I>pBuffer </I>
 </DT><DD>[out] Where the data is written.
</DD></DL>

</BLOCKQUOTE>
<P CLASS="ref">Return Value</P>
<BLOCKQUOTE>
<P>Returns an <A HREF="../Error_Success_Codes.htm#HRESULT">HRESULT</A> value that depends on the implementation of the interface. Current DirectShow implementation return values include:
<TABLE>
<TR><TD>VFW_E_BADALIGN </TD><TD>An invalid alignment was specified. 
</TD></TR><TR><TD>HRESULT_FROM_WIN32 </TD><TD>Win32 error.
</TD></TR><TR><TD>S_FALSE </TD><TD>Size changed (probably due to end of file).
</TD></TR><TR><TD>S_OK </TD><TD>Success.
</TD></TR></TABLE>
</BLOCKQUOTE>

<P CLASS="ref">Remarks</P>
<BLOCKQUOTE>

<P>The <B>SyncRead</B> method works in a stopped state as well as in a running state.
The read is not necessarily aligned. This method fails if the read is beyond the actual total length.
</BLOCKQUOTE>


<H1><A NAME="SyncReadAligned">IAsyncReader::SyncReadAligned</A><HR size=1></H1>
<A HREF="IAsyncReader.htm">IAsyncReader Interface</A>
<P>Performs a synchronous read of the data.

<P CLASS="ref">Syntax</P><BLOCKQUOTE><PRE><P><B>HRESULT</B> <B>SyncReadAligned</B><B>(</B><BR>&nbsp;&nbsp;<B>IMediaSample*</B> <I>pSample</I><BR>&nbsp;&nbsp;<B>)</B><B>;</B><BR></PRE></BLOCKQUOTE>
<P CLASS="ref">Parameters</P>
<BLOCKQUOTE>
<DL><DT><I>pSample</I>
 </DT><DD>Sample to read.
</DD></DL>

</BLOCKQUOTE>
<P CLASS="ref">Return Value</P>
<BLOCKQUOTE>
<P>Returns an <A HREF="../Error_Success_Codes.htm#HRESULT">HRESULT</A> value that depends on the implementation of the interface. Current DirectShow implementation return values include:
<TABLE>
<TR><TD>VFW_E_BADALIGN </TD><TD>An invalid alignment was specified. 
</TD></TR><TR><TD>HRESULT_FROM_WIN32 </TD><TD>Win32 error.
</TD></TR><TR><TD>S_FALSE </TD><TD>Size changed (probably due to end of file).
</TD></TR><TR><TD>S_OK </TD><TD>Success.
</TD></TR></TABLE>
</BLOCKQUOTE>

<P CLASS="ref">Remarks</P>
<BLOCKQUOTE>

<P>The sample passed in must have been acquired from the agreed allocator.
The start and stop positions must be aligned equivalent to an
<A HREF="IAsyncReader.htm#Request">IAsyncReader::Request</A>/<A HREF="IAsyncReader.htm#WaitForNext">IAsyncReader::WaitForNext</A> pair,
but may avoid the need for a thread on the <A CLASS="Glossary" HREF="javascript:Glossary(sRelPath + 'gloss/gloss_S.htm#source_filter')">source filter</A>.
</BLOCKQUOTE>


<H1><A NAME="WaitForNext">IAsyncReader::WaitForNext</A><HR size=1></H1>
<A HREF="IAsyncReader.htm">IAsyncReader Interface</A>
<P>Blocks until the next read requested through
<A HREF="IAsyncReader.htm#Request">IAsyncReader::Request</A> completes or the time-out occurs.

<P CLASS="ref">Syntax</P><BLOCKQUOTE><PRE><P><B>HRESULT</B> <B>WaitForNext</B><B>(</B><BR>&nbsp;&nbsp;<B>DWORD</B> <I>dwTimeout</I><B>,</B><BR>&nbsp;&nbsp;<B>IMediaSample**</B> <I>ppSample</I><B>,</B><BR>&nbsp;&nbsp;<B>DWORD</B> <B>*</B> <I>pdwUser</I><BR>&nbsp;&nbsp;<B>)</B><B>;</B><BR></PRE></BLOCKQUOTE>
<P CLASS="ref">Parameters</P>
<BLOCKQUOTE>
<DL><DT><I>dwTimeout</I>
 </DT><DD>[in] Time-out in milliseconds; can be zero or INFINITE.
</DD><DT><I>ppSample</I>
 </DT><DD>[out] Completed sample.
</DD><DT><I>pdwUser</I>
 </DT><DD>User context.
</DD></DL>

</BLOCKQUOTE>
<P CLASS="ref">Return Value</P>
<BLOCKQUOTE>
<P>Returns an <A HREF="../Error_Success_Codes.htm#HRESULT">HRESULT</A> value that depends on the implementation of the interface. Current DirectShow implementation return values include:
<TABLE>
<TR><TD>VFW_E_TIMEOUT </TD><TD>A time-out has expired. 
</TD></TR><TR><TD>VFW_E_WRONG_STATE </TD><TD>The operation could not be performed because the filter is in the wrong state. 
</TD></TR><TR><TD>E_FAIL </TD><TD>Failure.
</TD></TR><TR><TD>S_OK </TD><TD>Success.
</TD></TR></TABLE>
</BLOCKQUOTE>

<P CLASS="ref">Remarks</P>
<BLOCKQUOTE>

<P>Samples may not be returned in order. If there is a read error
of any sort, a notification will already have been sent by the source filter,
and <A HREF="../Error_Success_Codes.htm#HRESULT">HRESULT</A> will be an error. If <I>ppSample</I> is not null, a request has been completed with the result code returned.

<P>The <I>pdwUser</I> parameter returns the caller's context <A HREF="../../appendixes/Further_Reading.htm#DWORD">DWORD</A>
corresponding to the sample returned.
</BLOCKQUOTE>
<!-- CONTENTS_END -->

<!-- START_PAGE_FOOTER -->


<H6><HR size=1></H6>
<P><A Class="line" HREF="#pagetop"><IMG src="../../art/arrowup1.gif" WIDTH="11" HEIGHT="11" ALIGN="MIDDLE" BORDER=0 ALT="Top of Page">&nbsp;Top of Page</A>
<BR><A Class="line" HREF="../../../cpyright.htm">&#169; 1998 Microsoft Corporation. All rights reserved. Terms of Use.</A>
<!-- END_PAGE_FOOTER -->

</BLOCKQUOTE>

<SCRIPT>if((g_isIE == true) && (g_iMaj > 3)) {window.self.document.writeln('<SCR' + 'IPT SRC="../../tip2.js"></SCR' + 'IPT><IFRAME ID="G_L_S" NAME="SecretBuffer" STYLE="display: none" SRC=""></IFRAME>')}</SCRIPT>

<!-- DACONTROL_START -->

	<DIV ID="HeadGraphAnim"></DIV>
	<SCRIPT>if((g_isIE == true) && (g_iMaj > 3)) {window.self.document.writeln('<SCR' + 'IPT SRC="../../anim.js"></SCR' + 'IPT>')}</SCRIPT>
<!-- DACONTROL_END -->

</BODY>
</HTML>
