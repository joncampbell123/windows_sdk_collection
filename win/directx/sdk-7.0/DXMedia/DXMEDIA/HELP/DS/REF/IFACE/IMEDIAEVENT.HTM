<!-- DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN" -->

<HTML>
<HEAD><TITLE>IMediaEvent Interface</TITLE>
<SCRIPT> var sRelPath = '../../' </SCRIPT>


<META NAME="Description" CONTENT="IMediaEvent Interface">
<META NAME="Description" CONTENT="IMediaEvent::CancelDefaultHandling">
<META NAME="Description" CONTENT="IMediaEvent::FreeEventParams">
<META NAME="Description" CONTENT="IMediaEvent::GetEvent">
<META NAME="Description" CONTENT="IMediaEvent::GetEventHandle">
<META NAME="Description" CONTENT="IMediaEvent::RestoreDefaultHandling">
<META NAME="Description" CONTENT="IMediaEvent::WaitForCompletion">
<META NAME="Description" CONTENT="CancelDefaultHandling (IMediaEvent)">
<META NAME="Description" CONTENT="FreeEventParams (IMediaEvent)">
<META NAME="Description" CONTENT="GetEvent (IMediaEvent)">
<META NAME="Description" CONTENT="GetEventHandle (IMediaEvent)">
<META NAME="Description" CONTENT="RestoreDefaultHandling (IMediaEvent)">
<META NAME="Description" CONTENT="WaitForCompletion (IMediaEvent)">
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; CHARSET=iso8859-1">
<META NAME="MS.LOCALE" CONTENT="EN-US">
<META NAME="ROBOTS" CONTENT="all">

<!-- SNIFF_START -->

<SCRIPT>
//<!--
var g_isIE = false, g_isNav = false, g_iMaj = 0, g_sPlat = "";
// -->

</SCRIPT>
<SCRIPT SRC="../../ver.js"></SCRIPT>
<SCRIPT SRC="../../gloss.js"></SCRIPT>

<!-- SNIFF_END -->


<SCRIPT DEFER SRC="../../common.js"></SCRIPT>
<SCRIPT DEFER>
//<!--
function InitPage()
{
	if (g_isIE && g_iMaj >= 4)	
	{

		SetTOC();
	}
}
//-->

</SCRIPT>

<!-- SNIFF_END -->


<!-- STYLE_START -->

<SCRIPT>
//<!--
   var sVR = '../../'	// Set root for the style sheet
   var sCSS = '<LINK REL="stylesheet" HREF="' + sVR;

   if(g_isIE)
   {
	   if (g_iMaj >= 4) // For MSIE 4.0 or later
	   {
		   sCSS += 'dxm_basicsdkIE4';
		   if (g_sPlat == "Win") // Windows only for now
		   {
			   document.createStyleSheet(sVR + 'dxm_advSDKIE4.css');
		   }
	   }
	   else // For MSIE 3.0 or earlier
	   {
		   sCSS += 'dxm_basicsdkIE3';
	   }
   }
   else if (g_isNav) // For all Nav versions
   {
	   sCSS += 'dxm_basicsdkNAV';
   }
   else
   {
	   sCSS += 'dxm_basicsdkIE3'; // default to IE3 sheet
   }

   sCSS += (sCSS == '' ? '' : '.css" TYPE="text/css">');

   document.write(sCSS);
//-->

</SCRIPT>
<!-- STYLE_END -->


</HEAD>
<BODY onload="InitPage(); if (g_isIE && g_iMaj >= 4){HdgrphControl()}" BGCOLOR="#FFFFFF">
<A NAME="pagetop"></A><A NAME="IMediaEvent"></A>

<!-- HEADGRAPH_START -->

<TABLE CLASS="main" BORDER=0 CELLSPACING="0" CELLPADDING="0" WIDTH="*">
<TR>
<TD ROWSPAN="3" VALIGN="TOP" WIDTH="*">
<IMG SRC="../../art/header1.gif" WIDTH="107" HEIGHT="110" BORDER=0 ALT="DirectShow Animated Header"></TD>
<TD ROWSPAN="2" VALIGN="TOP" WIDTH="217"><IMG SRC="../../art/hdrdshow.gif" WIDTH="217" HEIGHT="110" BORDER=0 ALT="DirectShow Animated Header"></TD>
<TD VALIGN="TOP" WIDTH="383">
<IMG SRC="../../art/header3.gif" WIDTH="383" HEIGHT="95" BORDER=0 ALT="DirectShow Animated Header">
</TD>
<TD VALIGN="TOP" WIDTH="100%">
<IMG SRC="../../art/spacer1.gif" WIDTH="100%" HEIGHT="94" BORDER=0 ALT="Microsoft DirectShow SDK">
</TD>
</TR>
<!-- HEADGRAPH_END -->

<!-- NAV_LINKS_START -->

<TR><TD VALIGN="TOP"><PRE><IMG ID="TOC_" SRC="../../art/yelbtn.gif" WIDTH="11" HEIGHT="11" ALIGN="MIDDLE" BORDER=0 ALT="*"><A STYLE="color:black;font-weight:bold" ID="TOC" HREF="../../contents.htm">Contents</A>  <IMG SRC="../../art/yelbtn.gif" WIDTH="11" HEIGHT="11" ALIGN="MIDDLE" BORDER=0 ALT="*"><A STYLE="color:black;font-weight:bold" HREF="../../index.htm">Index</A>  <IMG SRC="../../art/yelbtn.gif" WIDTH="11" HEIGHT="11" ALIGN="MIDDLE" BORDER=0 ALT="*"><A STYLE="color:black;font-weight:bold" HREF="ifaces_intro.htm">Topic Contents</A>
</PRE></TD></TR>
<TR><TD COLSPAN="2" VALIGN="TOP"><PRE><IMG SRC="../../art/yelbtn.gif" WIDTH="11" HEIGHT="11" ALIGN="MIDDLE" BORDER=0 ALT="*"><B>Previous Topic:</B> <A STYLE="color:black" HREF="IMediaControl.htm">IMediaControl Interface</A>
<IMG SRC="../../art/yelbtn.gif" WIDTH="11" HEIGHT="11" ALIGN="MIDDLE" BORDER=0 ALT="*"><B>Next Topic:</B> <A  STYLE="color:black" HREF="IMediaEventEx.htm">IMediaEventEx Interface</A>
</PRE></TD></TR></TABLE>
<!-- NAV_LINKS_END -->


<BLOCKQUOTE CLASS="body">


<!-- CONTENTS_START -->

<H1>IMediaEvent Interface</H1>

<P>The <B>IMediaEvent</B> interface supports <A CLASS="Glossary" HREF="javascript:Glossary(sRelPath + 'gloss/gloss_E.htm#event_notification')">event notification</A> from the <A CLASS="Glossary" HREF="javascript:Glossary(sRelPath + 'gloss/gloss_F.htm#filter_graph')">filter graph</A> and <A CLASS="Glossary" HREF="javascript:Glossary(sRelPath + 'gloss/gloss_f.htm#filter')">filters</A> within it to the application. It is decoupled by using a queuing scheme rather than callbacks, because events can be notified from worker threads that cannot safely call back into application code.

<P>An event code and two <A HREF="../../appendixes/Further_Reading.htm#DWORD">DWORD</A> values represent event notification information. Your application can use this for typical completion of asynchronous operations, errors that occur during asynchronous operation, or user-initiated events, such as when a user clicks a hot spot.

<P>Filters within the filter graph and the filter graph itself raise event notifications. Possible events include playback completion or asynchronous playback errors. In addition, the filter graph provides a <A CLASS="Glossary" HREF="javascript:Glossary(sRelPath + 'gloss/gloss_M.htm#method')">method</A> to generate events at specific <A CLASS="Glossary" HREF="javascript:Glossary(sRelPath + 'gloss/gloss_R.htm#reference_clock')">reference clock</A> times. The filter graph exposes an <A HREF="IMediaEventSink.htm">IMediaEventSink</A> interface that the filters within the graph can call to pass event notifications to the application.

<P>Event notifications are placed in a queue. An application calls the <A HREF="IMediaEvent.htm#GetEvent">IMediaEvent::GetEvent</A> method to retrieve the next notification from the queue. This method blocks until there is an event to return. The <A HREF="IMediaEvent.htm#GetEvent">GetEvent</A> time-out parameter (<I>msTimeout</I>)
allows the application to specify the time, in milliseconds, to wait for an event, including values of zero and INFINITE. After calling <B>GetEvent</B>, applications should always call 
<A HREF="IMediaEvent.htm#FreeEventParams">FreeEventParams</A> to release any resource associated with the event.

<P>In addition, applications can retrieve the event handle. <A HREF="IMediaEvent.htm#GetEventHandle">IMediaEvent::GetEventHandle</A> returns a handle to a manual-reset event created by the Microsoft&#174; Win32&#174; <A HREF="../../appendixes/Further_Reading.htm#CreateEvent">CreateEvent</A> function. This event is in a signaled state as long as there are event notifications to collect. The <A HREF="IMediaEvent.htm#GetEvent">IMediaEvent::GetEvent</A> method clears the event when there are no more event notifications to collect. This enables an application to use an application programming interface (API), such as <A HREF="../../appendixes/Further_Reading.htm#MsgWaitForMultipleOb">MsgWaitForMultipleObjects</A>, to wait for events and other occurrences at the same time. This event handle will be closed when the filter graph is released; therefore, applications should ensure that they are not using it after this point.

<P>The <A CLASS="Glossary" HREF="javascript:Glossary(sRelPath + 'gloss/gloss_F.htm#filter_graph_manager')">filter graph manager</A> handles some events raised by filters that are not passed to the application. One example of this is the <A HREF="../Event_Notification_Codes.htm#EC_REPAINT">EC_REPAINT</A> event notification. By default the filter graph manager handles this event by pausing the filter graph and repainting the video <A CLASS="Glossary" HREF="javascript:Glossary(sRelPath + 'gloss/gloss_R.htm#renderer')">renderer's</A> static images. An application can override default handling for a specific event by calling the <A HREF="IMediaEvent.htm#CancelDefaultHandling">IMediaEvent::CancelDefaultHandling</A> method with the event value as a parameter. The <A HREF="IMediaEvent.htm#RestoreDefaultHandling">IMediaEvent::RestoreDefaultHandling</A> method reinstates default handling for the specified event value. These methods have no effect on events that have no default handling.

<P>If an error occurs during the transition to a running state on any filter, the <A HREF="IMediaControl.htm#Run">IMediaControl::Run</A> method returns an error value. In this case, some filters within the graph might be running successfully. The filter graph leaves it up to the application to determine whether to stop the graph in case of an error. After the <B>IMediaControl::Run</B> method has returned, event notifications report any additional errors. The <A HREF="../Event_Notification_Codes.htm#EC_ERRORABORT">EC_ERRORABORT</A> and <A HREF="../Event_Notification_Codes.htm#EC_USERABORT">EC_USERABORT</A> event notifications indicate that playback has probably stopped in the graph (certainly in the filter that reported it). Other errors and events indicate that it is still running. Note, however, that in all cases the graph remains in running mode until the application explicitly changes it to stopped or paused mode.

<P>If the streams in the filter graph detect the end of the stream, the streams report this by using the <A HREF="../Event_Notification_Codes.htm#EC_COMPLETE">EC_COMPLETE</A> event notification. The filter graph manager asks filters if they can report <B>EC_COMPLETE</B> by means of <A CLASS="Glossary" HREF="javascript:Glossary(sRelPath + 'gloss/gloss_S.htm#seekable_renderer')">seekable renderers</A>.

<P>A seekable renderer is one that supports the <A HREF="IMediaPosition.htm">IMediaPosition</A> interface from the filter and that has only <A CLASS="Glossary" HREF="javascript:Glossary(sRelPath + 'gloss/gloss_I.htm#input_pin')">input pins</A>, or whose input pins report through <A HREF="IPin.htm#QueryInternalConnections">IPin::QueryInternalConnections</A> that they are rendered.
 The filter graph uses <B>IPin::QueryInternalConnections</B> and <B>IMediaPosition</B> to detect seekable renderers. A seekable renderer should report <A HREF="../Event_Notification_Codes.htm#EC_COMPLETE">EC_COMPLETE</A> when all seekable streams on that filter have reached the stream's end.

<P>A renderer can produce <A HREF="../Event_Notification_Codes.htm#EC_COMPLETE">EC_COMPLETE</A> (and a regular filter produce <A HREF="IPin.htm#EndOfStream">EndOfStream</A>) for one of four reasons as follows:
<UL>
<LI>The typical case: Whether there is data arriving or not, if it succeeds all calls to <A HREF="../class/CBaseRenderer.htm#Receive">Receive</A> it will eventually get <A HREF="IPin.htm#EndOfStream">EndOfStream</A>. If the end of the media is reached and when all data and <B>EndOfStream</B> has been processed it will signal <A HREF="../Event_Notification_Codes.htm#EC_COMPLETE">EC_COMPLETE</A>.
<LI>The filter can never produce any data. In that case it just passes <A HREF="../Event_Notification_Codes.htm#EC_COMPLETE">EC_COMPLETE</A> immediately when a Run method is called. For example, a filter would pass <B>EC_COMPLETE</B> if none if its input pins is connected.
<LI>The complicated case, sometimes used by the wave renderer: It can't render data right now even though it's getting it but it might be able to later. In that case, it fails the first <A HREF="../class/CBaseRenderer.htm#Receive">Receive</A>, schedules an <A HREF="../Event_Notification_Codes.htm#EC_COMPLETE">EC_COMPLETE</A> for a time <I>tStop</I> minus <I>tStart</I> in the future (based on the <A HREF="IPin.htm#NewSegment">NewSegment</A> parameters). If it finds it can start sending data it signals an <A HREF="../Event_Notification_Codes.htm#EC_NEED_RESTART">EC_NEED_RESTART</A>. A better approach could be to use stream control for this to avoid stopping and starting the graph.
<LI>It detects an unrecoverable error. Then, like any filter, it signals end of stream which for a renderer means signaling <A HREF="../Event_Notification_Codes.htm#EC_COMPLETE">EC_COMPLETE</A>.
</UL>
<P>The filter graph manager will not pass <A HREF="../Event_Notification_Codes.htm#EC_COMPLETE">EC_COMPLETE</A> to the application until an <B>EC_COMPLETE</B> event notification has been received from each stream. For example, if a live camera stream is playing as the background for a video playing from a file, the application will be notified about <B>EC_COMPLETE</B> when the video and audio streams from the file have come to the stream's end, even though the live source is still playing. In this case, too, the filter graph remains in running mode until the application explicitly calls the <A HREF="IMediaControl.htm#Pause">IMediaControl::Pause</A> or <A HREF="IMediaControl.htm#Stop">IMediaControl::Stop</A> method.

<P>Your application can disable the aggregation of <A HREF="../Event_Notification_Codes.htm#EC_COMPLETE">EC_COMPLETE</A> messages 
 by calling <A HREF="IMediaEvent.htm#CancelDefaultHandling">IMediaEvent::CancelDefaultHandling</A> with <B>EC_COMPLETE</B> as the parameter. In this case, all <B>EC_COMPLETE</B> events raised by the filters will be passed directly to the application.

<P>For a list of system-defined event notifications, see <A HREF="../Event_Notification_Codes.htm#Events">Event Notification Codes</A>.

<P><B>Note</B>  All events must be handled if a handle to an <B>IMediaEvent</B> interface is obtained otherwise events will pile up and cause the heap to be used up.

<P CLASS="ref"><A NAME="When_to_Implement">When to Implement</A></P>
<P>The filter graph manager implements this interface.

<P>You can use the <A HREF="../class/CMediaEvent.htm#CMediaEvent">CMediaEvent</A> class, which handles the <A HREF="../../appendixes/Further_Reading.htm#IDispatch">IDispatch</A> implementation for Automation, to help implement this interface.

<P CLASS="ref"><A NAME="When_to_Use">When to Use</A></P>
<P>Applications use this interface to retrieve event notifications or event handles from the filter graph manager. For example, an application can retrieve the <A HREF="../Event_Notification_Codes.htm#EC_COMPLETE">EC_COMPLETE</A> notification to find out when a media stream has been rendered completely.

<P CLASS="ref"><A NAME="Methods_in_Vtable_Or">Methods in Vtable Order</A></P>
<TABLE>
<TR><TH>IUnknown methods</TH><TH>Description</TH></TR><TR><TD><A HREF="IUnknown.htm#QueryInterface">QueryInterface</A> </TD><TD>Returns pointers to supported interfaces.
</TD></TR><TR><TD><A HREF="IUnknown.htm#AddRef">AddRef</A> </TD><TD>Increments the reference count.
</TD></TR><TR><TD><A HREF="IUnknown.htm#Release">Release</A> </TD><TD>Decrements the reference count.
</TD></TR><TR></TR>
<TR><TH>IDispatch methods</TH><TH>Description</TH></TR><TR><TD><A HREF="../../appendixes/Further_Reading.htm#IDispatch__GetTypeIn">GetTypeInfoCount</A>
 </TD><TD>Determines whether there is type information available for this dispinterface.
</TD></TR><TR><TD><A HREF="../../appendixes/Further_Reading.htm#IDispatch__GetTypeIn">GetTypeInfo</A>
 </TD><TD>Retrieves the type information for this dispinterface if
 <A HREF="../../appendixes/Further_Reading.htm#IDispatch__GetTypeIn">GetTypeInfoCount</A> returned
successfully.
</TD></TR><TR><TD><A HREF="../../appendixes/Further_Reading.htm#IDispatch__GetIDsOfN">GetIDsOfNames</A>
 </TD><TD>Converts text names of properties and methods (including arguments) to
their corresponding DISPIDs.
</TD></TR><TR><TD><A HREF="../../appendixes/Further_Reading.htm#IDispatch__Invoke">Invoke</A>
 </TD><TD>Calls a method or accesses a property in this dispinterface if given a DISPID
and any other necessary parameters.
</TD></TR><TR></TR>
<TR><TH>IMediaEvent methods</TH><TH>Description</TH></TR><TR><TD><A HREF="IMediaEvent.htm#GetEventHandle">GetEventHandle</A>
 </TD><TD>Retrieves a handle to a manual-reset event that will be signaled.
</TD></TR><TR><TD><A HREF="IMediaEvent.htm#GetEvent">GetEvent</A>
 </TD><TD>Retrieves the next notification event.
</TD></TR><TR><TD><A HREF="IMediaEvent.htm#WaitForCompletion">WaitForCompletion</A>
 </TD><TD>Blocks execution of the application thread until the graph's operation finishes.
</TD></TR><TR><TD><A HREF="IMediaEvent.htm#CancelDefaultHandling">CancelDefaultHandling</A>
 </TD><TD>Cancels any default handling of the specified event by the filter graph.
</TD></TR><TR><TD><A HREF="IMediaEvent.htm#RestoreDefaultHandling">RestoreDefaultHandling</A>
 </TD><TD>Restores default handling for this event.
</TD></TR><TR><TD><A HREF="IMediaEvent.htm#FreeEventParams">FreeEventParams</A>
 </TD><TD>Frees resources associated with the parameters to an event.
 </TD></TR></TABLE>



<H1><A NAME="CancelDefaultHandling">IMediaEvent::CancelDefaultHandling</A><HR size=1></H1>
<A HREF="IMediaEvent.htm">IMediaEvent Interface</A>
<P>Cancels any default handling by the filter graph of the specified event and ensures
that it is passed to the application.

<P CLASS="ref">Syntax</P><BLOCKQUOTE><PRE>
<P><B>HRESULT</B> <B>CancelDefaultHandling</B><B>(</B><BR>&nbsp;&nbsp;<B>long</B> <I>lEvCode</I><BR>&nbsp;&nbsp;<B>)</B><B>;</B></PRE></BLOCKQUOTE>

<P CLASS="ref">Parameters</P>
<BLOCKQUOTE>
<DL><DT><I>lEvCode</I>
 </DT><DD>Event code for which to cancel default handling.
</DD></DL>

</BLOCKQUOTE>
<P CLASS="ref">Return Value</P>
<BLOCKQUOTE>
<P>Returns S_OK if successful, or S_FALSE if the event does not have any default handling.



</BLOCKQUOTE>
<P CLASS="ref">Remarks</P>


<BLOCKQUOTE>

<P> Currently the filter graph manager applies default handling only to <A HREF="../Event_Notification_Codes.htm#EC_COMPLETE">EC_COMPLETE</A> and <A HREF="../Event_Notification_Codes.htm#EC_REPAINT">EC_REPAINT</A>.
</BLOCKQUOTE>


<H1><A NAME="FreeEventParams">IMediaEvent::FreeEventParams</A><HR size=1></H1>
<A HREF="IMediaEvent.htm">IMediaEvent Interface</A>
<P>Frees resources associated with the parameters of an event.

<P CLASS="ref">Syntax</P><BLOCKQUOTE><PRE>
<P><B>HRESULT</B> <B>FreeEventParams</B><B>(</B><BR>&nbsp;&nbsp;<B>long</B> <I>lEventCode</I><B>,</B><BR>&nbsp;&nbsp;<B>long</B> <I>lParam1</I><B>,</B><BR>&nbsp;&nbsp;<B>long</B> <I>lParam2</I><BR>&nbsp;&nbsp;<B>)</B><B>;</B></PRE></BLOCKQUOTE>

<P CLASS="ref">Parameters</P>
<BLOCKQUOTE>
<DL><DT><I>lEventCode</I>
 </DT><DD>[in] Next event notification.
</DD><DT><I>lParam1</I>
 </DT><DD>[in] First parameter of the event.
</DD><DT><I>lParam2</I>
 </DT><DD>[in] Second parameter of the event.
</DD></DL>

</BLOCKQUOTE>
<P CLASS="ref">Return Value</P>
<BLOCKQUOTE>
<P>Returns an <A HREF="../Error_Success_Codes.htm#HRESULT">HRESULT</A> value.



</BLOCKQUOTE>
<P CLASS="ref">Remarks</P>


<BLOCKQUOTE>

<P>Event parameters can be of type <A HREF="../../appendixes/Further_Reading.htm#LONG">LONG</A> or <A HREF="../../appendixes/Further_Reading.htm#BSTR">BSTR</A>. If a <B>BSTR</B> is passed as an event, it will have been allocated by the task allocator and
should be freed using this method.

No reference-counted interfaces are passed to an application using <A HREF="IMediaEvent.htm#GetEvent">IMediaEvent::GetEvent</A>
because these cannot be overridden by <A HREF="IMediaEvent.htm#CancelDefaultHandling">IMediaEvent::CancelDefaultHandling</A>. Therefore,
this method is not used to release interfaces.

</BLOCKQUOTE>


<H1><A NAME="GetEvent">IMediaEvent::GetEvent</A><HR size=1></H1>
<A HREF="IMediaEvent.htm">IMediaEvent Interface</A>
<P>Retrieves the next notification event.

<P CLASS="ref">Syntax</P><BLOCKQUOTE><PRE>
<P><B>HRESULT</B> <B>GetEvent</B><B>(</B><BR>&nbsp;&nbsp;<B>long</B> <B>*</B> <I>lEventCode</I><B>,</B><BR>&nbsp;&nbsp;<B>long</B> <B>*</B> <I>lParam1</I><B>,</B><BR>&nbsp;&nbsp;<B>long</B> <B>*</B> <I>lParam2</I><B>,</B><BR>&nbsp;&nbsp;<B>long</B> <I>msTimeout</I><BR>&nbsp;&nbsp;<B>)</B><B>;</B></PRE></BLOCKQUOTE>

<P CLASS="ref">Parameters</P>
<BLOCKQUOTE>
<DL><DT><I>IEventCode</I>
 </DT><DD>[out] Next event notification.
</DD><DT><I>lParam1</I>
 </DT><DD>[out] First parameter of the event.
</DD><DT><I>lParam2</I>
 </DT><DD>[out] Second parameter of the event.
</DD><DT><I>msTimeout</I>
 </DT><DD>[in] Time, in milliseconds, to wait before assuming that there are no events.
</DD></DL>

</BLOCKQUOTE>
<P CLASS="ref">Return Value</P>
<BLOCKQUOTE>
<P>Returns an <A HREF="../Error_Success_Codes.htm#HRESULT">HRESULT</A> value that depends on the implementation of the interface. If the time-out is zero and no event is waiting, or if the time-out elapses before an event appears, this method returns E_ABORT.



</BLOCKQUOTE>
<P CLASS="ref">Remarks</P>


<BLOCKQUOTE>

<P>The application can pass a time-out value of INFINITE to indicate that the method should block until there is an event; however, applications should avoid using INFINITE. Threads cannot process any messages while waiting in <B>GetEvent</B>. If you call <B>GetEvent</B> from the thread that processes Windows messages, specify only small wait times on the call in order to remain responsive to user input. This is most important when streaming data from a source such as the Internet, because state transitions can take significantly more time to complete.

<P>After calling <B>GetEvent</B>, applications should always call 
<A HREF="IMediaEvent.htm#FreeEventParams">FreeEventParams</A> to release any resource associated with the event.
<P>For a list of notification codes and event parameter values, see <A HREF="../Event_Notification_Codes.htm#Events">Event Notification Codes</A>.
</BLOCKQUOTE>


<H1><A NAME="GetEventHandle">IMediaEvent::GetEventHandle</A><HR size=1></H1>
<A HREF="IMediaEvent.htm">IMediaEvent Interface</A>
<P>Retrieves a handle to a manual-reset event that will be signaled as long as there are event notifications to deliver.

<P CLASS="ref">Syntax</P><BLOCKQUOTE><PRE>
<P><B>HRESULT</B> <B>GetEventHandle</B><B>(</B><BR>&nbsp;&nbsp;<B>OAEVENT</B> <B>*</B> <I>hEvent</I><BR>&nbsp;&nbsp;<B>)</B><B>;</B></PRE></BLOCKQUOTE>

<P CLASS="ref">Parameters</P>
<BLOCKQUOTE>
<DL><DT><I>hEvent</I>
 </DT><DD>[out] Handle for the event.
</DD></DL>

</BLOCKQUOTE>
<P CLASS="ref">Return Value</P>
<BLOCKQUOTE>
<P>Returns an <A HREF="../Error_Success_Codes.htm#HRESULT">HRESULT</A> value.



</BLOCKQUOTE>
<P CLASS="ref">Remarks</P>


<BLOCKQUOTE>

<P>You can monitor events (including the retrieved event) and messages on a single thread; to do this, declare a HANDLE variable, cast it to an OAEVENT pointer, then pass it to GetEventHandle. You must cast the pointer to an OAEVENT pointer because HANDLE is not a valid OLE Automation type. The following code fragment demonstrates how to cast and use the HANDLE.

<PRE>
HANDLE hEvent;
GetEventHandle( (OAEVENT*) &amp;hEvent );
</PRE>
<P>You can pass the retrieved event handle to the Microsoft Win32 <A HREF="../../appendixes/Further_Reading.htm#WaitForMultipleObjec">WaitForMultipleObjects</A> or <A HREF="../../appendixes/Further_Reading.htm#MsgWaitForMultipleOb">MsgWaitForMultipleObjects</A> functions to wait for event notifications at the same time as other messages and events on a single thread. The implementation of <A HREF="IMediaEvent.htm#GetEvent">GetEvent</A> sets and resets the handle within the application, so applications should not reset the handle themselves.
</BLOCKQUOTE>


<H1><A NAME="RestoreDefaultHandling">IMediaEvent::RestoreDefaultHandling</A><HR size=1></H1>
<A HREF="IMediaEvent.htm">IMediaEvent Interface</A>
<P>Reinstates the normal default handling by a filter graph for the specified event, if there is one.

<P CLASS="ref">Syntax</P><BLOCKQUOTE><PRE>
<P><B>HRESULT</B> <B>RestoreDefaultHandling</B><B>(</B><BR>&nbsp;&nbsp;<B>long</B> <I>lEvCode</I><BR>&nbsp;&nbsp;<B>)</B><B>;</B></PRE></BLOCKQUOTE>

<P CLASS="ref">Parameters</P>
<BLOCKQUOTE>
<DL><DT><I>lEvCode</I>
 </DT><DD>[in] Event to restore.
</DD></DL>

</BLOCKQUOTE>
<P CLASS="ref">Return Value</P>
<BLOCKQUOTE>
<P>Returns S_OK if successful, or S_FALSE if there is no default handling for this event.



</BLOCKQUOTE>
<P CLASS="ref">Remarks</P>


<BLOCKQUOTE>

<P>Events that have default handling in place, such as <A HREF="../Event_Notification_Codes.htm#EC_REPAINT">EC_REPAINT</A>, are not typically
passed to the application.
</BLOCKQUOTE>


<H1><A NAME="WaitForCompletion">IMediaEvent::WaitForCompletion</A><HR size=1></H1>
<A HREF="IMediaEvent.htm">IMediaEvent Interface</A>
<P>Blocks execution of the application thread until the graph's operation finishes.

<P CLASS="ref">Syntax</P><BLOCKQUOTE><PRE>
<P><B>HRESULT</B> <B>WaitForCompletion</B><B>(</B><BR>&nbsp;&nbsp;<B>long</B> <I>msTimeout</I><B>,</B><BR>&nbsp;&nbsp;<B>long</B> <B>*</B> <I>pEvCode</I><BR>&nbsp;&nbsp;<B>)</B><B>;</B></PRE></BLOCKQUOTE>

<P CLASS="ref">Parameters</P>
<BLOCKQUOTE>
<DL><DT><I>msTimeout</I>
 </DT><DD>[in] Duration of the time-out, in milliseconds. Pass zero to return immediately. To block indefinitely, pass INFINITE.
</DD><DT><I>pEvCode</I>
 </DT><DD>[out] Event that terminated the wait. This value can be one of the following:
<TABLE>
<TR><TD>EC_COMPLETE </TD><TD>Operation completed.
</TD></TR><TR><TD>EC_ERRORABORT </TD><TD>Error. Playback can't continue.
</TD></TR><TR><TD>EC_USERABORT </TD><TD>User terminated the operation.
</TD></TR><TR><TD>Zero (0) </TD><TD>Operation has not completed.
</TD></TR></TABLE>
</DD></DL>

</BLOCKQUOTE>
<P CLASS="ref">Return Value</P>
<BLOCKQUOTE>
<P>Returns one of the following <A HREF="../Error_Success_Codes.htm#HRESULT">HRESULT</A> values.

<TABLE>
<TR><TD>E_ABORT </TD><TD>Function timed out before the operation completed. This is equivalent to a zero <I>pEvCode</I> value.
</TD></TR><TR><TD>S_OK </TD><TD>Operation completed.
</TD></TR></TABLE>


</BLOCKQUOTE>
<P CLASS="ref">Remarks</P>


<BLOCKQUOTE>

<P>This method is the equivalent of blocking until the event notification <A HREF="../Event_Notification_Codes.htm#EC_COMPLETE">EC_COMPLETE</A>, <A HREF="../Event_Notification_Codes.htm#EC_ERRORABORT">EC_ERRORABORT</A>, or <A HREF="../Event_Notification_Codes.htm#EC_USERABORT">EC_USERABORT</A> is received, or the time-out occurs.

<P>When this method returns, the filter graph is still running. This method assumes that separate calls to the <A HREF="IMediaEvent.htm">IMediaEvent</A> interface are not being made. This method
fails if the graph is not in or transitioning into a running state. 

<P>The time-out parameter (<I>msTimeout</I>) specifies the length of time to wait for completion. To test if the operation completed, specify a zero <I>msTimeout</I> value and check the event code value (<I>pEvCode</I>) for zero, indicating that the operation is not completed.

</BLOCKQUOTE>
<!-- CONTENTS_END -->

<!-- START_PAGE_FOOTER -->


<H6><HR size=1></H6>
<P><A Class="line" HREF="#pagetop"><IMG src="../../art/arrowup1.gif" WIDTH="11" HEIGHT="11" ALIGN="MIDDLE" BORDER=0 ALT="Top of Page">&nbsp;Top of Page</A>
<BR><A Class="line" HREF="../../../cpyright.htm">&#169; 1998 Microsoft Corporation. All rights reserved. Terms of Use.</A>
<!-- END_PAGE_FOOTER -->

</BLOCKQUOTE>

<SCRIPT>if((g_isIE == true) && (g_iMaj > 3)) {window.self.document.writeln('<SCR' + 'IPT SRC="../../tip2.js"></SCR' + 'IPT><IFRAME ID="G_L_S" NAME="SecretBuffer" STYLE="display: none" SRC=""></IFRAME>')}</SCRIPT>

<!-- DACONTROL_START -->

	<DIV ID="HeadGraphAnim"></DIV>
	<SCRIPT>if((g_isIE == true) && (g_iMaj > 3)) {window.self.document.writeln('<SCR' + 'IPT SRC="../../anim.js"></SCR' + 'IPT>')}</SCRIPT>
<!-- DACONTROL_END -->

</BODY>
</HTML>
