<!-- DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN" -->

<HTML>
<HEAD><TITLE>CUnknown Class</TITLE>
<SCRIPT> var sRelPath = '../../' </SCRIPT>


<META NAME="Description" CONTENT="CUnknown Class">
<META NAME="Description" CONTENT="CUnknown (CUnknown)">
<META NAME="Description" CONTENT="CUnknown::CUnknown">
<META NAME="Description" CONTENT="GetOwner (CUnknown)">
<META NAME="Description" CONTENT="CUnknown::GetOwner">
<META NAME="Description" CONTENT="NonDelegatingAddRef (CUnknown)">
<META NAME="Description" CONTENT="CUnknown::NonDelegatingAddRef">
<META NAME="Description" CONTENT="NonDelegatingQueryInterface (CUnknown)">
<META NAME="Description" CONTENT="CUnknown::NonDelegatingQueryInterface">
<META NAME="Description" CONTENT="NonDelegatingRelease (CUnknown)">
<META NAME="Description" CONTENT="CUnknown::NonDelegatingRelease">
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; CHARSET=iso8859-1">
<META NAME="MS.LOCALE" CONTENT="EN-US">
<META NAME="ROBOTS" CONTENT="all">

<!-- SNIFF_START -->

<SCRIPT>
//<!--
var g_isIE = false, g_isNav = false, g_iMaj = 0, g_sPlat = "";
// -->

</SCRIPT>
<SCRIPT SRC="../../ver.js"></SCRIPT>
<SCRIPT SRC="../../gloss.js"></SCRIPT>

<!-- SNIFF_END -->


<SCRIPT DEFER SRC="../../common.js"></SCRIPT>
<SCRIPT DEFER>
//<!--
function InitPage()
{
	if (g_isIE && g_iMaj >= 4)	
	{

		SetTOC();
	}
}
//-->

</SCRIPT>

<!-- SNIFF_END -->


<!-- STYLE_START -->

<SCRIPT>
//<!--
   var sVR = '../../'	// Set root for the style sheet
   var sCSS = '<LINK REL="stylesheet" HREF="' + sVR;

   if(g_isIE)
   {
	   if (g_iMaj >= 4) // For MSIE 4.0 or later
	   {
		   sCSS += 'dxm_basicsdkIE4';
		   if (g_sPlat == "Win") // Windows only for now
		   {
			   document.createStyleSheet(sVR + 'dxm_advSDKIE4.css');
		   }
	   }
	   else // For MSIE 3.0 or earlier
	   {
		   sCSS += 'dxm_basicsdkIE3';
	   }
   }
   else if (g_isNav) // For all Nav versions
   {
	   sCSS += 'dxm_basicsdkNAV';
   }
   else
   {
	   sCSS += 'dxm_basicsdkIE3'; // default to IE3 sheet
   }

   sCSS += (sCSS == '' ? '' : '.css" TYPE="text/css">');

   document.write(sCSS);
//-->

</SCRIPT>
<!-- STYLE_END -->


</HEAD>
<BODY onload="InitPage(); if (g_isIE && g_iMaj >= 4){HdgrphControl()}" BGCOLOR="#FFFFFF">
<A NAME="pagetop"></A><A NAME="CUnknown"></A>

<!-- HEADGRAPH_START -->

<TABLE CLASS="main" BORDER=0 CELLSPACING="0" CELLPADDING="0" WIDTH="*">
<TR>
<TD ROWSPAN="3" VALIGN="TOP" WIDTH="*">
<IMG SRC="../../art/header1.gif" WIDTH="107" HEIGHT="110" BORDER=0 ALT="DirectShow Animated Header -- CUnknown Class"></TD>
<TD ROWSPAN="2" VALIGN="TOP" WIDTH="217"><IMG SRC="../../art/hdrdshow.gif" WIDTH="217" HEIGHT="110" BORDER=0 ALT="DirectShow Animated Header -- CUnknown Class"></TD>
<TD VALIGN="TOP" WIDTH="383">
<IMG SRC="../../art/header3.gif" WIDTH="383" HEIGHT="95" BORDER=0 ALT="DirectShow Animated Header">
</TD>
<TD VALIGN="TOP" WIDTH="100%">
<IMG SRC="../../art/spacer1.gif" WIDTH="100%" HEIGHT="94" BORDER=0 ALT="Microsoft DirectShow SDK">
</TD>
</TR>
<!-- HEADGRAPH_END -->

<!-- NAV_LINKS_START -->

<TR><TD VALIGN="TOP"><PRE><IMG ID="TOC_" SRC="../../art/yelbtn.gif" WIDTH="11" HEIGHT="11" ALIGN="MIDDLE" BORDER=0 ALT="*"><A STYLE="color:black;font-weight:bold" ID="TOC" HREF="../../contents.htm">Contents</A>  <IMG SRC="../../art/yelbtn.gif" WIDTH="11" HEIGHT="11" ALIGN="MIDDLE" BORDER=0 ALT="*"><A STYLE="color:black;font-weight:bold" HREF="../../index.htm">Index</A>  <IMG SRC="../../art/yelbtn.gif" WIDTH="11" HEIGHT="11" ALIGN="MIDDLE" BORDER=0 ALT="*"><A STYLE="color:black;font-weight:bold" HREF="Classes_intro.htm">Topic Contents</A>
</PRE></TD></TR>
<TR><TD COLSPAN="2" VALIGN="TOP"><PRE><IMG SRC="../../art/yelbtn.gif" WIDTH="11" HEIGHT="11" ALIGN="MIDDLE" BORDER=0 ALT="*"><B>Previous Topic:</B> <A STYLE="color:black" HREF="CTransInPlaceOutputPin.htm">CTransInPlaceOutputPin Class</A>
<IMG SRC="../../art/yelbtn.gif" WIDTH="11" HEIGHT="11" ALIGN="MIDDLE" BORDER=0 ALT="*"><B>Next Topic:</B> <A  STYLE="color:black" HREF="CVideoTransformFilter.htm">CVideoTransformFilter Class</A>
</PRE></TD></TR></TABLE>
<!-- NAV_LINKS_END -->


<BLOCKQUOTE CLASS="body">


<!-- CONTENTS_START -->

<H1>CUnknown Class</H1>

<P><IMG SRC="../../art/cbase01.gif" WIDTH="219" HEIGHT="83" ALT="CUnknown class hierarchy">

<P>All Microsoft&#174; DirectShow&#153; Component Object Model (COM) objects derive from the <B>CUnknown</B> abstract base class. This class facilitates the creation of simple COM objects that you can combine with other COM objects to support multiple interfaces. To use this class, derive your object from <B>CUnknown</B> and call the <A HREF="../utilfunct/IUnknown_Macro.htm#DECLARE_IUNKNOWN">DECLARE_IUNKNOWN</A> macro in the public section of your object class definition; this implements the <A HREF="../iface/IUnknown.htm">IUnknown</A> interface for your object. Note that if derive from an object that has already done this, such as <A HREF="CBaseFilter.htm">CBaseFilter</A>, you do not need to do it yourself.

<P>The <B>CUnknown</B> class supports only one interface, <A HREF="../iface/IUnknown.htm">IUnknown</A>. To support interfaces in addition to those provided by the base class, override the 
<A HREF="CUnknown.htm#NonDelegatingQueryInterface">NonDelegatingQueryInterface</A> method. In the overriding function, call the <A HREF="../utilfunct/Object_Pin_functs.htm#GetInterface">GetInterface</A> function to retrieve the interface pointer for any interfaces your object supports. If the derived class does not implement the specified interface, you must query the base class to retrieve the interface.

<P>For example, <A HREF="CBaseFilter.htm">CBaseFilter</A> supports the following interfaces directly.

<UL><LI><A HREF="../iface/IBaseFilter.htm">IBaseFilter</A> 
<LI><A HREF="../../appendixes/Further_Reading.htm#IPersist">IPersist</A> 
<LI><A HREF="../iface/IAMovieSetup.htm">IAMovieSetup</A> 
</UL>
<P><A HREF="CBaseFilter.htm">CBaseFilter</A> also supports <A HREF="../iface/IUnknown.htm">IUnknown</A> by passing queries for this interface to <B>CUnknown</B>. The following code sample demonstrates this process.

<PRE>
/* Override this to say what interfaces are supported and where */

STDMETHODIMP CBaseFilter::NonDelegatingQueryInterface(REFIID riid, void **ppv)
{
    CheckPointer(ppv,E_POINTER);
    ValidateReadWritePtr(ppv,sizeof(PVOID));

    /* Do we have this interface */

    if (riid == IID_IFilter) {
         return GetInterface((IBaseFilter *) this, ppv);
    } else if (riid == IID_IMediaFilter) {
                   return GetInterface((IMediaFilter *) this, ppv);
    } else if (riid == IID_IPersist) {
                   return GetInterface((IPersist *) this, ppv);
    } else if (riid == IID_IAMovieSetup) {
                   return GetInterface((IAMovieSetup *) this, ppv);
    } else {
                   return CUnknown::NonDelegatingQueryInterface(riid, ppv);
    }
}
</PRE>
<P>To build composite objects, the <B>CUnknown</B> constructor has an LPUNKNOWN parameter that is a pointer to the top-level <A HREF="../iface/IUnknown.htm">IUnknown</A> interface for the entire composite object (the object that includes all objects based on a class derived from <B>CUnknown</B>). If this value is non-NULL, <B>CUnknown</B> stores a pointer to the topmost object; if it is null, the topmost object is <B>CUnknown</B> itself. This way, the topmost object's <B>IUnknown</B> has the same implementation as the <A HREF="../utilfunct/INonDelegatingUnknown_iface.htm#INonDelegatingUnknown">INonDelegatingUnknown</A> interface.

<P>A derived class will typically override the <A HREF="CUnknown.htm#NonDelegatingQueryInterface">NonDelegatingQueryInterface</A> method to return interfaces that it supports; however, it must delegate support for <A HREF="../iface/IUnknown.htm">IUnknown</A> to the <B>CUnknown</B> class implementation. Usually <A HREF="CUnknown.htm#NonDelegatingAddRef">NonDelegatingAddRef</A> and <A HREF="CUnknown.htm#NonDelegatingRelease">NonDelegatingRelease</A> do not need to be overridden because the reference count for the whole object is managed inside the top-level object. However, <B>NonDelegatingRelease</B> might need to be overridden sometimes because its default action when the reference count goes to zero is to delete the object from inside itself.

<P><B>CUnknown</B> provides the <A HREF="CUnknown.htm#GetOwner">CUnknown::GetOwner</A> member function. <A HREF="CUnknown.htm#GetOwner">GetOwner</A> simply returns an LPUNKNOWN pointer to the controlling unknown. This is used in the <A HREF="../utilfunct/IUnknown_Macro.htm#DECLARE_IUNKNOWN">DECLARE_IUNKNOWN</A> macro when calling <A HREF="../iface/IUnknown.htm#QueryInterface">QueryInterface</A>. It can also be used when creating a composite object to pass an LPUNKNOWN pointer to a component interface as an (equivalent) alternative to passing the LPUNKNOWN pointer that was passed to the composite object constructor.

<P>When <A HREF="../iface/IUnknown.htm#QueryInterface">QueryInterface</A> is called on an interface owned by a component interface, it is immediately passed to the <A HREF="CUnknown.htm#NonDelegatingQueryInterface">NonDelegatingQueryInterface</A> method of the top-level object's
<A HREF="../utilfunct/INonDelegatingUnknown_iface.htm#INonDelegatingUnknow">INonDelegatingUnknown::NonDelegatingQueryInterface</A> method, which either returns an interface it implements itself or passes the call to the correct member or base class's
<B>INonDelegatingUnknown::NonDelegatingQueryInterface</B> method. This then repeats the process until a component is found that implements the interface or calls <A HREF="CUnknown.htm#NonDelegatingQueryInterface">CUnknown::NonDelegatingQueryInterface</A>, which fails the call.

<P>Note that the top-level object's <A HREF="CUnknown.htm#NonDelegatingQueryInterface">CUnknown::NonDelegatingQueryInterface</A> member function (as distinct from its own implementation) must be called to support <A HREF="../iface/IUnknown.htm">IUnknown</A>.


 
 
<P>This design makes support for COM aggregation straightforward. The derived object's <B>CreateInstance</B> member function, which is called from the <A CLASS="Glossary" HREF="javascript:Glossary(sRelPath + 'gloss/gloss_C.htm#class_factory')">class factory</A> (by <B>CClassFactory::CreateInstance</B>) passes the outer unknown (the <I>pUnkOuter</I> parameter from <A HREF="../../appendixes/Further_Reading.htm#CoCreateInstance">CoCreateInstance</A>) on to <B>CUnknown</B> by calling the class constructor. So the object behaves as if it were part of a larger object by delegating its <A HREF="../iface/IUnknown.htm#QueryInterface">QueryInterface</A> calls to the outer unknown.

<P CLASS="ref"><A NAME="Protected_Data_Membe"></A>Protected Data Members</P>
<TABLE><TR><TD><B><A NAME="m_cRef">m_cRef</A></B> 
 </TD><TD>Number of reference counts (so the 
<A HREF="../utilfunct/INonDelegatingUnknown_iface.htm#INonDelegatingUnknow">INonDelegatingUnknown::NonDelegatingRelease</A> method can be overridden).
</TD></TR></TABLE>

<P CLASS="ref"><A NAME="Member_Functions"></A>Member Functions</P>

<TABLE><TR><TD><A HREF="CUnknown.htm#CUnknown_CUnknown">CUnknown</A> </TD><TD>Constructs a <A HREF="CUnknown.htm">CUnknown</A> object.
</TD></TR><TR><TD><A HREF="CUnknown.htm#GetOwner">GetOwner</A> </TD><TD>Returns an LPUNKNOWN 
pointer to the controlling unknown.
</TD></TR></TABLE>
<P CLASS="ref"><A NAME="Implemented_INonDele"></A>Implemented INonDelegatingUnknown Methods</P>

<TABLE><TR><TD><A HREF="CUnknown.htm#NonDelegatingAddRef">NonDelegatingAddRef</A>
 </TD><TD>Increments the reference count for an interface.
</TD></TR><TR><TD><A HREF="CUnknown.htm#NonDelegatingQueryInterface">NonDelegatingQueryInterface</A>
 </TD><TD>Returns an interface and increments the reference count.
</TD></TR><TR><TD><A HREF="CUnknown.htm#NonDelegatingRelease">NonDelegatingRelease</A>
 </TD><TD>Decrements the reference count for an interface.
</TD></TR></TABLE>



<H1><A NAME="CUnknown_CUnknown">CUnknown::CUnknown</A><HR size=1></H1>
<A HREF="CUnknown.htm">CUnknown Class</A>
<P>Constructs a <A HREF="CUnknown.htm">CUnknown</A> object.
<P CLASS="ref">Syntax</P><BLOCKQUOTE><PRE>
<P><B>CUnknown</B><B>(</B><BR>&nbsp;&nbsp;<B>const</B> <B>TCHAR</B> <I>*pName</I><B>,</B><BR>&nbsp;&nbsp;<B>LPUNKNOWN</B> <I>pUnk</I><BR>&nbsp;&nbsp;<B>)</B><B>;</B>
</PRE></BLOCKQUOTE>

<P CLASS="ref">Parameters</P>
<BLOCKQUOTE>
<DL><DT><I>pName</I>
</DT><DD>Name of the object used in the <A HREF="CBaseObject.htm">CBaseObject</A> constructor for debugging purposes.
</DD><DT><I>pUnk</I>
</DT><DD>Pointer to the owner of this object. If non-NULL, <A HREF="../iface/IUnknown.htm">IUnknown</A> calls are delegated 
to this object.
</DD></DL>
</BLOCKQUOTE>

<P CLASS="ref">Return Value</P>
<BLOCKQUOTE>
<P>No return value.
</BLOCKQUOTE>

<P CLASS="ref">Remarks</P>
<BLOCKQUOTE>
<P>The object is initialized with a reference count of zero. This reference count can be 
incremented when the object is queried for its first interface, depending on whether the object 
is currently being aggregated.
</BLOCKQUOTE>


<H1><A NAME="GetOwner">CUnknown::GetOwner</A><HR size=1></H1>
<A HREF="CUnknown.htm">CUnknown Class</A>
<P>Retrieves this object's Component Object Model (COM) class owner.
<P CLASS="ref">Syntax</P><BLOCKQUOTE><PRE>
<P><B>LPUNKNOWN</B> <B>GetOwner</B><B>(</B><B>void</B><B>)</B><B>;</B>
</PRE></BLOCKQUOTE>

<P CLASS="ref">Return Value</P>
<BLOCKQUOTE>
<P>Returns an LPUNKNOWN pointer to the controlling <A HREF="../iface/IUnknown.htm">IUnknown</A> interface.



</BLOCKQUOTE>


<H1><A NAME="NonDelegatingAddRef">CUnknown::NonDelegatingAddRef</A><HR size=1></H1>
<A HREF="CUnknown.htm">CUnknown Class</A>
<P>Increments the reference count for an interface.

<P CLASS="ref">Syntax</P>
<BLOCKQUOTE><PRE>
<P><B>ULONG</B> <B>NonDelegatingAddRef</B><B>(</B> <B>)</B><B>;</B>
</PRE></BLOCKQUOTE>

<P CLASS="ref">Return Value</P>
<BLOCKQUOTE>
<P>Returns the reference count of the object.


</BLOCKQUOTE>

<P CLASS="ref">Remarks</P>
<BLOCKQUOTE>
<P>This member function provides a base class implementation of the
<A HREF="../utilfunct/INonDelegatingUnknown_iface.htm#INonDelegatingUnknow">INonDelegatingUnknown::NonDelegatingAddRef</A> method. When the
object derived from <A HREF="CUnknown.htm">CUnknown</A> is part of an aggregated object,
this reference count modification is private to the embedded object.
</BLOCKQUOTE>


<H1><A NAME="NonDelegatingQueryInterface">CUnknown::NonDelegatingQueryInterface</A><HR size=1></H1>
<A HREF="CUnknown.htm">CUnknown Class</A>
<P>Returns an interface and increments the reference count.

<P CLASS="ref">Syntax</P>
<BLOCKQUOTE><PRE>
<P><B>HRESULT</B> <B>NonDelegatingQueryInterface</B><B>(</B><BR>&nbsp;&nbsp;<B>REFIID</B> <I>riid</I><B>,</B><BR>&nbsp;&nbsp;<B>void</B> <B>**</B> <I>ppv</I><BR>&nbsp;&nbsp;<B>)</B><B>;</B>
</PRE></BLOCKQUOTE>

<P CLASS="ref">Parameters</P>
<BLOCKQUOTE>
<DL><DT><I>riid</I>
 </DT><DD>Reference identifier.
</DD><DT><I>ppv</I>
 </DT><DD>Pointer to the interface.
</DD></DL>
</BLOCKQUOTE>

<P CLASS="ref">Return Value</P>
<BLOCKQUOTE>
<P>Returns E_POINTER if <I>ppv</I> is invalid. Returns NOERROR if the query is successful or E_NOINTERFACE if it is not. 

</BLOCKQUOTE>

<P CLASS="ref">Remarks</P>
<BLOCKQUOTE>
<P>This member function provides a base class implementation of the 
<A HREF="../utilfunct/INonDelegatingUnknown_iface.htm#INonDelegatingUnknow">INonDelegatingUnknown::NonDelegatingQueryInterface</A> method. 
Override this class to return interfaces on the object in the derived class.
</BLOCKQUOTE>


<H1><A NAME="NonDelegatingRelease">CUnknown::NonDelegatingRelease</A><HR size=1></H1>
<A HREF="CUnknown.htm">CUnknown Class</A>
<P>Decrements the reference count for an interface.

<P CLASS="ref">Syntax</P>
<BLOCKQUOTE><PRE>
<P><B>ULONG</B> <B>NonDelegatingRelease</B><B>(</B> <B>)</B><B>;</B>
</PRE></BLOCKQUOTE>

<P CLASS="ref">Return Value</P>
<BLOCKQUOTE>
<P>Returns the reference count.


</BLOCKQUOTE>

<P CLASS="ref">Remarks</P>
<BLOCKQUOTE>
<P>This member function provides a base class implementation of the
<A HREF="../utilfunct/INonDelegatingUnknown_iface.htm#INonDelegatingUnknow">INonDelegatingUnknown::NonDelegatingRelease</A> method. When the
object derived from <A HREF="CUnknown.htm">CUnknown</A> is part of an aggregated object,
this reference count modification is private to the embedded object.

</BLOCKQUOTE>
<!-- CONTENTS_END -->

<!-- START_PAGE_FOOTER -->


<H6><HR size=1></H6>
<P><A Class="line" HREF="#pagetop"><IMG src="../../art/arrowup1.gif" WIDTH="11" HEIGHT="11" ALIGN="MIDDLE" BORDER=0 ALT="Top of Page">&nbsp;Top of Page</A>
<BR><A Class="line" HREF="../../../cpyright.htm">&#169; 1998 Microsoft Corporation. All rights reserved. Terms of Use.</A>
<!-- END_PAGE_FOOTER -->

</BLOCKQUOTE>

<SCRIPT>if((g_isIE == true) && (g_iMaj > 3)) {window.self.document.writeln('<SCR' + 'IPT SRC="../../tip2.js"></SCR' + 'IPT><IFRAME ID="G_L_S" NAME="SecretBuffer" STYLE="display: none" SRC=""></IFRAME>')}</SCRIPT>

<!-- DACONTROL_START -->

	<DIV ID="HeadGraphAnim"></DIV>
	<SCRIPT>if((g_isIE == true) && (g_iMaj > 3)) {window.self.document.writeln('<SCR' + 'IPT SRC="../../anim.js"></SCR' + 'IPT>')}</SCRIPT>
<!-- DACONTROL_END -->

</BODY>
</HTML>
