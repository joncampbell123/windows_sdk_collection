<!-- DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN" -->

<HTML>
<HEAD><TITLE>CBaseInputPin Class</TITLE>
<SCRIPT> var sRelPath = '../../' </SCRIPT>


<META NAME="Description" CONTENT="CBaseInputPin Class">
<META NAME="Description" CONTENT="BeginFlush (CBaseInputPin)">
<META NAME="Description" CONTENT="CBaseInputPin::BeginFlush">
<META NAME="Description" CONTENT="CBaseInputPin (CBaseInputPin)">
<META NAME="Description" CONTENT="CBaseInputPin::CBaseInputPin">
<META NAME="Description" CONTENT="CheckStreaming (CBaseInputPin)">
<META NAME="Description" CONTENT="CBaseInputPin::CheckStreaming">
<META NAME="Description" CONTENT="Disconnect (CBaseInputPin)">
<META NAME="Description" CONTENT="CBaseInputPin::Disconnect">
<META NAME="Description" CONTENT="EndFlush (CBaseInputPin)">
<META NAME="Description" CONTENT="CBaseInputPin::EndFlush">
<META NAME="Description" CONTENT="GetAllocator (CBaseInputPin)">
<META NAME="Description" CONTENT="CBaseInputPin::GetAllocator">
<META NAME="Description" CONTENT="GetAllocatorRequirements (CBaseInputPin)">
<META NAME="Description" CONTENT="CBaseInputPin::GetAllocatorRequirements">
<META NAME="Description" CONTENT="Inactive (CBaseInputPin)">
<META NAME="Description" CONTENT="CBaseInputPin::Inactive">
<META NAME="Description" CONTENT="IsFlushing (CBaseInputPin)">
<META NAME="Description" CONTENT="CBaseInputPin::IsFlushing">
<META NAME="Description" CONTENT="IsReadOnly (CBaseInputPin)">
<META NAME="Description" CONTENT="CBaseInputPin::IsReadOnly">
<META NAME="Description" CONTENT="NonDelegatingQueryInterface (CBaseInputPin)">
<META NAME="Description" CONTENT="CBaseInputPin::NonDelegatingQueryInterface">
<META NAME="Description" CONTENT="Notify (CBaseInputPin)">
<META NAME="Description" CONTENT="CBaseInputPin::Notify">
<META NAME="Description" CONTENT="NotifyAllocator (CBaseInputPin)">
<META NAME="Description" CONTENT="CBaseInputPin::NotifyAllocator">
<META NAME="Description" CONTENT="PassNotify (CBaseInputPin)">
<META NAME="Description" CONTENT="CBaseInputPin::PassNotify">
<META NAME="Description" CONTENT="Receive (CBaseInputPin)">
<META NAME="Description" CONTENT="CBaseInputPin::Receive">
<META NAME="Description" CONTENT="ReceiveCanBlock (CBaseInputPin)">
<META NAME="Description" CONTENT="CBaseInputPin::ReceiveCanBlock">
<META NAME="Description" CONTENT="ReceiveMultiple (CBaseInputPin)">
<META NAME="Description" CONTENT="CBaseInputPin::ReceiveMultiple">
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; CHARSET=iso8859-1">
<META NAME="MS.LOCALE" CONTENT="EN-US">
<META NAME="ROBOTS" CONTENT="all">

<!-- SNIFF_START -->

<SCRIPT>
//<!--
var g_isIE = false, g_isNav = false, g_iMaj = 0, g_sPlat = "";
// -->

</SCRIPT>
<SCRIPT SRC="../../ver.js"></SCRIPT>
<SCRIPT SRC="../../gloss.js"></SCRIPT>

<!-- SNIFF_END -->


<SCRIPT DEFER SRC="../../common.js"></SCRIPT>
<SCRIPT DEFER>
//<!--
function InitPage()
{
	if (g_isIE && g_iMaj >= 4)	
	{

		SetTOC();
	}
}
//-->

</SCRIPT>

<!-- SNIFF_END -->


<!-- STYLE_START -->

<SCRIPT>
//<!--
   var sVR = '../../'	// Set root for the style sheet
   var sCSS = '<LINK REL="stylesheet" HREF="' + sVR;

   if(g_isIE)
   {
	   if (g_iMaj >= 4) // For MSIE 4.0 or later
	   {
		   sCSS += 'dxm_basicsdkIE4';
		   if (g_sPlat == "Win") // Windows only for now
		   {
			   document.createStyleSheet(sVR + 'dxm_advSDKIE4.css');
		   }
	   }
	   else // For MSIE 3.0 or earlier
	   {
		   sCSS += 'dxm_basicsdkIE3';
	   }
   }
   else if (g_isNav) // For all Nav versions
   {
	   sCSS += 'dxm_basicsdkNAV';
   }
   else
   {
	   sCSS += 'dxm_basicsdkIE3'; // default to IE3 sheet
   }

   sCSS += (sCSS == '' ? '' : '.css" TYPE="text/css">');

   document.write(sCSS);
//-->

</SCRIPT>
<!-- STYLE_END -->


</HEAD>
<BODY onload="InitPage(); if (g_isIE && g_iMaj >= 4){HdgrphControl()}" BGCOLOR="#FFFFFF">
<A NAME="pagetop"></A><A NAME="CBaseInputPin"></A>

<!-- HEADGRAPH_START -->

<TABLE CLASS="main" BORDER=0 CELLSPACING="0" CELLPADDING="0" WIDTH="*">
<TR>
<TD ROWSPAN="3" VALIGN="TOP" WIDTH="*">
<IMG SRC="../../art/header1.gif" WIDTH="107" HEIGHT="110" BORDER=0 ALT="DirectShow Animated Header"></TD>
<TD ROWSPAN="2" VALIGN="TOP" WIDTH="217"><IMG SRC="../../art/hdrdshow.gif" WIDTH="217" HEIGHT="110" BORDER=0 ALT="DirectShow Animated Header"></TD>
<TD VALIGN="TOP" WIDTH="383">
<IMG SRC="../../art/header3.gif" WIDTH="383" HEIGHT="95" BORDER=0 ALT="DirectShow Animated Header">
</TD>
<TD VALIGN="TOP" WIDTH="100%">
<IMG SRC="../../art/spacer1.gif" WIDTH="100%" HEIGHT="94" BORDER=0 ALT="Microsoft DirectShow SDK">
</TD>
</TR>
<!-- HEADGRAPH_END -->

<!-- NAV_LINKS_START -->

<TR><TD VALIGN="TOP"><PRE><IMG ID="TOC_" SRC="../../art/yelbtn.gif" WIDTH="11" HEIGHT="11" ALIGN="MIDDLE" BORDER=0 ALT="*"><A STYLE="color:black;font-weight:bold" ID="TOC" HREF="../../contents.htm">Contents</A>  <IMG SRC="../../art/yelbtn.gif" WIDTH="11" HEIGHT="11" ALIGN="MIDDLE" BORDER=0 ALT="*"><A STYLE="color:black;font-weight:bold" HREF="../../index.htm">Index</A>  <IMG SRC="../../art/yelbtn.gif" WIDTH="11" HEIGHT="11" ALIGN="MIDDLE" BORDER=0 ALT="*"><A STYLE="color:black;font-weight:bold" HREF="Classes_intro.htm">Topic Contents</A>
</PRE></TD></TR>
<TR><TD COLSPAN="2" VALIGN="TOP"><PRE><IMG SRC="../../art/yelbtn.gif" WIDTH="11" HEIGHT="11" ALIGN="MIDDLE" BORDER=0 ALT="*"><B>Previous Topic:</B> <A STYLE="color:black" HREF="CBaseFilter.htm">CBaseFilter Class</A>
<IMG SRC="../../art/yelbtn.gif" WIDTH="11" HEIGHT="11" ALIGN="MIDDLE" BORDER=0 ALT="*"><B>Next Topic:</B> <A  STYLE="color:black" HREF="CBaseList.htm">CBaseList Class</A>
</PRE></TD></TR></TABLE>
<!-- NAV_LINKS_END -->


<BLOCKQUOTE CLASS="body">


<!-- CONTENTS_START -->

<H1>CBaseInputPin Class</H1>

<P><IMG SRC="../../art/filter07.gif" WIDTH="315" HEIGHT="229" ALT="CBaseInputPin class hierarchy">

<P><B>CBaseInputPin</B> is an abstract base class derived from <A HREF="CBasePin.htm">CBasePin</A> that adds 
support for <A HREF="../iface/IMemInputPin.htm">IMemInputPin</A> in addition to the <A HREF="../iface/IPin.htm">IPin</A> interface support provided by 
<B>CBasePin</B>. Its <A HREF="../iface/IMemInputPin.htm#GetAllocator">IMemInputPin::GetAllocator</A> method returns a 
<A HREF="CMemAllocator.htm">CMemAllocator</A> object. Derive your <A CLASS="Glossary" HREF="javascript:Glossary(sRelPath + 'gloss/gloss_I.htm#input_pin')">input pin</A> from this class.

<P>All member functions in this class that return <A HREF="../Error_Success_Codes.htm#HRESULT">HRESULT</A> and accept a pointer as a 
parameter return E_POINTER when passed a null pointer. 

<A NAME="Protected_Data_Membe"></A><P CLASS="ref">Protected Data Members</P>
<TABLE><TR><TD><B><A NAME="CBaseInputPin::m_bFlushing">m_bFlushing</A></B>
 </TD><TD>In the state of flushing; if TRUE, all <A HREF="../iface/IMemInputPin.htm#Receive">IMemInputPin::Receive</A> methods are returned 
with S_FALSE.
</TD></TR><TR><TD><B><A NAME="CBaseInputPin::m_bReadOnly">m_bReadOnly</A></B>
 </TD><TD>If TRUE, indicates that the allocator being used contains samples that are read-only.
</TD></TR><TR><TD><B><A NAME="CBaseInputPin::m_pAllocator">m_pAllocator</A></B>
 </TD><TD>Pointer to the default memory allocator.

</TD></TR></TABLE>
<A NAME="Member_Functions"></A><P CLASS="ref">Member Functions</P>

<TABLE><TR><TD><A HREF="CBaseInputPin.htm#CBaseInputPin_CBaseInputPin">CBaseInputPin</A>
 </TD><TD>Constructs a <A HREF="CBaseInputPin.htm">CBaseInputPin</A> object.
</TD></TR><TR><TD><A HREF="CBaseInputPin.htm#IsReadOnly">IsReadOnly</A>
 </TD><TD>Checks the <A HREF="CBaseInputPin.htm#CBaseInputPin::m_bReadOnly">m_bReadOnly</A> data member and returns its value.
</TD></TR><TR><TD><A HREF="CBaseInputPin.htm#IsFlushing">IsFlushing</A>
 </TD><TD>Checks the <A HREF="CBaseInputPin.htm#CBaseInputPin::m_bFlushing">m_bFlushing</A> data member 
 and returns its value.
</TD></TR><TR><TD><A HREF="CBaseInputPin.htm#PassNotify">PassNotify</A>
 </TD><TD>Passes a quality-control notification to the appropriate sink.

</TD></TR></TABLE>
<A NAME="Overridable_Member_F"></A><P CLASS="ref">Overridable Member Functions</P>

<TABLE><TR><TD><A HREF="CBaseInputPin.htm#CheckStreaming">CheckStreaming</A>
 </TD><TD>Verifies conditions for continuing with a streaming operation.
</TD></TR><TR><TD><A HREF="CBaseInputPin.htm#Inactive">Inactive</A>
 </TD><TD>Switches the <A CLASS="Glossary" HREF="javascript:Glossary(sRelPath + 'gloss/gloss_P.htm#pin')">pin</A> to an inactive state.
</TD></TR></TABLE>

<P CLASS="ref"><A NAME="Implemented_IPin_Met"></A>Implemented IPin Methods</P>
<TABLE><TR><TD><A HREF="CBaseInputPin.htm#BeginFlush">BeginFlush</A>
 </TD><TD>Informs the pin to begin a flush operation.
</TD></TR><TR><TD><A HREF="CBaseInputPin.htm#Disconnect">Disconnect</A>
 </TD><TD>Releases the stored allocator.
</TD></TR><TR><TD><A HREF="CBaseInputPin.htm#EndFlush">EndFlush</A>
 </TD><TD>Informs the pin to end a flush operation.
</TD></TR></TABLE>

<P CLASS="ref"><A NAME="Implemented_IMemInpu"></A>Implemented IMemInputPin Methods</P>
<TABLE><TR><TD><A HREF="CBaseInputPin.htm#GetAllocator">GetAllocator</A>
 </TD><TD>Returns the allocator interface that this input pin would like the <A CLASS="Glossary" HREF="javascript:Glossary(sRelPath + 'gloss/gloss_O.htm#output_pin')">output pin</A> to use.
</TD></TR><TR><TD><A HREF="CBaseInputPin.htm#GetAllocatorRequirements">GetAllocatorRequirements</A>
 </TD><TD>Indicates an optional method to use if the <A CLASS="Glossary" HREF="javascript:Glossary(sRelPath + 'gloss/gloss_f.htm#filter')">filter</A> has specific alignment or prefix requirements 
but could use an upstream allocator.
</TD></TR><TR><TD><A HREF="CBaseInputPin.htm#NotifyAllocator">NotifyAllocator</A>
 </TD><TD>Tells the input pin which allocator the output pin is actually going to use.
</TD></TR><TR><TD><A HREF="CBaseInputPin.htm#Receive">Receive</A>
 </TD><TD>Returns the next block of data from the stream. (Override this method to process a
sample being passed in.)
</TD></TR><TR><TD><A HREF="CBaseInputPin.htm#ReceiveCanBlock">ReceiveCanBlock</A>
 </TD><TD>Determines if sending an <A HREF="../iface/IMemInputPin.htm#Receive">IMemInputPin::Receive</A> method might block.
</TD></TR><TR><TD><A HREF="CBaseInputPin.htm#ReceiveMultiple">ReceiveMultiple</A>
 </TD><TD>Returns the next block of data from the stream. (Override this method to process
samples being passed in.)
</TD></TR></TABLE>

<P CLASS="ref"><A NAME="Implemented_INonDele"></A>Implemented INonDelegatingUnknown Methods</P>
<TABLE><TR><TD><A HREF="CBaseInputPin.htm#NonDelegatingQueryInterface">NonDelegatingQueryInterface</A>
 </TD><TD>Retrieves an interface from the subobject, not the aggregated object.
</TD></TR></TABLE>

<P CLASS="ref"><A NAME="Implemented_IQuality"></A>Implemented IQualityControl Methods</P>
<TABLE><TR><TD><A HREF="CBaseInputPin.htm#Notify">Notify</A>
 </TD><TD>Notifies the recipient that a quality-control change is requested.
(Override on the output pin only. This implementation returns NOERROR.)
</TD></TR></TABLE>



<H1><A NAME="BeginFlush">CBaseInputPin::BeginFlush</A><HR size=1></H1>
<A HREF="CBaseInputPin.htm">CBaseInputPin Class</A>
<P>Informs the pin to begin a flush operation.

<P CLASS="ref">Syntax</P>
<BLOCKQUOTE><PRE>
<P><B>HRESULT</B> <B>BeginFlush</B><B>(</B><B>void</B><B>)</B><B>;</B>
</PRE></BLOCKQUOTE>
<P CLASS="ref">Return Value</P>
<BLOCKQUOTE>
<P>Returns an <A HREF="../Error_Success_Codes.htm#HRESULT">HRESULT</A> value.

</BLOCKQUOTE>

<P CLASS="ref">Remarks</P>
<BLOCKQUOTE>
<P>This member function implements the <A HREF="../iface/IPin.htm#BeginFlush">IPin::BeginFlush</A> method.
When this method is called, the pin is entering flush state. You must
override this method in your derived class, but you should call this base
class first in your implementation, because it sets <A HREF="CBaseInputPin.htm#CBaseInputPin::m_bFlushing">m_bFlushing</A>
so that no more <A HREF="../iface/IMemInputPin.htm#Receive">IMemInputPin::Receive</A> calls will succeed.

<P>The overriding member function should then carry out the following steps.
<OL><LI>Discard any queued data.
<LI>Free any pin blocked by the <A HREF="../iface/IMemInputPin.htm#Receive">Receive</A> method.
<LI>Pass the <A HREF="../iface/IPin.htm#BeginFlush">IPin::BeginFlush</A> method to any downstream pins.
</OL>
<P><A HREF="../iface/IPin.htm#BeginFlush">IPin::BeginFlush</A> is not logically part of the media stream and can
be optimized in the sense that if a pin has passed no data downstream before
this method is called, there is no need to pass this notification on.

<P>An example of an overriding implementation of this member function can be
found in the <A HREF="CTransformInputPin.htm#BeginFlush">CTransformInputPin::BeginFlush</A> member function, which
uses the <A HREF="CBaseOutputPin.htm#DeliverBeginFlush">CBaseOutputPin::DeliverBeginFlush</A> member function to
perform the last step.
</BLOCKQUOTE>


<H1><A NAME="CBaseInputPin_CBaseInputPin">CBaseInputPin::CBaseInputPin</A><HR size=1></H1>
<A HREF="CBaseInputPin.htm">CBaseInputPin Class</A>
<P>Constructs a <A HREF="CBaseInputPin.htm">CBaseInputPin</A> object.
<P CLASS="ref">Syntax</P><BLOCKQUOTE><PRE>
<P><B>CBaseInputPin::CBaseInputPin</B><B>(</B><BR>&nbsp;&nbsp;<B>TCHAR</B> <I>*pObjectName</I><B>,</B><BR>&nbsp;&nbsp;<B>CBaseFilter</B> <I>*pFilter</I><B>,</B><BR>&nbsp;&nbsp;<B>CCritSec</B> <I>*pLock</I><B>,</B><BR>&nbsp;&nbsp;<B>HRESULT</B> <I>*phr</I><B>,</B><BR>&nbsp;&nbsp;<B>LPCWSTR</B> <I>pPinName</I><BR>&nbsp;&nbsp;<B>)</B><B>;</B>
</PRE></BLOCKQUOTE>

<P CLASS="ref">Parameters</P>
<BLOCKQUOTE>
<DL><DT><I>pObjectName</I>
</DT><DD>Name of the class object.
</DD><DT><I>pFilter</I>
</DT><DD>Pointer to the filter that owns this pin.
</DD><DT><I>pLock</I>
</DT><DD>Pointer to the <A HREF="CCritSec.htm">CCritSec</A> critical section object used to lock the pin.
</DD><DT><I>phr</I>
</DT><DD>Pointer to the general COM return value. This value is changed only if this function fails.
</DD><DT><I>pPinName</I>
</DT><DD>Name of the pin.
</DD></DL>
</BLOCKQUOTE>

<P CLASS="ref">Return Value</P>
<BLOCKQUOTE>
<P>No return value.
</BLOCKQUOTE>


<H1><A NAME="CheckStreaming">CBaseInputPin::CheckStreaming</A><HR size=1></H1>
<A HREF="CBaseInputPin.htm">CBaseInputPin Class</A>
<P>Verifies conditions for continuing with a streaming operation.

<P CLASS="ref">Syntax</P>
<BLOCKQUOTE><PRE>
<P><B>virtual</B> <B>HRESULT</B> <B>CheckStreaming</B><B>(</B> <B>)</B><B>;</B>
</PRE></BLOCKQUOTE>
<P CLASS="ref">Return Value</P>
<BLOCKQUOTE>
<P>Returns one of the following <A HREF="../Error_Success_Codes.htm#HRESULT">HRESULT</A> values, depending on the state.
<TABLE>
<TR><TD>S_FALSE </TD><TD>Currently in flushing state.
</TD></TR><TR><TD>S_OK </TD><TD>Receive or EndOfStream operations can safely proceed.
</TD></TR><TR><TD><A HREF="../Error_Success_Codes.htm#VFW_E_RUNTIME_ERROR">VFW_E_RUNTIME_ERROR</A> </TD><TD>Run-time error occurred while processing a previous 
sample.
</TD></TR><TR><TD><A HREF="../Error_Success_Codes.htm#VFW_E_WRONG_STATE">VFW_E_WRONG_STATE</A> </TD><TD>Filter is in the State_Stopped state.
</TD></TR></TABLE>

</BLOCKQUOTE>

<P CLASS="ref">Remarks</P>
<BLOCKQUOTE>
<P>Conditions checked in this member function include whether the filter is connected, if it is in an active state, if it is not currently flushing data, and if it has not just issued a run-time error. If all these conditions pass, it returns S_OK.

<P>You can override this member function to add restrictions defined by your derived class. The overriding member function should call this base class implementation to check for conditions here as well.

<P>This function member should be called from any override of the <A HREF="CBaseInputPin.htm#Receive">CBaseInputPin::Receive</A> or <A HREF="CBasePin.htm#EndOfStream">CBasePin::EndOfStream</A> member function (or they should do some equivalent check). 
</BLOCKQUOTE>


<H1><A NAME="Disconnect">CBaseInputPin::Disconnect</A><HR size=1></H1>
<A HREF="CBaseInputPin.htm">CBaseInputPin Class</A>
<P>Releases the stored allocator.

<P CLASS="ref">Syntax</P>
<BLOCKQUOTE><PRE>
<P><B>HRESULT</B> <B>Disconnect</B><B>(</B> <B>)</B><B>;</B>
</PRE></BLOCKQUOTE>
<P CLASS="ref">Return Value</P>
<BLOCKQUOTE>
<P>Returns an <A HREF="../Error_Success_Codes.htm#HRESULT">HRESULT</A> value.

</BLOCKQUOTE>

<P CLASS="ref">Remarks</P>
<BLOCKQUOTE>
<P>This member function overrides the <A HREF="CBasePin.htm#Disconnect">CBasePin::Disconnect</A> member function. It calls <B>CBasePin::Disconnect</B> first, and then releases the allocator held by <A HREF="CBaseInputPin.htm#CBaseInputPin::m_pAllocator">m_pAllocator</A>. 
</BLOCKQUOTE>


<H1><A NAME="EndFlush">CBaseInputPin::EndFlush</A><HR size=1></H1>
<A HREF="CBaseInputPin.htm">CBaseInputPin Class</A>
<P>Informs the pin to end a flush operation and notifies the pin that it
can start accepting data again.

<P CLASS="ref">Syntax</P>
<BLOCKQUOTE><PRE>
<P><B>HRESULT</B> <B>EndFlush</B><B>(</B><B>void</B><B>)</B><B>;</B>
</PRE></BLOCKQUOTE>
<P CLASS="ref">Return Value</P>
<BLOCKQUOTE>
<P>Returns an <A HREF="../Error_Success_Codes.htm#HRESULT">HRESULT</A> value.

</BLOCKQUOTE>

<P CLASS="ref">Remarks</P>
<BLOCKQUOTE>
<P>This member function implements the <A HREF="../iface/IPin.htm#EndFlush">IPin::EndFlush</A> method.
When this method is called, the pin is beginning to end a flush operation.
Your derived class must override this member function, but should call
this member function at the end of your implementation
to clear <A HREF="CBaseInputPin.htm#CBaseInputPin::m_bFlushing">m_bFlushing</A> so that <A HREF="../iface/IMemInputPin.htm#Receive">IMemInputPin::Receive</A> calls
will succeed.

<P>Before calling this base class implementation, your overriding member function
should perform the following steps.
<OL><LI>Ensure that your filter will not push any additional data.
(To do this, synchronize with a thread, stop it pushing, and discard any queued data.)
<LI>Pass the <A HREF="../iface/IPin.htm#EndFlush">EndFlush</A> method downstream by calling the
method on the <A CLASS="Glossary" HREF="javascript:Glossary(sRelPath + 'gloss/gloss_D.htm#downstream_filter')">downstream filter's</A> input pin.
</OL>
<P><A HREF="../iface/IPin.htm#EndFlush">IPin::EndFlush</A> is not logically part of the media stream. It can
be optimized in the sense that if a pin has passed no data downstream before
this method is called, there is no need to pass this notification on.

<P>An example of an overriding implementation of this member function can be
found in the <A HREF="CTransformInputPin.htm#EndFlush">CTransformInputPin::EndFlush</A> member function,
which uses the <A HREF="CBaseOutputPin.htm#DeliverEndFlush">CBaseOutputPin::DeliverEndFlush</A> member function to
perform the last step.
</BLOCKQUOTE>


<H1><A NAME="GetAllocator">CBaseInputPin::GetAllocator</A><HR size=1></H1>
<A HREF="CBaseInputPin.htm">CBaseInputPin Class</A>
<P>Retrieves the allocator interface that this input pin identifies as the
interface for the output pin to use.

<P CLASS="ref">Syntax</P>
<BLOCKQUOTE><PRE>
<P><B>HRESULT</B> <B>GetAllocator</B><B>(</B><BR>&nbsp;&nbsp;<B>IMemAllocator</B> <B>**</B> <I>ppAllocator</I><BR>&nbsp;&nbsp;<B>)</B><B>;</B>
</PRE></BLOCKQUOTE>

<P CLASS="ref">Parameters</P>
<BLOCKQUOTE>
<DL><DT><I>ppAllocator</I>
</DT><DD>Pointer to an obtained <A HREF="../iface/IMemAllocator.htm">IMemAllocator</A> object.
</DD></DL>
</BLOCKQUOTE>

<P CLASS="ref">Return Value</P>
<BLOCKQUOTE>
<P>Default implementation returns either E_OUTOFMEMORY, if an allocator cannot be 
created, or NOERROR upon success.

</BLOCKQUOTE>

<P CLASS="ref">Remarks</P>
<BLOCKQUOTE>
<P>This member function implements the <A HREF="../iface/IMemInputPin.htm#GetAllocator">IMemInputPin::GetAllocator</A> method,
which is called by the connected output pin to retrieve an allocator to use
for transporting media samples. By default, this member function creates
a <A HREF="CMemAllocator.htm">CMemAllocator</A> object and obtains the <A HREF="../iface/IMemAllocator.htm">IMemAllocator</A> interface,
to which it adds a reference count for the pin when assigning it to the <A HREF="CBaseInputPin.htm#CBaseInputPin::m_pAllocator">m_pAllocator</A>
data member, and adds another reference count before passing it back to the output pin.

<P>Override this member function if your filter has another allocator, such as one
from a downstream pin, or a specialized allocator to offer the connected output pin.
</BLOCKQUOTE>


<H1><A NAME="GetAllocatorRequirements">CBaseInputPin::GetAllocatorRequirements</A><HR size=1></H1>
<A HREF="CBaseInputPin.htm">CBaseInputPin Class</A>
<P>Optional member function to use if the filter has specific alignment or prefix requirements 
but could use an upstream allocator.

<P CLASS="ref">Syntax</P>
<BLOCKQUOTE><PRE>
<P><B>HRESULT</B> <B>GetAllocatorRequirements</B><B>(</B><BR>&nbsp;&nbsp;<B>ALLOCATOR_PROPERTIES</B> <B>*</B> <I>pProps</I><BR>&nbsp;&nbsp;<B>)</B><B>;</B>
</PRE></BLOCKQUOTE>

<P CLASS="ref">Parameters</P>
<BLOCKQUOTE>
<DL><DT><I>pProps</I>
</DT><DD><A HREF="../structs.htm#ALLOCATOR_PROPERTIES">ALLOCATOR_PROPERTIES</A> structure containing the required size,
count, and alignment of the allocator.
</DD></DL>
</BLOCKQUOTE>

<P CLASS="ref">Return Value</P>
<BLOCKQUOTE>
<P>Returns an <A HREF="../Error_Success_Codes.htm#HRESULT">HRESULT</A> value. Returns E_NOTIMPL by default.

</BLOCKQUOTE>

<P CLASS="ref">Remarks</P>
<BLOCKQUOTE>
<P>Override this member function if you have specific alignment or prefix requirements
but could use an upstream allocator. 

</BLOCKQUOTE>


<H1><A NAME="Inactive">CBaseInputPin::Inactive</A><HR size=1></H1>
<A HREF="CBaseInputPin.htm">CBaseInputPin Class</A>
<P>Releases the allocator's memory.

<P CLASS="ref">Syntax</P>
<BLOCKQUOTE><PRE>
<P><B>HRESULT</B> <B>Inactive</B><B>(</B><B>void</B><B>)</B><B>;</B>
</PRE></BLOCKQUOTE>
<P CLASS="ref">Return Value</P>
<BLOCKQUOTE>
<P>Returns an <A HREF="../Error_Success_Codes.htm#HRESULT">HRESULT</A> value.


</BLOCKQUOTE>

<P CLASS="ref">Remarks</P>
<BLOCKQUOTE>
<P>This member function is called through <A HREF="../iface/IMediaFilter.htm">IMediaFilter</A>, which is responsible 
for locking the object first.
</BLOCKQUOTE>


<H1><A NAME="IsFlushing">CBaseInputPin::IsFlushing</A><HR size=1></H1>
<A HREF="CBaseInputPin.htm">CBaseInputPin Class</A>
<P>Checks the <A HREF="CBaseInputPin.htm#CBaseInputPin::m_bFlushing">m_bFlushing</A> data member and returns its value.

<P CLASS="ref">Syntax</P>
<BLOCKQUOTE><PRE>
<P><B>BOOL</B> <B>IsFlushing</B><B>(</B><B>void</B><B>)</B><B>;</B>
</PRE></BLOCKQUOTE>
<P CLASS="ref">Return Value</P>
<BLOCKQUOTE>
<P>Returns TRUE if the input pin is flushing data; otherwise, returns FALSE.


</BLOCKQUOTE>


<H1><A NAME="IsReadOnly">CBaseInputPin::IsReadOnly</A><HR size=1></H1>
<A HREF="CBaseInputPin.htm">CBaseInputPin Class</A>
<P>Checks the <A HREF="CBaseInputPin.htm#CBaseInputPin::m_bReadOnly">m_bReadOnly</A> data member and returns its value.

<P CLASS="ref">Syntax</P>
<BLOCKQUOTE><PRE>
<P><B>BOOL</B> <B>IsReadOnly</B><B>(</B><B>void</B><B>)</B><B>;</B>
</PRE></BLOCKQUOTE>
<P CLASS="ref">Return Value</P>
<BLOCKQUOTE>
<P>Returns TRUE if the allocator has read-only samples; otherwise, returns FALSE.


</BLOCKQUOTE>


<H1><A NAME="NonDelegatingQueryInterface">CBaseInputPin::NonDelegatingQueryInterface</A><HR size=1></H1>
<A HREF="CBaseInputPin.htm">CBaseInputPin Class</A>
<P>Retrieves an interface and increments the reference count.

<P CLASS="ref">Syntax</P>
<BLOCKQUOTE><PRE>
<P><B>HRESULT</B> <B>NonDelegatingQueryInterface</B><B>(</B><BR>&nbsp;&nbsp;<B>REFIID</B> <I>riid</I><B>,</B><BR>&nbsp;&nbsp;<B>void</B> <B>**</B> <I>ppv</I><BR>&nbsp;&nbsp;<B>)</B><B>;</B>
</PRE></BLOCKQUOTE>

<P CLASS="ref">Parameters</P>
<BLOCKQUOTE>
<DL><DT><I>riid</I>
 </DT><DD>Reference identifier.
</DD><DT><I>ppv</I>
 </DT><DD>Pointer to the interface.
</DD></DL>
</BLOCKQUOTE>

<P CLASS="ref">Return Value</P>
<BLOCKQUOTE>
<P>Returns E_POINTER if <I>ppv</I> is invalid. Returns NOERROR if the query is successful or E_NOINTERFACE if it is not. 

</BLOCKQUOTE>

<P CLASS="ref">Remarks</P>
<BLOCKQUOTE>
<P>This member function implements the <A HREF="../utilfunct/INonDelegatingUnknown_iface.htm#INonDelegatingUnknow">INonDelegatingUnknown::NonDelegatingQueryInterface</A> method and passes out 
references to the <A HREF="../iface/IMemInputPin.htm">IMemInputPin</A> and <A HREF="../iface/IUnknown.htm">IUnknown</A> interfaces. Override this class to return other interfaces on the object in the derived class.
</BLOCKQUOTE>


<H1><A NAME="Notify">CBaseInputPin::Notify</A><HR size=1></H1>
<A HREF="CBaseInputPin.htm">CBaseInputPin Class</A>
<P>Notifies the recipient that a quality change is requested.

<P CLASS="ref">Syntax</P>
<BLOCKQUOTE><PRE>
<P><B>HRESULT</B> <B>Notify</B><B>(</B><BR>&nbsp;&nbsp;<B>IBaseFilter</B> <B>*</B> <I>pSelf</I><B>,</B><BR>&nbsp;&nbsp;<B>Quality</B> <I>q</I><BR>&nbsp;&nbsp;<B>)</B><B>;</B>
</PRE></BLOCKQUOTE>

<P CLASS="ref">Parameters</P>
<BLOCKQUOTE>
<DL><DT><I>pSelf</I>
 </DT><DD>Pointer to the filter that is sending the quality notification.
</DD><DT><I>q</I>
 </DT><DD>Quality notification structure.
</DD></DL>
</BLOCKQUOTE>

<P CLASS="ref">Return Value</P>
<BLOCKQUOTE>
<P>Returns NOERROR by default.

</BLOCKQUOTE>

<P CLASS="ref">Remarks</P>
<BLOCKQUOTE>
<P>The <A HREF="../iface/IQualityControl.htm#Notify">IQualityControl::Notify</A> method is usually implemented on the output pin, 
because quality-control messages are passed upstream, and not on the input pin.
</BLOCKQUOTE>


<H1><A NAME="NotifyAllocator">CBaseInputPin::NotifyAllocator</A><HR size=1></H1>
<A HREF="CBaseInputPin.htm">CBaseInputPin Class</A>
<P>Notifies the input pin as to which allocator the output pin is actually going to use.

<P CLASS="ref">Syntax</P>
<BLOCKQUOTE><PRE>
<P><B>HRESULT</B> <B>NotifyAllocator</B><B>(</B><BR>&nbsp;&nbsp;<B>IMemAllocator</B> <B>*</B> <I>pAllocator</I><B>,</B><BR>&nbsp;&nbsp;<B>BOOL</B> <I>bReadOnly</I><BR>&nbsp;&nbsp;<B>)</B><B>;</B>
</PRE></BLOCKQUOTE>

<P CLASS="ref">Parameters</P>
<BLOCKQUOTE>
<DL><DT><I>pAllocator</I>
</DT><DD>Pointer to the <A HREF="../iface/IMemAllocator.htm">IMemAllocator</A> object to use. This might or might not
be the same <B>IMemAllocator</B> object that the input pin provided in the
<A HREF="../iface/IMemInputPin.htm#GetAllocator">IMemInputPin::GetAllocator</A> method (the output pin could provide its own allocator).
</DD><DT><I>bReadOnly</I>
</DT><DD>Flag to indicate if the samples from this allocator are read-only.
</DD></DL>
</BLOCKQUOTE>

<P CLASS="ref">Return Value</P>
<BLOCKQUOTE>
<P>Default implementation returns NOERROR.

</BLOCKQUOTE>

<P CLASS="ref">Remarks</P>
<BLOCKQUOTE>
<P>This member function implements the <A HREF="../iface/IMemInputPin.htm#NotifyAllocator">IMemInputPin::NotifyAllocator</A> method,
which is called by the connected output pin to inform the input pin of the
chosen allocator for the memory <A CLASS="Glossary" HREF="javascript:Glossary(sRelPath + 'gloss/gloss_T.htm#transport')">transport</A>. Override this member function
if your filter cares about this information. By default, this sets the
<A HREF="CBaseInputPin.htm#CBaseInputPin::m_pAllocator">m_pAllocator</A> data member to the allocator interface passed in after
adding a reference count to that interface.
</BLOCKQUOTE>


<H1><A NAME="PassNotify">CBaseInputPin::PassNotify</A><HR size=1></H1>
<A HREF="CBaseInputPin.htm">CBaseInputPin Class</A>
<P>Passes a quality-control notification to the appropriate sink.

<P CLASS="ref">Syntax</P>
<BLOCKQUOTE><PRE>
<P><B>HRESULT</B> <B>PassNotify</B><B>(</B><BR>&nbsp;&nbsp;<B>Quality</B> <I>q</I><BR>&nbsp;&nbsp;<B>)</B><B>;</B>
</PRE></BLOCKQUOTE>

<P CLASS="ref">Parameters</P>
<BLOCKQUOTE>
<DL><DT><I>q</I>
</DT><DD>Quality-control notification object.
</DD></DL>
</BLOCKQUOTE>

<P CLASS="ref">Return Value</P>
<BLOCKQUOTE>
<P>Returns VFW_E_NOT_FOUND if no <A CLASS="Glossary" HREF="javascript:Glossary(sRelPath + 'gloss/gloss_Q.htm#quality_sink')">quality sink</A> is set and the <A CLASS="Glossary" HREF="javascript:Glossary(sRelPath + 'gloss/gloss_U.htm#upstream_filter')">upstream filter</A> does not support the <A HREF="../iface/IQualityControl.htm">IQualityControl</A> interface. Otherwise, returns the <A HREF="../Error_Success_Codes.htm#HRESULT">HRESULT</A> value resulting from notifying the sink or the upstream filter.


</BLOCKQUOTE>

<P CLASS="ref">Remarks</P>
<BLOCKQUOTE>
<P>Output pins receive quality-control notifications and, if possible, filters act on them to degrade appropriately. Often, filters cannot respond to the notifications; in this case the notification should be passed to the quality-control sink or, by default, upstream to the next filter. The <B>PassNotify</B> member function is called from the <A HREF="CTransformOutputPin.htm#Notify">CTransformOutputPin::Notify</A> member function when a notification requires passing. The <A HREF="../structs.htm#Quality">Quality</A> structure passed is the one that the output pin received.
</BLOCKQUOTE>


<H1><A NAME="Receive">CBaseInputPin::Receive</A><HR size=1></H1>
<A HREF="CBaseInputPin.htm">CBaseInputPin Class</A>
<P>Retrieves the next block of data from the stream.

<P CLASS="ref">Syntax</P>
<BLOCKQUOTE><PRE>
<P><B>HRESULT</B> <B>Receive</B><B>(</B><BR>&nbsp;&nbsp;<B>IMediaSample</B> <B>*</B> <I>pSample</I><BR>&nbsp;&nbsp;<B>)</B><B>;</B>
</PRE></BLOCKQUOTE>

<P CLASS="ref">Parameters</P>
<BLOCKQUOTE>
<DL><DT><I>pSample</I>
</DT><DD>Pointer to a media sample.
</DD></DL>
</BLOCKQUOTE>

<P CLASS="ref">Return Value</P>
<BLOCKQUOTE>
<P>Returns an <A HREF="../Error_Success_Codes.htm#HRESULT">HRESULT</A> value.

</BLOCKQUOTE>

<P CLASS="ref">Remarks</P>
<BLOCKQUOTE>
<P>This member function implements the <A HREF="../iface/IMemInputPin.htm#Receive">IMemInputPin::Receive</A> method. It first checks that it can process the sample by calling <A HREF="CBaseInputPin.htm#CheckStreaming">CBaseInputPin::CheckStreaming</A>; if that member function does not return S_OK, <B>Receive</B> returns immediately with the value returned by <B>CBaseInputPin::CheckStreaming</B>.

<P>This base class member function checks to see if the format has changed with
this media sample; if so, it checks that the filter will accept it, generating a
run-time error if not. If a run-time error is raised, the <A HREF="CBasePin.htm#CBasePin::m_bRunTimeError">m_bRunTimeError</A>
data member is set so that no more samples will be accepted.

<P>The overriding member function does something with the passed-in sample,
such as calling a member function to transform it or pass it downstream.

<P>This is a blocking synchronous call. Typically no blocking occurs, but
if a filter cannot process the sample immediately, it can use the calling
application's thread to wait until it can.

<P>Call the <A HREF="../iface/IUnknown.htm#AddRef">IUnknown::AddRef</A> method if you must hold the returned data block
beyond the completion of the <A HREF="../iface/IMemInputPin.htm#Receive">IMemInputPin::Receive</A> method.
If you call <A HREF="../iface/IUnknown.htm#AddRef">AddRef</A>, be sure to call <A HREF="../iface/IUnknown.htm#Release">IUnknown::Release</A> when done with it.
</BLOCKQUOTE>


<H1><A NAME="ReceiveCanBlock">CBaseInputPin::ReceiveCanBlock</A><HR size=1></H1>
<A HREF="CBaseInputPin.htm">CBaseInputPin Class</A>
<P>Determines if the implementation of the <A HREF="../iface/IMemInputPin.htm#Receive">IMemInputPin::Receive</A> method might block on the connected output pin.

<P CLASS="ref">Syntax</P>
<BLOCKQUOTE><PRE>
<P><B>HRESULT</B> <B>ReceiveCanBlock</B><B>(</B><B>void</B><B>)</B><B>;</B>
</PRE></BLOCKQUOTE>
<P CLASS="ref">Return Value</P>
<BLOCKQUOTE>
<P>Returns an <A HREF="../Error_Success_Codes.htm#HRESULT">HRESULT</A> value, which can include one of the following values.
<TABLE>
<TR><TD>S_FALSE 
 </TD><TD>Input pin will not block on a <A HREF="../iface/IMemInputPin.htm#Receive">Receive</A> method.
</TD></TR><TR><TD>S_OK 
 </TD><TD>Input pin might block on a <A HREF="../iface/IMemInputPin.htm#Receive">Receive</A> method.
</TD></TR></TABLE>

</BLOCKQUOTE>

<P CLASS="ref">Remarks</P>
<BLOCKQUOTE>
<P>This member function implements the <A HREF="../iface/IMemInputPin.htm#ReceiveCanBlock">IMemInputPin::ReceiveCanBlock</A> method.
The base class implementation calls the <B>IMemInputPin::ReceiveCanBlock</B> method on
the input pin connected to each of the filter's output pins.

<P>This member function is useful because an output pin from a filter might require
notification if its thread might be blocked when it calls the <A HREF="../iface/IMemInputPin.htm#Receive">Receive</A> method on the 
connected input pin. For example, a <A CLASS="Glossary" HREF="javascript:Glossary(sRelPath + 'gloss/gloss_S.htm#source_filter')">source filter</A> might prefer to keep reading and buffering data 
rather than be blocked, and might choose to start another thread to wait on the blocking
<B>Receive</B> method. See the <A HREF="COutputQueue.htm">COutputQueue</A> 
base class for queuing samples to input pins that potentially block.
</BLOCKQUOTE>


<H1><A NAME="ReceiveMultiple">CBaseInputPin::ReceiveMultiple</A><HR size=1></H1>
<A HREF="CBaseInputPin.htm">CBaseInputPin Class</A>
<P>Retrieves the next block of data from the stream. This method behaves much like the
<A HREF="../iface/IMemInputPin.htm#Receive">IMemInputPin::Receive</A> method, but it works with multiple samples.
Override this function if you can usefully process samples in batches.

<P CLASS="ref">Syntax</P>
<BLOCKQUOTE><PRE>
<P><B>HRESULT</B> <B>ReceiveMultiple</B><B>(</B><BR>&nbsp;&nbsp;<B>IMediaSample</B> <B>**</B> <I>pSamples</I><B>,</B><BR>&nbsp;&nbsp;<B>long</B> <I>nSamples</I><B>,</B><BR>&nbsp;&nbsp;<B>long</B> <B>*</B> <I>nSamplesProcessed</I><BR>&nbsp;&nbsp;<B>)</B><B>;</B>
</PRE></BLOCKQUOTE>

<P CLASS="ref">Parameters</P>
<BLOCKQUOTE>
<DL><DT><I>pSamples</I>
</DT><DD>Pointer to an array of samples.
</DD><DT><I>nSamples</I>
</DT><DD>Number of samples to process.
</DD><DT><I>nSamplesProcessed</I>
</DT><DD>Number of samples processed.
</DD></DL>
</BLOCKQUOTE>

<P CLASS="ref">Return Value</P>
<BLOCKQUOTE>
<P>Returns an <A HREF="../Error_Success_Codes.htm#HRESULT">HRESULT</A> value.

</BLOCKQUOTE>

<P CLASS="ref">Remarks</P>
<BLOCKQUOTE>
<P>This member function implements the <A HREF="../iface/IMemInputPin.htm#ReceiveMultiple">IMemInputPin::ReceiveMultiple</A> method.
It is implemented to call the <A HREF="CBaseInputPin.htm#Receive">CBaseInputPin::Receive</A> member function in a loop
for <I>nSamples</I> number of iterations.

</BLOCKQUOTE>
<!-- CONTENTS_END -->

<!-- START_PAGE_FOOTER -->


<H6><HR size=1></H6>
<P><A Class="line" HREF="#pagetop"><IMG src="../../art/arrowup1.gif" WIDTH="11" HEIGHT="11" ALIGN="MIDDLE" BORDER=0 ALT="Top of Page">&nbsp;Top of Page</A>
<BR><A Class="line" HREF="../../../cpyright.htm">&#169; 1998 Microsoft Corporation. All rights reserved. Terms of Use.</A>
<!-- END_PAGE_FOOTER -->

</BLOCKQUOTE>

<SCRIPT>if((g_isIE == true) && (g_iMaj > 3)) {window.self.document.writeln('<SCR' + 'IPT SRC="../../tip2.js"></SCR' + 'IPT><IFRAME ID="G_L_S" NAME="SecretBuffer" STYLE="display: none" SRC=""></IFRAME>')}</SCRIPT>

<!-- DACONTROL_START -->

	<DIV ID="HeadGraphAnim"></DIV>
	<SCRIPT>if((g_isIE == true) && (g_iMaj > 3)) {window.self.document.writeln('<SCR' + 'IPT SRC="../../anim.js"></SCR' + 'IPT>')}</SCRIPT>
<!-- DACONTROL_END -->

</BODY>
</HTML>
