<!-- DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN" -->

<HTML>
<HEAD><TITLE>IPin Interface</TITLE>
<SCRIPT> var sRelPath = '../../' </SCRIPT>


<META NAME="Description" CONTENT="IPin Interface">
<META NAME="Description" CONTENT="IPin::BeginFlush">
<META NAME="Description" CONTENT="IPin::Connect">
<META NAME="Description" CONTENT="IPin::ConnectedTo">
<META NAME="Description" CONTENT="IPin::ConnectionMediaType">
<META NAME="Description" CONTENT="IPin::Disconnect">
<META NAME="Description" CONTENT="IPin::EndFlush">
<META NAME="Description" CONTENT="IPin::EndOfStream">
<META NAME="Description" CONTENT="IPin::EnumMediaTypes">
<META NAME="Description" CONTENT="IPin::NewSegment">
<META NAME="Description" CONTENT="IPin::QueryAccept">
<META NAME="Description" CONTENT="IPin::QueryDirection">
<META NAME="Description" CONTENT="IPin::QueryId">
<META NAME="Description" CONTENT="IPin::QueryInternalConnections">
<META NAME="Description" CONTENT="IPin::QueryPinInfo">
<META NAME="Description" CONTENT="IPin::ReceiveConnection">
<META NAME="Description" CONTENT="BeginFlush (IPin)">
<META NAME="Description" CONTENT="Connect (IPin)">
<META NAME="Description" CONTENT="ConnectedTo (IPin)">
<META NAME="Description" CONTENT="ConnectionMediaType (IPin)">
<META NAME="Description" CONTENT="Disconnect (IPin)">
<META NAME="Description" CONTENT="EndFlush (IPin)">
<META NAME="Description" CONTENT="EndOfStream (IPin)">
<META NAME="Description" CONTENT="EnumMediaTypes (IPin)">
<META NAME="Description" CONTENT="NewSegment (IPin)">
<META NAME="Description" CONTENT="QueryAccept (IPin)">
<META NAME="Description" CONTENT="QueryDirection (IPin)">
<META NAME="Description" CONTENT="QueryId (IPin)">
<META NAME="Description" CONTENT="QueryInternalConnections (IPin)">
<META NAME="Description" CONTENT="QueryPinInfo (IPin)">
<META NAME="Description" CONTENT="ReceiveConnection (IPin)">
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; CHARSET=iso8859-1">
<META NAME="MS.LOCALE" CONTENT="EN-US">
<META NAME="ROBOTS" CONTENT="all">

<!-- SNIFF_START -->

<SCRIPT>
//<!--
var g_isIE = false, g_isNav = false, g_iMaj = 0, g_sPlat = "";
// -->

</SCRIPT>
<SCRIPT SRC="../../ver.js"></SCRIPT>
<SCRIPT SRC="../../gloss.js"></SCRIPT>

<!-- SNIFF_END -->


<SCRIPT DEFER SRC="../../common.js"></SCRIPT>
<SCRIPT DEFER>
//<!--
function InitPage()
{
	if (g_isIE && g_iMaj >= 4)	
	{

		SetTOC();
	}
}
//-->

</SCRIPT>

<!-- SNIFF_END -->


<!-- STYLE_START -->

<SCRIPT>
//<!--
   var sVR = '../../'	// Set root for the style sheet
   var sCSS = '<LINK REL="stylesheet" HREF="' + sVR;

   if(g_isIE)
   {
	   if (g_iMaj >= 4) // For MSIE 4.0 or later
	   {
		   sCSS += 'dxm_basicsdkIE4';
		   if (g_sPlat == "Win") // Windows only for now
		   {
			   document.createStyleSheet(sVR + 'dxm_advSDKIE4.css');
		   }
	   }
	   else // For MSIE 3.0 or earlier
	   {
		   sCSS += 'dxm_basicsdkIE3';
	   }
   }
   else if (g_isNav) // For all Nav versions
   {
	   sCSS += 'dxm_basicsdkNAV';
   }
   else
   {
	   sCSS += 'dxm_basicsdkIE3'; // default to IE3 sheet
   }

   sCSS += (sCSS == '' ? '' : '.css" TYPE="text/css">');

   document.write(sCSS);
//-->

</SCRIPT>
<!-- STYLE_END -->


</HEAD>
<BODY onload="InitPage(); if (g_isIE && g_iMaj >= 4){HdgrphControl()}" BGCOLOR="#FFFFFF">
<A NAME="pagetop"></A><A NAME="IPin"></A>

<!-- HEADGRAPH_START -->

<TABLE CLASS="main" BORDER=0 CELLSPACING="0" CELLPADDING="0" WIDTH="*">
<TR>
<TD ROWSPAN="3" VALIGN="TOP" WIDTH="*">
<IMG SRC="../../art/header1.gif" WIDTH="107" HEIGHT="110" BORDER=0 ALT="DirectShow Animated Header"></TD>
<TD ROWSPAN="2" VALIGN="TOP" WIDTH="217"><IMG SRC="../../art/hdrdshow.gif" WIDTH="217" HEIGHT="110" BORDER=0 ALT="DirectShow Animated Header"></TD>
<TD VALIGN="TOP" WIDTH="383">
<IMG SRC="../../art/header3.gif" WIDTH="383" HEIGHT="95" BORDER=0 ALT="DirectShow Animated Header">
</TD>
<TD VALIGN="TOP" WIDTH="100%">
<IMG SRC="../../art/spacer1.gif" WIDTH="100%" HEIGHT="94" BORDER=0 ALT="Microsoft DirectShow SDK">
</TD>
</TR>
<!-- HEADGRAPH_END -->

<!-- NAV_LINKS_START -->

<TR><TD VALIGN="TOP"><PRE><IMG ID="TOC_" SRC="../../art/yelbtn.gif" WIDTH="11" HEIGHT="11" ALIGN="MIDDLE" BORDER=0 ALT="*"><A STYLE="color:black;font-weight:bold" ID="TOC" HREF="../../contents.htm">Contents</A>  <IMG SRC="../../art/yelbtn.gif" WIDTH="11" HEIGHT="11" ALIGN="MIDDLE" BORDER=0 ALT="*"><A STYLE="color:black;font-weight:bold" HREF="../../index.htm">Index</A>  <IMG SRC="../../art/yelbtn.gif" WIDTH="11" HEIGHT="11" ALIGN="MIDDLE" BORDER=0 ALT="*"><A STYLE="color:black;font-weight:bold" HREF="ifaces_intro.htm">Topic Contents</A>
</PRE></TD></TR>
<TR><TD COLSPAN="2" VALIGN="TOP"><PRE><IMG SRC="../../art/yelbtn.gif" WIDTH="11" HEIGHT="11" ALIGN="MIDDLE" BORDER=0 ALT="*"><B>Previous Topic:</B> <A STYLE="color:black" HREF="IOverlayNotify.htm">IOverlayNotify Interface</A>
<IMG SRC="../../art/yelbtn.gif" WIDTH="11" HEIGHT="11" ALIGN="MIDDLE" BORDER=0 ALT="*"><B>Next Topic:</B> <A  STYLE="color:black" HREF="IPinInfo.htm">IPinInfo Interface</A>
</PRE></TD></TR></TABLE>
<!-- NAV_LINKS_END -->


<BLOCKQUOTE CLASS="body">


<!-- CONTENTS_START -->

<H1>IPin Interface</H1>

<P>The <B>IPin</B> interface represents a single, unidirectional connection point on a
<A CLASS="Glossary" HREF="javascript:Glossary(sRelPath + 'gloss/gloss_f.htm#filter')">filter</A>. A <A CLASS="Glossary" HREF="javascript:Glossary(sRelPath + 'gloss/gloss_P.htm#pin')">pin</A> connects to exactly one other pin on another filter. Other objects can use this
interface on this pin. The interface between the filter and the pin is private to the implementation
of a specific filter.

<P>During the connection process, one pin takes the lead. The base classes assume that this is
the <A CLASS="Glossary" HREF="javascript:Glossary(sRelPath + 'gloss/gloss_O.htm#output_pin')">output pin</A> of the upstream connecting filter. The <A CLASS="Glossary" HREF="javascript:Glossary(sRelPath + 'gloss/gloss_F.htm#filter_graph_manager')">filter graph manager</A> calls the
<A HREF="IPin.htm#Connect">IPin::Connect</A> <A CLASS="Glossary" HREF="javascript:Glossary(sRelPath + 'gloss/gloss_M.htm#method')">method</A> on this pin's <B>IPin</B> interface, passing the <B>IPin</B>
pointer for the connecting pin. This connecting pin then calls the <A HREF="IPin.htm#ReceiveConnection">IPin::ReceiveConnection</A>
method located on the other pin, in addition to its format-enumeration, <A HREF="IUnknown.htm#QueryInterface">IUnknown::QueryInterface</A>,
and possibly <A HREF="IPin.htm#QueryAccept">IPin::QueryAccept</A> methods, to establish whether the connection is possible.

<P CLASS="ref"><A NAME="When_to_Implement">When to Implement</A></P>
<P>All filters must implement this interface on each of its pins. Which methods are implemented
depends on whether the pin is an <A CLASS="Glossary" HREF="javascript:Glossary(sRelPath + 'gloss/gloss_I.htm#input_pin')">input pin</A> or an output pin. Use the <A HREF="../class/CBasePin.htm#CBasePin">CBasePin</A>,
<A HREF="../class/CBaseInputPin.htm#CBaseInputPin">CBaseInputPin</A>, or <A HREF="../class/CBaseOutputPin.htm#CBaseOutputPin">CBaseOutputPin</A> class, or classes derived
from these classes, to implement this interface.

<P CLASS="ref"><A NAME="When_to_Use">When to Use</A></P>
<P>This interface is used by other connecting pins and by the filter graph manager. Applications
should not use this interface directly but should go through the filter graph manager. Connecting
pins use the <A HREF="IPin.htm">IPin</A> interface on the opposite pin to negotiate a common media type and
an agreed allocator to use for passing samples.

<P CLASS="ref"><A NAME="Methods_in_Vtable_Or">Methods in Vtable Order</A></P>
<TABLE>
<TR><TH>IUnknown methods</TH><TH>Description</TH></TR><TR><TD><A HREF="IUnknown.htm#QueryInterface">QueryInterface</A> </TD><TD>Returns pointers to supported interfaces.
</TD></TR><TR><TD><A HREF="IUnknown.htm#AddRef">AddRef</A> </TD><TD>Increments the reference count.
</TD></TR><TR><TD><A HREF="IUnknown.htm#Release">Release</A> </TD><TD>Decrements the reference count.
</TD></TR><TR></TR>
<TR><TH>IPin methods</TH><TH>Description</TH></TR><TR><TD><A HREF="IPin.htm#Connect">Connect</A>
</TD><TD>Makes a connection to another pin.
</TD></TR><TR><TD><A HREF="IPin.htm#ReceiveConnection">ReceiveConnection</A>
</TD><TD>Makes a connection to this pin and is called by a connecting pin.
</TD></TR><TR><TD><A HREF="IPin.htm#Disconnect">Disconnect</A>
</TD><TD>Breaks a connection.
</TD></TR><TR><TD><A HREF="IPin.htm#ConnectedTo">ConnectedTo</A>
</TD><TD>Returns a pointer to the connecting pin.
</TD></TR><TR><TD><A HREF="IPin.htm#ConnectionMediaType">ConnectionMediaType</A>
</TD><TD>Returns the media type of this pin's connection.
</TD></TR><TR><TD><A HREF="IPin.htm#QueryPinInfo">QueryPinInfo</A>
</TD><TD>Retrieves information about this pin (for example, the name, owning filter, and direction).
</TD></TR><TR><TD><A HREF="IPin.htm#QueryId">QueryId</A>
</TD><TD>Retrieves an identifier for the pin.
</TD></TR><TR><TD><A HREF="IPin.htm#QueryAccept">QueryAccept</A>
</TD><TD>Queries whether a given media type is acceptable by the pin.
</TD></TR><TR><TD><A HREF="IPin.htm#EnumMediaTypes">EnumMediaTypes</A>
</TD><TD>Provides an enumerator for this pin's preferred media types.
</TD></TR><TR><TD><A HREF="IPin.htm#QueryInternalConnections">QueryInternalConnections</A>
</TD><TD>Provides an array of the pins to which this pin internally connects.
</TD></TR><TR><TD><A HREF="IPin.htm#EndOfStream">EndOfStream</A>
</TD><TD>Informs the pin that no additional data is expected until a new run command is issued.
</TD></TR><TR><TD><A HREF="IPin.htm#BeginFlush">BeginFlush</A>
</TD><TD>Informs the pin to begin a flush operation.
</TD></TR><TR><TD><A HREF="IPin.htm#EndFlush">EndFlush</A>
</TD><TD>Informs the pin to end a flush operation.
</TD></TR><TR><TD><A HREF="IPin.htm#NewSegment">NewSegment</A>
</TD><TD>Specifies that samples following this call are grouped as a segment with a given
start time, stop time, and rate.
</TD></TR><TR><TD><A HREF="IPin.htm#QueryDirection">QueryDirection</A>
</TD><TD>Retrieves the direction for this pin.
</TD></TR></TABLE>



<H1><A NAME="BeginFlush">IPin::BeginFlush</A><HR size=1></H1>
<A HREF="IPin.htm">IPin Interface</A>
<P>Informs the pin to begin a flush operation.

<P CLASS="ref">Syntax</P><BLOCKQUOTE><PRE>
<P><B>HRESULT</B> <B>BeginFlush</B><B>(</B><B>void</B><B>)</B><B>;</B></PRE></BLOCKQUOTE>

<P CLASS="ref">Return Value</P>
<BLOCKQUOTE>
<P>Returns an <A HREF="../Error_Success_Codes.htm#HRESULT">HRESULT</A> value that depends on the implementation. <B>HRESULT</B> can be one of the following standard constants, or other values not listed.
<TABLE>
<TR><TD>E_FAIL </TD><TD>Failure.
</TD></TR><TR><TD>E_POINTER </TD><TD>Null pointer argument.
</TD></TR><TR><TD>E_INVALIDARG </TD><TD>Invalid argument.
</TD></TR><TR><TD>E_NOTIMPL </TD><TD>Method isn't supported.
</TD></TR><TR><TD>S_OK or NOERROR </TD><TD>Success.
</TD></TR></TABLE>


</BLOCKQUOTE>
<P CLASS="ref">Remarks</P>


<BLOCKQUOTE>

<P>When this method is called, the pin is entering flush state. In this case, carry out the
following steps.

<OL><LI>Set a flushing flag to prevent any more <A HREF="IMemInputPin.htm#Receive">IMemInputPin::Receive</A> methods
from succeeding.
<LI>Discard any queued data.
<LI>Free the pin if it was blocked by the <A HREF="IMemInputPin.htm#Receive">Receive</A> method,
if possible.
<LI>Pass the <B>IPin::BeginFlush</B> method to any downstream pins.
</OL>
<P>The <B>BeginFlush</B> notification is passed downstream until it
reaches the <A CLASS="Glossary" HREF="javascript:Glossary(sRelPath + 'gloss/gloss_R.htm#renderer')">renderer</A>, which must free any sample it holds. This
unblocks other pins (usually in the <A HREF="IMemAllocator.htm#GetBuffer">IMemAllocator::GetBuffer</A> or
<A HREF="IMemInputPin.htm#Receive">IMemInputPin::Receive</A> methods).

<P>After <B>BeginFlush</B> is called, all samples passed by the
<A HREF="IMemInputPin.htm#Receive">Receive</A> method to the pin, or on another <A CLASS="Glossary" HREF="javascript:Glossary(sRelPath + 'gloss/gloss_T.htm#transport')">transport</A>,
are rejected with S_FALSE until the <A HREF="IPin.htm#EndFlush">IPin::EndFlush</A> method is called.

<P>This method is implemented in the base classes by <A HREF="../class/CBaseInputPin.htm#BeginFlush">CBaseInputPin::BeginFlush</A>.
</BLOCKQUOTE>


<H1><A NAME="Connect">IPin::Connect</A><HR size=1></H1>
<A HREF="IPin.htm">IPin Interface</A>
<P>Initiates a connection from this pin to the other pin.

<P CLASS="ref">Syntax</P><BLOCKQUOTE><PRE>
<P><B>HRESULT</B> <B>Connect</B><B>(</B><BR>&nbsp;&nbsp;<B>IPin</B> <B>*</B> <I>pReceivePin</I><B>,</B><BR>&nbsp;&nbsp;<B>const</B> <B>AM_MEDIA_TYPE</B> <B>*</B> <I>pmt</I><BR>&nbsp;&nbsp;<B>)</B><B>;</B></PRE></BLOCKQUOTE>

<P CLASS="ref">Parameters</P>
<BLOCKQUOTE>
<DL><DT><I>pReceivePin</I>
 </DT><DD>[in] Other pin to connect to.
</DD><DT><I>pmt</I>
 </DT><DD>[in] Type to use for the connections (optional).
</DD></DL>

</BLOCKQUOTE>
<P CLASS="ref">Return Value</P>
<BLOCKQUOTE>
<P>Returns an <A HREF="../Error_Success_Codes.htm#HRESULT">HRESULT</A> value that depends on the implementation. <B>HRESULT</B> can be one of the following standard constants, or other values not listed.
<TABLE>
<TR><TD>E_FAIL </TD><TD>Failure.
</TD></TR><TR><TD>E_POINTER </TD><TD>Null pointer argument.
</TD></TR><TR><TD>E_INVALIDARG </TD><TD>Invalid argument.
</TD></TR><TR><TD>E_NOTIMPL </TD><TD>Method isn't supported.
</TD></TR><TR><TD>S_OK or NOERROR </TD><TD>Success.
</TD></TR></TABLE>


</BLOCKQUOTE>
<P CLASS="ref">Remarks</P>


<BLOCKQUOTE>

<P>This method calls the <A HREF="IPin.htm#ReceiveConnection">IPin::ReceiveConnection</A> method for the other pin.
The <B>IPin::Connect</B> method verifies that the connection is
possible and might reject it. This pin proposes a media type to the other pin.

<P>This method is implemented in the base classes by <A HREF="../class/CBasePin.htm#Connect">CBasePin::Connect</A>.

<P>Applications should not use this method. Instead, use <A HREF="IFilterGraph.htm#ConnectDirect">IFilterGraph::ConnectDirect</A>,
which will use this method. Changing connections underneath the filter graph manager
can cause commands to be distributed incorrectly and can cause a deadlock.
</BLOCKQUOTE>


<H1><A NAME="ConnectedTo">IPin::ConnectedTo</A><HR size=1></H1>
<A HREF="IPin.htm">IPin Interface</A>
<P>If this pin is connected to another pin, the <B>IPin::ConnectedTo</B> method
returns a pointer to that pin.

<P CLASS="ref">Syntax</P><BLOCKQUOTE><PRE>
<P><B>HRESULT</B> <B>ConnectedTo</B><B>(</B><BR>&nbsp;&nbsp;<B>IPin</B> <B>**</B> <I>ppPin</I><BR>&nbsp;&nbsp;<B>)</B><B>;</B></PRE></BLOCKQUOTE>

<P CLASS="ref">Parameters</P>
<BLOCKQUOTE>
<DL><DT><I>ppPin</I>
</DT><DD>[out] Pointer to an <A HREF="IPin.htm">IPin</A> pointer to the <B>IPin</B> interface of the other pin
(if any) to which this pin is connected. If there is no connection, the other pin interface pointer will be NULL.
</DD></DL>

</BLOCKQUOTE>
<P CLASS="ref">Return Value</P>
<BLOCKQUOTE>
<P>Returns an <A HREF="../Error_Success_Codes.htm#HRESULT">HRESULT</A> value that depends on the implementation. <B>HRESULT</B> can be one of the following standard constants, or other values not listed.
<TABLE>
<TR><TD>E_FAIL </TD><TD>Failure.
</TD></TR><TR><TD>E_POINTER </TD><TD>Null pointer argument.
</TD></TR><TR><TD>E_INVALIDARG </TD><TD>Invalid argument.
</TD></TR><TR><TD>E_NOTIMPL </TD><TD>Method isn't supported.
</TD></TR><TR><TD>S_OK or NOERROR </TD><TD>Success.
</TD></TR></TABLE>


</BLOCKQUOTE>
<P CLASS="ref">Remarks</P>


<BLOCKQUOTE>

<P>This method is implemented in the base classes by <A HREF="../class/CBasePin.htm#ConnectedTo">CBasePin::ConnectedTo</A>.
The interface returned by this method has had its reference count
incremented. Be sure to use <A HREF="IUnknown.htm#Release">IUnknown::Release</A> on the interface
to decrement the reference count when you have finished using the interface.
</BLOCKQUOTE>


<H1><A NAME="ConnectionMediaType">IPin::ConnectionMediaType</A><HR size=1></H1>
<A HREF="IPin.htm">IPin Interface</A>
<P>Determines the media type associated with the current connection of the pin.
This method fails if the pin is unconnected.

<P CLASS="ref">Syntax</P><BLOCKQUOTE><PRE>
<P><B>HRESULT</B> <B>ConnectionMediaType</B><B>(</B><BR>&nbsp;&nbsp;<B>AM_MEDIA_TYPE</B> <I>*pmt</I><BR>&nbsp;&nbsp;<B>)</B><B>;</B></PRE></BLOCKQUOTE>

<P CLASS="ref">Parameters</P>
<BLOCKQUOTE>
<DL><DT><I>pmt</I>
</DT><DD>[out] Pointer to an <A HREF="../structs.htm#AM_MEDIA_TYPE">AM_MEDIA_TYPE</A> structure. If the pin is connected,
the media type is returned. Otherwise, the structure is initialized to a default
state in which all elements are 0, with the exception of <I>lSampleSize</I>, which
is set to 1, and <I>bFixedSizeSamples</I>, which is set to TRUE.
</DD></DL>

</BLOCKQUOTE>
<P CLASS="ref">Return Value</P>
<BLOCKQUOTE>
<P>Returns an <A HREF="../Error_Success_Codes.htm#HRESULT">HRESULT</A> value that depends on the implementation. <B>HRESULT</B> can be one of the following standard constants, or other values not listed.
<TABLE>
<TR><TD>E_FAIL </TD><TD>Failure.
</TD></TR><TR><TD>E_POINTER </TD><TD>Null pointer argument.
</TD></TR><TR><TD>E_INVALIDARG </TD><TD>Invalid argument.
</TD></TR><TR><TD>E_NOTIMPL </TD><TD>Method isn't supported.
</TD></TR><TR><TD>S_OK or NOERROR </TD><TD>Success.
</TD></TR></TABLE>


</BLOCKQUOTE>
<P CLASS="ref">Remarks</P>


<BLOCKQUOTE>

<P>The returned structure can contain an allocated format block
and a reference-counted <A HREF="IUnknown.htm">IUnknown</A> interface pointer. These
resources should be released by calling the <A HREF="../utilfunct/Media_Type_functs.htm#FreeMediaType">FreeMediaType</A> utility function.

<P>This method is implemented in the base classes by <A HREF="../class/CBasePin.htm#ConnectionMediaType">CBasePin::ConnectionMediaType</A>.
</BLOCKQUOTE>


<H1><A NAME="Disconnect">IPin::Disconnect</A><HR size=1></H1>
<A HREF="IPin.htm">IPin Interface</A>
<P>Breaks a connection.

<P CLASS="ref">Syntax</P><BLOCKQUOTE><PRE>
<P><B>HRESULT</B> <B>Disconnect</B><B>(</B><B>void</B><B>)</B><B>;</B></PRE></BLOCKQUOTE>
<P CLASS="ref">Return Value</P>
<BLOCKQUOTE>
<P>Returns NOERROR if there is no connection.


</BLOCKQUOTE>
<P CLASS="ref">Remarks</P>


<BLOCKQUOTE>

<P>There are no parameters because there is only one possible connection on this pin.

<P>This method is implemented in the base classes by <A HREF="../class/CBasePin.htm#Disconnect">CBasePin::Disconnect</A>.

<P>A pin should never use this method to disconnect from its peer.
An application should not use this method. Use <A HREF="IFilterGraph.htm#Disconnect">IFilterGraph::Disconnect</A> instead.
</BLOCKQUOTE>


<H1><A NAME="EndFlush">IPin::EndFlush</A><HR size=1></H1>
<A HREF="IPin.htm">IPin Interface</A>
<P>Informs the pin to end a flush operation.

<P CLASS="ref">Syntax</P><BLOCKQUOTE><PRE>
<P><B>HRESULT</B> <B>EndFlush</B><B>(</B><B>void</B><B>)</B><B>;</B></PRE></BLOCKQUOTE>
<P CLASS="ref">Return Value</P>
<BLOCKQUOTE>
<P>Returns an <A HREF="../Error_Success_Codes.htm#HRESULT">HRESULT</A> value that depends on the implementation. <B>HRESULT</B> can be one of the following standard constants, or other values not listed.
<TABLE>
<TR><TD>E_FAIL </TD><TD>Failure.
</TD></TR><TR><TD>E_POINTER </TD><TD>Null pointer argument.
</TD></TR><TR><TD>E_INVALIDARG </TD><TD>Invalid argument.
</TD></TR><TR><TD>E_NOTIMPL </TD><TD>Method isn't supported.
</TD></TR><TR><TD>S_OK or NOERROR </TD><TD>Success.
</TD></TR></TABLE>


</BLOCKQUOTE>
<P CLASS="ref">Remarks</P>


<BLOCKQUOTE>

<P>When this method is called, the pin is beginning to end a flush operation.
It should perform the following steps.

<OL><LI>Ensure that your filter will not push any additional data. (To do this, synchronize with
a thread, stop it pushing, and discard any queued data.)
<LI>Reenable the <A HREF="IMemInputPin.htm#Receive">IMemInputPin::Receive</A> method by
clearing the internal flushing flag.
<LI>Pass the <B>EndFlush</B> method downstream by calling the method
on the connecting input pin.
</OL>
<P>This method is implemented in the base classes by <A HREF="../class/CBaseInputPin.htm#EndFlush">CBaseInputPin::EndFlush</A>.
</BLOCKQUOTE>


<H1><A NAME="EndOfStream">IPin::EndOfStream</A><HR size=1></H1>
<A HREF="IPin.htm">IPin Interface</A>
<P>Informs the input pin that no additional data is expected until a new run command is issued.

<P CLASS="ref">Syntax</P><BLOCKQUOTE><PRE>
<P><B>HRESULT</B> <B>EndOfStream</B><B>(</B><B>void</B><B>)</B><B>;</B></PRE></BLOCKQUOTE>
<P CLASS="ref">Return Value</P>
<BLOCKQUOTE>
<P>Returns one of the following <A HREF="../Error_Success_Codes.htm#HRESULT">HRESULT</A> values.

<TABLE>
<TR><TD>S_OK </TD><TD>No error occurred.
</TD></TR><TR><TD>E_UNEXPECTED </TD><TD>Method was probably called on an output pin
that does not support this.
</TD></TR></TABLE>


</BLOCKQUOTE>
<P CLASS="ref">Remarks</P>


<BLOCKQUOTE>

<P>Calling this method notifies the pin that no additional data is expected until a new run
command is issued. The end-of-stream notification should be queued and delivered after
all queued data is delivered. It can be delivered immediately if there is no queued data.

<P>The <A HREF="IPin.htm#BeginFlush">IPin::BeginFlush</A> method flushes any queued end-of-stream notifications.
This is intended for input pins only.

<P>This method is implemented in the base classes by <A HREF="../class/CBaseOutputPin.htm#EndOfStream">CBaseOutputPin::EndOfStream</A>.
</BLOCKQUOTE>


<H1><A NAME="EnumMediaTypes">IPin::EnumMediaTypes</A><HR size=1></H1>
<A HREF="IPin.htm">IPin Interface</A>
<P>Provides an enumerator for this pin's preferred media types.

<P CLASS="ref">Syntax</P><BLOCKQUOTE><PRE>
<P><B>HRESULT</B> <B>EnumMediaTypes</B><B>(</B><BR>&nbsp;&nbsp;<B>IEnumMediaTypes</B> <B>**</B> <I>ppEnum</I><BR>&nbsp;&nbsp;<B>)</B><B>;</B></PRE></BLOCKQUOTE>

<P CLASS="ref">Parameters</P>
<BLOCKQUOTE>
<DL><DT><I>ppEnum</I>
</DT><DD>[out] Pointer to an enumerator for the media types.
</DD></DL>

</BLOCKQUOTE>
<P CLASS="ref">Return Value</P>
<BLOCKQUOTE>
<P>Returns an <A HREF="../Error_Success_Codes.htm#HRESULT">HRESULT</A> value that depends on the implementation. <B>HRESULT</B> can be one of the following standard constants, or other values not listed.
<TABLE>
<TR><TD>E_FAIL </TD><TD>Failure.
</TD></TR><TR><TD>E_POINTER </TD><TD>Null pointer argument.
</TD></TR><TR><TD>E_INVALIDARG </TD><TD>Invalid argument.
</TD></TR><TR><TD>E_NOTIMPL </TD><TD>Method isn't supported.
</TD></TR><TR><TD>S_OK or NOERROR </TD><TD>Success.
</TD></TR></TABLE>


</BLOCKQUOTE>
<P CLASS="ref">Remarks</P>


<BLOCKQUOTE>

<P>If an enumerator is received, it must be released when the operation is finished.

<P>This method is implemented in the base classes by <A HREF="../class/CBasePin.htm#EnumMediaTypes">CBasePin::EnumMediaTypes</A>.

</BLOCKQUOTE>


<H1><A NAME="NewSegment">IPin::NewSegment</A><HR size=1></H1>
<A HREF="IPin.htm">IPin Interface</A>
<P>Specifies that samples following this method are grouped as a segment with a
given start time, stop time, and rate.

<P CLASS="ref">Syntax</P><BLOCKQUOTE><PRE>
<P><B>HRESULT</B> <B>NewSegment</B><B>(</B><BR>&nbsp;&nbsp;<B>REFERENCE_TIME</B> <I>tStart</I><B>,</B><BR>&nbsp;&nbsp;<B>REFERENCE_TIME</B> <I>tStop</I><B>,</B><BR>&nbsp;&nbsp;<B>double</B> <I>dRate</I><BR>&nbsp;&nbsp;<B>)</B><B>;</B></PRE></BLOCKQUOTE>

<P CLASS="ref">Parameters</P>
<BLOCKQUOTE>
<DL><DT><I>tStart</I>
</DT><DD>[in] Start time of the segment.
</DD><DT><I>tStop</I>
</DT><DD>[in] Stop time of the segment.
</DD><DT><I>dRate</I>
</DT><DD>[in] Rate of the segment.
</DD></DL>

</BLOCKQUOTE>
<P CLASS="ref">Return Value</P>
<BLOCKQUOTE>
<P>Returns an <A HREF="../Error_Success_Codes.htm#HRESULT">HRESULT</A> value that depends on the implementation. <B>HRESULT</B> can be one of the following standard constants, or other values not listed.
<TABLE>
<TR><TD>E_FAIL </TD><TD>Failure.
</TD></TR><TR><TD>E_POINTER </TD><TD>Null pointer argument.
</TD></TR><TR><TD>E_INVALIDARG </TD><TD>Invalid argument.
</TD></TR><TR><TD>E_NOTIMPL </TD><TD>Method isn't supported.
</TD></TR><TR><TD>S_OK or NOERROR </TD><TD>Success.
</TD></TR></TABLE>


</BLOCKQUOTE>
<P CLASS="ref">Remarks</P>


<BLOCKQUOTE>

<P>This method enables filters that process buffers containing more than
one sample to delineate the rendering of the samples between start and
stop time, as indicated by the <I>tStart</I> and <I>tStop</I> parameters.

<P>This method is intended to be implemented on an input pin. A connected output pin
on the <A CLASS="Glossary" HREF="javascript:Glossary(sRelPath + 'gloss/gloss_U.htm#upstream_filter')">upstream filter</A> calls this method after completing delivery of
previous data and before calling <A HREF="IMemInputPin.htm#Receive">IMemInputPin::Receive</A> with any new data. It indicates
that all data arriving after this call is part of a segment delineated by the parameters.
</BLOCKQUOTE>


<H1><A NAME="QueryAccept">IPin::QueryAccept</A><HR size=1></H1>
<A HREF="IPin.htm">IPin Interface</A>
<P>Determines if the pin could accept the <A CLASS="Glossary" HREF="javascript:Glossary(sRelPath + 'gloss/gloss_F.htm#format_type')">format type</A>.

<P CLASS="ref">Syntax</P><BLOCKQUOTE><PRE>
<P><B>HRESULT</B> <B>QueryAccept</B><B>(</B><BR>&nbsp;&nbsp;<B>const</B> <B>AM_MEDIA_TYPE</B> <B>*</B> <I>pmt</I><BR>&nbsp;&nbsp;<B>)</B><B>;</B></PRE></BLOCKQUOTE>

<P CLASS="ref">Parameters</P>
<BLOCKQUOTE>
<DL><DT><I>pmt</I>
</DT><DD>[in] Pointer to a proposed media type.
</DD></DL>

</BLOCKQUOTE>
<P CLASS="ref">Return Value</P>
<BLOCKQUOTE>
<P>Returns S_OK if the format is acceptable; otherwise, returns
S_FALSE.


</BLOCKQUOTE>
<P CLASS="ref">Remarks</P>


<BLOCKQUOTE>

<P>This method is implemented in the base classes by
<A HREF="../class/CBasePin.htm#QueryAccept">CBasePin::QueryAccept</A>.
</BLOCKQUOTE>


<H1><A NAME="QueryDirection">IPin::QueryDirection</A><HR size=1></H1>
<A HREF="IPin.htm">IPin Interface</A>
<P>Retrieves the direction for this pin.

<P CLASS="ref">Syntax</P><BLOCKQUOTE><PRE>
<P><B>HRESULT</B> <B>QueryDirection</B><B>(</B><BR>&nbsp;&nbsp;<B>PIN_DIRECTION</B> <B>*</B> <I>pPinDir</I><BR>&nbsp;&nbsp;<B>)</B><B>;</B></PRE></BLOCKQUOTE>

<P CLASS="ref">Parameters</P>
<BLOCKQUOTE>
<DL><DT><I>pPinDir</I>
</DT><DD>[out] Pointer to a <A HREF="../dtypes.htm#PIN_DIRECTION">PIN_DIRECTION</A> variable.
</DD></DL>

</BLOCKQUOTE>
<P CLASS="ref">Return Value</P>
<BLOCKQUOTE>
<P>Returns an <A HREF="../Error_Success_Codes.htm#HRESULT">HRESULT</A> value that depends on the implementation. <B>HRESULT</B> can be one of the following standard constants, or other values not listed.
<TABLE>
<TR><TD>E_FAIL </TD><TD>Failure.
</TD></TR><TR><TD>E_POINTER </TD><TD>Null pointer argument.
</TD></TR><TR><TD>E_INVALIDARG </TD><TD>Invalid argument.
</TD></TR><TR><TD>E_NOTIMPL </TD><TD>Method isn't supported.
</TD></TR><TR><TD>S_OK or NOERROR </TD><TD>Success.
</TD></TR></TABLE>


</BLOCKQUOTE>
<P CLASS="ref">Remarks</P>


<BLOCKQUOTE>

<P>The returned <I>pPinDir</I> parameter will contain PINDIR_INPUT
if the pin is an input pin or PINDIR_OUTPUT otherwise.
The same information is available by using <A HREF="IPin.htm#QueryPinInfo">IPin::QueryPinInfo</A>, but this
method is more direct and more efficient.
</BLOCKQUOTE>


<H1><A NAME="QueryId">IPin::QueryId</A><HR size=1></H1>
<A HREF="IPin.htm">IPin Interface</A>
<P>Retrieves an identifier for the pin.

<P CLASS="ref">Syntax</P><BLOCKQUOTE><PRE>
<P><B>HRESULT</B> <B>QueryId</B><B>(</B><BR>&nbsp;&nbsp;<B>LPWSTR</B> <B>*</B> <I>Id</I><BR>&nbsp;&nbsp;<B>)</B><B>;</B></PRE></BLOCKQUOTE>

<P CLASS="ref">Parameters</P>
<BLOCKQUOTE>
<DL><DT><I>Id</I>
</DT><DD>[out] Pin identifier.
</DD></DL>

</BLOCKQUOTE>
<P CLASS="ref">Return Value</P>
<BLOCKQUOTE>
<P>Returns an <A HREF="../Error_Success_Codes.htm#HRESULT">HRESULT</A> value that depends on the implementation. <B>HRESULT</B> can be one of the following standard constants, or other values not listed.
<TABLE>
<TR><TD>E_FAIL </TD><TD>Failure.
</TD></TR><TR><TD>E_POINTER </TD><TD>Null pointer argument.
</TD></TR><TR><TD>E_INVALIDARG </TD><TD>Invalid argument.
</TD></TR><TR><TD>E_NOTIMPL </TD><TD>Method isn't supported.
</TD></TR><TR><TD>S_OK or NOERROR </TD><TD>Success.
</TD></TR></TABLE>


</BLOCKQUOTE>
<P CLASS="ref">Remarks</P>


<BLOCKQUOTE>

<P>This method and the <A HREF="IBaseFilter.htm#FindPin">IBaseFilter::FindPin</A> method allow connections in a <A CLASS="Glossary" HREF="javascript:Glossary(sRelPath + 'gloss/gloss_F.htm#filter_graph')">filter graph</A> to be saved and restored. Because pins are identified only by their <A HREF="IPin.htm">IPin</A> interface
pointers at <A CLASS="Glossary" HREF="javascript:Glossary(sRelPath + 'gloss/gloss_R.htm#run_time')">run time</A>, and pointer information cannot be reliably saved,
an identifier is necessary to specify which pins belong to each filter.
The implementation of this method by the pin provides a unique
name that the filter graph manager can use to turn into an <B>IPin</B> interface pointer,
by calling <B>IBaseFilter::FindPin</B> when the filter graph is restored.

<P>The storage is allocated by the filter using the Microsoft&#174; Win32&#174; <A HREF="../../appendixes/Further_Reading.htm#CoTaskMemAlloc">CoTaskMemAlloc</A>
function. The caller should free it by using <A HREF="../../appendixes/Further_Reading.htm#CoTaskMemFree">CoTaskMemFree</A>.

<P>This method is implemented in the base classes by <A HREF="../class/CBasePin.htm#QueryId">CBasePin::QueryId</A>.
</BLOCKQUOTE>


<H1><A NAME="QueryInternalConnections">IPin::QueryInternalConnections</A><HR size=1></H1>
<A HREF="IPin.htm">IPin Interface</A>
<P>Provides an array of pointers to the <A HREF="IPin.htm">IPin</A> interface of the pins to which
this pin internally connects.

<P CLASS="ref">Syntax</P><BLOCKQUOTE><PRE>
<P><B>HRESULT</B> <B>QueryInternalConnections</B><B>(</B><BR>&nbsp;&nbsp;<B>IPin</B> <B>**</B> <I>apPin</I><B>,</B><BR>&nbsp;&nbsp;<B>ULONG</B> <B>*</B> <I>nPin</I><BR>&nbsp;&nbsp;<B>)</B><B>;</B></PRE></BLOCKQUOTE>

<P CLASS="ref">Parameters</P>
<BLOCKQUOTE>
<DL><DT><I>apPin</I>
</DT><DD>[out] Array of <A HREF="IPin.htm">IPin</A> pointers.
</DD><DT><I>nPin</I>
</DT><DD>[out] Upon input, indicates the number of array elements; upon output,
indicates the number of pins.
</DD></DL>

</BLOCKQUOTE>
<P CLASS="ref">Return Value</P>
<BLOCKQUOTE>
<P>Returns one of the following <A HREF="../Error_Success_Codes.htm#HRESULT">HRESULT</A> values.

<TABLE>
<TR><TD>E_FAIL</TD><TD>Undetermined.
</TD></TR><TR><TD>S_FALSE </TD><TD>Insufficient number of array elements to return all the results,
 in which case no pins are returned in the <I>apPin</I> array.
</TD></TR><TR><TD>E_NOTIMPL </TD><TD>Filter graph manager interprets E_NOTIMPL as meaning that
 any input pin connects to all visible output pins, and vice versa.
</TD></TR></TABLE>


</BLOCKQUOTE>
<P CLASS="ref">Remarks</P>


<BLOCKQUOTE>

<P>All pins put in the array are added by the <A HREF="IUnknown.htm#AddRef">IUnknown::AddRef</A> method. The
<I>apPin</I> parameter can be NULL if the <I>nPin</I> parameter equals zero.
This allows the calling application to determine the number of required arrays.

<P>This method is implemented in the base classes by
<A HREF="../class/CBasePin.htm#QueryInternalConnections">CBasePin::QueryInternalConnections</A>.
</BLOCKQUOTE>


<H1><A NAME="QueryPinInfo">IPin::QueryPinInfo</A><HR size=1></H1>
<A HREF="IPin.htm">IPin Interface</A>
<P>Retrieves information about the pin.

<P CLASS="ref">Syntax</P><BLOCKQUOTE><PRE>
<P><B>HRESULT</B> <B>QueryPinInfo</B><B>(</B><BR>&nbsp;&nbsp;<B>PIN_INFO</B> <B>*</B> <I>pInfo</I><BR>&nbsp;&nbsp;<B>)</B><B>;</B></PRE></BLOCKQUOTE>

<P CLASS="ref">Parameters</P>
<BLOCKQUOTE>
<DL><DT><I>pInfo</I>
</DT><DD>[out] Pointer to a <A HREF="../structs.htm#PIN_INFO">PIN_INFO</A> structure that specifies the name of the pin,
a pointer to an <A HREF="IBaseFilter.htm">IBaseFilter</A> interface on its owning filter, and the direction of the pin.
</DD></DL>

</BLOCKQUOTE>
<P CLASS="ref">Return Value</P>
<BLOCKQUOTE>
<P>Returns an <A HREF="../Error_Success_Codes.htm#HRESULT">HRESULT</A> value that depends on the implementation. <B>HRESULT</B> can be one of the following standard constants, or other values not listed.
<TABLE>
<TR><TD>E_FAIL </TD><TD>Failure.
</TD></TR><TR><TD>E_POINTER </TD><TD>Null pointer argument.
</TD></TR><TR><TD>E_INVALIDARG </TD><TD>Invalid argument.
</TD></TR><TR><TD>E_NOTIMPL </TD><TD>Method isn't supported.
</TD></TR><TR><TD>S_OK or NOERROR </TD><TD>Success.
</TD></TR></TABLE>


</BLOCKQUOTE>
<P CLASS="ref">Remarks</P>


<BLOCKQUOTE>

<P>Unlike the pin name in the <A HREF="IPin.htm#QueryId">IPin::QueryId</A> method,
which is used by the filter graph manager, the name in the <A HREF="../structs.htm#PIN_INFO">PIN_INFO</A> structure is
intended to be read by users.

<P>On return, the <A HREF="../structs.htm#pFilter">pFilter</A> member of <A HREF="../structs.htm#PIN_INFO">PIN_INFO</A>
has an outstanding reference count if it is non-NULL, and therefore
should be released when the interface is no longer needed.
</BLOCKQUOTE>


<H1><A NAME="ReceiveConnection">IPin::ReceiveConnection</A><HR size=1></H1>
<A HREF="IPin.htm">IPin Interface</A>
<P>Makes a connection to the calling pin.

<P CLASS="ref">Syntax</P><BLOCKQUOTE><PRE>
<P><B>HRESULT</B> <B>ReceiveConnection</B><B>(</B><BR>&nbsp;&nbsp;<B>IPin</B> <B>*</B> <I>pConnector</I><B>,</B><BR>&nbsp;&nbsp;<B>AM_MEDIA_TYPE</B> <I>*pmt</I><BR>&nbsp;&nbsp;<B>)</B><B>;</B></PRE></BLOCKQUOTE>

<P CLASS="ref">Parameters</P>
<BLOCKQUOTE>
<DL><DT><I>pConnector</I>
 </DT><DD>[in] Connecting pin.
</DD><DT><I>pmt</I>
 </DT><DD>[in] Media type of the samples to be streamed.
</DD></DL>

</BLOCKQUOTE>
<P CLASS="ref">Return Value</P>
<BLOCKQUOTE>
<P>Returns an <A HREF="../Error_Success_Codes.htm#HRESULT">HRESULT</A> value that depends on the implementation. <B>HRESULT</B> can be one of the following standard constants, or other values not listed.
<TABLE>
<TR><TD>E_FAIL </TD><TD>Failure.
</TD></TR><TR><TD>E_POINTER </TD><TD>Null pointer argument.
</TD></TR><TR><TD>E_INVALIDARG </TD><TD>Invalid argument.
</TD></TR><TR><TD>E_NOTIMPL </TD><TD>Method isn't supported.
</TD></TR><TR><TD>S_OK or NOERROR </TD><TD>Success.
</TD></TR></TABLE>


</BLOCKQUOTE>
<P CLASS="ref">Remarks</P>


<BLOCKQUOTE>

<P>This method is intended for input pins only. Output pins should implement
this to return an error. The pin should verify that it accepts the media type
passed to it and return S_OK if so.

<P>This method is implemented in the base classes by <A HREF="../class/CBasePin.htm#ReceiveConnection">CBasePin::ReceiveConnection</A>.

</BLOCKQUOTE>
<!-- CONTENTS_END -->

<!-- START_PAGE_FOOTER -->


<H6><HR size=1></H6>
<P><A Class="line" HREF="#pagetop"><IMG src="../../art/arrowup1.gif" WIDTH="11" HEIGHT="11" ALIGN="MIDDLE" BORDER=0 ALT="Top of Page">&nbsp;Top of Page</A>
<BR><A Class="line" HREF="../../../cpyright.htm">&#169; 1998 Microsoft Corporation. All rights reserved. Terms of Use.</A>
<!-- END_PAGE_FOOTER -->

</BLOCKQUOTE>

<SCRIPT>if((g_isIE == true) && (g_iMaj > 3)) {window.self.document.writeln('<SCR' + 'IPT SRC="../../tip2.js"></SCR' + 'IPT><IFRAME ID="G_L_S" NAME="SecretBuffer" STYLE="display: none" SRC=""></IFRAME>')}</SCRIPT>

<!-- DACONTROL_START -->

	<DIV ID="HeadGraphAnim"></DIV>
	<SCRIPT>if((g_isIE == true) && (g_iMaj > 3)) {window.self.document.writeln('<SCR' + 'IPT SRC="../../anim.js"></SCR' + 'IPT>')}</SCRIPT>
<!-- DACONTROL_END -->

</BODY>
</HTML>
