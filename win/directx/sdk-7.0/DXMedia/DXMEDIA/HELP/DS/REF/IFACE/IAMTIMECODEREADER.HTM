<!-- DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN" -->

<HTML>
<HEAD><TITLE>IAMTimecodeReader Interface</TITLE>
<SCRIPT> var sRelPath = '../../' </SCRIPT>


<META NAME="Description" CONTENT="IAMTimecodeReader Interface">
<META NAME="Description" CONTENT="IAMTimecodeReader::GetTCRMode">
<META NAME="Description" CONTENT="IAMTimecodeReader::GetTimecode">
<META NAME="Description" CONTENT="IAMTimecodeReader::get_VITCLine">
<META NAME="Description" CONTENT="IAMTimecodeReader::put_VITCLine">
<META NAME="Description" CONTENT="IAMTimecodeReader::SetTCRMode">
<META NAME="Description" CONTENT="GetTCRMode (IAMTimecodeReader)">
<META NAME="Description" CONTENT="GetTimecode (IAMTimecodeReader)">
<META NAME="Description" CONTENT="get_VITCLine (IAMTimecodeReader)">
<META NAME="Description" CONTENT="put_VITCLine (IAMTimecodeReader)">
<META NAME="Description" CONTENT="SetTCRMode (IAMTimecodeReader)">
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; CHARSET=iso8859-1">
<META NAME="MS.LOCALE" CONTENT="EN-US">
<META NAME="ROBOTS" CONTENT="all">

<!-- SNIFF_START -->

<SCRIPT>
//<!--
var g_isIE = false, g_isNav = false, g_iMaj = 0, g_sPlat = "";
// -->

</SCRIPT>
<SCRIPT SRC="../../ver.js"></SCRIPT>
<SCRIPT SRC="../../gloss.js"></SCRIPT>

<!-- SNIFF_END -->


<SCRIPT DEFER SRC="../../common.js"></SCRIPT>
<SCRIPT DEFER>
//<!--
function InitPage()
{
	if (g_isIE && g_iMaj >= 4)	
	{

		SetTOC();
	}
}
//-->

</SCRIPT>

<!-- SNIFF_END -->


<!-- STYLE_START -->

<SCRIPT>
//<!--
   var sVR = '../../'	// Set root for the style sheet
   var sCSS = '<LINK REL="stylesheet" HREF="' + sVR;

   if(g_isIE)
   {
	   if (g_iMaj >= 4) // For MSIE 4.0 or later
	   {
		   sCSS += 'dxm_basicsdkIE4';
		   if (g_sPlat == "Win") // Windows only for now
		   {
			   document.createStyleSheet(sVR + 'dxm_advSDKIE4.css');
		   }
	   }
	   else // For MSIE 3.0 or earlier
	   {
		   sCSS += 'dxm_basicsdkIE3';
	   }
   }
   else if (g_isNav) // For all Nav versions
   {
	   sCSS += 'dxm_basicsdkNAV';
   }
   else
   {
	   sCSS += 'dxm_basicsdkIE3'; // default to IE3 sheet
   }

   sCSS += (sCSS == '' ? '' : '.css" TYPE="text/css">');

   document.write(sCSS);
//-->

</SCRIPT>
<!-- STYLE_END -->


</HEAD>
<BODY onload="InitPage(); if (g_isIE && g_iMaj >= 4){HdgrphControl()}" BGCOLOR="#FFFFFF">
<A NAME="pagetop"></A><A NAME="IAMTimecodeReader"></A>

<!-- HEADGRAPH_START -->

<TABLE CLASS="main" BORDER=0 CELLSPACING="0" CELLPADDING="0" WIDTH="*">
<TR>
<TD ROWSPAN="3" VALIGN="TOP" WIDTH="*">
<IMG SRC="../../art/header1.gif" WIDTH="107" HEIGHT="110" BORDER=0 ALT="DirectShow Animated Header"></TD>
<TD ROWSPAN="2" VALIGN="TOP" WIDTH="217"><IMG SRC="../../art/hdrdshow.gif" WIDTH="217" HEIGHT="110" BORDER=0 ALT="DirectShow Animated Header"></TD>
<TD VALIGN="TOP" WIDTH="383">
<IMG SRC="../../art/header3.gif" WIDTH="383" HEIGHT="95" BORDER=0 ALT="DirectShow Animated Header">
</TD>
<TD VALIGN="TOP" WIDTH="100%">
<IMG SRC="../../art/spacer1.gif" WIDTH="100%" HEIGHT="94" BORDER=0 ALT="Microsoft DirectShow SDK">
</TD>
</TR>
<!-- HEADGRAPH_END -->

<!-- NAV_LINKS_START -->

<TR><TD VALIGN="TOP"><PRE><IMG ID="TOC_" SRC="../../art/yelbtn.gif" WIDTH="11" HEIGHT="11" ALIGN="MIDDLE" BORDER=0 ALT="*"><A STYLE="color:black;font-weight:bold" ID="TOC" HREF="../../contents.htm">Contents</A>  <IMG SRC="../../art/yelbtn.gif" WIDTH="11" HEIGHT="11" ALIGN="MIDDLE" BORDER=0 ALT="*"><A STYLE="color:black;font-weight:bold" HREF="../../index.htm">Index</A>  <IMG SRC="../../art/yelbtn.gif" WIDTH="11" HEIGHT="11" ALIGN="MIDDLE" BORDER=0 ALT="*"><A STYLE="color:black;font-weight:bold" HREF="ifaces_intro.htm">Topic Contents</A>
</PRE></TD></TR>
<TR><TD COLSPAN="2" VALIGN="TOP"><PRE><IMG SRC="../../art/yelbtn.gif" WIDTH="11" HEIGHT="11" ALIGN="MIDDLE" BORDER=0 ALT="*"><B>Previous Topic:</B> <A STYLE="color:black" HREF="IAMTimecodeGenerator.htm">IAMTimecodeGenerator Interface</A>
<IMG SRC="../../art/yelbtn.gif" WIDTH="11" HEIGHT="11" ALIGN="MIDDLE" BORDER=0 ALT="*"><B>Next Topic:</B> <A  STYLE="color:black" HREF="IAMTVTuner.htm">IAMTVTuner Interface</A>
</PRE></TD></TR></TABLE>
<!-- NAV_LINKS_END -->


<BLOCKQUOTE CLASS="body">


<!-- CONTENTS_START -->


<H1>IAMTimecodeReader Interface</H1>

<P>You can implement the <B>IAMTimecodeReader</B> interface to read SMPTE (Society of Motion Picture and Television Engineers) or MIDI <A CLASS="Glossary" HREF="javascript:Glossary(sRelPath + 'gloss/gloss_T.htm#timecode')">timecode</A> from an external device. It contains properties and methods that specify the timecode format that an external device should read, and how it is embedded in the media. It is expected that you will use this interface with the <A HREF="IAMExtDevice.htm">IAMExtDevice</A> and <A HREF="IAMExtTransport.htm">IAMExtTransport</A> interfaces to control an external device, such as a VCR, which can read timecode data. 

<P>SMPTE timecode is a frame addressing system that identifies video and audio sources, makes automatic track synchronization possible, and provides a container for additional data related to the source material. SMPTE timecode's main purpose is to provide a machine-readable address for video and audio. It is displayed in hh:mm:ss:ff (hours, minutes, seconds, frames) format and is thoroughly defined in ANSI/SMPTE 12-1986.

<P>For more information on SMPTE timecode, see <A HREF="../../appdev/Control_External_Device.htm">Control an External Device in DirectShow</A>.

<P CLASS="ref"><A NAME="When_to_Implement">When to Implement</A></P>

<P>Implement this interface on an external device <A CLASS="Glossary" HREF="javascript:Glossary(sRelPath + 'gloss/gloss_f.htm#filter')">filter</A> when you want to specify how an external device should read SMPTE/MIDI timecode information. 

<P>Expose the <A HREF="IMediaSeeking.htm">IMediaSeeking</A> interface on your filter so that applications can convert timecode to DirectShow <A CLASS="Glossary" HREF="javascript:Glossary(sRelPath + 'gloss/gloss_R.htm#reference_time')">reference time</A> (by using the <A HREF="IMediaSeeking.htm#ConvertTimeFormat">IMediaSeeking::ConvertTimeFormat</A> method).

<P>Your external device must be able to read timecode and send it to the computer over its control interface. If this is not the case, you must either have a timecode reader card in your computer, or you can write a software decoder that converts <A CLASS="Glossary" HREF="javascript:Glossary(sRelPath + 'gloss/gloss_V.htm#VITC')">VITC</A> (Vertical Interval Timecode) in captured video frames or <A CLASS="Glossary" HREF="javascript:Glossary(sRelPath + 'gloss/gloss_L.htm#LTC')">LTC</A> (Linear Timecode) captured as an audio signal into DirectShow timecode samples.

<P CLASS="ref"><A NAME="When_to_Use">When to Use</A></P>

<P>Use this interface when you need to read timecode information for controlling an external device, or when you want to use timecode information from an external device in applications that must refer to original program information. 

<P>Applications generally save timecode in one of two ways. It is either written to the capture file as an additional stream or as a discontinuity table stored in the extended AVI file index. It is commonly used to trigger capture or playback and to create <A CLASS="Glossary" HREF="javascript:Glossary(sRelPath + 'gloss/gloss_E.htm#edit_decision_list')">edit decision lists</A> that describes how source material is organized into a finished product.

<P>If you intend to capture timecode, treat it as a separate stream that has its own media type. It can be consumed by an appropriate file-writing multiplexer filter. However, sometimes there are errors in reading the timecode off the tape because of dropouts and other mechanical tape problems. In such cases, the timecode <A CLASS="Glossary" HREF="javascript:Glossary(sRelPath + 'gloss/gloss_S.htm#source_filter')">source filter</A> should simply drop samples and mark the next valid one with the discontinuity property.

<P>If you intend to use timecodes to trigger capture or playback from a timecoded (or "striped") videotape, the sequence of events goes as follows:
<OL>
<LI>Build a capture graph, open a target AVI file, and pre allocate disk space if necessary. If the captured material will be appended to an existing AVI file, seek to the end of the file before writing. The capture graph is paused at this point.
<LI>Search the VCR to the capture start point and note the timecode. You can either enter this value manually into your program, or the application can automatically read it. Automatic reading requires that the graph is running but the stream control interfaces on the file multiplexer's <A CLASS="Glossary" HREF="javascript:Glossary(sRelPath + 'gloss/gloss_I.htm#input_pin')">input pins</A> are discarding incoming samples, effectively gating the capture.
<LI>Cue the VCR to <A CLASS="Glossary" HREF="javascript:Glossary(sRelPath + 'gloss/gloss_P.htm#preroll')">preroll</A> position, usually five seconds before the target point.
<LI>Start the VCR and the graph. When the trigger point is reached (or the trigger point minus the file writer's <A CLASS="Glossary" HREF="javascript:Glossary(sRelPath + 'gloss/gloss_P.htm#preroll')">preroll</A>), the stream control interfaces release the file multiplexer and it begins streaming media samples to the file writer.
<LI>You can stop the capture process manually or by setting a duration property on the stream control interface.
</OL>

<P>You must consider discontinuous timecode, both during preroll and during the capture process; it is reasonable to demand that the timecode be continuous and monotonically increasing throughout the preroll and capture start point. This prevents a potentially ambiguous calculation of relative <A CLASS="Glossary" HREF="javascript:Glossary(sRelPath + 'gloss/gloss_S.htm#stream_time')">stream times</A> by the <A HREF="IMediaSeeking.htm#ConvertTimeFormat">IMediaSeeking::ConvertTimeFormat</A> method. Also, the timecode need not be the only gating signal for triggered capture. Any time-stamped data stored in the <A CLASS="Glossary" HREF="javascript:Glossary(sRelPath + 'gloss/gloss_V.htm#vertical_blanking_in')">vertical blanking interval</A>, such as Intercast or Closed Caption data (XDS), can be used to start the streaming of video and audio data to disk.

<P CLASS="ref"><A NAME="Hardware_Requirement">Hardware Requirements</A></P>

<P>See the <A HREF="IAMExtTransport.htm">IAMExtTransport</A> interface for hardware requirements.

<P CLASS="ref"><A NAME="Methods_in_Vtable_Or">Methods in Vtable Order</A></P>

<TABLE>
<TR><TH>IUnknown methods</TH><TH>Description</TH></TR><TR><TD><A HREF="IUnknown.htm#QueryInterface">QueryInterface</A>
 </TD><TD>Retrieves pointers to supported interfaces.
 </TD></TR><TR><TD><A HREF="IUnknown.htm#AddRef">AddRef</A>
 </TD><TD>Increments the reference count.
 </TD></TR><TR><TD><A HREF="IUnknown.htm#Release">Release</A>
 </TD><TD>Decrements the reference count.
</TD></TR><TR></TR>
<TR><TH>IAMTimecodeReader methods</TH><TH>Description</TH></TR>
<TR><TD><A HREF="IAMTimecodeReader.htm#GetTCRMode">GetTCRMode</A>
 </TD><TD>Retrieves properties of the timecode reader.
 </TD></TR><TR><TD><A HREF="IAMTimecodeReader.htm#SetTCRMode">SetTCRMode</A>
 </TD><TD>Sets the timecode reader properties.
 </TD></TR><TR><TD><A HREF="IAMTimecodeReader.htm#put_VITCLine">put_VITCLine</A>
 </TD><TD>Specifies the vertical interval line that the timecode reader will use to read timecode.
 </TD></TR><TR><TD><A HREF="IAMTimecodeReader.htm#get_VITCLine">get_VITCLine</A>
 </TD><TD>Retrieves the vertical interval line that the timecode reader is using to read timecode.
 </TD></TR><TR><TD><A HREF="IAMTimecodeReader.htm#GetTimecode">GetTimecode</A>
 </TD><TD>Retrieves the most recent timecode, <A CLASS="Glossary" HREF="javascript:Glossary(sRelPath + 'gloss/gloss_U.htm#userbits')">userbits</A>, and flag values available in the stream.
</TD></TR></TABLE>



<H1><A NAME="GetTCRMode">IAMTimecodeReader::GetTCRMode</A><HR size=1></H1>
<A HREF="IAMTimecodeReader.htm">IAMTimecodeReader Interface</A>

<P>Retrieves the timecode reader's properties.

<P CLASS="ref">Syntax</P>
<BLOCKQUOTE><PRE><P><B>HRESULT</B> <B>GetTCRMode</B><B>(</B><BR>&nbsp;&nbsp;<B>long</B>
<I>Param</I><B>,</B><BR>&nbsp;&nbsp;<B>long</B>
<I>*pValue</I><BR>&nbsp;&nbsp;<B>)</B><B>;</B><BR></PRE></BLOCKQUOTE>

<P CLASS="ref">Parameters</P>
<BLOCKQUOTE><DL><DT><I>Param</I>
 </DT><DD>[in] Timecode reader property to get (either ED_TCR_SOURCE or ED_TCR_NOTIFY_ENABLE).
</DD><DT><I>pValue</I>
 </DT><DD>[out] Pointer to the value of the requested timecode reader property. If <I>Param</I> is set to ED_TCR_NOTIFY_ENABLE, then this value will return OATRUE, meaning that notifications are enabled, or OAFALSE. If<I>Param</I>is set to ED_TCR_SOURCE, then this value must be one of the following:
<TABLE>
<TR><TD>ED_TCR_CT </TD><TD>Control track
</TD></TR><TR><TD>ED_TCR_LTC </TD><TD>Linear timecode
</TD></TR><TR><TD>ED_TCR_VITC </TD><TD>Vertical interval timecode
</TD></TR><TR><TD>ED_TCR_LAST_VALUE </TD><TD>Last read value
</TD></TR></TABLE>
</DD></DL></BLOCKQUOTE>

<P CLASS="ref">Return Value</P>
<BLOCKQUOTE><P>Returns an <A HREF="../Error_Success_Codes.htm#HRESULT">HRESULT</A> value that depends on the implementation of the interface.</BLOCKQUOTE> 

<P CLASS="ref">Remarks</P>
<BLOCKQUOTE><P>Linear timecode is recorded on an analog audio track as a <A CLASS="Glossary" HREF="javascript:Glossary(sRelPath + 'gloss/gloss_B.htm#bi_phase_mark')">bi-phase mark</A>-encoded signal. Each timecode frame is one video frame time in duration.

<P>Vertical timecode is usually stored in two lines of a video signal's vertical interval, somewhere between lines 11 and 20.

<P>Control track is a once-per-frame signal recorded on a special track on a tape. The head and drive <A CLASS="Glossary" HREF="javascript:Glossary(sRelPath + 'gloss/gloss_S.htm#servo')">servo</A> mechanisms use it to keep everything locked. It is also used to drive the counter on machines without timecode capability, and can optionally be used on machines equipped with a timecode reader.</BLOCKQUOTE>

<P>Note that ED_TCR_LAST_VALUE is used when implementing timecode notification because the application does not want to initiate another timecode request to the external device. This method is not recommended for frame-accurate applications because of multithreading issues.

<P CLASS="ref">See Also</P>
<BLOCKQUOTE><P><A HREF="IAMTimecodeReader.htm#SetTCRMode">IAMTimecodeReader::SetTCRMode</A></BLOCKQUOTE>



<H1><A NAME="GetTimecode">IAMTimecodeReader::GetTimecode</A><HR size=1></H1>
<A HREF="IAMTimecodeReader.htm">IAMTimecodeReader Interface</A>
<P>Retrieves the most recent timecode, userbit, and flag values available in the stream.

<P CLASS="ref">Syntax</P><BLOCKQUOTE><PRE><P><B>HRESULT</B> <B>GetTimecode</B><B>(</B><BR>&nbsp;&nbsp;<B>PTIMECODE_SAMPLE</B> <I>pTimecodeSample</I><BR>&nbsp;&nbsp;<B>)</B><B>;</B><BR></PRE></BLOCKQUOTE>
<P CLASS="ref">Parameters</P>
<BLOCKQUOTE><DL><DT><I>pTimecodeSample</I>
 </DT><DD>[out] Pointer to a <A HREF="../structs.htm#TIMECODE_SAMPLE">TIMECODE_SAMPLE</A> timecode structure.
</DD></DL></BLOCKQUOTE>

<P CLASS="ref">Return Value</P>
<BLOCKQUOTE><P>Returns an <A HREF="../Error_Success_Codes.htm#HRESULT">HRESULT</A> value that depends on the implementation of the interface.</BLOCKQUOTE>


<P CLASS="ref">Remarks</P>
<BLOCKQUOTE><P>Use this method to monitor the timecode and to parse duplicates and discontinuities. The source filter supplying the timecode, or possibly a <A CLASS="Glossary" HREF="javascript:Glossary(sRelPath + 'gloss/gloss_D.htm#downstream_filter')">downstream filter</A>, might want to parse for discontinuities or errors because you have to look at every sample to be able to retrieve the most recent timecode.

<P>Applications can fill undefined bits in the timecode word to store synchronization information, or to encode original film and audio tape information. These undefined bits, or userbits, are retrieved by calling this method.</BLOCKQUOTE>


<H1><A NAME="get_VITCLine">IAMTimecodeReader::get_VITCLine</A><HR size=1></H1>
<A HREF="IAMTimecodeReader.htm">IAMTimecodeReader Interface</A>
<P>Retrieves the vertical interval line that the timecode reader is using to read timecode.
<P CLASS="ref">Syntax</P><BLOCKQUOTE><PRE><P><B>HRESULT</B> <B>get_VITCLine</B><B>(</B><BR>&nbsp;&nbsp;<B>long</B> <I>*pLine</I> <B>)</B><B>;</B><BR></PRE></BLOCKQUOTE>
<P CLASS="ref">Parameters</P>
<BLOCKQUOTE><DL><DT><I>pLine</I>
 </DT><DD>[out] Vertical line containing timecode information (valid lines are 11-20).
</DD></DL></BLOCKQUOTE>

<P CLASS="ref">Return Value</P>
<BLOCKQUOTE><P>Returns an <A HREF="../Error_Success_Codes.htm#HRESULT">HRESULT</A> value that depends on the implementation of the interface.</BLOCKQUOTE> 


<P CLASS="ref">Remarks</P>
<BLOCKQUOTE><P>The high bit indicates that multiple lines are used and successive calls will cycle through the line numbers.</BLOCKQUOTE>
 

<P CLASS="ref">See Also</P>
<BLOCKQUOTE><P><A HREF="IAMTimecodeReader.htm#put_VITCLine">IAMTimecodeReader::put_VITCLine</A></BLOCKQUOTE>


<H1><A NAME="put_VITCLine">IAMTimecodeReader::put_VITCLine</A><HR size=1></H1>
<A HREF="IAMTimecodeReader.htm">IAMTimecodeReader Interface</A>
<P>Specifies the vertical interval line that the timecode reader will use to read timecode.
<P CLASS="ref">Syntax</P><BLOCKQUOTE><PRE><P><B>HRESULT</B> <B>put_VITCLine</B><B>(</B><BR>&nbsp;&nbsp;<B>long</B> <I>Line</I> <B>)</B><B>;</B><BR></PRE></BLOCKQUOTE>
<P CLASS="ref">Parameters</P>
<BLOCKQUOTE><DL><DT><I>Line</I>
 </DT><DD>[in] Vertical line containing timecode information (valid lines are 11-20; 0 means autoselect).
</DD></DL></BLOCKQUOTE>

<P CLASS="ref">Return Value</P>
<BLOCKQUOTE><P>Returns an <A HREF="../Error_Success_Codes.htm#HRESULT">HRESULT</A> value that depends on the implementation of the interface.</BLOCKQUOTE> 


<P CLASS="ref">Remarks</P>
<BLOCKQUOTE><P>If VITC mode is specified in the <A HREF="IAMTimecodeReader.htm#SetTCRMode">IAMTimecodeReader::SetTCRMode</A> method, you must specify which line or lines will contain timecode information. To read VITC on specific multiple lines, the caller would make successive calls to <B>put_VITCLine</B>, once for each line desired.

<P>Set the hi bit to add to the list of lines for readers that test across multiple lines.</BLOCKQUOTE>
 
<P CLASS="ref">See Also</P>
<BLOCKQUOTE><P><A HREF="IAMTimecodeReader.htm#get_VITCLine">IAMTimecodeReader::get_VITCLine</A></BLOCKQUOTE>



<H1><A NAME="SetTCRMode">IAMTimecodeReader::SetTCRMode</A><HR size=1></H1>
<A HREF="IAMTimecodeReader.htm">IAMTimecodeReader Interface</A>
<P>Sets the timecode reader properties.
<P CLASS="ref">Syntax</P><BLOCKQUOTE><PRE><P><B>HRESULT</B> <B>SetTCRMode</B><B>(</B><BR>&nbsp;&nbsp;<B>long</B> <I>Param</I><B>,</B><BR>&nbsp;&nbsp;<B>long</B> <I>Value</I><BR>&nbsp;&nbsp;<B>)</B><B>;</B><BR></PRE></BLOCKQUOTE>
<P CLASS="ref">Parameters</P>
<BLOCKQUOTE><DL><DT><I>Param</I>
 </DT><DD>[in] Property you want to set (use ED_TCR_SOURCE or ED_TCR_NOTIFY_ENABLE).
</DD><DT><I>Value</I>
 </DT><DD>[in] Value of the specified property; If <I>Param</I> returns ED_TCR_NOTIFY_ENABLE, then this value will return OATRUE or OAFALSE.  If<I>Param</I> returns ED_TCR_SOURCE, then this value must be one of the following:
<TABLE>
<TR><TD> ED_TCR_CT </TD><TD>Control Track
</TD></TR><TR><TD>ED_TCR_LTC </TD><TD>Linear Timecode
</TD></TR><TR><TD>ED_TCR_VITC </TD><TD>Vertical Interval Timecode
</TD></TR><TR><TD>ED_TCR_LAST_VALUE </TD><TD>Return last read value.
</TD></TR></TABLE>
</DD></DL></BLOCKQUOTE>

<P CLASS="ref">Return Value</P>
<BLOCKQUOTE><P>Returns an <A HREF="../Error_Success_Codes.htm#HRESULT">HRESULT</A> value that depends on the implementation of the interface.</BLOCKQUOTE> 


<P CLASS="ref">Remarks</P>
<BLOCKQUOTE><P>Linear timecode is recorded on an analog audio track as an NRZ <A CLASS="Glossary" HREF="javascript:Glossary(sRelPath + 'gloss/gloss_B.htm#bi_phase_mark')">bi-phase mark</A>-encoded signal. Each timecode frame is one video frame time in duration.

<P>Vertical timecode is usually stored in two lines of a video signal's vertical interval, somewhere between 10 and 20.

<P>Control track is a once-per-frame signal recorded on a special track on a tape. The head and drive servo mechanisms use it to keep everything locked. It is also used to drive the counter on machines without timecode capability, and can optionally be used on machines equipped with a timecode reader.</BLOCKQUOTE>

<P>Note that ED_TCR_LAST_VALUE is used when implementing timecode notification because the application does not want to initiate another timecode request to the external device. This method is not recommended for frame-accurate applications because of multithreading issues.

<P CLASS="ref">See Also</P>
<BLOCKQUOTE><P><A HREF="IAMTimecodeReader.htm#GetTCRMode">IAMTimecodeReader::GetTCRMode</A></BLOCKQUOTE>

<!-- CONTENTS_END -->

<!-- START_PAGE_FOOTER -->


<H6><HR size=1></H6>
<P><A Class="line" HREF="#pagetop"><IMG src="../../art/arrowup1.gif" WIDTH="11" HEIGHT="11" ALIGN="MIDDLE" BORDER=0 ALT="Top of Page">&nbsp;Top of Page</A>
<BR><A Class="line" HREF="../../../cpyright.htm">&#169; 1998 Microsoft Corporation. All rights reserved. Terms of Use.</A>
<!-- END_PAGE_FOOTER -->

</BLOCKQUOTE>

<SCRIPT>if((g_isIE == true) && (g_iMaj > 3)) {window.self.document.writeln('<SCR' + 'IPT SRC="../../tip2.js"></SCR' + 'IPT><IFRAME ID="G_L_S" NAME="SecretBuffer" STYLE="display: none" SRC=""></IFRAME>')}</SCRIPT>

<!-- DACONTROL_START -->

	<DIV ID="HeadGraphAnim"></DIV>
	<SCRIPT>if((g_isIE == true) && (g_iMaj > 3)) {window.self.document.writeln('<SCR' + 'IPT SRC="../../anim.js"></SCR' + 'IPT>')}</SCRIPT>
<!-- DACONTROL_END -->

</BODY>
</HTML>
