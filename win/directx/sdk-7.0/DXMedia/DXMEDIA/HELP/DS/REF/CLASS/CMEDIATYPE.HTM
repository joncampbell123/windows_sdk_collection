<!-- DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN" -->

<HTML>
<HEAD><TITLE>CMediaType Class</TITLE>
<SCRIPT> var sRelPath = '../../' </SCRIPT>


<META NAME="Description" CONTENT="CMediaType Class">
<META NAME="Description" CONTENT="AllocFormatBuffer (CMediaType)">
<META NAME="Description" CONTENT="CMediaType::AllocFormatBuffer">
<META NAME="Description" CONTENT="CMediaType (CMediaType)">
<META NAME="Description" CONTENT="CMediaType::CMediaType">
<META NAME="Description" CONTENT="Format (CMediaType)">
<META NAME="Description" CONTENT="CMediaType::Format">
<META NAME="Description" CONTENT="FormatLength (CMediaType)">
<META NAME="Description" CONTENT="CMediaType::FormatLength">
<META NAME="Description" CONTENT="FormatType (CMediaType)">
<META NAME="Description" CONTENT="CMediaType::FormatType">
<META NAME="Description" CONTENT="GetSampleSize (CMediaType)">
<META NAME="Description" CONTENT="CMediaType::GetSampleSize">
<META NAME="Description" CONTENT="InitMediaType (CMediaType)">
<META NAME="Description" CONTENT="CMediaType::InitMediaType">
<META NAME="Description" CONTENT="IsFixedSize (CMediaType)">
<META NAME="Description" CONTENT="CMediaType::IsFixedSize">
<META NAME="Description" CONTENT="IsPartiallySpecified (CMediaType)">
<META NAME="Description" CONTENT="CMediaType::IsPartiallySpecified">
<META NAME="Description" CONTENT="IsTemporalCompressed (CMediaType)">
<META NAME="Description" CONTENT="CMediaType::IsTemporalCompressed">
<META NAME="Description" CONTENT="IsValid (CMediaType)">
<META NAME="Description" CONTENT="CMediaType::IsValid">
<META NAME="Description" CONTENT="MatchesPartial (CMediaType)">
<META NAME="Description" CONTENT="CMediaType::MatchesPartial">
<META NAME="Description" CONTENT="ReallocFormatBuffer (CMediaType)">
<META NAME="Description" CONTENT="CMediaType::ReallocFormatBuffer">
<META NAME="Description" CONTENT="ResetFormatBuffer (CMediaType)">
<META NAME="Description" CONTENT="CMediaType::ResetFormatBuffer">
<META NAME="Description" CONTENT="SetFormat (CMediaType)">
<META NAME="Description" CONTENT="CMediaType::SetFormat">
<META NAME="Description" CONTENT="SetFormatType (CMediaType)">
<META NAME="Description" CONTENT="CMediaType::SetFormatType">
<META NAME="Description" CONTENT="SetSampleSize (CMediaType)">
<META NAME="Description" CONTENT="CMediaType::SetSampleSize">
<META NAME="Description" CONTENT="SetSubtype (CMediaType)">
<META NAME="Description" CONTENT="CMediaType::SetSubtype">
<META NAME="Description" CONTENT="SetTemporalCompression (CMediaType)">
<META NAME="Description" CONTENT="CMediaType::SetTemporalCompression">
<META NAME="Description" CONTENT="SetType (CMediaType)">
<META NAME="Description" CONTENT="CMediaType::SetType">
<META NAME="Description" CONTENT="SetVariableSize (CMediaType)">
<META NAME="Description" CONTENT="CMediaType::SetVariableSize">
<META NAME="Description" CONTENT="Subtype (CMediaType)">
<META NAME="Description" CONTENT="CMediaType::Subtype">
<META NAME="Description" CONTENT="Type (CMediaType)">
<META NAME="Description" CONTENT="CMediaType::Type">
<META NAME="Description" CONTENT="operator = (CMediaType)">
<META NAME="Description" CONTENT="CMediaType::operator =">
<META NAME="Description" CONTENT="operator == (CMediaType)">
<META NAME="Description" CONTENT="CMediaType::operator ==">
<META NAME="Description" CONTENT="operator != (CMediaType)">
<META NAME="Description" CONTENT="CMediaType::operator !=">
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; CHARSET=iso8859-1">
<META NAME="MS.LOCALE" CONTENT="EN-US">
<META NAME="ROBOTS" CONTENT="all">

<!-- SNIFF_START -->

<SCRIPT>
//<!--
var g_isIE = false, g_isNav = false, g_iMaj = 0, g_sPlat = "";
// -->

</SCRIPT>
<SCRIPT SRC="../../ver.js"></SCRIPT>
<SCRIPT SRC="../../gloss.js"></SCRIPT>

<!-- SNIFF_END -->


<SCRIPT DEFER SRC="../../common.js"></SCRIPT>
<SCRIPT DEFER>
//<!--
function InitPage()
{
	if (g_isIE && g_iMaj >= 4)	
	{

		SetTOC();
	}
}
//-->

</SCRIPT>

<!-- SNIFF_END -->


<!-- STYLE_START -->

<SCRIPT>
//<!--
   var sVR = '../../'	// Set root for the style sheet
   var sCSS = '<LINK REL="stylesheet" HREF="' + sVR;

   if(g_isIE)
   {
	   if (g_iMaj >= 4) // For MSIE 4.0 or later
	   {
		   sCSS += 'dxm_basicsdkIE4';
		   if (g_sPlat == "Win") // Windows only for now
		   {
			   document.createStyleSheet(sVR + 'dxm_advSDKIE4.css');
		   }
	   }
	   else // For MSIE 3.0 or earlier
	   {
		   sCSS += 'dxm_basicsdkIE3';
	   }
   }
   else if (g_isNav) // For all Nav versions
   {
	   sCSS += 'dxm_basicsdkNAV';
   }
   else
   {
	   sCSS += 'dxm_basicsdkIE3'; // default to IE3 sheet
   }

   sCSS += (sCSS == '' ? '' : '.css" TYPE="text/css">');

   document.write(sCSS);
//-->

</SCRIPT>
<!-- STYLE_END -->


</HEAD>
<BODY onload="InitPage(); if (g_isIE && g_iMaj >= 4){HdgrphControl()}" BGCOLOR="#FFFFFF">
<A NAME="pagetop"></A><A NAME="CMediaType"></A>

<!-- HEADGRAPH_START -->

<TABLE CLASS="main" BORDER=0 CELLSPACING="0" CELLPADDING="0" WIDTH="*">
<TR>
<TD ROWSPAN="3" VALIGN="TOP" WIDTH="*">
<IMG SRC="../../art/header1.gif" WIDTH="107" HEIGHT="110" BORDER=0 ALT="DirectShow Animated Header -- CMediaType Class"></TD>
<TD ROWSPAN="2" VALIGN="TOP" WIDTH="217"><IMG SRC="../../art/hdrdshow.gif" WIDTH="217" HEIGHT="110" BORDER=0 ALT="DirectShow Animated Header -- CMediaType Class"></TD>
<TD VALIGN="TOP" WIDTH="383">
<IMG SRC="../../art/header3.gif" WIDTH="383" HEIGHT="95" BORDER=0 ALT="DirectShow Animated Header">
</TD>
<TD VALIGN="TOP" WIDTH="100%">
<IMG SRC="../../art/spacer1.gif" WIDTH="100%" HEIGHT="94" BORDER=0 ALT="Microsoft DirectShow SDK">
</TD>
</TR>
<!-- HEADGRAPH_END -->

<!-- NAV_LINKS_START -->

<TR><TD VALIGN="TOP"><PRE><IMG ID="TOC_" SRC="../../art/yelbtn.gif" WIDTH="11" HEIGHT="11" ALIGN="MIDDLE" BORDER=0 ALT="*"><A STYLE="color:black;font-weight:bold" ID="TOC" HREF="../../contents.htm">Contents</A>  <IMG SRC="../../art/yelbtn.gif" WIDTH="11" HEIGHT="11" ALIGN="MIDDLE" BORDER=0 ALT="*"><A STYLE="color:black;font-weight:bold" HREF="../../index.htm">Index</A>  <IMG SRC="../../art/yelbtn.gif" WIDTH="11" HEIGHT="11" ALIGN="MIDDLE" BORDER=0 ALT="*"><A STYLE="color:black;font-weight:bold" HREF="Classes_intro.htm">Topic Contents</A>
</PRE></TD></TR>
<TR><TD COLSPAN="2" VALIGN="TOP"><PRE><IMG SRC="../../art/yelbtn.gif" WIDTH="11" HEIGHT="11" ALIGN="MIDDLE" BORDER=0 ALT="*"><B>Previous Topic:</B> <A STYLE="color:black" HREF="CMediaSample.htm">CMediaSample Class</A>
<IMG SRC="../../art/yelbtn.gif" WIDTH="11" HEIGHT="11" ALIGN="MIDDLE" BORDER=0 ALT="*"><B>Next Topic:</B> <A  STYLE="color:black" HREF="CMemAllocator.htm">CMemAllocator Class</A>
</PRE></TD></TR></TABLE>
<!-- NAV_LINKS_END -->


<BLOCKQUOTE CLASS="body">


<!-- CONTENTS_START -->

<H1>CMediaType Class</H1>

<P><IMG SRC="../../art/mtype01.gif" WIDTH="205" HEIGHT="56" ALT="CMediaType class hierarchy">

<P>When <A CLASS="Glossary" HREF="javascript:Glossary(sRelPath + 'gloss/gloss_f.htm#filter')">filters</A> are connected, they typically negotiate a type between them. This type describes the format of the data to be exchanged; if the filters do not agree on a media type, they cannot connect. Microsoft&#174; DirectShow&#153; describes types through the media type structure, which contains two conceptual parts. The first is a list of members that describes generic attributes of a data stream. An example of this is a member that declares whether the data will be passed in fixed-size buffers. The second part of the structure is a variable-length block of data. How large the block of data should be and what it will contain depend on the type of data stream. For example, if the data stream is digital video, the format block is a <A HREF="../structs.htm#VIDEOINFOHEADER">VIDEOINFOHEADER</A> structure. If, on the other hand, it is digital audio, the format block is a Microsoft Win32&#174; <A HREF="../../filtdev/DV_Data_AVI_File_Format.htm#WAVEFORMATEX_AVI">WAVEFORMATEX</A> structure.

<P>A data stream type (for example, digital video) is set with a combination of two globally unique identifiers (<A CLASS="Glossary" HREF="javascript:Glossary(sRelPath + 'gloss/gloss_G.htm#GUID')">GUID</A>s), called a <A CLASS="Glossary" HREF="javascript:Glossary(sRelPath + 'gloss/gloss_M.htm#major_type')">major type</A> and a subtype. The <I>major type</I> describes the overall class of data, examples of which might be digital video, digital audio, MIDI, or text captions. The <I>subtype</I> should supply a more specific description of the data type. In the case of digital video, for example, the subtype could be RGB8, RGB16, or RGB32 (among others). By having these two types in a generic structure (<A HREF="../structs.htm#AM_MEDIA_TYPE">AM_MEDIA_TYPE</A>), a component, such as a <A CLASS="Glossary" HREF="javascript:Glossary(sRelPath + 'gloss/gloss_F.htm#filter_graph')">filter graph</A>, can connect filters without any knowledge that is type specific.

<P>The distinction between what goes in the major type and the subtype is somewhat arbitrary. However, as a general rule, transformations between major types (for example, video to audio or video to MIDI) should be relatively rare. Such a rare exception might be a transformation between audio and MIDI. As for the subtype, the more information promoted from the type-specific format block into the subtype, the better the design.

<P>As an example of promoting type-specific information to the subtype, video in DirectShow uses a <A HREF="../structs.htm#VIDEOINFOHEADER">VIDEOINFOHEADER</A> structure for the type-specific format block. This contains a Win32 <A HREF="../../filtdev/DV_Data_AVI_File_Format.htm#BITMAPINFOHEADER_AVI">BITMAPINFOHEADER</A> structure that defines the video stream. <B>BITMAPINFOHEADER</B> contains the bit depth of the video, such as 8-bit, 16-bit, or 24-bit. This information is duplicated in the subtype <A CLASS="Glossary" HREF="javascript:Glossary(sRelPath + 'gloss/gloss_f.htm#field')">field</A>, because a subtype of RGB8 directly infers a bit count of 8.

<P>DirectShow defines a number of major types. The most important of these are a video type that uses <A HREF="../structs.htm#VIDEOINFOHEADER">VIDEOINFOHEADER</A> for the variable-length format block, and an audio that uses <A HREF="../../filtdev/DV_Data_AVI_File_Format.htm#WAVEFORMATEX_AVI">WAVEFORMATEX</A>. However, it is insufficient to have a major type (such as digital video) inferring the contents of the format block (in this case, <B>VIDEOINFOHEADER</B>). The principal reason for this is extensibility: the format block type must be able to be updated without changing the less-specific major type. Therefore, what the format block actually contains is inferred by another <A CLASS="Glossary" HREF="javascript:Glossary(sRelPath + 'gloss/gloss_G.htm#GUID')">GUID</A> called the <I><A CLASS="Glossary" HREF="javascript:Glossary(sRelPath + 'gloss/gloss_F.htm#format_type')">format type</A></I>. If the format block contains <B>VIDEOINFOHEADER</B>, the format type <B>GUID</B> will be FORMAT_VideoInfo.

<P>The principal use of the <B>CMediaType</B> class is to manage a media type structure in a simple way. At the same time, the class provides some extra helper functions (such as format-block copying and allocation). The class can be cast to an <A HREF="../structs.htm#AM_MEDIA_TYPE">AM_MEDIA_TYPE</A> structure when an interface method requires one to be passed to it.

<P>The <B>CMediaType</B> class contains a pointer to a block of memory. When copying a <B>CMediaType</B> object, it is insufficient to simply copy the pointer. In C++, a data copy is required, which actually allocates a new block of memory and copies the data into it. This is the purpose of the copy operator.

<P>Similarly, when comparing two <B>CMediaType</B> objects, you must compare the blocks of variable-length data (actually using <A HREF="../../appendixes/Further_Reading.htm#memcmp">memcmp</A>) when producing the final result. To make this possible, <B>CMediaType</B> overrides the equivalence operator.

<A NAME="Member_Functions"></A><P CLASS="ref">Member Functions</P>

<TABLE><TR><TD><A HREF="CMediaType.htm#AllocFormatBuffer">AllocFormatBuffer</A>
 </TD><TD>Allocates an uninitialized format block in the object.
</TD></TR><TR><TD><A HREF="CMediaType.htm#CMediaType_CMediaType">CMediaType</A>
 </TD><TD>Constructs a <B>CMediaType</B> object.
</TD></TR><TR><TD><A HREF="CMediaType.htm#Format">Format</A>
 </TD><TD>Returns the format block for this media type.
</TD></TR><TR><TD><A HREF="CMediaType.htm#FormatLength">FormatLength</A>
 </TD><TD>Returns the length of the format block of this object.
</TD></TR><TR><TD><A HREF="CMediaType.htm#FormatType">FormatType</A>
 </TD><TD>Returns a pointer to the format type.
</TD></TR><TR><TD><A HREF="CMediaType.htm#GetSampleSize">GetSampleSize</A>
 </TD><TD>Returns the size of the samples.
</TD></TR><TR><TD><A HREF="CMediaType.htm#InitMediaType">InitMediaType</A>
 </TD><TD>Initializes the media type.
</TD></TR><TR><TD><A HREF="CMediaType.htm#IsFixedSize">IsFixedSize</A>
 </TD><TD>Queries whether the samples are fixed in length.
</TD></TR><TR><TD><A HREF="CMediaType.htm#IsPartiallySpecified">IsPartiallySpecified</A>
 </TD><TD>Checks if the media type is not completely specified.
</TD></TR><TR><TD><A HREF="CMediaType.htm#IsTemporalCompressed">IsTemporalCompressed</A>
 </TD><TD>Queries whether the data stream is compressed temporally.
</TD></TR><TR><TD><A HREF="CMediaType.htm#IsValid">IsValid</A>
 </TD><TD>Queries whether the media type is currently valid.
</TD></TR><TR><TD><A HREF="CMediaType.htm#MatchesPartial">MatchesPartial</A>
 </TD><TD>Checks whether this media type matches another media type that is only partially specified.
</TD></TR><TR><TD><A HREF="CMediaType.htm#ReallocFormatBuffer">ReallocFormatBuffer</A>
 </TD><TD>Reallocates the format block,
maintaining its current content where possible.
</TD></TR><TR><TD><A HREF="CMediaType.htm#ResetFormatBuffer">ResetFormatBuffer</A>
 </TD><TD>Deletes any format block that is currently present.
</TD></TR><TR><TD><A HREF="CMediaType.htm#SetFormat">SetFormat</A>
 </TD><TD>Sets the format block.
</TD></TR><TR><TD><A HREF="CMediaType.htm#SetFormatType">SetFormatType</A>
 </TD><TD>Sets the type of the format block in the object.
</TD></TR><TR><TD><A HREF="CMediaType.htm#SetSampleSize">SetSampleSize</A>
 </TD><TD>Sets the size of the samples.
</TD></TR><TR><TD><A HREF="CMediaType.htm#SetSubtype">SetSubtype</A>
 </TD><TD>Sets the subtype.
</TD></TR><TR><TD><A HREF="CMediaType.htm#SetTemporalCompression">SetTemporalCompression</A>
 </TD><TD>Marks the media type to indicate that samples will be temporally compressed.
</TD></TR><TR><TD><A HREF="CMediaType.htm#SetType">SetType</A>
 </TD><TD>Sets the major type.
</TD></TR><TR><TD><A HREF="CMediaType.htm#SetVariableSize">SetVariableSize</A>
 </TD><TD>Marks the media type to indicate that samples will vary in length.
</TD></TR><TR><TD><A HREF="CMediaType.htm#CMediaType_Subtype">Subtype</A>
 </TD><TD>Returns a pointer to the subtype.
</TD></TR><TR><TD><A HREF="CMediaType.htm#Type">Type</A>
 </TD><TD>Returns a pointer to the major type.
</TD></TR></TABLE>
<P CLASS="ref"><A NAME="Operators"></A>Operators</P>


<TABLE><TR><TD><A HREF="CMediaType.htm#CMediaType_EQ_Operator">operator =</A>
 </TD><TD>Performs a copy operation.
</TD></TR><TR><TD><A HREF="CMediaType.htm#CMediaType_EQTEST_Operator">operator ==</A>
 </TD><TD>Tests for equality between <B>CMediaType</B> objects.
</TD></TR><TR><TD><A HREF="CMediaType.htm#CMediaType_NOTEQ_Operator">operator !=</A>
 </TD><TD>Tests for inequality between <B>CMediaType</B> objects.
</TD></TR></TABLE>



<H1><A NAME="AllocFormatBuffer">CMediaType::AllocFormatBuffer</A><HR size=1></H1>
<A HREF="CMediaType.htm">CMediaType Class</A>
<P>Allocates a block of memory for the format block.
<P CLASS="ref">Syntax</P><BLOCKQUOTE><PRE>
<P><B>BYTE*</B> <B>AllocFormatBuffer</B><B>(</B><BR>&nbsp;&nbsp;<B>ULONG</B> <I>length</I><BR>&nbsp;&nbsp;<B>)</B><B>;</B>
</PRE></BLOCKQUOTE>

<P CLASS="ref">Parameters</P>
<BLOCKQUOTE>
<DL><DT><I>length</I>
</DT><DD>Size required for the format block.
</DD></DL>
</BLOCKQUOTE>

<P CLASS="ref">Return Value</P>
<BLOCKQUOTE>
<P>Returns a pointer to the new block if successful; otherwise, returns NULL.

</BLOCKQUOTE>

<P CLASS="ref">Remarks</P>
<BLOCKQUOTE>
<P>Any previous format block is deleted and a new block is allocated and installed.
The size required must be nonzero.
</BLOCKQUOTE>


<H1><A NAME="CMediaType_CMediaType">CMediaType::CMediaType</A><HR size=1></H1>
<A HREF="CMediaType.htm">CMediaType Class</A>
<P>Constructs a <A HREF="CMediaType.htm">CMediaType</A> object.
<P CLASS="ref">Syntax</P><BLOCKQUOTE><PRE>
<P><B>CMediaType</B><B>(</B> <B>)</B><B>;</B><BR><B>CMediaType</B><B>(</B><BR>&nbsp;&nbsp;<B>const</B> <B>GUID</B> <B>*</B> <I>majortype</I><BR>&nbsp;&nbsp;<B>)</B><B>;</B><BR><B>CMediaType</B><B>(</B><BR>&nbsp;&nbsp;<B>const</B> <B>AM_MEDIA_TYPE&amp;</B> <I>mtype</I><BR>&nbsp;&nbsp;<B>)</B><B>;</B><BR><B>CMediaType</B><B>(</B><BR>&nbsp;&nbsp;<B>const</B> <B>CMediaType&amp;</B> <I>cmtype</I><BR>&nbsp;&nbsp;<B>)</B><B>;</B>
</PRE></BLOCKQUOTE>

<P CLASS="ref">Parameters</P>
<BLOCKQUOTE>
<DL><DT><I>majortype</I>
 </DT><DD>Major type <A CLASS="Glossary" HREF="javascript:Glossary(sRelPath + 'gloss/gloss_G.htm#GUID')">GUID</A>.
</DD><DT><I>mtype</I>
 </DT><DD><A HREF="../structs.htm#AM_MEDIA_TYPE">AM_MEDIA_TYPE</A> structure.
</DD><DT><I>cmtype</I>
 </DT><DD><A HREF="CMediaType.htm">CMediaType</A> object from which this object is constructed.
</DD></DL>
</BLOCKQUOTE>

<P CLASS="ref">Return Value</P>
<BLOCKQUOTE>
<P>No return value.
</BLOCKQUOTE>

<P CLASS="ref">Remarks</P>
<BLOCKQUOTE>
<P>A <A HREF="CMediaType.htm">CMediaType</A> object can be constructed in a number of different ways.
The class provides a default constructor that takes no parameters. It can also be constructed
based on an <A HREF="../structs.htm#AM_MEDIA_TYPE">AM_MEDIA_TYPE</A> structure or another <B>CMediaType</B> object. In both
cases, it takes a data copy of the format block before returning.
</BLOCKQUOTE>


<H1><A NAME="Format">CMediaType::Format</A><HR size=1></H1>
<A HREF="CMediaType.htm">CMediaType Class</A>
<P>Returns a pointer to the variable-length format block of the object.
<P CLASS="ref">Syntax</P><BLOCKQUOTE><PRE>
<P><B>BYTE*</B> <B>Format</B><B>(</B> <B>)</B> <B>const;</B>
</PRE></BLOCKQUOTE>

<P CLASS="ref">Return Value</P>
<BLOCKQUOTE>
<P>Returns the format block of the object whose content is type-specific.

</BLOCKQUOTE>

<P CLASS="ref">Remarks</P>
<BLOCKQUOTE>
<P>If no format block has been allocated, it might return NULL.
</BLOCKQUOTE>


<H1><A NAME="FormatLength">CMediaType::FormatLength</A><HR size=1></H1>
<A HREF="CMediaType.htm">CMediaType Class</A>
<P>Returns the size, in bytes, of the format block that the object contains.

<P CLASS="ref">Syntax</P>
<BLOCKQUOTE><PRE>
<P><B>ULONG</B> <B>FormatLength</B><B>(</B> <B>)</B> <B>const;</B>
</PRE></BLOCKQUOTE>

<P CLASS="ref">Return Value</P>
<BLOCKQUOTE>
<P>Returns the length of the format block, or NULL if no format block is present.


</BLOCKQUOTE>


<H1><A NAME="FormatType">CMediaType::FormatType</A><HR size=1></H1>
<A HREF="CMediaType.htm">CMediaType Class</A>
<P>Retrieves the format type.

<P CLASS="ref">Syntax</P>
<BLOCKQUOTE><PRE>
<P><B>const</B> <B>GUID</B> <B>*FormatType</B><B>(</B> <B>)</B> <B>const;</B>
</PRE></BLOCKQUOTE>

<P CLASS="ref">Return Value</P>
<BLOCKQUOTE>
<P>Returns a pointer to the format type.


</BLOCKQUOTE>

<P CLASS="ref">Remarks</P>
<BLOCKQUOTE>
<P>The format <A CLASS="Glossary" HREF="javascript:Glossary(sRelPath + 'gloss/gloss_G.htm#GUID')">GUID</A> describes the content of the
variable-length format block. Examples of format types are FORMAT_VideoInfo and
FORMAT_WaveFormatEx.
</BLOCKQUOTE>


<H1><A NAME="GetSampleSize">CMediaType::GetSampleSize</A><HR size=1></H1>
<A HREF="CMediaType.htm">CMediaType Class</A>
<P>Returns the maximum sample size for the data stream.

<P CLASS="ref">Syntax</P>
<BLOCKQUOTE><PRE>
<P><B>ULONG</B> <B>GetSampleSize</B><B>(</B> <B>)</B> <B>const;</B>
</PRE></BLOCKQUOTE>

<P CLASS="ref">Return Value</P>
<BLOCKQUOTE>
<P>Returns the maximum size of any sample to be sent, or zero
to indicate that the sample size is variable.


</BLOCKQUOTE>


<H1><A NAME="InitMediaType">CMediaType::InitMediaType</A><HR size=1></H1>
<A HREF="CMediaType.htm">CMediaType Class</A>
<P>Initializes the sample.

<P CLASS="ref">Syntax</P>
<BLOCKQUOTE><PRE>
<P><B>void</B> <B>InitMediaType</B><B>(</B> <B>)</B><B>;</B>
</PRE></BLOCKQUOTE>

<P CLASS="ref">Return Value</P>
<BLOCKQUOTE>
<P>No return value.
</BLOCKQUOTE>

<P CLASS="ref">Remarks</P>
<BLOCKQUOTE>
<P>This member function clears memory, sets the fixed sample size property, and sets
the sample size to 1.
</BLOCKQUOTE>


<H1><A NAME="IsFixedSize">CMediaType::IsFixedSize</A><HR size=1></H1>
<A HREF="CMediaType.htm">CMediaType Class</A>
<P>Determines if the samples for the stream will be fixed or variable size.

<P CLASS="ref">Syntax</P>
<BLOCKQUOTE><PRE>
<P><B>BOOL</B> <B>IsFixedSize</B><B>(</B> <B>)</B> <B>const;</B>
</PRE></BLOCKQUOTE>

<P CLASS="ref">Return Value</P>
<BLOCKQUOTE>
<P>Returns one of the following values.
<TABLE><TR><TD>TRUE </TD><TD>Samples will be fixed size.
</TD></TR><TR><TD>FALSE </TD><TD>Samples will be variable length.
</TD></TR></TABLE>
</BLOCKQUOTE>


<H1><A NAME="IsPartiallySpecified">CMediaType::IsPartiallySpecified</A><HR size=1></H1>
<A HREF="CMediaType.htm">CMediaType Class</A>
<P>Determines if the media type is only partially defined. This is
the case if the major type or format type is GUID_NULL.

<P CLASS="ref">Syntax</P>
<BLOCKQUOTE><PRE>
<P><B>BOOL</B> <B>IsPartiallySpecified</B><B>(</B> <B>)</B> <B>const;</B>
</PRE></BLOCKQUOTE>

<P CLASS="ref">Return Value</P>
<BLOCKQUOTE>
<P>Returns one of the following values.
<TABLE><TR><TD>TRUE </TD><TD>Media type is partially specified.
</TD></TR><TR><TD>FALSE </TD><TD>Media type is completely specified.
</TD></TR></TABLE>

</BLOCKQUOTE>

<P CLASS="ref">Remarks</P>
<BLOCKQUOTE>
<P>This function does not check the sub type.
</BLOCKQUOTE>


<H1><A NAME="IsTemporalCompressed">CMediaType::IsTemporalCompressed</A><HR size=1></H1>
<A HREF="CMediaType.htm">CMediaType Class</A>
<P>Asks if the stream will be compressed temporally.

<P CLASS="ref">Syntax</P>
<BLOCKQUOTE><PRE>
<P><B>BOOL</B> <B>IsTemporalCompressed</B><B>(</B> <B>)</B> <B>const;</B>
</PRE></BLOCKQUOTE>

<P CLASS="ref">Return Value</P>
<BLOCKQUOTE>
<P>Returns one of the following values.
<TABLE><TR><TD>TRUE </TD><TD>Stream will have temporal compression.
</TD></TR><TR><TD>FALSE </TD><TD>Stream will have no temporal compression.
</TD></TR></TABLE>

</BLOCKQUOTE>

<P CLASS="ref">Remarks</P>
<BLOCKQUOTE>
<P>Some data streams, such as compressed video, have temporal dependencies between
successive samples. Other data streams do not have temporal dependencies between their samples;
that is, each sample can be treated as an independent unit; for example, MIDI.
</BLOCKQUOTE>


<H1><A NAME="IsValid">CMediaType::IsValid</A><HR size=1></H1>
<A HREF="CMediaType.htm">CMediaType Class</A>
<P>Queries whether the object has a valid major type.

<P CLASS="ref">Syntax</P>
<BLOCKQUOTE><PRE>
<P><B>BOOL</B> <B>IsValid</B><B>(</B> <B>)</B> <B>const;</B>
</PRE></BLOCKQUOTE>

<P CLASS="ref">Return Value</P>
<BLOCKQUOTE>
<P>Returns one of the following values.
<TABLE><TR><TD>TRUE </TD><TD><A HREF="CMediaType.htm">CMediaType</A> object has a valid major type.
</TD></TR><TR><TD>FALSE </TD><TD><A HREF="CMediaType.htm">CMediaType</A> object does not have a valid major type.
</TD></TR></TABLE>

</BLOCKQUOTE>

<P CLASS="ref">Remarks</P>
<BLOCKQUOTE>
<P>When <A HREF="CMediaType.htm">CMediaType</A> objects are constructed, their GUIDs are initialized with
GUID_NULL (unless they are constructed based on another <A HREF="../structs.htm#AM_MEDIA_TYPE">AM_MEDIA_TYPE</A>
structure or <B>CMediaType</B> object). This member function is useful
for discovering if the object has been correctly initialized.
</BLOCKQUOTE>


<H1><A NAME="MatchesPartial">CMediaType::MatchesPartial</A><HR size=1></H1>
<A HREF="CMediaType.htm">CMediaType Class</A>
<P>Determines if this media type matches the media type pointed to
by the <I>ppartial</I> parameter.

<P CLASS="ref">Syntax</P>
<BLOCKQUOTE><PRE>
<P><B>BOOL</B> <B>MatchesPartial</B><B>(</B><BR>&nbsp;&nbsp;<B>const</B> <B>CMediaType</B> <I>*ppartial</I><BR>&nbsp;&nbsp;<B>)</B> <B>const;</B>
</PRE></BLOCKQUOTE>

<P CLASS="ref">Parameters</P>
<BLOCKQUOTE>
<DL><DT><I>ppartial</I>
 </DT><DD>Pointer to the media type to match.
</DD></DL>
</BLOCKQUOTE>

<P CLASS="ref">Return Value</P>
<BLOCKQUOTE>
<P>Returns one of the following values.
<TABLE><TR><TD>TRUE </TD><TD>Media types match for the parts that are defined.
</TD></TR><TR><TD>FALSE </TD><TD>Media types do not match.
</TD></TR></TABLE>

</BLOCKQUOTE>

<P CLASS="ref">Remarks</P>
<BLOCKQUOTE>
<P>The matching applies only for the parts of <I>ppartial</I> that are defined.
That is, this only matches the major type, subtype, or format type of the media type if these
are not defined as GUID_NULL.
</BLOCKQUOTE>


<H1><A NAME="ReallocFormatBuffer">CMediaType::ReallocFormatBuffer</A><HR size=1></H1>
<A HREF="CMediaType.htm">CMediaType Class</A>
<P>Reallocates the format block to a new size.
<P CLASS="ref">Syntax</P><BLOCKQUOTE><PRE>
<P><B>BYTE*</B> <B>ReallocFormatBuffer</B><B>(</B><BR>&nbsp;&nbsp;<B>ULONG</B> <I>length</I><BR>&nbsp;&nbsp;<B>)</B><B>;</B>
</PRE></BLOCKQUOTE>

<P CLASS="ref">Parameters</P>
<BLOCKQUOTE>
<DL><DT><I>length</I>
 </DT><DD>New size required for the format block.
</DD></DL>
</BLOCKQUOTE>

<P CLASS="ref">Return Value</P>
<BLOCKQUOTE>
<P>Returns a pointer to the new block if successful; otherwise, returns NULL.


</BLOCKQUOTE>

<P CLASS="ref">Remarks</P>
<BLOCKQUOTE>
<P>Any current format block will be copied into the newly allocated block up to
its maximum size. Any excess will be lost when the new block is smaller than the old one.
When the new block is larger, the excess is not filled with zeros.

<P>The size required must be nonzero.
</BLOCKQUOTE>


<H1><A NAME="ResetFormatBuffer">CMediaType::ResetFormatBuffer</A><HR size=1></H1>
<A HREF="CMediaType.htm">CMediaType Class</A>
<P>Deletes any format block currently held, sets it to NULL, and
sets the size of the format block to zero.

<P CLASS="ref">Syntax</P>
<BLOCKQUOTE><PRE>
<P><B>void</B> <B>ResetFormatBuffer</B><B>(</B> <B>)</B><B>;</B>
</PRE></BLOCKQUOTE>

<P CLASS="ref">Return Value</P>
<BLOCKQUOTE>
<P>No return value.
</BLOCKQUOTE>


<H1><A NAME="SetFormat">CMediaType::SetFormat</A><HR size=1></H1>
<A HREF="CMediaType.htm">CMediaType Class</A>
<P>Sets the variable-length format block.

<P CLASS="ref">Syntax</P>
<BLOCKQUOTE><PRE>
<P><B>BOOL</B> <B>SetFormat</B><B>(</B><BR>&nbsp;&nbsp;<B>BYTE</B> <I>*pFormat</I><B>,</B><BR>&nbsp;&nbsp;<B>ULONG</B> <I>length</I><BR>&nbsp;&nbsp;<B>)</B><B>;</B>
</PRE></BLOCKQUOTE>

<P CLASS="ref">Parameters</P>
<BLOCKQUOTE>
<DL><DT><I>pFormat</I>
 </DT><DD>Block of memory containing type-specific information.
</DD><DT><I>length</I>
 </DT><DD>Overall length of the format block.
</DD></DL>
</BLOCKQUOTE>

<P CLASS="ref">Return Value</P>
<BLOCKQUOTE>
<P>Returns one of the following values.
<TABLE><TR><TD>TRUE </TD><TD>Format block was set.
</TD></TR><TR><TD>FALSE </TD><TD>An error occurred; most likely there was no memory available.
</TD></TR></TABLE>

</BLOCKQUOTE>

<P CLASS="ref">Remarks</P>
<BLOCKQUOTE>
<P>The function takes a copy of the format block and stores that internally.
</BLOCKQUOTE>


<H1><A NAME="SetFormatType">CMediaType::SetFormatType</A><HR size=1></H1>
<A HREF="CMediaType.htm">CMediaType Class</A>
<P>Sets the <A CLASS="Glossary" HREF="javascript:Glossary(sRelPath + 'gloss/gloss_G.htm#GUID')">GUID</A> that describes the content of the format block.

<P CLASS="ref">Syntax</P>
<BLOCKQUOTE><PRE>
<P><B>void</B> <B>SetFormatType</B><B>(</B><BR>&nbsp;&nbsp;<B>const</B> <B>GUID</B> <B>*</B> <I>pformattype</I><BR>&nbsp;&nbsp;<B>)</B><B>;</B>
</PRE></BLOCKQUOTE>

<P CLASS="ref">Parameters</P>
<BLOCKQUOTE>
<DL><DT><I>pformattype</I>
</DT><DD><A CLASS="Glossary" HREF="javascript:Glossary(sRelPath + 'gloss/gloss_G.htm#GUID')">GUID</A> describing the format type.
</DD></DL>
</BLOCKQUOTE>

<P CLASS="ref">Return Value</P>
<BLOCKQUOTE>
<P>No return value.
</BLOCKQUOTE>

<P CLASS="ref">Remarks</P>
<BLOCKQUOTE>
<P>The format <A CLASS="Glossary" HREF="javascript:Glossary(sRelPath + 'gloss/gloss_G.htm#GUID')">GUID</A> describes what can be expected to be found in the
variable-length format block. For example, if the format type is FORMAT_VideoInfo,
the format block should contain a <A HREF="../structs.htm#VIDEOINFOHEADER">VIDEOINFOHEADER</A> structure. The creator of this object is
responsible for making them consistent.
</BLOCKQUOTE>


<H1><A NAME="SetSampleSize">CMediaType::SetSampleSize</A><HR size=1></H1>
<A HREF="CMediaType.htm">CMediaType Class</A>
<P>Sets the maximum sample size for the data stream.

<P CLASS="ref">Syntax</P>
<BLOCKQUOTE><PRE>
<P><B>void</B> <B>SetSampleSize</B><B>(</B><BR>&nbsp;&nbsp;<B>ULONG</B> <I>sz</I><BR>&nbsp;&nbsp;<B>)</B><B>;</B>
</PRE></BLOCKQUOTE>

<P CLASS="ref">Parameters</P>
<BLOCKQUOTE>
<DL><DT><I>sz</I>
 </DT><DD>Size of the sample.
</DD></DL>
</BLOCKQUOTE>

<P CLASS="ref">Return Value</P>
<BLOCKQUOTE>
<P>No return value.
</BLOCKQUOTE>

<P CLASS="ref">Remarks</P>
<BLOCKQUOTE>
<P>If the sample size passed is zero, the object is set so that the data
stream will send variable-length samples (the <A HREF="CMediaType.htm#GetSampleSize">CMediaType::GetSampleSize</A> member
function will return zero). Otherwise, it will set the maximum size of the sample to the size
specified in the <I>sz</I> parameter.
</BLOCKQUOTE>


<H1><A NAME="SetSubtype">CMediaType::SetSubtype</A><HR size=1></H1>
<A HREF="CMediaType.htm">CMediaType Class</A>
<P>Sets the subtype for the object.

<P CLASS="ref">Syntax</P>
<BLOCKQUOTE><PRE>
<P><B>void</B> <B>SetSubtype</B><B>(</B><BR>&nbsp;&nbsp;<B>const</B> <B>GUID</B> <B>*</B> <I>psubtype</I><BR>&nbsp;&nbsp;<B>)</B><B>;</B>
</PRE></BLOCKQUOTE>

<P CLASS="ref">Parameters</P>
<BLOCKQUOTE>
<DL><DT><I>psubtype</I>
 </DT><DD><A CLASS="Glossary" HREF="javascript:Glossary(sRelPath + 'gloss/gloss_G.htm#GUID')">GUID</A> defining the subtype for the object.
</DD></DL>
</BLOCKQUOTE>

<P CLASS="ref">Return Value</P>
<BLOCKQUOTE>
<P>No return value.
</BLOCKQUOTE>


<H1><A NAME="SetTemporalCompression">CMediaType::SetTemporalCompression</A><HR size=1></H1>
<A HREF="CMediaType.htm">CMediaType Class</A>
<P>Marks the media type so that the data stream it describes might or might not
contain temporal compression (according to the input Boolean flag).

<P CLASS="ref">Syntax</P>
<BLOCKQUOTE><PRE>
<P><B>void</B> <B>SetTemporalCompression</B><B>(</B><BR>&nbsp;&nbsp;<B>BOOL</B> <I>bCompressed</I><BR>&nbsp;&nbsp;<B>)</B><B>;</B>
</PRE></BLOCKQUOTE>

<P CLASS="ref">Parameters</P>
<BLOCKQUOTE>
<DL><DT><I>bCompressed</I>
 </DT><DD>TRUE to indicate that the stream will contain temporal compression;
otherwise, FALSE.
</DD></DL>
</BLOCKQUOTE>

<P CLASS="ref">Return Value</P>
<BLOCKQUOTE>
<P>No return value.
</BLOCKQUOTE>


<H1><A NAME="SetType">CMediaType::SetType</A><HR size=1></H1>
<A HREF="CMediaType.htm">CMediaType Class</A>
<P>Sets the major type for the object.

<P CLASS="ref">Syntax</P>
<BLOCKQUOTE><PRE>
<P><B>void</B> <B>SetType</B><B>(</B><BR>&nbsp;&nbsp;<B>const</B> <B>GUID</B> <B>*</B> <I>ptype</I><BR>&nbsp;&nbsp;<B>)</B><B>;</B>
</PRE></BLOCKQUOTE>

<P CLASS="ref">Parameters</P>
<BLOCKQUOTE>
<DL><DT><I>ptype</I>
 </DT><DD><A CLASS="Glossary" HREF="javascript:Glossary(sRelPath + 'gloss/gloss_G.htm#GUID')">GUID</A> defining the major type for the object.
</DD></DL>
</BLOCKQUOTE>

<P CLASS="ref">Return Value</P>
<BLOCKQUOTE>
<P>No return value.
</BLOCKQUOTE>


<H1><A NAME="SetVariableSize">CMediaType::SetVariableSize</A><HR size=1></H1>
<A HREF="CMediaType.htm">CMediaType Class</A>
<P>Sets the media type to indicate that the data stream will send variable-length samples. 

<P CLASS="ref">Syntax</P>
<BLOCKQUOTE><PRE>
<P><B>void</B> <B>SetVariableSize</B><B>(</B> <B>)</B><B>;</B>
</PRE></BLOCKQUOTE>

<P CLASS="ref">Return Value</P>
<BLOCKQUOTE>
<P>No return value.
</BLOCKQUOTE>

<P CLASS="ref">Remarks</P>
<BLOCKQUOTE>
<P>Subsequent calls to <A HREF="CMediaType.htm#GetSampleSize">CMediaType::GetSampleSize</A> will return zero.
</BLOCKQUOTE>


<H1><A NAME="CMediaType_Subtype">CMediaType::Subtype</A><HR size=1></H1>
<A HREF="CMediaType.htm">CMediaType Class</A>
<P>Retrieves the subtype.

<P CLASS="ref">Syntax</P>
<BLOCKQUOTE><PRE>
<P><B>const</B> <B>GUID</B> <B>*Type</B><B>(</B> <B>)</B> <B>const;</B>
</PRE></BLOCKQUOTE>

<P CLASS="ref">Return Value</P>
<BLOCKQUOTE>
<P>Returns a pointer to the subtype.


</BLOCKQUOTE>

<P CLASS="ref">Remarks</P>
<BLOCKQUOTE>
<P>The subtype <A CLASS="Glossary" HREF="javascript:Glossary(sRelPath + 'gloss/gloss_G.htm#GUID')">GUID</A> gives finer detail within the
major type of data represented by this media type.
</BLOCKQUOTE>


<H1><A NAME="Type">CMediaType::Type</A><HR size=1></H1>
<A HREF="CMediaType.htm">CMediaType Class</A>
<P>Retrieves the major type.

<P CLASS="ref">Syntax</P>
<BLOCKQUOTE><PRE>
<P><B>const</B> <B>GUID</B> <B>*Type</B><B>(</B> <B>)</B> <B>const;</B>
</PRE></BLOCKQUOTE>

<P CLASS="ref">Return Value</P>
<BLOCKQUOTE>
<P>Returns a pointer to the major type.


</BLOCKQUOTE>

<P CLASS="ref">Remarks</P>
<BLOCKQUOTE>
<P>The major type <A CLASS="Glossary" HREF="javascript:Glossary(sRelPath + 'gloss/gloss_G.htm#GUID')">GUID</A> describes the class of data
represented by this media type.
</BLOCKQUOTE>


<H1><A NAME="CMediaType_EQ_Operator">CMediaType::operator =</A><HR size=1></H1>
<A HREF="CMediaType.htm">CMediaType Class</A>
<P>The <A HREF="CMediaType.htm">CMediaType</A> variation of this operator is the copy constructor for a <B>CMediaType</B> object.

<P>The <A HREF="../structs.htm#AM_MEDIA_TYPE">AM_MEDIA_TYPE</A> variation of this operator is the copy constructor for an
<B>AM_MEDIA_TYPE</B> object.
<P CLASS="ref">Syntax</P><BLOCKQUOTE><PRE>
<P><B>CMediaType&amp;</B> <B>operator=</B><B>(</B><BR>&nbsp;&nbsp;<B>const</B> <B>CMediaType&amp;</B> <I>rt</I><BR>&nbsp;&nbsp;<B>)</B><B>;</B><BR><B>CMediaType&amp;</B> <B>operator=</B><B>(</B><BR>&nbsp;&nbsp;<B>const</B> <B>AM_MEDIA_TYPE&amp;</B> <I>mrt</I><BR>&nbsp;&nbsp;<B>)</B><B>;</B>
</PRE></BLOCKQUOTE>

<P CLASS="ref">Parameters</P>
<BLOCKQUOTE>
<DL><DT><I>rt</I>
 </DT><DD>Object to copy during the assignment operation.
</DD><DT><I>mrt</I>
 </DT><DD>Object to copy during the assignment operation.
</DD></DL>
</BLOCKQUOTE>

<P CLASS="ref">Return Value</P>
<BLOCKQUOTE>
<P>Returns a reference to this object after the operation.


</BLOCKQUOTE>

<P CLASS="ref">Remarks</P>
<BLOCKQUOTE>
<P>Because the <A HREF="CMediaType.htm">CMediaType</A> class inherits publicly from <A HREF="../structs.htm#AM_MEDIA_TYPE">AM_MEDIA_TYPE</A>,
the compiler could generate the copy constructor for the <B>AM_MEDIA_TYPE</B> object itself.
However, this could introduce some memory conflicts and leaks in the process because
the structure contains a dynamically allocated block
(which the <B>AM_MEDIA_TYPE</B> <A HREF="../structs.htm#pbFormat">pbFormat</A> member points to), which the
compiler's copy constructor will not copy correctly.
</BLOCKQUOTE>


<H1><A NAME="CMediaType_EQTEST_Operator">CMediaType::operator ==</A><HR size=1></H1>
<A HREF="CMediaType.htm">CMediaType Class</A>
<P>Tests for equality between <A HREF="CMediaType.htm">CMediaType</A> objects.

<P CLASS="ref">Syntax</P><BLOCKQUOTE><PRE><B>inline BOOL operator==(const CMediaType&amp;</B> <I>rt</I>) <B>const;</B></PRE></BLOCKQUOTE>

<P CLASS="ref">Parameters</P>
<BLOCKQUOTE>
<DL><DT><I>rt</I>
 </DT><DD><A HREF="CMediaType.htm">CMediaType</A> object corresponding to the right side of the operator.
</DD></DL>
</BLOCKQUOTE>

<P CLASS="ref">Return Value</P>
<BLOCKQUOTE>
<P>Returns TRUE if the <A HREF="CMediaType.htm">CMediaType</A> object tested is equal to
this object; otherwise, returns FALSE.


</BLOCKQUOTE>

<P CLASS="ref">Remarks</P>
<BLOCKQUOTE>
<P>This object is on the left side of the operator.
</BLOCKQUOTE>


<H1><A NAME="CMediaType_NOTEQ_Operator">CMediaType::operator !=</A><HR size=1></H1>
<A HREF="CMediaType.htm">CMediaType Class</A>
<P>Tests for inequality between <A HREF="CMediaType.htm">CMediaType</A> objects.

<P CLASS="ref">Syntax</P>
<BLOCKQUOTE><PRE>
<P><B>BOOL</B> <B>operator!=</B><B>(</B><BR>&nbsp;&nbsp;<B>const</B> <B>CMediaType&amp;</B> <I>rt</I><BR>&nbsp;&nbsp;<B>)</B> <B>const;</B>
</PRE></BLOCKQUOTE>

<P CLASS="ref">Parameters</P>
<BLOCKQUOTE>
<DL><DT><I>rt</I>
 </DT><DD><A HREF="CMediaType.htm">CMediaType</A> object corresponding to the right side of the operator.
</DD></DL>
</BLOCKQUOTE>

<P CLASS="ref">Return Value</P>
<BLOCKQUOTE>
<P>Returns TRUE if the <A HREF="CMediaType.htm">CMediaType</A> object tested is not equal to
this object; otherwise, returns FALSE.


</BLOCKQUOTE>

<P CLASS="ref">Remarks</P>
<BLOCKQUOTE>
<P>This object is on the left side of the operator.

</BLOCKQUOTE>
<!-- CONTENTS_END -->

<!-- START_PAGE_FOOTER -->


<H6><HR size=1></H6>
<P><A Class="line" HREF="#pagetop"><IMG src="../../art/arrowup1.gif" WIDTH="11" HEIGHT="11" ALIGN="MIDDLE" BORDER=0 ALT="Top of Page">&nbsp;Top of Page</A>
<BR><A Class="line" HREF="../../../cpyright.htm">&#169; 1998 Microsoft Corporation. All rights reserved. Terms of Use.</A>
<!-- END_PAGE_FOOTER -->

</BLOCKQUOTE>

<SCRIPT>if((g_isIE == true) && (g_iMaj > 3)) {window.self.document.writeln('<SCR' + 'IPT SRC="../../tip2.js"></SCR' + 'IPT><IFRAME ID="G_L_S" NAME="SecretBuffer" STYLE="display: none" SRC=""></IFRAME>')}</SCRIPT>

<!-- DACONTROL_START -->

	<DIV ID="HeadGraphAnim"></DIV>
	<SCRIPT>if((g_isIE == true) && (g_iMaj > 3)) {window.self.document.writeln('<SCR' + 'IPT SRC="../../anim.js"></SCR' + 'IPT>')}</SCRIPT>
<!-- DACONTROL_END -->

</BODY>
</HTML>
