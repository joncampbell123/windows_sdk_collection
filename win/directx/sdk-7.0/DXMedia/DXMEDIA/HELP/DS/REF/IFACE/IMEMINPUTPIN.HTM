<!-- DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN" -->

<HTML>
<HEAD><TITLE>IMemInputPin Interface</TITLE>
<SCRIPT> var sRelPath = '../../' </SCRIPT>


<META NAME="Description" CONTENT="IMemInputPin Interface">
<META NAME="Description" CONTENT="IMemInputPin::GetAllocator">
<META NAME="Description" CONTENT="IMemInputPin::GetAllocatorRequirements">
<META NAME="Description" CONTENT="IMemInputPin::NotifyAllocator">
<META NAME="Description" CONTENT="IMemInputPin::Receive">
<META NAME="Description" CONTENT="IMemInputPin::ReceiveCanBlock">
<META NAME="Description" CONTENT="IMemInputPin::ReceiveMultiple">
<META NAME="Description" CONTENT="GetAllocator (IMemInputPin)">
<META NAME="Description" CONTENT="GetAllocatorRequirements (IMemInputPin)">
<META NAME="Description" CONTENT="NotifyAllocator (IMemInputPin)">
<META NAME="Description" CONTENT="Receive (IMemInputPin)">
<META NAME="Description" CONTENT="ReceiveCanBlock (IMemInputPin)">
<META NAME="Description" CONTENT="ReceiveMultiple (IMemInputPin)">
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; CHARSET=iso8859-1">
<META NAME="MS.LOCALE" CONTENT="EN-US">
<META NAME="ROBOTS" CONTENT="all">

<!-- SNIFF_START -->

<SCRIPT>
//<!--
var g_isIE = false, g_isNav = false, g_iMaj = 0, g_sPlat = "";
// -->

</SCRIPT>
<SCRIPT SRC="../../ver.js"></SCRIPT>
<SCRIPT SRC="../../gloss.js"></SCRIPT>

<!-- SNIFF_END -->


<SCRIPT DEFER SRC="../../common.js"></SCRIPT>
<SCRIPT DEFER>
//<!--
function InitPage()
{
	if (g_isIE && g_iMaj >= 4)	
	{

		SetTOC();
	}
}
//-->

</SCRIPT>

<!-- SNIFF_END -->


<!-- STYLE_START -->

<SCRIPT>
//<!--
   var sVR = '../../'	// Set root for the style sheet
   var sCSS = '<LINK REL="stylesheet" HREF="' + sVR;

   if(g_isIE)
   {
	   if (g_iMaj >= 4) // For MSIE 4.0 or later
	   {
		   sCSS += 'dxm_basicsdkIE4';
		   if (g_sPlat == "Win") // Windows only for now
		   {
			   document.createStyleSheet(sVR + 'dxm_advSDKIE4.css');
		   }
	   }
	   else // For MSIE 3.0 or earlier
	   {
		   sCSS += 'dxm_basicsdkIE3';
	   }
   }
   else if (g_isNav) // For all Nav versions
   {
	   sCSS += 'dxm_basicsdkNAV';
   }
   else
   {
	   sCSS += 'dxm_basicsdkIE3'; // default to IE3 sheet
   }

   sCSS += (sCSS == '' ? '' : '.css" TYPE="text/css">');

   document.write(sCSS);
//-->

</SCRIPT>
<!-- STYLE_END -->


</HEAD>
<BODY onload="InitPage(); if (g_isIE && g_iMaj >= 4){HdgrphControl()}" BGCOLOR="#FFFFFF">
<A NAME="pagetop"></A><A NAME="IMemInputPin"></A>

<!-- HEADGRAPH_START -->

<TABLE CLASS="main" BORDER=0 CELLSPACING="0" CELLPADDING="0" WIDTH="*">
<TR>
<TD ROWSPAN="3" VALIGN="TOP" WIDTH="*">
<IMG SRC="../../art/header1.gif" WIDTH="107" HEIGHT="110" BORDER=0 ALT="DirectShow Animated Header"></TD>
<TD ROWSPAN="2" VALIGN="TOP" WIDTH="217"><IMG SRC="../../art/hdrdshow.gif" WIDTH="217" HEIGHT="110" BORDER=0 ALT="DirectShow Animated Header"></TD>
<TD VALIGN="TOP" WIDTH="383">
<IMG SRC="../../art/header3.gif" WIDTH="383" HEIGHT="95" BORDER=0 ALT="DirectShow Animated Header">
</TD>
<TD VALIGN="TOP" WIDTH="100%">
<IMG SRC="../../art/spacer1.gif" WIDTH="100%" HEIGHT="94" BORDER=0 ALT="Microsoft DirectShow SDK">
</TD>
</TR>
<!-- HEADGRAPH_END -->

<!-- NAV_LINKS_START -->

<TR><TD VALIGN="TOP"><PRE><IMG ID="TOC_" SRC="../../art/yelbtn.gif" WIDTH="11" HEIGHT="11" ALIGN="MIDDLE" BORDER=0 ALT="*"><A STYLE="color:black;font-weight:bold" ID="TOC" HREF="../../contents.htm">Contents</A>  <IMG SRC="../../art/yelbtn.gif" WIDTH="11" HEIGHT="11" ALIGN="MIDDLE" BORDER=0 ALT="*"><A STYLE="color:black;font-weight:bold" HREF="../../index.htm">Index</A>  <IMG SRC="../../art/yelbtn.gif" WIDTH="11" HEIGHT="11" ALIGN="MIDDLE" BORDER=0 ALT="*"><A STYLE="color:black;font-weight:bold" HREF="ifaces_intro.htm">Topic Contents</A>
</PRE></TD></TR>
<TR><TD COLSPAN="2" VALIGN="TOP"><PRE><IMG SRC="../../art/yelbtn.gif" WIDTH="11" HEIGHT="11" ALIGN="MIDDLE" BORDER=0 ALT="*"><B>Previous Topic:</B> <A STYLE="color:black" HREF="IMemAllocator.htm">IMemAllocator Interface</A>
<IMG SRC="../../art/yelbtn.gif" WIDTH="11" HEIGHT="11" ALIGN="MIDDLE" BORDER=0 ALT="*"><B>Next Topic:</B> <A  STYLE="color:black" HREF="IMixerPinConfig.htm">IMixerPinConfig Interface</A>
</PRE></TD></TR></TABLE>
<!-- NAV_LINKS_END -->


<BLOCKQUOTE CLASS="body">


<!-- CONTENTS_START -->

<H1>IMemInputPin Interface</H1>

<P>The <B>IMemInputPin</B> interface provides <A CLASS="Glossary" HREF="javascript:Glossary(sRelPath + 'gloss/gloss_M.htm#method')">methods</A> on an <A CLASS="Glossary" HREF="javascript:Glossary(sRelPath + 'gloss/gloss_I.htm#input_pin')">input pin</A> to facilitate
passing data and flush notifications from a connected <A CLASS="Glossary" HREF="javascript:Glossary(sRelPath + 'gloss/gloss_O.htm#output_pin')">output pin</A> of an upstream <A CLASS="Glossary" HREF="javascript:Glossary(sRelPath + 'gloss/gloss_f.htm#filter')">filter</A>.

<P CLASS="ref"><A NAME="When_to_Implement">When to Implement</A></P>
<P>Implement this interface on the input <A CLASS="Glossary" HREF="javascript:Glossary(sRelPath + 'gloss/gloss_P.htm#pin')">pin</A> of every filter. The <A HREF="../class/CBaseInputPin.htm#CBaseInputPin">CBaseInputPin</A> class
implements this interface.

<P CLASS="ref"><A NAME="When_to_Use">When to Use</A></P>
<P>A connected output pin uses this interface to retrieve an <A HREF="IMemAllocator.htm">IMemAllocator</A>
interface, to pass media samples to the input pin, and to flush pending buffers downstream.

<P CLASS="ref"><A NAME="Methods_in_Vtable_Or">Methods in Vtable Order</A></P>
<TABLE>
<TR><TH>IUnknown methods</TH><TH>Description</TH></TR><TR><TD><A HREF="IUnknown.htm#QueryInterface">QueryInterface</A> </TD><TD>Returns pointers to supported interfaces.
</TD></TR><TR><TD><A HREF="IUnknown.htm#AddRef">AddRef</A> </TD><TD>Increments the reference count.
</TD></TR><TR><TD><A HREF="IUnknown.htm#Release">Release</A> </TD><TD>Decrements the reference count.
</TD></TR><TR></TR>
<TR><TH>IMemInputPin methods</TH><TH>Description</TH></TR><TR><TD><A HREF="IMemInputPin.htm#GetAllocator">GetAllocator</A>
</TD><TD>Returns the allocator interface that this input pin proposes as the interface
for the output pin to use.
</TD></TR><TR><TD><A HREF="IMemInputPin.htm#NotifyAllocator">NotifyAllocator</A>
</TD><TD>Notifies the input pin as to which allocator the output pin is actually going to use.
</TD></TR><TR><TD><A HREF="IMemInputPin.htm#GetAllocatorRequirements">GetAllocatorRequirements</A>
</TD><TD>Optional method to use if the filter has specific alignment or prefix requirements but
could use an upstream allocator.
</TD></TR><TR><TD><A HREF="IMemInputPin.htm#Receive">Receive</A>
</TD><TD>Receives the next block of data from the stream.
</TD></TR><TR><TD><A HREF="IMemInputPin.htm#ReceiveMultiple">ReceiveMultiple</A>
</TD><TD>Receives the next block of data from the stream. This method behaves similarly to the
<A HREF="IMemInputPin.htm#Receive">IMemInputPin::Receive</A> method, but it works with multiple samples.
</TD></TR><TR><TD><A HREF="IMemInputPin.htm#ReceiveCanBlock">ReceiveCanBlock</A>
</TD><TD>Determines if sending the <A HREF="IMemInputPin.htm#Receive">IMemInputPin::Receive</A> method might block.
</TD></TR></TABLE>



<H1><A NAME="GetAllocator">IMemInputPin::GetAllocator</A><HR size=1></H1>
<A HREF="IMemInputPin.htm">IMemInputPin Interface</A>
<P>Returns the allocator interface that this input pin proposes as the interface for the
output pin to use.

<P CLASS="ref">Syntax</P><BLOCKQUOTE><PRE>
<P><B>HRESULT</B> <B>GetAllocator</B><B>(</B><BR>&nbsp;&nbsp;<B>IMemAllocator</B> <B>**</B> <I>ppAllocator</I><BR>&nbsp;&nbsp;<B>)</B><B>;</B></PRE></BLOCKQUOTE>

<P CLASS="ref">Parameters</P>
<BLOCKQUOTE>
<DL><DT><I>ppAllocator</I>
</DT><DD>[out] Pointer to an obtained <A HREF="IMemAllocator.htm">IMemAllocator</A> object.
</DD></DL>

</BLOCKQUOTE>
<P CLASS="ref">Return Value</P>
<BLOCKQUOTE>
<P>Returns an <A HREF="../Error_Success_Codes.htm#HRESULT">HRESULT</A> value that depends on the implementation. <B>HRESULT</B> can be one of the following standard constants, or other values not listed.
<TABLE>
<TR><TD>E_FAIL </TD><TD>Failure.
</TD></TR><TR><TD>E_POINTER </TD><TD>Null pointer argument.
</TD></TR><TR><TD>E_INVALIDARG </TD><TD>Invalid argument.
</TD></TR><TR><TD>E_NOTIMPL </TD><TD>Method isn't supported.
</TD></TR><TR><TD>S_OK or NOERROR </TD><TD>Success.
</TD></TR></TABLE>

</BLOCKQUOTE>


<H1><A NAME="GetAllocatorRequirements">IMemInputPin::GetAllocatorRequirements</A><HR size=1></H1>
<A HREF="IMemInputPin.htm">IMemInputPin Interface</A>
<P>Optional method to suggest specific alignment or prefix requirements to an <A CLASS="Glossary" HREF="javascript:Glossary(sRelPath + 'gloss/gloss_U.htm#upstream_filter')">upstream filter</A>.

<P CLASS="ref">Syntax</P><BLOCKQUOTE><PRE>
<P><B>HRESULT</B> <B>GetAllocatorRequirements</B><B>(</B><BR>&nbsp;&nbsp;<B>ALLOCATOR_PROPERTIES</B> <B>*</B> <I>pProps</I><BR>&nbsp;&nbsp;<B>)</B><B>;</B></PRE></BLOCKQUOTE>

<P CLASS="ref">Parameters</P>
<BLOCKQUOTE>
<DL><DT><I>pProps</I>
</DT><DD>[in] <A HREF="../structs.htm#ALLOCATOR_PROPERTIES">ALLOCATOR_PROPERTIES</A> structure containing the required size,
count, and alignment of the allocator.
</DD></DL>

</BLOCKQUOTE>
<P CLASS="ref">Return Value</P>
<BLOCKQUOTE>
<P>Returns an <A HREF="../Error_Success_Codes.htm#HRESULT">HRESULT</A> value. Returns E_NOTIMPL if not implemented.


</BLOCKQUOTE>
<P CLASS="ref">Remarks</P>


<BLOCKQUOTE>

<P><A CLASS="Glossary" HREF="javascript:Glossary(sRelPath + 'gloss/gloss_S.htm#source_filter')">Source filters</A> that insist on their own allocator may use this
method downstream to accommodate <A CLASS="Glossary" HREF="javascript:Glossary(sRelPath + 'gloss/gloss_D.htm#downstream_filter')">downstream filters'</A> memory
requirements for performance benefits.
</BLOCKQUOTE>


<H1><A NAME="NotifyAllocator">IMemInputPin::NotifyAllocator</A><HR size=1></H1>
<A HREF="IMemInputPin.htm">IMemInputPin Interface</A>
<P>Notifies the input pin as to which allocator the output pin is actually going to use.

<P CLASS="ref">Syntax</P><BLOCKQUOTE><PRE>
<P><B>HRESULT</B> <B>NotifyAllocator</B><B>(</B><BR>&nbsp;&nbsp;<B>IMemAllocator</B> <B>*</B> <I>pAllocator</I><B>,</B><BR>&nbsp;&nbsp;<B>BOOL</B> <I>bReadOnly</I><BR>&nbsp;&nbsp;<B>)</B><B>;</B></PRE></BLOCKQUOTE>

<P CLASS="ref">Parameters</P>
<BLOCKQUOTE>
<DL><DT><I>pAllocator</I>
</DT><DD>[in] Pointer to the <A HREF="IMemAllocator.htm">IMemAllocator</A> object to use. This might or might not
be the same <B>IMemAllocator</B> object that the input pin provided in the
<A HREF="IMemInputPin.htm#GetAllocator">IMemInputPin::GetAllocator</A> method (the output pin could provide its
own allocator).
</DD><DT><I>bReadOnly</I>
</DT><DD>[out] Flag to indicate if the samples from this allocator are read-only.
</DD></DL>

</BLOCKQUOTE>
<P CLASS="ref">Return Value</P>
<BLOCKQUOTE>
<P>Returns an <A HREF="../Error_Success_Codes.htm#HRESULT">HRESULT</A> value that depends on the implementation. <B>HRESULT</B> can be one of the following standard constants, or other values not listed.
<TABLE>
<TR><TD>E_FAIL </TD><TD>Failure.
</TD></TR><TR><TD>E_POINTER </TD><TD>Null pointer argument.
</TD></TR><TR><TD>E_INVALIDARG </TD><TD>Invalid argument.
</TD></TR><TR><TD>E_NOTIMPL </TD><TD>Method isn't supported.
</TD></TR><TR><TD>S_OK or NOERROR </TD><TD>Success.
</TD></TR></TABLE>


</BLOCKQUOTE>
<P CLASS="ref">Remarks</P>


<BLOCKQUOTE>

<P>This method is called by the connecting output pin to notify the pin on
which this interface is implemented of the allocator it chooses to use for transporting
media samples. If the <I>bReadOnly</I> parameter is TRUE, all samples in the allocator
are read-only and a copy must be made before modifying any of them.
</BLOCKQUOTE>


<H1><A NAME="Receive">IMemInputPin::Receive</A><HR size=1></H1>
<A HREF="IMemInputPin.htm">IMemInputPin Interface</A>
<P>Receives the next block of data from the stream.

<P CLASS="ref">Syntax</P><BLOCKQUOTE><PRE>
<P><B>HRESULT</B> <B>Receive</B><B>(</B><BR>&nbsp;&nbsp;<B>IMediaSample</B> <B>*</B> <I>pSample</I><BR>&nbsp;&nbsp;<B>)</B><B>;</B></PRE></BLOCKQUOTE>

<P CLASS="ref">Parameters</P>
<BLOCKQUOTE>
<DL><DT><I>pSample</I>
</DT><DD>[in] Pointer to a media sample.
</DD></DL>

</BLOCKQUOTE>
<P CLASS="ref">Return Value</P>
<BLOCKQUOTE>
<P>Returns an <A HREF="../Error_Success_Codes.htm#HRESULT">HRESULT</A> value that depends on the implementation. <B>HRESULT</B> can be one of the following standard constants, or other values not listed.
<TABLE>
<TR><TD>E_FAIL </TD><TD>Failure.
</TD></TR><TR><TD>E_POINTER </TD><TD>Null pointer argument.
</TD></TR><TR><TD>E_INVALIDARG </TD><TD>Invalid argument.
</TD></TR><TR><TD>E_NOTIMPL </TD><TD>Method isn't supported.
</TD></TR><TR><TD>S_OK or NOERROR </TD><TD>Success.
</TD></TR></TABLE>


</BLOCKQUOTE>
<P CLASS="ref">Remarks</P>


<BLOCKQUOTE>

<P>This is a blocking synchronous call. Typically, no blocking occurs, but
if a filter cannot process the sample immediately it may use the calling application's thread
to wait until it can.

<P>Use the <A HREF="IUnknown.htm#AddRef">IUnknown::AddRef</A> method if you need to hold the returned data block
beyond the completion of the <B>IMemInputPin::Receive</B>
method. If you use <A HREF="IUnknown.htm#AddRef">AddRef</A>, be sure to use
<A HREF="IUnknown.htm#Release">IUnknown::Release</A> when done with it.
</BLOCKQUOTE>


<H1><A NAME="ReceiveCanBlock">IMemInputPin::ReceiveCanBlock</A><HR size=1></H1>
<A HREF="IMemInputPin.htm">IMemInputPin Interface</A>
<P>Determines if the implementation of the
<A HREF="IMemInputPin.htm#Receive">IMemInputPin::Receive</A> method might block
on the connected output pin.

<P CLASS="ref">Syntax</P><BLOCKQUOTE><PRE>
<P><B>HRESULT</B> <B>ReceiveCanBlock</B><B>(</B><B>void</B><B>)</B><B>;</B>
</PRE></BLOCKQUOTE>
<P CLASS="ref">Return Value</P>
<BLOCKQUOTE>
<P>Can return any <A HREF="../Error_Success_Codes.htm#HRESULT">HRESULT</A> value. The following specific success values can be returned.
<TABLE>
<TR><TD>S_FALSE </TD><TD>Input pin will not block on a <A HREF="IMemInputPin.htm#Receive">Receive</A>
method.
</TD></TR><TR><TD>S_OK </TD><TD>Input pin might block on a <A HREF="IMemInputPin.htm#Receive">Receive</A>
method.
</TD></TR></TABLE>


</BLOCKQUOTE>
<P CLASS="ref">Remarks</P>


<BLOCKQUOTE>

<P>An output pin from a filter might require notification if its thread might be blocked
when it calls the <A HREF="IMemInputPin.htm#Receive">Receive</A> method on the connected input pin.
For example, a source filter might prefer to keep reading and buffering data rather than to be
blocked, and may choose to start another thread to wait on the blocking
<B>Receive</B> method.

<P>If your implementation of <A HREF="IMemInputPin.htm#Receive">Receive</A> calls a downstream
filter's <B>Receive</B> method on the same thread,
the application will block if that filter blocks, and this method must indicate that.
</BLOCKQUOTE>


<H1><A NAME="ReceiveMultiple">IMemInputPin::ReceiveMultiple</A><HR size=1></H1>
<A HREF="IMemInputPin.htm">IMemInputPin Interface</A>
<P>Returns the next block of data from the stream. This method behaves much like the
<A HREF="IMemInputPin.htm#Receive">IMemInputPin::Receive</A> method, but it works with
multiple samples.

<P CLASS="ref">Syntax</P><BLOCKQUOTE><PRE>
<P><B>HRESULT</B> <B>ReceiveMultiple</B><B>(</B><BR>&nbsp;&nbsp;<B>IMediaSample</B> <B>**</B> <I>pSamples</I><B>,</B><BR>&nbsp;&nbsp;<B>long</B> <I>nSamples</I><B>,</B><BR>&nbsp;&nbsp;<B>long</B> <B>*</B> <I>nSamplesProcessed</I><BR>&nbsp;&nbsp;<B>)</B><B>;</B></PRE></BLOCKQUOTE>

<P CLASS="ref">Parameters</P>
<BLOCKQUOTE>
<DL><DT><I>pSamples</I>
</DT><DD>[in] Pointer to an array of samples.
</DD><DT><I>nSamples</I>
</DT><DD>[in] Number of samples to process.
</DD><DT><I>nSamplesProcessed</I>
</DT><DD>[out] Number of samples processed.
</DD></DL>

</BLOCKQUOTE>
<P CLASS="ref">Return Value</P>
<BLOCKQUOTE>
<P>Returns an <A HREF="../Error_Success_Codes.htm#HRESULT">HRESULT</A> value that depends on the implementation. <B>HRESULT</B> can be one of the following standard constants, or other values not listed.
<TABLE>
<TR><TD>E_FAIL </TD><TD>Failure.
</TD></TR><TR><TD>E_POINTER </TD><TD>Null pointer argument.
</TD></TR><TR><TD>E_INVALIDARG </TD><TD>Invalid argument.
</TD></TR><TR><TD>E_NOTIMPL </TD><TD>Method isn't supported.
</TD></TR><TR><TD>S_OK or NOERROR </TD><TD>Success.
</TD></TR></TABLE>


</BLOCKQUOTE>
<P CLASS="ref">Remarks</P>


<BLOCKQUOTE>

<P>This method allows a connected output pin to deliver multiple samples at one time.
Use it if, like <A HREF="../class/COutputQueue.htm#COutputQueue">COutputQueue</A>, the output pin batches samples for delivery
together. Implement this if your filter can handle batched samples more efficiently
than individual samples. The base class implementation of this method simply
calls <A HREF="IMemInputPin.htm#Receive">IMemInputPin::Receive</A> repeatedly. Override this implementation if you can
do something more efficiently in your derived class.

</BLOCKQUOTE>
<!-- CONTENTS_END -->

<!-- START_PAGE_FOOTER -->


<H6><HR size=1></H6>
<P><A Class="line" HREF="#pagetop"><IMG src="../../art/arrowup1.gif" WIDTH="11" HEIGHT="11" ALIGN="MIDDLE" BORDER=0 ALT="Top of Page">&nbsp;Top of Page</A>
<BR><A Class="line" HREF="../../../cpyright.htm">&#169; 1998 Microsoft Corporation. All rights reserved. Terms of Use.</A>
<!-- END_PAGE_FOOTER -->

</BLOCKQUOTE>

<SCRIPT>if((g_isIE == true) && (g_iMaj > 3)) {window.self.document.writeln('<SCR' + 'IPT SRC="../../tip2.js"></SCR' + 'IPT><IFRAME ID="G_L_S" NAME="SecretBuffer" STYLE="display: none" SRC=""></IFRAME>')}</SCRIPT>

<!-- DACONTROL_START -->

	<DIV ID="HeadGraphAnim"></DIV>
	<SCRIPT>if((g_isIE == true) && (g_iMaj > 3)) {window.self.document.writeln('<SCR' + 'IPT SRC="../../anim.js"></SCR' + 'IPT>')}</SCRIPT>
<!-- DACONTROL_END -->

</BODY>
</HTML>
