<!-- DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN" -->

<HTML>
<HEAD><TITLE>IAMStreamControl Interface</TITLE>
<SCRIPT> var sRelPath = '../../' </SCRIPT>


<META NAME="Description" CONTENT="IAMStreamControl Interface">
<META NAME="Description" CONTENT="IAMStreamControl::GetInfo">
<META NAME="Description" CONTENT="IAMStreamControl::StartAt">
<META NAME="Description" CONTENT="IAMStreamControl::StopAt">
<META NAME="Description" CONTENT="GetInfo (IAMStreamControl)">
<META NAME="Description" CONTENT="StartAt (IAMStreamControl)">
<META NAME="Description" CONTENT="StopAt (IAMStreamControl)">
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; CHARSET=iso8859-1">
<META NAME="MS.LOCALE" CONTENT="EN-US">
<META NAME="ROBOTS" CONTENT="all">

<!-- SNIFF_START -->

<SCRIPT>
//<!--
var g_isIE = false, g_isNav = false, g_iMaj = 0, g_sPlat = "";
// -->

</SCRIPT>
<SCRIPT SRC="../../ver.js"></SCRIPT>
<SCRIPT SRC="../../gloss.js"></SCRIPT>

<!-- SNIFF_END -->


<SCRIPT DEFER SRC="../../common.js"></SCRIPT>
<SCRIPT DEFER>
//<!--
function InitPage()
{
	if (g_isIE && g_iMaj >= 4)	
	{

		SetTOC();
	}
}
//-->

</SCRIPT>

<!-- SNIFF_END -->


<!-- STYLE_START -->

<SCRIPT>
//<!--
   var sVR = '../../'	// Set root for the style sheet
   var sCSS = '<LINK REL="stylesheet" HREF="' + sVR;

   if(g_isIE)
   {
	   if (g_iMaj >= 4) // For MSIE 4.0 or later
	   {
		   sCSS += 'dxm_basicsdkIE4';
		   if (g_sPlat == "Win") // Windows only for now
		   {
			   document.createStyleSheet(sVR + 'dxm_advSDKIE4.css');
		   }
	   }
	   else // For MSIE 3.0 or earlier
	   {
		   sCSS += 'dxm_basicsdkIE3';
	   }
   }
   else if (g_isNav) // For all Nav versions
   {
	   sCSS += 'dxm_basicsdkNAV';
   }
   else
   {
	   sCSS += 'dxm_basicsdkIE3'; // default to IE3 sheet
   }

   sCSS += (sCSS == '' ? '' : '.css" TYPE="text/css">');

   document.write(sCSS);
//-->

</SCRIPT>
<!-- STYLE_END -->


</HEAD>
<BODY onload="InitPage(); if (g_isIE && g_iMaj >= 4){HdgrphControl()}" BGCOLOR="#FFFFFF">
<A NAME="pagetop"></A><A NAME="IAMStreamControl"></A>

<!-- HEADGRAPH_START -->

<TABLE CLASS="main" BORDER=0 CELLSPACING="0" CELLPADDING="0" WIDTH="*">
<TR>
<TD ROWSPAN="3" VALIGN="TOP" WIDTH="*">
<IMG SRC="../../art/header1.gif" WIDTH="107" HEIGHT="110" BORDER=0 ALT="DirectShow Animated Header"></TD>
<TD ROWSPAN="2" VALIGN="TOP" WIDTH="217"><IMG SRC="../../art/hdrdshow.gif" WIDTH="217" HEIGHT="110" BORDER=0 ALT="DirectShow Animated Header"></TD>
<TD VALIGN="TOP" WIDTH="383">
<IMG SRC="../../art/header3.gif" WIDTH="383" HEIGHT="95" BORDER=0 ALT="DirectShow Animated Header">
</TD>
<TD VALIGN="TOP" WIDTH="100%">
<IMG SRC="../../art/spacer1.gif" WIDTH="100%" HEIGHT="94" BORDER=0 ALT="Microsoft DirectShow SDK">
</TD>
</TR>
<!-- HEADGRAPH_END -->

<!-- NAV_LINKS_START -->

<TR><TD VALIGN="TOP"><PRE><IMG ID="TOC_" SRC="../../art/yelbtn.gif" WIDTH="11" HEIGHT="11" ALIGN="MIDDLE" BORDER=0 ALT="*"><A STYLE="color:black;font-weight:bold" ID="TOC" HREF="../../contents.htm">Contents</A>  <IMG SRC="../../art/yelbtn.gif" WIDTH="11" HEIGHT="11" ALIGN="MIDDLE" BORDER=0 ALT="*"><A STYLE="color:black;font-weight:bold" HREF="../../index.htm">Index</A>  <IMG SRC="../../art/yelbtn.gif" WIDTH="11" HEIGHT="11" ALIGN="MIDDLE" BORDER=0 ALT="*"><A STYLE="color:black;font-weight:bold" HREF="ifaces_intro.htm">Topic Contents</A>
</PRE></TD></TR>
<TR><TD COLSPAN="2" VALIGN="TOP"><PRE><IMG SRC="../../art/yelbtn.gif" WIDTH="11" HEIGHT="11" ALIGN="MIDDLE" BORDER=0 ALT="*"><B>Previous Topic:</B> <A STYLE="color:black" HREF="IAMStreamConfig.htm">IAMStreamConfig Interface</A>
<IMG SRC="../../art/yelbtn.gif" WIDTH="11" HEIGHT="11" ALIGN="MIDDLE" BORDER=0 ALT="*"><B>Next Topic:</B> <A  STYLE="color:black" HREF="IAMStreamSelect.htm">IAMStreamSelect Interface</A>
</PRE></TD></TR></TABLE>
<!-- NAV_LINKS_END -->


<BLOCKQUOTE CLASS="body">


<!-- CONTENTS_START -->

<H1>IAMStreamControl Interface</H1>
<P>The <B>IAMStreamControl</B> interface is exposed on input and <A CLASS="Glossary" HREF="javascript:Glossary(sRelPath + 'gloss/gloss_O.htm#output_pin')">output pins</A> on any <A CLASS="Glossary" HREF="javascript:Glossary(sRelPath + 'gloss/gloss_f.htm#filter')">filter</A> in a <A CLASS="Glossary" HREF="javascript:Glossary(sRelPath + 'gloss/gloss_F.htm#filter_graph')">filter graph</A>. This interface exposes methods that allow applications to control individual stream components in a filter graph. You can turn various streams on or off without affecting the rest of the graph. For example, you can turn off an audio stream while a video stream continues, for muting. Or a capture stream can be turned off while preview continues to flow. This interface also assists in frame accuracy when exact capture start or stop times are important.

<P>Currently, the <A HREF="../class/CBaseStreamControl.htm#CBaseStreamControl">CBaseStreamControl</A> base class implements <B>IAMStreamControl</B>. <B>CBaseStreamControl</B> enables the user to specify start and stop times in the <A HREF="../class/CBaseStreamControl.htm#StartAt">CBaseStreamControl::StartAt</A> and <A HREF="../class/CBaseStreamControl.htm#StopAt">CBaseStreamControl::StopAt</A> member functions and provides stream information in the <A HREF="../class/CBaseStreamControl.htm#GetInfo">CBaseStreamControl::GetInfo</A> member function. <B>CBaseStreamControl</B> uses the <A HREF="../dtypes.htm#StreamControlState">StreamControlState</A> enumerated data type to describe the various states a stream is in. A flowing stream is indicated by the STREAM_FLOWING setting; otherwise it is in a discarding state indicated by the STREAM_DISCARDING setting. See <B>StreamControlState</B> for more details on stream states.

<P>If you want to implement this interface on your own your class should typically inherit from <A HREF="../class/CBaseStreamControl.htm#CBaseStreamControl">CBaseStreamControl</A> to obtain an implementation of the <A HREF="../class/CBaseStreamControl.htm#StartAt">CBaseStreamControl::StartAt</A>, <A HREF="../class/CBaseStreamControl.htm#StopAt">CBaseStreamControl::StopAt</A>, and <A HREF="../class/CBaseStreamControl.htm#GetInfo">CBaseStreamControl::GetInfo</A> methods. The <B>CBaseStreamControl</B> class also maintains state information and makes decisions about what to do with the sample. Developers implementing their own filters with pins that support <B>IAMStreamControl</B> through the <B>CBaseStreamControl</B> base class must follow certain guidelines outlined in the <B>CBaseStreamControl</B> documentation.

<P><B>Note</B> There must be a clock in the filter graph or the stream control methods might not function as expected.

<P>This interface is not available on the preview <A CLASS="Glossary" HREF="javascript:Glossary(sRelPath + 'gloss/gloss_P.htm#pin')">pin</A> of capture cards with hardware overlay. Calling <A HREF="IUnknown.htm#QueryInterface">QueryInterface</A> for this interface will return the error E_NOINTERFACE (0x80004002).

<P CLASS="ref"><A NAME="When_to_Implement">When to Implement</A></P>

<P>Implement on input or output pins of filters when you want precise control of the data stream. This interface enables you to turn off portions of the filter graph's streams at specific times without affecting the rest of the graph. Although this interface can be used throughout the graph, the output pins of audio and video capture filters and <A CLASS="Glossary" HREF="javascript:Glossary(sRelPath + 'gloss/gloss_I.htm#input_pin')">input pins</A> of multiplexer filters primarily use it.

<P>If you are writing a filter that will implement <A HREF="IAMStreamControl.htm">IAMStreamControl</A> on one of its pins, you should set the STREAM_DISCARDING state so that the pin discards media samples in a timely fashion, rather than as soon as they are received. This means that if your pin is discarding samples as soon as it determines they are outside the time that the pin is supposed to be on, it will discard samples as fast as possible and the whole file could potentially be pushed into your filter and discarded in mere moments. This causes problems if the pin tries to call <A HREF="IAMStreamControl.htm#StartAt">IAMStreamControl::StartAt</A> at a later point in time because the entire file will have already been discarded. To avoid pins from dumping media samples as fast possible, your code should check the media sample's timestamp and wait until the <A CLASS="Glossary" HREF="javascript:Glossary(sRelPath + 'gloss/gloss_R.htm#reference_clock')">reference clock</A> verifies that the end of the sample's time has actually occurred before discarding. This is known as discarding in a timely fashion (see <A HREF="../class/CBaseStreamControl.htm#CBaseStreamControl">CBaseStreamControl</A> for an implementation that does this).
 
<P CLASS="ref"><A NAME="When_to_Use">When to Use</A></P>

<P>Use this interface to turn on or off certain portions of the filter graph's streams while other portions continue to process data. For example, your application can tell a video capture filter's output pin precisely when to start or stop capturing, independent of what is happening in the rest of the graph. This assists in frame accuracy when exact capture start or stop times are important.


<P><B>Note</B> If you are using this interface to control capture in a graph
that is capturing audio and video to an AVI file through an AVI multiplexor
filter (or other similar scenario), stream control will only work if the
AVI multiplexor is not interleaving. If you use the
<A HREF="iconfiginterleaving.htm#put_Mode">IConfigInterleaving::put_Mode</A> method to interleave the streams
(either <A HREF="../dtypes.htm#InterleavingMode">INTERLEAVE_CAPTURE</A> or <A HREF="../dtypes.htm#InterleavingMode">INTERLEAVE_FULL</A>) then the multiplexor needs
both streams to be on at the same time to interleave the data, and using the
stream control interface to start and stop streams individually will interfere
with the capture and it will not work.


<P CLASS="ref"><A NAME="Methods_in_Vtable_Or">Methods in Vtable Order</A></P>

<TABLE>
<TR><TH>IUnknown methods</TH><TH>Description</TH></TR><TR><TD><A HREF="IUnknown.htm#QueryInterface">QueryInterface</A>
 </TD><TD>Retrieves pointers to supported interfaces.
 </TD></TR><TR><TD><A HREF="IUnknown.htm#AddRef">AddRef</A>
 </TD><TD>Increments the reference count.
 </TD></TR><TR><TD><A HREF="IUnknown.htm#Release">Release</A>
 </TD><TD>Decrements the reference count.
</TD></TR><TR></TR>
<TR><TH>IAMStreamControl methods</TH><TH>Description</TH></TR>
<TR><TD><A HREF="IAMStreamControl.htm#StartAt">StartAt</A>
 </TD><TD>Informs the pin when to start sending streaming data.
 </TD></TR><TR><TD><A HREF="IAMStreamControl.htm#StopAt">StopAt</A>
 </TD><TD>Informs the pin when to suspend processing and supplying data.
 </TD></TR><TR><TD><A HREF="IAMStreamControl.htm#GetInfo">GetInfo</A>
 </TD><TD>Retrieves information about the current streaming settings.
</TD></TR></TABLE>


<H1><A NAME="GetInfo">IAMStreamControl::GetInfo</A><HR size=1></H1>
<A HREF="IAMStreamControl.htm">IAMStreamControl Interface</A>
<P>Retrieves information about the current streaming settings.
<P CLASS="ref">Syntax</P><BLOCKQUOTE><PRE><P><B>HRESULT</B> <B>GetInfo</B><B>(</B><BR>&nbsp;&nbsp;<B>AM_STREAM_INFO</B> <I>*pInfo</I><BR>&nbsp;&nbsp;<B>)</B><B>;</B><BR></PRE></BLOCKQUOTE>
<P CLASS="ref">Parameters</P>
<BLOCKQUOTE><DL><DT><I>pInfo</I>
 </DT><DD>[out] Pointer to an <A HREF="../structs.htm#AM_STREAM_INFO">AM_STREAM_INFO</A> structure that contains current stream settings.
</DD></DL></BLOCKQUOTE>

<P CLASS="ref">Return Value</P>
<BLOCKQUOTE><P>Returns an <A HREF="../Error_Success_Codes.htm#HRESULT">HRESULT</A> value that depends on the implementation of the interface.</BLOCKQUOTE> 


<P CLASS="ref">Remarks</P>
<BLOCKQUOTE><P>Call this method to discover the state of the <A HREF="../dtypes.htm#StreamControlState">StreamControlState</A> enumerated data type, which indicates the stream's state. Other values in the <A HREF="../structs.htm#AM_STREAM_INFO">AM_STREAM_INFO</A> structure include start time, stop time, start cookie, and stop cookie.</BLOCKQUOTE>


<H1><A NAME="StartAt">IAMStreamControl::StartAt</A><HR size=1></H1>
<A HREF="IAMStreamControl.htm">IAMStreamControl Interface</A>
<P>Informs the pin when to start sending streaming data.
<P CLASS="ref">Syntax</P><BLOCKQUOTE><PRE><P><B>HRESULT</B> <B>StartAt</B><B>(</B><BR>&nbsp;&nbsp;<B>const</B> <B>REFERENCE_TIME</B> <B>*</B> <I>ptStart</I><B>,</B><BR>&nbsp;&nbsp;<B>DWORD</B> <I>dwCookie</I> <B>)</B><B>;</B><BR></PRE></BLOCKQUOTE>
<P CLASS="ref">Parameters</P>
<BLOCKQUOTE><DL><DT><I>ptStart</I>
 </DT><DD>[in] Time at which to start streaming as specified in the <A HREF="IReferenceClock.htm#REFERENCE_TIME">REFERENCE_TIME</A> structure. If NULL, start immediately (no notification); if MAX_TIME, start canceled and will have no effect.
</DD><DT><I>dwCookie</I>
 </DT><DD>[in] Specifies a particular value to be sent with the notification when the start occurs. (Only used if <I>ptStart</I> is non-NULL or MAX_TIME).
</DD></DL></BLOCKQUOTE>

<P CLASS="ref">Return Value</P>
<BLOCKQUOTE><P>Returns an <A HREF="../Error_Success_Codes.htm#HRESULT">HRESULT</A> value that depends on the implementation of the interface.</BLOCKQUOTE> 

<P CLASS="ref">Remarks</P>
<BLOCKQUOTE><P>Streams are enabled by default, so this method will have no effect unless a previous <A HREF="IAMStreamControl.htm#StopAt">StopAt</A> member function has been called. 

<P>If the pointer to the <A HREF="IReferenceClock.htm#REFERENCE_TIME">REFERENCE_TIME</A> is not NULL or MAX_TIME, then pins should signal <A HREF="../Event_Notification_Codes.htm#EC_STREAM_CONTROL_STARTED">EC_STREAM_CONTROL_STARTED</A> with an <A HREF="IPin.htm">IPin</A> pointer and the cookie specified in the <I>dwCookie</I> parameter. This enables applications to tie the events back to their requests. If the <I>ptStart</I> pointer is NULL or MAX_TIME, then the filter graph sends no event.

<P>If start and stop are scheduled for a single point in time, the effect is as if the start occurred an infinitesimal time before the stop. You can use this to capture a single frame.</BLOCKQUOTE>


<H1><A NAME="StopAt">IAMStreamControl::StopAt</A><HR size=1></H1>
<A HREF="IAMStreamControl.htm">IAMStreamControl Interface</A>
<P>Informs the pin when to suspend processing and supplying data.
<P CLASS="ref">Syntax</P><BLOCKQUOTE><PRE><P><B>HRESULT</B> <B>StopAt</B><B>(</B><BR>&nbsp;&nbsp;<B>const</B> <B>REFERENCE_TIME</B> <B>*</B> <I>ptStop</I><B>,</B><BR>&nbsp;&nbsp;<B>BOOL</B> <I>bSendExtra</I><B>,</B><BR>&nbsp;&nbsp;<B>DWORD</B> <I>dwCookie</I> <B>)</B><B>;</B><BR></PRE></BLOCKQUOTE>
<P CLASS="ref">Parameters</P>
<BLOCKQUOTE><DL><DT><I>ptStop</I>
 </DT><DD>[in] Time at which to stop streaming as specified in the <A HREF="IReferenceClock.htm#REFERENCE_TIME">REFERENCE_TIME</A> structure. If you specify NULL for <I>ptStop</I>, it will stop immediately (no notification); if MAX_TIME, cancels stop.
</DD><DT><I>bSendExtra</I>
 </DT><DD>[in] Indicates whether to send an extra sample after scheduled <I>ptStop</I> time.
</DD><DT><I>dwCookie</I>
 </DT><DD>[in] Specifies a particular value to send with the notification when the stop occurs (used only if <I>ptStart</I> if not NULL or MAX_TIME).
</DD></DL></BLOCKQUOTE>

<P CLASS="ref">Return Value</P>
<BLOCKQUOTE><P>Returns an <A HREF="../Error_Success_Codes.htm#HRESULT">HRESULT</A> value that depends on the implementation of the interface.</BLOCKQUOTE> 

<P CLASS="ref">Remarks</P>
<BLOCKQUOTE><P>This method is exposed by pins that support the stopping of streams. It sets the <A HREF="../dtypes.htm#StreamControlState">StreamControlState</A> enumeration type to STREAM_DISCARDING.

<P>In video capture, you would typically call <B>StopAt</B> on both the output pin of a capture filter and the input pin of a multiplexer, and pay attention only to the notification from the multiplexer. This ensures that the capture filter doesn't needlessly capture extra frames, while guaranteeing that the multiplexer has, in fact, saved the last frame to a file.

<P>In addition, you should specify TRUE for the <I>bSendExtra</I> parameter on the capture pin, and specify FALSE to the multiplexer pin. If an extra frame is not sent, the multiplexer will wait for the stop time indefinitely and not realize it already has received all the capture information. The multiplexer will discard the extra sample sent by the capture pin, so it will not get written to the file. Do not set <I>bSendExtra</I> to TRUE unless you also use <A HREF="IAMStreamControl.htm">IAMStreamControl</A> on another downstream pin too, like in the preceding case.

<P>If you call <B>StopAt</B> with a time that is in the middle of a packet, the filter will deliver the whole packet before going into a discarding state. Also, if start and stop are scheduled for a single point in time, the effect is as if the start occurred an infinitesimal time before the stop. You can use this effect to capture a single frame (see <A HREF="../class/CBaseStreamControl.htm#CBaseStreamControl">CBaseStreamControl</A> for an implementation example).</BLOCKQUOTE> 

<!-- CONTENTS_END -->

<!-- START_PAGE_FOOTER -->


<H6><HR size=1></H6>
<P><A Class="line" HREF="#pagetop"><IMG src="../../art/arrowup1.gif" WIDTH="11" HEIGHT="11" ALIGN="MIDDLE" BORDER=0 ALT="Top of Page">&nbsp;Top of Page</A>
<BR><A Class="line" HREF="../../../cpyright.htm">&#169; 1998 Microsoft Corporation. All rights reserved. Terms of Use.</A>
<!-- END_PAGE_FOOTER -->

</BLOCKQUOTE>

<SCRIPT>if((g_isIE == true) && (g_iMaj > 3)) {window.self.document.writeln('<SCR' + 'IPT SRC="../../tip2.js"></SCR' + 'IPT><IFRAME ID="G_L_S" NAME="SecretBuffer" STYLE="display: none" SRC=""></IFRAME>')}</SCRIPT>

<!-- DACONTROL_START -->

	<DIV ID="HeadGraphAnim"></DIV>
	<SCRIPT>if((g_isIE == true) && (g_iMaj > 3)) {window.self.document.writeln('<SCR' + 'IPT SRC="../../anim.js"></SCR' + 'IPT>')}</SCRIPT>
<!-- DACONTROL_END -->

</BODY>
</HTML>
