<!-- DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN" -->

<HTML>
<HEAD><TITLE>CMsgThread Class</TITLE>
<SCRIPT> var sRelPath = '../../' </SCRIPT>


<META NAME="Description" CONTENT="CMsgThread Class">
<META NAME="Description" CONTENT="CMsgThread (CMsgThread)">
<META NAME="Description" CONTENT="CMsgThread::CMsgThread">
<META NAME="Description" CONTENT="CreateThread (CMsgThread)">
<META NAME="Description" CONTENT="CMsgThread::CreateThread">
<META NAME="Description" CONTENT="GetThreadHandle (CMsgThread)">
<META NAME="Description" CONTENT="CMsgThread::GetThreadHandle">
<META NAME="Description" CONTENT="GetThreadID (CMsgThread)">
<META NAME="Description" CONTENT="CMsgThread::GetThreadID">
<META NAME="Description" CONTENT="GetThreadMsg (CMsgThread)">
<META NAME="Description" CONTENT="CMsgThread::GetThreadMsg">
<META NAME="Description" CONTENT="GetThreadPriority (CMsgThread)">
<META NAME="Description" CONTENT="CMsgThread::GetThreadPriority">
<META NAME="Description" CONTENT="OnThreadInit (CMsgThread)">
<META NAME="Description" CONTENT="CMsgThread::OnThreadInit">
<META NAME="Description" CONTENT="PutThreadMsg (CMsgThread)">
<META NAME="Description" CONTENT="CMsgThread::PutThreadMsg">
<META NAME="Description" CONTENT="ResumeThread (CMsgThread)">
<META NAME="Description" CONTENT="CMsgThread::ResumeThread">
<META NAME="Description" CONTENT="SetThreadPriority (CMsgThread)">
<META NAME="Description" CONTENT="CMsgThread::SetThreadPriority">
<META NAME="Description" CONTENT="SuspendThread (CMsgThread)">
<META NAME="Description" CONTENT="CMsgThread::SuspendThread">
<META NAME="Description" CONTENT="ThreadMessageProc (CMsgThread)">
<META NAME="Description" CONTENT="CMsgThread::ThreadMessageProc">
<META NAME="Description" CONTENT="WaitForThreadExit (CMsgThread)">
<META NAME="Description" CONTENT="CMsgThread::WaitForThreadExit">
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; CHARSET=iso8859-1">
<META NAME="MS.LOCALE" CONTENT="EN-US">
<META NAME="ROBOTS" CONTENT="all">

<!-- SNIFF_START -->

<SCRIPT>
//<!--
var g_isIE = false, g_isNav = false, g_iMaj = 0, g_sPlat = "";
// -->

</SCRIPT>
<SCRIPT SRC="../../ver.js"></SCRIPT>
<SCRIPT SRC="../../gloss.js"></SCRIPT>

<!-- SNIFF_END -->


<SCRIPT DEFER SRC="../../common.js"></SCRIPT>
<SCRIPT DEFER>
//<!--
function InitPage()
{
	if (g_isIE && g_iMaj >= 4)	
	{

		SetTOC();
	}
}
//-->

</SCRIPT>

<!-- SNIFF_END -->


<!-- STYLE_START -->

<SCRIPT>
//<!--
   var sVR = '../../'	// Set root for the style sheet
   var sCSS = '<LINK REL="stylesheet" HREF="' + sVR;

   if(g_isIE)
   {
	   if (g_iMaj >= 4) // For MSIE 4.0 or later
	   {
		   sCSS += 'dxm_basicsdkIE4';
		   if (g_sPlat == "Win") // Windows only for now
		   {
			   document.createStyleSheet(sVR + 'dxm_advSDKIE4.css');
		   }
	   }
	   else // For MSIE 3.0 or earlier
	   {
		   sCSS += 'dxm_basicsdkIE3';
	   }
   }
   else if (g_isNav) // For all Nav versions
   {
	   sCSS += 'dxm_basicsdkNAV';
   }
   else
   {
	   sCSS += 'dxm_basicsdkIE3'; // default to IE3 sheet
   }

   sCSS += (sCSS == '' ? '' : '.css" TYPE="text/css">');

   document.write(sCSS);
//-->

</SCRIPT>
<!-- STYLE_END -->


</HEAD>
<BODY onload="InitPage(); if (g_isIE && g_iMaj >= 4){HdgrphControl()}" BGCOLOR="#FFFFFF">
<A NAME="pagetop"></A><A NAME="CMsgThread"></A>

<!-- HEADGRAPH_START -->

<TABLE CLASS="main" BORDER=0 CELLSPACING="0" CELLPADDING="0" WIDTH="*">
<TR>
<TD ROWSPAN="3" VALIGN="TOP" WIDTH="*">
<IMG SRC="../../art/header1.gif" WIDTH="107" HEIGHT="110" BORDER=0 ALT="DirectShow Animated Header -- CMsgThread Class"></TD>
<TD ROWSPAN="2" VALIGN="TOP" WIDTH="217"><IMG SRC="../../art/hdrdshow.gif" WIDTH="217" HEIGHT="110" BORDER=0 ALT="DirectShow Animated Header -- CMsgThread Class"></TD>
<TD VALIGN="TOP" WIDTH="383">
<IMG SRC="../../art/header3.gif" WIDTH="383" HEIGHT="95" BORDER=0 ALT="DirectShow Animated Header">
</TD>
<TD VALIGN="TOP" WIDTH="100%">
<IMG SRC="../../art/spacer1.gif" WIDTH="100%" HEIGHT="94" BORDER=0 ALT="Microsoft DirectShow SDK">
</TD>
</TR>
<!-- HEADGRAPH_END -->

<!-- NAV_LINKS_START -->

<TR><TD VALIGN="TOP"><PRE><IMG ID="TOC_" SRC="../../art/yelbtn.gif" WIDTH="11" HEIGHT="11" ALIGN="MIDDLE" BORDER=0 ALT="*"><A STYLE="color:black;font-weight:bold" ID="TOC" HREF="../../contents.htm">Contents</A>  <IMG SRC="../../art/yelbtn.gif" WIDTH="11" HEIGHT="11" ALIGN="MIDDLE" BORDER=0 ALT="*"><A STYLE="color:black;font-weight:bold" HREF="../../index.htm">Index</A>  <IMG SRC="../../art/yelbtn.gif" WIDTH="11" HEIGHT="11" ALIGN="MIDDLE" BORDER=0 ALT="*"><A STYLE="color:black;font-weight:bold" HREF="Classes_intro.htm">Topic Contents</A>
</PRE></TD></TR>
<TR><TD COLSPAN="2" VALIGN="TOP"><PRE><IMG SRC="../../art/yelbtn.gif" WIDTH="11" HEIGHT="11" ALIGN="MIDDLE" BORDER=0 ALT="*"><B>Previous Topic:</B> <A STYLE="color:black" HREF="CMsg.htm">CMsg Class</A>
<IMG SRC="../../art/yelbtn.gif" WIDTH="11" HEIGHT="11" ALIGN="MIDDLE" BORDER=0 ALT="*"><B>Next Topic:</B> <A  STYLE="color:black" HREF="COARefTime.htm">COARefTime Class</A>
</PRE></TD></TR></TABLE>
<!-- NAV_LINKS_END -->


<BLOCKQUOTE CLASS="body">


<!-- CONTENTS_START -->

<H1>CMsgThread Class</H1>

<P><IMG SRC="../../art/mthrd02.gif" WIDTH="179" HEIGHT="24" ALT="CMsgThread class hierarchy">

<P>This class is a worker thread class that queues requests to the queuing thread for completion
asynchronously. To use this class, derive your class from it and override the 
<A HREF="CMsgThread.htm#ThreadMessageProc">CMsgThread::ThreadMessageProc</A> member function.
The <A HREF="CMsgThread.htm#ThreadMessageProc">ThreadMessageProc</A> member function carries out each request.
Your client functions and the <B>ThreadMessageProc</B> member function
must share a common definition of the parameters in the <A HREF="CMsg.htm">CMsg</A> object.

<P>A negotiated mechanism tells the worker thread to exit. Typically, 
this will be one value of the <A HREF="CMsg.htm">CMsg</A> class's <A HREF="CMsg.htm#uMsg">uMsg</A> message code.

<P>It is a good idea to send this message from the destructor of your derived class, and call
the <A HREF="CMsgThread.htm#WaitForThreadExit">CMsgThread::WaitForThreadExit</A> member function before completing the 
destruction of the derived class.

<A NAME="Protected_Data_Membe"></A><P CLASS="ref">Protected Data Members</P>
<TABLE><TR><TD><B><A NAME="CMsgThread::m_hSem">m_hSem</A></B>
 </TD><TD>Indicates a handle used for signaling.
</TD></TR><TR><TD><B><A NAME="CMsgThread::m_Lock">m_Lock</A></B>
 </TD><TD>Protects access to lists.
</TD></TR><TR><TD><B><A NAME="CMsgThread::m_lWaiting">m_lWaiting</A></B>
 </TD><TD>Indicates waiting for a free thread.
</TD></TR><TR><TD><B><A NAME="CMsgThread::m_ThreadQueue">m_ThreadQueue</A></B>
 </TD><TD>Overrides the <A HREF="CMsgThread.htm#GetThreadMsg">CMsgThread::GetThreadMsg</A> member
function and blocks on things other than this queue.
</TD></TR></TABLE>
<A NAME="Member_Functions"></A><P CLASS="ref">Member Functions</P>

<TABLE><TR><TD><A HREF="CMsgThread.htm#CMsgThread_CMsgThread">CMsgThread</A> 
 </TD><TD>Constructs a <A HREF="CMsgThread.htm">CMsgThread</A> object.
</TD></TR><TR><TD><A HREF="CMsgThread.htm#CreateThread">CreateThread</A> 
 </TD><TD>Creates a thread.
</TD></TR><TR><TD><A HREF="CMsgThread.htm#GetThreadHandle">GetThreadHandle</A> 
 </TD><TD>Returns the thread handle.
</TD></TR><TR><TD><A HREF="CMsgThread.htm#GetThreadID">GetThreadID</A> 
 </TD><TD>Returns the identifier of the thread.
</TD></TR><TR><TD><A HREF="CMsgThread.htm#GetThreadPriority">GetThreadPriority</A> 
 </TD><TD>Retrieves the current thread priority.
</TD></TR><TR><TD><A HREF="CMsgThread.htm#PutThreadMsg">PutThreadMsg</A> 
 </TD><TD>Queues a request for execution by the worker thread.
</TD></TR><TR><TD><A HREF="CMsgThread.htm#ResumeThread">ResumeThread</A> 
 </TD><TD>Continues the operation of the worker thread. 
</TD></TR><TR><TD><A HREF="CMsgThread.htm#SetThreadPriority">SetThreadPriority</A> 
 </TD><TD>Sets the priority of the thread to a new value.
</TD></TR><TR><TD><A HREF="CMsgThread.htm#SuspendThread">SuspendThread</A> 
 </TD><TD>Suspends the operation of a running thread.
</TD></TR><TR><TD><A HREF="CMsgThread.htm#WaitForThreadExit">WaitForThreadExit</A> 
 </TD><TD>Blocks until the thread has exited after a call to the <A HREF="CMsgThread.htm#SuspendThread">CMsgThread::SuspendThread</A>
member function.
</TD></TR></TABLE>
<A NAME="Overridable_Member_F"></A><P CLASS="ref">Overridable Member Functions</P>

<TABLE><TR><TD><A HREF="CMsgThread.htm#GetThreadMsg">GetThreadMsg</A>
 </TD><TD>Retrieves a queued <A HREF="CMsg.htm">CMsg</A> object containing a request.
</TD></TR><TR><TD><A HREF="CMsgThread.htm#OnThreadInit">OnThreadInit</A>
 </TD><TD>Provides initialization on a thread.
</TD></TR><TR><TD><A HREF="CMsgThread.htm#ThreadMessageProc">ThreadMessageProc</A>
 </TD><TD>Processes requests. This is a pure virtual member function.
</TD></TR></TABLE>



<H1><A NAME="CMsgThread_CMsgThread">CMsgThread::CMsgThread</A><HR size=1></H1>
<A HREF="CMsgThread.htm">CMsgThread Class</A>
<P>Constructs a <A HREF="CMsgThread.htm">CMsgThread</A> object.
<P CLASS="ref">Syntax</P><BLOCKQUOTE><PRE>
<P><B>CMsgThread</B><B>(</B> <B>)</B><B>;</B>
</PRE></BLOCKQUOTE>

<P CLASS="ref">Return Value</P>
<BLOCKQUOTE>
<P>No return value.
</BLOCKQUOTE>

<P CLASS="ref">Remarks</P>
<BLOCKQUOTE>
<P>Constructing a message thread object does not automatically create the
thread. You must call the <A HREF="CMsgThread.htm#CreateThread">CMsgThread::CreateThread</A> member function to create the thread.
</BLOCKQUOTE>


<H1><A NAME="CreateThread">CMsgThread::CreateThread</A><HR size=1></H1>
<A HREF="CMsgThread.htm">CMsgThread Class</A>
<P>Creates a thread.

<P CLASS="ref">Syntax</P>
<BLOCKQUOTE><PRE>
<P><B>BOOL</B> <B>CreateThread</B><B>(</B> <B>)</B><B>;</B>
</PRE></BLOCKQUOTE>

<P CLASS="ref">Return Value</P>
<BLOCKQUOTE>
<P>Returns one of the following values.
<TABLE><TR><TD>TRUE </TD><TD>Thread was successfully created.
</TD></TR><TR><TD>FALSE </TD><TD>Thread was not successfully created.
</TD></TR></TABLE>

</BLOCKQUOTE>

<P CLASS="ref">Remarks</P>
<BLOCKQUOTE>
<P>The thread will loop, blocking until a request is queued (through 
the <A HREF="CMsgThread.htm#PutThreadMsg">CMsgThread::PutThreadMsg</A> member function) and then calling the <A HREF="CMsgThread.htm#ThreadMessageProc">CMsgThread::ThreadMessageProc</A> member function with each message.
</BLOCKQUOTE>


<H1><A NAME="GetThreadHandle">CMsgThread::GetThreadHandle</A><HR size=1></H1>
<A HREF="CMsgThread.htm">CMsgThread Class</A>
<P>Retrieves the handle to the thread in the <A HREF="CMsgThread.htm">CMsgThread</A> object.
<P CLASS="ref">Syntax</P>
<BLOCKQUOTE><PRE>
<P><B>HANDLE</B> <B>GetThreadHandle</B><B>(</B> <B>)</B><B>;</B>
</PRE></BLOCKQUOTE>

<P CLASS="ref">Return Value</P>
<BLOCKQUOTE>
<P>Returns the thread handle.


</BLOCKQUOTE>

<P CLASS="ref">Remarks</P>
<BLOCKQUOTE>
<P>The thread handle can be passed to Microsoft&#174;
Win32&#174; application programming interface (API) functions, such as
<A HREF="../../appendixes/Further_Reading.htm#WaitForMultipleObjec">WaitForMultipleObjects</A>. The thread handle is signaled when the thread has
exited.
</BLOCKQUOTE>


<H1><A NAME="GetThreadID">CMsgThread::GetThreadID</A><HR size=1></H1>
<A HREF="CMsgThread.htm">CMsgThread Class</A>
<P>Retrieves the thread's identifier.

<P CLASS="ref">Syntax</P>
<BLOCKQUOTE><PRE>
<P><B>DWORD</B> <B>GetThreadID</B><B>(</B> <B>)</B><B>;</B>
</PRE></BLOCKQUOTE>

<P CLASS="ref">Return Value</P>
<BLOCKQUOTE>
<P>Returns the <I>m_ThreadId</I> private data member.


</BLOCKQUOTE>

<P CLASS="ref">Remarks</P>
<BLOCKQUOTE>
<P>This function returns the Microsoft Win32 identifier for the
worker thread. You can call this member function on either the
worker thread or a client thread.
</BLOCKQUOTE>


<H1><A NAME="GetThreadMsg">CMsgThread::GetThreadMsg</A><HR size=1></H1>
<A HREF="CMsgThread.htm">CMsgThread Class</A>
<P>Retrieves a queued <A HREF="CMsg.htm">CMsg</A> object containing a request.

<P CLASS="ref">Syntax</P>
<BLOCKQUOTE><PRE>
<P><B>void</B> <B>virtual</B> <B>GetThreadMsg</B><B>(</B><BR>&nbsp;&nbsp;<B>CMsg</B> <I>*msg</I><BR>&nbsp;&nbsp;<B>)</B><B>;</B>
</PRE></BLOCKQUOTE>

<P CLASS="ref">Parameters</P>
<BLOCKQUOTE>
<DL><DT><I>msg</I>
 </DT><DD>Pointer to an allocated <A HREF="CMsg.htm">CMsg</A> object.
</DD></DL>
</BLOCKQUOTE>

<P CLASS="ref">Remarks</P>
<BLOCKQUOTE>
<P>This member function is called from the worker thread's private 
<A HREF="CAMThread.htm#ThreadProc">ThreadProc</A> 
function to retrieve the next member function. The <I>msg</I> parameter should point to an 
allocated <A HREF="CMsg.htm">CMsg</A> object that will be filled with the parameters to the next request in the
queue. If there are no queued requests, this member function blocks until the next
request is queued (by a call to the <A HREF="CMsgThread.htm#PutThreadMsg">CMsgThread::PutThreadMsg</A> member function).
</BLOCKQUOTE>


<H1><A NAME="GetThreadPriority">CMsgThread::GetThreadPriority</A><HR size=1></H1>
<A HREF="CMsgThread.htm">CMsgThread Class</A>
<P>Uses the Microsoft Win32 <B>GetThreadPriority</B> function to
retrieve the priority of the current worker thread. 

<P CLASS="ref">Syntax</P>
<BLOCKQUOTE><PRE>
<P><B>int</B> <B>GetThreadPriority</B><B>(</B> <B>)</B><B>;</B>
</PRE></BLOCKQUOTE>

<P CLASS="ref">Return Value</P>
<BLOCKQUOTE>
<P>Returns the thread priority as an integer.


</BLOCKQUOTE>


<H1><A NAME="OnThreadInit">CMsgThread::OnThreadInit</A><HR size=1></H1>
<A HREF="CMsgThread.htm">CMsgThread Class</A>
<P>Provides initialization on a thread.<P CLASS="ref">Syntax</P>
<BLOCKQUOTE><PRE>
<P><B>virtual</B> <B>void</B> <B>OnThreadInit</B><B>(</B> <B>)</B><B>;</B>
</PRE></BLOCKQUOTE>

<P CLASS="ref">Return Value</P>
<BLOCKQUOTE>
<P>No return value.
</BLOCKQUOTE>

<P CLASS="ref">Remarks</P>
<BLOCKQUOTE>
<P>Override this function if you want to do your own specific initialization on thread startup.</BLOCKQUOTE>


<H1><A NAME="PutThreadMsg">CMsgThread::PutThreadMsg</A><HR size=1></H1>
<A HREF="CMsgThread.htm">CMsgThread Class</A>
<P>Queues a request for execution by the worker thread.

<P CLASS="ref">Syntax</P>
<BLOCKQUOTE><PRE>
<P><B>void</B> <B>PutThreadMsg</B><B>(</B><BR>&nbsp;&nbsp;<B>UINT</B> <I>uMsg</I><B>,</B><BR>&nbsp;&nbsp;<B>DWORD</B> <I>dwMsgFlags</I><B>,</B><BR>&nbsp;&nbsp;<B>LPVOID</B> <I>lpMsgParam</I><B>,</B><BR>&nbsp;&nbsp;<B>CAMEvent</B> <I>*pEvent</I> <B>=</B> <B>NULL</B><BR>&nbsp;&nbsp;<B>)</B><B>;</B>
</PRE></BLOCKQUOTE>

<P CLASS="ref">Parameters</P>
<BLOCKQUOTE>
<DL><DT><I>uMsg</I>
 </DT><DD>Request code.
</DD><DT><I>dwMsgFlags</I>
 </DT><DD>Optional flags parameter.
</DD><DT><I>lpMsgParam</I>
 </DT><DD>Optional pointer to a data block containing additional parameters or return
values. Must be statically or heap-allocated and not automatic.
</DD><DT><I>pEvent</I>
 </DT><DD>Optional pointer to an event object to be signaled upon completion.
</DD></DL>
</BLOCKQUOTE>

<P CLASS="ref">Return Value</P>
<BLOCKQUOTE>
<P>No return value.
</BLOCKQUOTE>

<P CLASS="ref">Remarks</P>
<BLOCKQUOTE>
<P>This member function queues a request for execution by the worker thread. The parameters
of this member function will be queued (in a <A HREF="CMsg.htm">CMsg</A> object) and passed to the 
<A HREF="CMsgThread.htm#ThreadMessageProc">CMsgThread::ThreadMessageProc</A> member function of the worker thread. This member 
function returns immediately after queuing the request and does not wait for the thread to fulfill 
the request. The <B>CMsgThread::ThreadMessageProc</B> member function of the derived class 
defines the four parameters.

<P>This member function uses a multithread safe list, so multiple calls to this member function 
from different threads can be made safely.
</BLOCKQUOTE>


<H1><A NAME="ResumeThread">CMsgThread::ResumeThread</A><HR size=1></H1>
<A HREF="CMsgThread.htm">CMsgThread Class</A>
<P>Uses the Microsoft Win32 <B>ResumeThread</B> function to
continue the operation of the worker thread after a previous call to the
<A HREF="CMsgThread.htm#SuspendThread">CMsgThread::SuspendThread</A> member function.

<P CLASS="ref">Syntax</P>
<BLOCKQUOTE><PRE>
<P><B>DWORD</B> <B>ResumeThread</B><B>(</B> <B>)</B><B>;</B>
</PRE></BLOCKQUOTE>

<P CLASS="ref">Return Value</P>
<BLOCKQUOTE>
<P>If the member function succeeds,
the return value is the previous suspend count of the thread. 
If the member function fails, the return value is 0xFFFFFFFF. 
To obtain extended error information, call the Microsoft
Win32 <A HREF="../../appendixes/Further_Reading.htm#GetLastError">GetLastError</A> function. 

</BLOCKQUOTE>


<H1><A NAME="SetThreadPriority">CMsgThread::SetThreadPriority</A><HR size=1></H1>
<A HREF="CMsgThread.htm">CMsgThread Class</A>
<P>Uses the Microsoft Win32 <B>SetThreadPriority</B> function to
set the priority of the thread to a new value.

<P CLASS="ref">Syntax</P>
<BLOCKQUOTE><PRE>
<P><B>BOOL</B> <B>SetThreadPriority</B><B>(</B><BR>&nbsp;&nbsp;<B>int</B> <I>nPriority</I><BR>&nbsp;&nbsp;<B>)</B><B>;</B>
</PRE></BLOCKQUOTE>

<P CLASS="ref">Parameters</P>
<BLOCKQUOTE>
<DL><DT><I>nPriority</I>
 </DT><DD>Priority of the thread.
</DD></DL>
</BLOCKQUOTE>

<P CLASS="ref">Return Value</P>
<BLOCKQUOTE>
<P> Returns one of the following values.
<TABLE><TR><TD>TRUE </TD><TD>Priority was successfully set.
</TD></TR><TR><TD>FALSE </TD><TD>Priority was not set.
</TD></TR></TABLE>

</BLOCKQUOTE>

<P CLASS="ref">Remarks</P>
<BLOCKQUOTE>
<P>The client and the worker thread can call this member function.
</BLOCKQUOTE>


<H1><A NAME="SuspendThread">CMsgThread::SuspendThread</A><HR size=1></H1>
<A HREF="CMsgThread.htm">CMsgThread Class</A>
<P>Uses the Microsoft Win32 <B>SuspendThread</B> function to
suspend the operation of a running thread.

<P CLASS="ref">Syntax</P>
<BLOCKQUOTE><PRE>
<P><B>DWORD</B> <B>SuspendThread</B><B>(</B> <B>)</B><B>;</B>
</PRE></BLOCKQUOTE>

<P CLASS="ref">Return Value</P>
<BLOCKQUOTE>
<P>If the member function succeeds, the return value is the previous suspend count of the thread. 
If the member function fails, the return value is 0xFFFFFFFF. To obtain extended error 
information, call the Microsoft Win32 <A HREF="../../appendixes/Further_Reading.htm#GetLastError">GetLastError</A> function. 


</BLOCKQUOTE>

<P CLASS="ref">Remarks</P>
<BLOCKQUOTE>
<P>The client thread calls this member function to suspend the operation of the
worker thread. The worker thread remains suspended and will not execute until an
additional call to the <A HREF="CMsgThread.htm#ResumeThread">CMsgThread::ResumeThread</A> member function is made.
</BLOCKQUOTE>


<H1><A NAME="ThreadMessageProc">CMsgThread::ThreadMessageProc</A><HR size=1></H1>
<A HREF="CMsgThread.htm">CMsgThread Class</A>
<P>Processes requests. This is a pure virtual member function. 

<P CLASS="ref">Syntax</P>
<BLOCKQUOTE><PRE>
<P><B>virtual</B> <B>LRESULT</B> <B>ThreadMessageProc</B><B>(</B><BR>&nbsp;&nbsp;<B>UINT</B> <I>uMsg</I><B>,</B><BR>&nbsp;&nbsp;<B>DWORD</B> <I>dwFlags</I><B>,</B><BR>&nbsp;&nbsp;<B>LPVOID</B> <I>lpParam</I><B>,</B><BR>&nbsp;&nbsp;<B>CAMEvent</B> <I>*pEvent</I><BR>&nbsp;&nbsp;<B>)</B><B>;</B>
</PRE></BLOCKQUOTE>

<P CLASS="ref">Parameters</P>
<BLOCKQUOTE>
<DL><DT><I>uMsg</I>
 </DT><DD>Request code.
</DD><DT><I>dwFlags</I>
 </DT><DD>Optional flag parameter to request.
</DD><DT><I>lpParam</I>
 </DT><DD>Optional pointer to extra data or a return data block.
</DD><DT><I>pEvent</I>
 </DT><DD>Optional pointer to an event object.
</DD></DL>
</BLOCKQUOTE>

<P CLASS="ref">Return Value</P>
<BLOCKQUOTE>
<P>Any nonzero return causes the thread to exit. Returns zero unless an exit
request has been processed recently.

</BLOCKQUOTE>

<P CLASS="ref">Remarks</P>
<BLOCKQUOTE>
<P>This pure virtual function must be overridden in your derived class. It will be
called once for each request queued by a call to the <A HREF="CMsgThread.htm#PutThreadMsg">CMsgThread::PutThreadMsg</A> 
member function.

<P>The member function defines the four parameters. Typically, use the <I>uMsg</I> 
parameter to indicate the request, and the other three parameters will be optional additional 
parameters. The calling application can supply a pointer to a <A HREF="CAMEvent.htm">CAMEvent</A> object in the
<I>pEvent</I> parameter if your application requires it. You must set this event after 
processing the event by using an expression such as:
<PRE>pEvent-&gt;SetEvent
</PRE>
<P>One request code must be set aside to tell the worker thread to exit. Upon receiving this request, 
return 1 from this member function. Return 0 if you do not want the worker thread to exit.
</BLOCKQUOTE>


<H1><A NAME="WaitForThreadExit">CMsgThread::WaitForThreadExit</A><HR size=1></H1>
<A HREF="CMsgThread.htm">CMsgThread Class</A>
<P>Blocks until the thread exits.

<P CLASS="ref">Syntax</P>
<BLOCKQUOTE><PRE>
<P><B>BOOL</B> <B>WaitForThreadExit</B><B>(</B><BR>&nbsp;&nbsp;<B>LPDWORD</B> <I>lpdwExitCode</I><BR>&nbsp;&nbsp;<B>)</B><B>;</B>
</PRE></BLOCKQUOTE>

<P CLASS="ref">Parameters</P>
<BLOCKQUOTE>
<DL><DT><I>lpdwExitCode</I>
 </DT><DD>Exit code returned by the thread.
</DD></DL>
</BLOCKQUOTE>

<P CLASS="ref">Return Value</P>
<BLOCKQUOTE>
<P>Returns either TRUE or FALSE, the meaning of which is determined by 
the class supplying the overridden <A HREF="CMsgThread.htm#ThreadMessageProc">CMsgThread::ThreadMessageProc</A> member function 
and the calling member function.

</BLOCKQUOTE>

<P CLASS="ref">Remarks</P>
<BLOCKQUOTE>
<P>Ensure that the worker thread has exited completely before completing the destruction of your derived class; otherwise, the thread might still execute after your dynamic-link library (DLL) has been unloaded from the address space of the process. 
Even if the only instruction left to exit is a single-return instruction, this would cause
an exception. The only reliable way to ensure that the thread has exited is to
signal the thread to exit (using a privately negotiated <A HREF="CMsg.htm">CMsg</A> object sent to the
<A HREF="CMsgThread.htm#PutThreadMsg">CMsgThread::PutThreadMsg</A> member function) and then call this member function. 
You should do this in the destructor for your derived class.

</BLOCKQUOTE>
<!-- CONTENTS_END -->

<!-- START_PAGE_FOOTER -->


<H6><HR size=1></H6>
<P><A Class="line" HREF="#pagetop"><IMG src="../../art/arrowup1.gif" WIDTH="11" HEIGHT="11" ALIGN="MIDDLE" BORDER=0 ALT="Top of Page">&nbsp;Top of Page</A>
<BR><A Class="line" HREF="../../../cpyright.htm">&#169; 1998 Microsoft Corporation. All rights reserved. Terms of Use.</A>
<!-- END_PAGE_FOOTER -->

</BLOCKQUOTE>

<SCRIPT>if((g_isIE == true) && (g_iMaj > 3)) {window.self.document.writeln('<SCR' + 'IPT SRC="../../tip2.js"></SCR' + 'IPT><IFRAME ID="G_L_S" NAME="SecretBuffer" STYLE="display: none" SRC=""></IFRAME>')}</SCRIPT>

<!-- DACONTROL_START -->

	<DIV ID="HeadGraphAnim"></DIV>
	<SCRIPT>if((g_isIE == true) && (g_iMaj > 3)) {window.self.document.writeln('<SCR' + 'IPT SRC="../../anim.js"></SCR' + 'IPT>')}</SCRIPT>
<!-- DACONTROL_END -->

</BODY>
</HTML>
