<!-- DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN" -->

<HTML>
<HEAD><TITLE>IOverlay Interface</TITLE>
<SCRIPT> var sRelPath = '../../' </SCRIPT>


<META NAME="Description" CONTENT="IOverlay Interface">
<META NAME="Description" CONTENT="IOverlay::Advise">
<META NAME="Description" CONTENT="IOverlay::GetClipList">
<META NAME="Description" CONTENT="IOverlay::GetColorKey">
<META NAME="Description" CONTENT="IOverlay::GetDefaultColorKey">
<META NAME="Description" CONTENT="IOverlay::GetPalette">
<META NAME="Description" CONTENT="IOverlay::GetVideoPosition">
<META NAME="Description" CONTENT="IOverlay::GetWindowHandle">
<META NAME="Description" CONTENT="IOverlay::SetColorKey">
<META NAME="Description" CONTENT="IOverlay::SetPalette">
<META NAME="Description" CONTENT="IOverlay::Unadvise">
<META NAME="Description" CONTENT="Advise (IOverlay)">
<META NAME="Description" CONTENT="GetClipList (IOverlay)">
<META NAME="Description" CONTENT="GetColorKey (IOverlay)">
<META NAME="Description" CONTENT="GetDefaultColorKey (IOverlay)">
<META NAME="Description" CONTENT="GetPalette (IOverlay)">
<META NAME="Description" CONTENT="GetVideoPosition (IOverlay)">
<META NAME="Description" CONTENT="GetWindowHandle (IOverlay)">
<META NAME="Description" CONTENT="SetColorKey (IOverlay)">
<META NAME="Description" CONTENT="SetPalette (IOverlay)">
<META NAME="Description" CONTENT="Unadvise (IOverlay)">
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; CHARSET=iso8859-1">
<META NAME="MS.LOCALE" CONTENT="EN-US">
<META NAME="ROBOTS" CONTENT="all">

<!-- SNIFF_START -->

<SCRIPT>
//<!--
var g_isIE = false, g_isNav = false, g_iMaj = 0, g_sPlat = "";
// -->

</SCRIPT>
<SCRIPT SRC="../../ver.js"></SCRIPT>
<SCRIPT SRC="../../gloss.js"></SCRIPT>

<!-- SNIFF_END -->


<SCRIPT DEFER SRC="../../common.js"></SCRIPT>
<SCRIPT DEFER>
//<!--
function InitPage()
{
	if (g_isIE && g_iMaj >= 4)	
	{

		SetTOC();
	}
}
//-->

</SCRIPT>

<!-- SNIFF_END -->


<!-- STYLE_START -->

<SCRIPT>
//<!--
   var sVR = '../../'	// Set root for the style sheet
   var sCSS = '<LINK REL="stylesheet" HREF="' + sVR;

   if(g_isIE)
   {
	   if (g_iMaj >= 4) // For MSIE 4.0 or later
	   {
		   sCSS += 'dxm_basicsdkIE4';
		   if (g_sPlat == "Win") // Windows only for now
		   {
			   document.createStyleSheet(sVR + 'dxm_advSDKIE4.css');
		   }
	   }
	   else // For MSIE 3.0 or earlier
	   {
		   sCSS += 'dxm_basicsdkIE3';
	   }
   }
   else if (g_isNav) // For all Nav versions
   {
	   sCSS += 'dxm_basicsdkNAV';
   }
   else
   {
	   sCSS += 'dxm_basicsdkIE3'; // default to IE3 sheet
   }

   sCSS += (sCSS == '' ? '' : '.css" TYPE="text/css">');

   document.write(sCSS);
//-->

</SCRIPT>
<!-- STYLE_END -->


</HEAD>
<BODY onload="InitPage(); if (g_isIE && g_iMaj >= 4){HdgrphControl()}" BGCOLOR="#FFFFFF">
<A NAME="pagetop"></A><A NAME="IOverlay"></A>

<!-- HEADGRAPH_START -->

<TABLE CLASS="main" BORDER=0 CELLSPACING="0" CELLPADDING="0" WIDTH="*">
<TR>
<TD ROWSPAN="3" VALIGN="TOP" WIDTH="*">
<IMG SRC="../../art/header1.gif" WIDTH="107" HEIGHT="110" BORDER=0 ALT="DirectShow Animated Header"></TD>
<TD ROWSPAN="2" VALIGN="TOP" WIDTH="217"><IMG SRC="../../art/hdrdshow.gif" WIDTH="217" HEIGHT="110" BORDER=0 ALT="DirectShow Animated Header"></TD>
<TD VALIGN="TOP" WIDTH="383">
<IMG SRC="../../art/header3.gif" WIDTH="383" HEIGHT="95" BORDER=0 ALT="DirectShow Animated Header">
</TD>
<TD VALIGN="TOP" WIDTH="100%">
<IMG SRC="../../art/spacer1.gif" WIDTH="100%" HEIGHT="94" BORDER=0 ALT="Microsoft DirectShow SDK">
</TD>
</TR>
<!-- HEADGRAPH_END -->

<!-- NAV_LINKS_START -->

<TR><TD VALIGN="TOP"><PRE><IMG ID="TOC_" SRC="../../art/yelbtn.gif" WIDTH="11" HEIGHT="11" ALIGN="MIDDLE" BORDER=0 ALT="*"><A STYLE="color:black;font-weight:bold" ID="TOC" HREF="../../contents.htm">Contents</A>  <IMG SRC="../../art/yelbtn.gif" WIDTH="11" HEIGHT="11" ALIGN="MIDDLE" BORDER=0 ALT="*"><A STYLE="color:black;font-weight:bold" HREF="../../index.htm">Index</A>  <IMG SRC="../../art/yelbtn.gif" WIDTH="11" HEIGHT="11" ALIGN="MIDDLE" BORDER=0 ALT="*"><A STYLE="color:black;font-weight:bold" HREF="ifaces_intro.htm">Topic Contents</A>
</PRE></TD></TR>
<TR><TD COLSPAN="2" VALIGN="TOP"><PRE><IMG SRC="../../art/yelbtn.gif" WIDTH="11" HEIGHT="11" ALIGN="MIDDLE" BORDER=0 ALT="*"><B>Previous Topic:</B> <A STYLE="color:black" HREF="IMultiFileReader.htm">IMultiFileReader Interface</A>
<IMG SRC="../../art/yelbtn.gif" WIDTH="11" HEIGHT="11" ALIGN="MIDDLE" BORDER=0 ALT="*"><B>Next Topic:</B> <A  STYLE="color:black" HREF="IOverlayNotify.htm">IOverlayNotify Interface</A>
</PRE></TD></TR></TABLE>
<!-- NAV_LINKS_END -->


<BLOCKQUOTE CLASS="body">


<!-- CONTENTS_START -->

<H1>IOverlay Interface</H1>

<P>The <B>IOverlay</B> interface provides information so that a <A CLASS="Glossary" HREF="javascript:Glossary(sRelPath + 'gloss/gloss_f.htm#filter')">filter</A> can write
directly to video memory while placing the video in the correct window position.
It is implemented on the <A CLASS="Glossary" HREF="javascript:Glossary(sRelPath + 'gloss/gloss_I.htm#input_pin')">input pin</A> of the video <A CLASS="Glossary" HREF="javascript:Glossary(sRelPath + 'gloss/gloss_R.htm#renderer')">renderer</A> and communicates with an
<A CLASS="Glossary" HREF="javascript:Glossary(sRelPath + 'gloss/gloss_U.htm#upstream_filter')">upstream filter</A> (typically a video decompressor) by calling that filter's
<A HREF="IOverlayNotify.htm">IOverlayNotify</A> <A CLASS="Glossary" HREF="javascript:Glossary(sRelPath + 'gloss/gloss_M.htm#method')">methods</A> to notify it of changes to the video window.

<P>This interface has no relationship to the DirectDraw&#174; overlay capability.
The Microsoft video renderer draws data it receives through the <A HREF="IMemInputPin.htm">IMemInputPin</A>
interface, using DirectDraw overlays when available.
This interface, used in place of <B>IMemInputPin</B>,
is intended to provide notification support for any upstream filter that bypasses
the renderer's drawing capabilities, but needs notifications of other display properties.

<P>See the <A HREF="IOverlayNotify.htm">IOverlayNotify</A> interface for more information on how the
<B>IOverlay</B> and <B>IOverlayNotify</B> interfaces work together.

<P CLASS="ref"><A NAME="When_to_Implement">When to Implement</A></P>
<P>This interface is implemented on the Microsoft&#174; DirectShow&#153; video renderer filter. It
can also be implemented on replacement video renderer filters if desired.
If doing so, implement this interface so that filters writing directly to the
frame buffer or trying to position an overlay know where to display their video.
To implement this interface, the renderer must be prepared to use methods on
the <A HREF="IOverlayNotify.htm">IOverlayNotify</A> interface of the filter doing the drawing, with notifications
of video property changes.

<P>The window-based renderer in DirectShow supports both <A HREF="IMemInputPin.htm">IMemInputPin</A> and
<A HREF="IOverlay.htm">IOverlay</A> interfaces. These two interfaces are mutually exclusive. A filter chooses to use
the <B>IOverlay</B> <A CLASS="Glossary" HREF="javascript:Glossary(sRelPath + 'gloss/gloss_T.htm#transport')">transport</A> interface by providing a media type during connection
that has a subtype of MEDIASUBTYPE_Overlay. After connection, it will be able
to get and use successfully the <B>IOverlay</B> interface. If it connects with any
other video formats (such as MEDIASUBTYPE_RGB8), trying to call through
<B>IOverlay</B> returns <A HREF="../Error_Success_Codes.htm#VFW_E_NOT_OVERLAY_CO">VFW_E_NOT_OVERLAY_CONNECTION</A>.

<P CLASS="ref"><A NAME="When_to_Use">When to Use</A></P>
<P>Use the methods on this function from an upstream filter that must
control video overlay properties and intends to handle the displaying of the
video data itself. This typically is used by hardware video decoders that have
an alternate connection to the video hardware.

<P CLASS="ref"><A NAME="Methods_in_Vtable_Or">Methods in Vtable Order</A></P>
<TABLE>
<TR><TH>IUnknown methods</TH><TH>Description</TH></TR><TR><TD><A HREF="IUnknown.htm#QueryInterface">QueryInterface</A> </TD><TD>Returns pointers to supported interfaces.
</TD></TR><TR><TD><A HREF="IUnknown.htm#AddRef">AddRef</A> </TD><TD>Increments the reference count.
</TD></TR><TR><TD><A HREF="IUnknown.htm#Release">Release</A> </TD><TD>Decrements the reference count.
</TD></TR><TR></TR>
<TR><TH>IOverlay methods</TH><TH>Description</TH></TR><TR><TD><A HREF="IOverlay.htm#GetPalette">GetPalette</A>
</TD><TD>Retrieves the current palette.
</TD></TR><TR><TD><A HREF="IOverlay.htm#SetPalette">SetPalette</A>
</TD><TD>Sets the palette.
</TD></TR><TR><TD><A HREF="IOverlay.htm#GetDefaultColorKey">GetDefaultColorKey</A>
</TD><TD>Retrieves the default color key.
</TD></TR><TR><TD><A HREF="IOverlay.htm#GetColorKey">GetColorKey</A>
</TD><TD>Returns the identifier of the currently active color key.
</TD></TR><TR><TD><A HREF="IOverlay.htm#SetColorKey">SetColorKey</A>
</TD><TD>Changes the color key.
</TD></TR><TR><TD><A HREF="IOverlay.htm#GetWindowHandle">GetWindowHandle</A>
</TD><TD>Returns the window handle.
</TD></TR><TR><TD><A HREF="IOverlay.htm#GetClipList">GetClipList</A>
</TD><TD>Retrieves the clipping list.
</TD></TR><TR><TD><A HREF="IOverlay.htm#GetVideoPosition">GetVideoPosition</A>
</TD><TD>Retrieves the current video source and destination rectangles.
</TD></TR><TR><TD><A HREF="IOverlay.htm#Advise">Advise</A>
</TD><TD>Sets up an <A CLASS="Glossary" HREF="javascript:Glossary(sRelPath + 'gloss/gloss_A.htm#advise')">advise</A> link for the overlay events.
</TD></TR><TR><TD><A HREF="IOverlay.htm#Unadvise">Unadvise</A>
</TD><TD>Terminates the advise link.
</TD></TR></TABLE>



<H1><A NAME="Advise">IOverlay::Advise</A><HR size=1></H1>
<A HREF="IOverlay.htm">IOverlay Interface</A>
<P>Sets up an advise link for the overlay events specified by
the <I>dwInterests</I> parameter.

<P CLASS="ref">Syntax</P><BLOCKQUOTE><PRE>
<P><B>HRESULT</B> <B>Advise</B><B>(</B><BR>&nbsp;&nbsp;<B>IOverlayNotify</B> <B>*</B> <I>pOverlayNotify</I><B>,</B><BR>&nbsp;&nbsp;<B>DWORD</B> <I>dwInterests</I><BR>&nbsp;&nbsp;<B>)</B><B>;</B></PRE></BLOCKQUOTE>

<P CLASS="ref">Parameters</P>
<BLOCKQUOTE>
<DL><DT><I>pOverlayNotify</I>
 </DT><DD>[in] Notification interface.
</DD><DT><I>dwInterests</I>
 </DT><DD>[in] Callbacks of interest, which can be any subset of the following events.
<TABLE>
<TR><TD>ADVISE_NONE </TD><TD>No changes.
</TD></TR><TR><TD>ADVISE_CLIPPING </TD><TD>Change in clipping region (synchronized with the window).
</TD></TR><TR><TD>ADVISE_PALETTE </TD><TD>Change in palette.
</TD></TR><TR><TD>ADVISE_COLORKEY </TD><TD>Change of chroma key value.
</TD></TR><TR><TD>ADVISE_POSITION </TD><TD>Change in position of video window (not synchronized with the window).
</TD></TR><TR><TD>ADVISE_ALL </TD><TD>All of the above.
</TD></TR></TABLE>
</DD></DL>

</BLOCKQUOTE>
<P CLASS="ref">Return Value</P>
<BLOCKQUOTE>
<P>No return value.

</BLOCKQUOTE>
<P CLASS="ref">Remarks</P>


<BLOCKQUOTE>

<P>This method sets up an advise link for the <A HREF="IOverlayNotify.htm">IOverlayNotify</A>
interface to receive notifications. If one of these events occurs, the appropriate
entry point in the <I>pOverlayNotify</I> parameter passed in is called
(<A HREF="IOverlayNotify.htm#OnClipChange">IOverlayNotify::OnClipChange</A>,
<A HREF="IOverlayNotify.htm#OnColorKeyChange">IOverlayNotify::OnColorKeyChange</A>,
<A HREF="IOverlayNotify.htm#OnPaletteChange">IOverlayNotify::OnPaletteChange</A>, or
<A HREF="IOverlayNotify.htm#OnPositionChange">IOverlayNotify::OnPositionChange</A>).

<P>Only one advise link can be set on any given <A HREF="IOverlay.htm">IOverlay</A> interface.
Trying to set another notification interface on second and subsequent calls
returns <A HREF="../Error_Success_Codes.htm#VFW_E_ADVISE_ALREADY">VFW_E_ADVISE_ALREADY_SET</A>. You can cancel an advise link by using
<A HREF="IOverlay.htm#Unadvise">IOverlay::Unadvise</A>.
</BLOCKQUOTE>


<H1><A NAME="GetClipList">IOverlay::GetClipList</A><HR size=1></H1>
<A HREF="IOverlay.htm">IOverlay Interface</A>
<P>Retrieves the clipping list.

<P CLASS="ref">Syntax</P><BLOCKQUOTE><PRE>
<P><B>HRESULT</B> <B>GetClipList</B><B>(</B><BR>&nbsp;&nbsp;<B>RECT</B> <B>*</B> <I>pSourceRect</I><B>,</B><BR>&nbsp;&nbsp;<B>RECT</B> <B>*</B> <I>pDestinationRect</I><B>,</B><BR>&nbsp;&nbsp;<B>RGNDATA</B> <B>**</B> <I>ppRgnData</I><BR>&nbsp;&nbsp;<B>)</B><B>;</B></PRE></BLOCKQUOTE>

<P CLASS="ref">Parameters</P>
<BLOCKQUOTE>
<DL><DT><I>pSourceRect</I>
</DT><DD>[out] Bounding client rectangle.
</DD><DT><I>pDestinationRect</I>
</DT><DD>[in] Destination rectangle.
</DD><DT><I>ppRgnData</I>
</DT><DD>[out] Header and data describing clipping. If successful,
the Microsoft&#174; Win32&#174; <A HREF="../../appendixes/Further_Reading.htm#CoTaskMemFree">CoTaskMemFree</A> function should free memory.
</DD></DL>

</BLOCKQUOTE>
<P CLASS="ref">Return Value</P>
<BLOCKQUOTE>
<P>No return value.

</BLOCKQUOTE>
<P CLASS="ref">Remarks</P>


<BLOCKQUOTE>

<P>The <A HREF="IOverlay.htm">IOverlay</A> implementation allocates the memory for the
clipping rectangles, because it can vary in length. The filter calling this method
should free the memory (using <A HREF="../../appendixes/Further_Reading.htm#CoTaskMemFree">CoTaskMemFree</A>) when it is finished with it.
</BLOCKQUOTE>


<H1><A NAME="GetColorKey">IOverlay::GetColorKey</A><HR size=1></H1>
<A HREF="IOverlay.htm">IOverlay Interface</A>
<P>Retrieves the current color key used for chroma keying.

<P CLASS="ref">Syntax</P><BLOCKQUOTE><PRE>
<P><B>HRESULT</B> <B>GetColorKey</B><B>(</B><BR>&nbsp;&nbsp;<B>COLORKEY</B> <B>*</B> <I>pColorKey</I><BR>&nbsp;&nbsp;<B>)</B><B>;</B></PRE></BLOCKQUOTE>

<P CLASS="ref">Parameters</P>
<BLOCKQUOTE>
<DL><DT><I>pColorKey</I>
</DT><DD>[out] Pointer to where the current color key for chroma keying is copied.
</DD></DL>

</BLOCKQUOTE>
<P CLASS="ref">Return Value</P>
<BLOCKQUOTE>
<P>No return value.

</BLOCKQUOTE>
<P CLASS="ref">Remarks</P>


<BLOCKQUOTE>

<P>If you change the color key by using the <A HREF="IOverlay.htm#SetColorKey">IOverlay::SetColorKey</A> method,
all the advise links receive an <A HREF="IOverlayNotify.htm#OnColorKeyChange">IOverlayNotify::OnColorKeyChange</A> callback method
with the new color.

<P>If no color key is currently being used, this method returns <A HREF="../Error_Success_Codes.htm#VFW_E_NO_COLOR_KEY_S">VFW_E_NO_COLOR_KEY_SET</A>.
</BLOCKQUOTE>


<H1><A NAME="GetDefaultColorKey">IOverlay::GetDefaultColorKey</A><HR size=1></H1>
<A HREF="IOverlay.htm">IOverlay Interface</A>
<P>Retrieves the default color key used for a chroma key overlay.

<P CLASS="ref">Syntax</P><BLOCKQUOTE><PRE>
<P><B>HRESULT</B> <B>GetDefaultColorKey</B><B>(</B><BR>&nbsp;&nbsp;<B>COLORKEY</B> <B>*</B> <I>pColorKey</I><BR>&nbsp;&nbsp;<B>)</B><B>;</B></PRE></BLOCKQUOTE>

<P CLASS="ref">Parameters</P>
<BLOCKQUOTE>
<DL><DT><I>pColorKey</I>
</DT><DD>[out] Pointer to where the default color key is copied.
</DD></DL>

</BLOCKQUOTE>
<P CLASS="ref">Return Value</P>
<BLOCKQUOTE>
<P>Returns an <A HREF="../Error_Success_Codes.htm#HRESULT">HRESULT</A> value that depends on the implementation. <B>HRESULT</B> can be one of the following standard constants, or other values not listed.
<TABLE>
<TR><TD>E_FAIL </TD><TD>Failure.
</TD></TR><TR><TD>E_POINTER </TD><TD>Null pointer argument.
</TD></TR><TR><TD>E_INVALIDARG </TD><TD>Invalid argument.
</TD></TR><TR><TD>E_NOTIMPL </TD><TD>Method isn't supported.
</TD></TR><TR><TD>S_OK or NOERROR </TD><TD>Success.
</TD></TR></TABLE>


</BLOCKQUOTE>
<P CLASS="ref">Remarks</P>


<BLOCKQUOTE>

<P>A filter using color keys can get a default color from the video renderer.
The default color key can then be installed into the window using
<A HREF="IOverlay.htm#SetColorKey">IOverlay::SetColorKey</A>. The colors returned through this method vary depending
on the current display mode. If the colors are 8-bit palettized, they will be
bright system colors (such as magenta). If the display is in a true-color mode,
they will be shades of black.

<P>The <A HREF="IOverlay.htm">IOverlay</A> interface ensures that separate instances of the
renderer on the same computer get different color keys so that
overlays do not conflict.
</BLOCKQUOTE>


<H1><A NAME="GetPalette">IOverlay::GetPalette</A><HR size=1></H1>
<A HREF="IOverlay.htm">IOverlay Interface</A>
<P>Retrieves the current system palette.

<P CLASS="ref">Syntax</P><BLOCKQUOTE><PRE>
<P><B>HRESULT</B> <B>GetPalette</B><B>(</B><BR>&nbsp;&nbsp;<B>DWORD</B> <B>*</B> <I>pdwColors</I><B>,</B><BR>&nbsp;&nbsp;<B>PALETTEENTRY</B> <B>**</B> <I>ppPalette</I><BR>&nbsp;&nbsp;<B>)</B><B>;</B></PRE></BLOCKQUOTE>

<P CLASS="ref">Parameters</P>
<BLOCKQUOTE>
<DL><DT><I>pdwColors</I>
</DT><DD>[out] Number of colors present.
</DD><DT><I>ppPalette</I>
</DT><DD>[out] Retrieved palette structure.
</DD></DL>

</BLOCKQUOTE>
<P CLASS="ref">Return Value</P>
<BLOCKQUOTE>
<P>Returns an <A HREF="../Error_Success_Codes.htm#HRESULT">HRESULT</A> value that depends on the implementation. <B>HRESULT</B> can be one of the following standard constants, or other values not listed.
<TABLE>
<TR><TD>E_FAIL </TD><TD>Failure.
</TD></TR><TR><TD>E_POINTER </TD><TD>Null pointer argument.
</TD></TR><TR><TD>E_INVALIDARG </TD><TD>Invalid argument.
</TD></TR><TR><TD>E_NOTIMPL </TD><TD>Method isn't supported.
</TD></TR><TR><TD>S_OK or NOERROR </TD><TD>Success.
</TD></TR></TABLE>

</BLOCKQUOTE>


<H1><A NAME="GetVideoPosition">IOverlay::GetVideoPosition</A><HR size=1></H1>
<A HREF="IOverlay.htm">IOverlay Interface</A>
<P>Retrieves the current video source and destination rectangles.

<P CLASS="ref">Syntax</P><BLOCKQUOTE><PRE>
<P><B>HRESULT</B> <B>GetVideoPosition</B><B>(</B><BR>&nbsp;&nbsp;<B>[out]</B> <B>RECT</B> <I>*pSourceRect</I><B>,</B><BR>&nbsp;&nbsp;<B>[out]</B> <B>RECT</B> <I>*pDestinationRect</I><BR>&nbsp;&nbsp;<B>)</B><B>;</B></PRE></BLOCKQUOTE>

<P CLASS="ref">Parameters</P>
<BLOCKQUOTE>
<DL><DT><I>pSourceRect</I>
</DT><DD>[out] Bounding video client rectangle.
</DD><DT><I>pDestinationRect</I>
</DT><DD>[in] Destination video rectangle.
</DD></DL>

</BLOCKQUOTE>
<P CLASS="ref">Return Value</P>
<BLOCKQUOTE>
<P>Returns an <A HREF="../Error_Success_Codes.htm#HRESULT">HRESULT</A> value that depends on the implementation. <B>HRESULT</B> can be one of the following standard constants, or other values not listed.
<TABLE>
<TR><TD>E_FAIL </TD><TD>Failure.
</TD></TR><TR><TD>E_POINTER </TD><TD>Null pointer argument.
</TD></TR><TR><TD>E_INVALIDARG </TD><TD>Invalid argument.
</TD></TR><TR><TD>E_NOTIMPL </TD><TD>Method isn't supported.
</TD></TR><TR><TD>S_OK or NOERROR </TD><TD>Success.
</TD></TR></TABLE>

</BLOCKQUOTE>


<H1><A NAME="GetWindowHandle">IOverlay::GetWindowHandle</A><HR size=1></H1>
<A HREF="IOverlay.htm">IOverlay Interface</A>
<P>Retrieves the current window handle.

<P CLASS="ref">Syntax</P><BLOCKQUOTE><PRE>
<P><B>HRESULT</B> <B>GetWindowHandle</B><B>(</B><BR>&nbsp;&nbsp;<B>HWND</B> <I>*pHwnd</I><BR>&nbsp;&nbsp;<B>)</B><B>;</B></PRE></BLOCKQUOTE>

<P CLASS="ref">Parameters</P>
<BLOCKQUOTE>
<DL><DT><I>pHwnd</I>
</DT><DD>[out] Window handle.
</DD></DL>

</BLOCKQUOTE>
<P CLASS="ref">Return Value</P>
<BLOCKQUOTE>
<P>Returns a pointer to the window handle.

</BLOCKQUOTE>


<H1><A NAME="SetColorKey">IOverlay::SetColorKey</A><HR size=1></H1>
<A HREF="IOverlay.htm">IOverlay Interface</A>
<P>Changes the color key.

<P CLASS="ref">Syntax</P><BLOCKQUOTE><PRE>
<P><B>HRESULT</B> <B>SetColorKey</B><B>(</B><BR>&nbsp;&nbsp;<B>COLORKEY</B> <B>*</B> <I>pColorKey</I><BR>&nbsp;&nbsp;<B>)</B><B>;</B></PRE></BLOCKQUOTE>

<P CLASS="ref">Parameters</P>
<BLOCKQUOTE>
<DL><DT><I>pColorKey</I>
</DT><DD>[out] Pointer to the color key value to be set. If successful, the actual
color key value selected is copied to this parameter.
</DD></DL>

</BLOCKQUOTE>
<P CLASS="ref">Return Value</P>
<BLOCKQUOTE>
<P>Returns an <A HREF="../Error_Success_Codes.htm#HRESULT">HRESULT</A> value that depends on the implementation. <B>HRESULT</B> can be one of the following standard constants, or other values not listed.
<TABLE>
<TR><TD>E_FAIL </TD><TD>Failure.
</TD></TR><TR><TD>E_POINTER </TD><TD>Null pointer argument.
</TD></TR><TR><TD>E_INVALIDARG </TD><TD>Invalid argument.
</TD></TR><TR><TD>E_NOTIMPL </TD><TD>Method isn't supported.
</TD></TR><TR><TD>S_OK or NOERROR </TD><TD>Success.
</TD></TR></TABLE>


</BLOCKQUOTE>
<P CLASS="ref">Remarks</P>


<BLOCKQUOTE>

<P>If you change the color key by using the <B>IOverlay::SetColorKey</B> method,
all the advise links will receive an <A HREF="IOverlayNotify.htm#OnColorKeyChange">IOverlayNotify::OnColorKeyChange</A> callback
method with the new color.

<P>When using <A HREF="IOverlay.htm">IOverlay</A> on a palettized display, a filter can either install a
color key (using <B>IOverlay::SetColorKey</B>) or install a palette
(using <A HREF="IOverlay.htm#SetPalette">IOverlay::SetPalette</A>), but not both.
This is because color keys in this mode require a palette to be realized that
would conflict with <A HREF="IOverlay.htm#SetPalette">SetPalette</A>. Color keys can be uninstalled by
requesting a color key with the CK_NOCOLORKEY flag. Likewise, any palette installed
through <B>SetPalette</B> can be uninstalled by calling
<B>SetPalette</B> and passing in null parameters
(that is, SetPalette(0,NULL)).

<P>Trying to set a palette when a color key is installed returns a <A HREF="../Error_Success_Codes.htm#VFW_E_PALETTE_SET">VFW_E_PALETTE_SET</A> error. Trying to set a color key when a palette is installed returns <A HREF="../Error_Success_Codes.htm#VFW_E_COLOR_KEY_SET">VFW_E_COLOR_KEY_SET</A>.
</BLOCKQUOTE>


<H1><A NAME="SetPalette">IOverlay::SetPalette</A><HR size=1></H1>
<A HREF="IOverlay.htm">IOverlay Interface</A>
<P>Sets the palette.

<P CLASS="ref">Syntax</P><BLOCKQUOTE><PRE>
<P><B>HRESULT</B> <B>SetPalette</B><B>(</B><BR>&nbsp;&nbsp;<B>DWORD</B> <I>dwColors</I><B>,</B><BR>&nbsp;&nbsp;<B>PALETTEENTRY</B> <B>*</B> <I>pPalette</I><BR>&nbsp;&nbsp;<B>)</B><B>;</B></PRE></BLOCKQUOTE>

<P CLASS="ref">Parameters</P>
<BLOCKQUOTE>
<DL><DT><I>dwColors</I>
</DT><DD>[in] Number of colors present.
</DD><DT><I>pPalette</I>
</DT><DD>[in] Colors to use for the palette.
</DD></DL>

</BLOCKQUOTE>
<P CLASS="ref">Return Value</P>
<BLOCKQUOTE>
<P>Returns an <A HREF="../Error_Success_Codes.htm#HRESULT">HRESULT</A> value that depends on the implementation. <B>HRESULT</B> can be one of the following standard constants, or other values not listed.
<TABLE>
<TR><TD>E_FAIL </TD><TD>Failure.
</TD></TR><TR><TD>E_POINTER </TD><TD>Null pointer argument.
</TD></TR><TR><TD>E_INVALIDARG </TD><TD>Invalid argument.
</TD></TR><TR><TD>E_NOTIMPL </TD><TD>Method isn't supported.
</TD></TR><TR><TD>S_OK or NOERROR </TD><TD>Success.
</TD></TR></TABLE>


</BLOCKQUOTE>
<P CLASS="ref">Remarks</P>


<BLOCKQUOTE>

<P>This method sets a logical palette for the window. The window is not guaranteed to
always have the colors requested in the actual system device palette.
The Microsoft&#174; Windows&#174; operating system only guarantees those colors when the window is the
foreground active window. The current device palette can be obtained by calling
<A HREF="IOverlay.htm#GetPalette">IOverlay::GetPalette</A>.

<P>If the device does not have a palette, it returns <A HREF="../Error_Success_Codes.htm#VFW_E_NO_DISPLAY_PAL">VFW_E_NO_DISPLAY_PALETTE</A>.
</BLOCKQUOTE>


<H1><A NAME="Unadvise">IOverlay::Unadvise</A><HR size=1></H1>
<A HREF="IOverlay.htm">IOverlay Interface</A>
<P>Terminates the advise link established with the <A HREF="IOverlayNotify.htm">IOverlayNotify</A> interface.

<P CLASS="ref">Syntax</P><BLOCKQUOTE><PRE>
<P><B>HRESULT</B> <B>Unadvise</B><B>(</B> <B>)</B><B>;</B>
</PRE></BLOCKQUOTE>
<P CLASS="ref">Return Value</P>
<BLOCKQUOTE>
<P>Returns an <A HREF="../Error_Success_Codes.htm#HRESULT">HRESULT</A> value that depends on the implementation. <B>HRESULT</B> can be one of the following standard constants, or other values not listed.
<TABLE>
<TR><TD>E_FAIL </TD><TD>Failure.
</TD></TR><TR><TD>E_POINTER </TD><TD>Null pointer argument.
</TD></TR><TR><TD>E_INVALIDARG </TD><TD>Invalid argument.
</TD></TR><TR><TD>E_NOTIMPL </TD><TD>Method isn't supported.
</TD></TR><TR><TD>S_OK or NOERROR </TD><TD>Success.
</TD></TR></TABLE>


</BLOCKQUOTE>
<P CLASS="ref">Remarks</P>


<BLOCKQUOTE>

<P>This method terminates the advise link established by using the <A HREF="IOverlay.htm#Advise">IOverlay::Advise</A>
method. Only one advise link can be maintained at any one time.

</BLOCKQUOTE>
<!-- CONTENTS_END -->

<!-- START_PAGE_FOOTER -->


<H6><HR size=1></H6>
<P><A Class="line" HREF="#pagetop"><IMG src="../../art/arrowup1.gif" WIDTH="11" HEIGHT="11" ALIGN="MIDDLE" BORDER=0 ALT="Top of Page">&nbsp;Top of Page</A>
<BR><A Class="line" HREF="../../../cpyright.htm">&#169; 1998 Microsoft Corporation. All rights reserved. Terms of Use.</A>
<!-- END_PAGE_FOOTER -->

</BLOCKQUOTE>

<SCRIPT>if((g_isIE == true) && (g_iMaj > 3)) {window.self.document.writeln('<SCR' + 'IPT SRC="../../tip2.js"></SCR' + 'IPT><IFRAME ID="G_L_S" NAME="SecretBuffer" STYLE="display: none" SRC=""></IFRAME>')}</SCRIPT>

<!-- DACONTROL_START -->

	<DIV ID="HeadGraphAnim"></DIV>
	<SCRIPT>if((g_isIE == true) && (g_iMaj > 3)) {window.self.document.writeln('<SCR' + 'IPT SRC="../../anim.js"></SCR' + 'IPT>')}</SCRIPT>
<!-- DACONTROL_END -->

</BODY>
</HTML>
