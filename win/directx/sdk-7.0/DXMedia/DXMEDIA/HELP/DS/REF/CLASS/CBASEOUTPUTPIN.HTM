<!-- DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN" -->

<HTML>
<HEAD><TITLE>CBaseOutputPin Class</TITLE>
<SCRIPT> var sRelPath = '../../' </SCRIPT>


<META NAME="Description" CONTENT="CBaseOutputPin Class">
<META NAME="Description" CONTENT="Active (CBaseOutputPin)">
<META NAME="Description" CONTENT="CBaseOutputPin::Active">
<META NAME="Description" CONTENT="BeginFlush (CBaseOutputPin)">
<META NAME="Description" CONTENT="CBaseOutputPin::BeginFlush">
<META NAME="Description" CONTENT="BreakConnect (CBaseOutputPin)">
<META NAME="Description" CONTENT="CBaseOutputPin::BreakConnect">
<META NAME="Description" CONTENT="CBaseOutputPin (CBaseOutputPin)">
<META NAME="Description" CONTENT="CBaseOutputPin::CBaseOutputPin">
<META NAME="Description" CONTENT="CheckConnect (CBaseOutputPin)">
<META NAME="Description" CONTENT="CBaseOutputPin::CheckConnect">
<META NAME="Description" CONTENT="CompleteConnect (CBaseOutputPin)">
<META NAME="Description" CONTENT="CBaseOutputPin::CompleteConnect">
<META NAME="Description" CONTENT="DecideAllocator (CBaseOutputPin)">
<META NAME="Description" CONTENT="CBaseOutputPin::DecideAllocator">
<META NAME="Description" CONTENT="DecideBufferSize (CBaseOutputPin)">
<META NAME="Description" CONTENT="CBaseOutputPin::DecideBufferSize">
<META NAME="Description" CONTENT="Deliver (CBaseOutputPin)">
<META NAME="Description" CONTENT="CBaseOutputPin::Deliver">
<META NAME="Description" CONTENT="DeliverBeginFlush (CBaseOutputPin)">
<META NAME="Description" CONTENT="CBaseOutputPin::DeliverBeginFlush">
<META NAME="Description" CONTENT="DeliverEndFlush (CBaseOutputPin)">
<META NAME="Description" CONTENT="CBaseOutputPin::DeliverEndFlush">
<META NAME="Description" CONTENT="DeliverEndOfStream (CBaseOutputPin)">
<META NAME="Description" CONTENT="CBaseOutputPin::DeliverEndOfStream">
<META NAME="Description" CONTENT="DeliverNewSegment (CBaseOutputPin)">
<META NAME="Description" CONTENT="CBaseOutputPin::DeliverNewSegment">
<META NAME="Description" CONTENT="EndFlush (CBaseOutputPin)">
<META NAME="Description" CONTENT="CBaseOutputPin::EndFlush">
<META NAME="Description" CONTENT="EndOfStream (CBaseOutputPin)">
<META NAME="Description" CONTENT="CBaseOutputPin::EndOfStream">
<META NAME="Description" CONTENT="GetDeliveryBuffer (CBaseOutputPin)">
<META NAME="Description" CONTENT="CBaseOutputPin::GetDeliveryBuffer">
<META NAME="Description" CONTENT="Inactive (CBaseOutputPin)">
<META NAME="Description" CONTENT="CBaseOutputPin::Inactive">
<META NAME="Description" CONTENT="InitAllocator (CBaseOutputPin)">
<META NAME="Description" CONTENT="CBaseOutputPin::InitAllocator">
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; CHARSET=iso8859-1">
<META NAME="MS.LOCALE" CONTENT="EN-US">
<META NAME="ROBOTS" CONTENT="all">

<!-- SNIFF_START -->

<SCRIPT>
//<!--
var g_isIE = false, g_isNav = false, g_iMaj = 0, g_sPlat = "";
// -->

</SCRIPT>
<SCRIPT SRC="../../ver.js"></SCRIPT>
<SCRIPT SRC="../../gloss.js"></SCRIPT>

<!-- SNIFF_END -->


<SCRIPT DEFER SRC="../../common.js"></SCRIPT>
<SCRIPT DEFER>
//<!--
function InitPage()
{
	if (g_isIE && g_iMaj >= 4)	
	{

		SetTOC();
	}
}
//-->

</SCRIPT>

<!-- SNIFF_END -->


<!-- STYLE_START -->

<SCRIPT>
//<!--
   var sVR = '../../'	// Set root for the style sheet
   var sCSS = '<LINK REL="stylesheet" HREF="' + sVR;

   if(g_isIE)
   {
	   if (g_iMaj >= 4) // For MSIE 4.0 or later
	   {
		   sCSS += 'dxm_basicsdkIE4';
		   if (g_sPlat == "Win") // Windows only for now
		   {
			   document.createStyleSheet(sVR + 'dxm_advSDKIE4.css');
		   }
	   }
	   else // For MSIE 3.0 or earlier
	   {
		   sCSS += 'dxm_basicsdkIE3';
	   }
   }
   else if (g_isNav) // For all Nav versions
   {
	   sCSS += 'dxm_basicsdkNAV';
   }
   else
   {
	   sCSS += 'dxm_basicsdkIE3'; // default to IE3 sheet
   }

   sCSS += (sCSS == '' ? '' : '.css" TYPE="text/css">');

   document.write(sCSS);
//-->

</SCRIPT>
<!-- STYLE_END -->


</HEAD>
<BODY onload="InitPage(); if (g_isIE && g_iMaj >= 4){HdgrphControl()}" BGCOLOR="#FFFFFF">
<A NAME="pagetop"></A><A NAME="CBaseOutputPin"></A>

<!-- HEADGRAPH_START -->

<TABLE CLASS="main" BORDER=0 CELLSPACING="0" CELLPADDING="0" WIDTH="*">
<TR>
<TD ROWSPAN="3" VALIGN="TOP" WIDTH="*">
<IMG SRC="../../art/header1.gif" WIDTH="107" HEIGHT="110" BORDER=0 ALT="DirectShow Animated Header"></TD>
<TD ROWSPAN="2" VALIGN="TOP" WIDTH="217"><IMG SRC="../../art/hdrdshow.gif" WIDTH="217" HEIGHT="110" BORDER=0 ALT="DirectShow Animated Header"></TD>
<TD VALIGN="TOP" WIDTH="383">
<IMG SRC="../../art/header3.gif" WIDTH="383" HEIGHT="95" BORDER=0 ALT="DirectShow Animated Header">
</TD>
<TD VALIGN="TOP" WIDTH="100%">
<IMG SRC="../../art/spacer1.gif" WIDTH="100%" HEIGHT="94" BORDER=0 ALT="Microsoft DirectShow SDK">
</TD>
</TR>
<!-- HEADGRAPH_END -->

<!-- NAV_LINKS_START -->

<TR><TD VALIGN="TOP"><PRE><IMG ID="TOC_" SRC="../../art/yelbtn.gif" WIDTH="11" HEIGHT="11" ALIGN="MIDDLE" BORDER=0 ALT="*"><A STYLE="color:black;font-weight:bold" ID="TOC" HREF="../../contents.htm">Contents</A>  <IMG SRC="../../art/yelbtn.gif" WIDTH="11" HEIGHT="11" ALIGN="MIDDLE" BORDER=0 ALT="*"><A STYLE="color:black;font-weight:bold" HREF="../../index.htm">Index</A>  <IMG SRC="../../art/yelbtn.gif" WIDTH="11" HEIGHT="11" ALIGN="MIDDLE" BORDER=0 ALT="*"><A STYLE="color:black;font-weight:bold" HREF="Classes_intro.htm">Topic Contents</A>
</PRE></TD></TR>
<TR><TD COLSPAN="2" VALIGN="TOP"><PRE><IMG SRC="../../art/yelbtn.gif" WIDTH="11" HEIGHT="11" ALIGN="MIDDLE" BORDER=0 ALT="*"><B>Previous Topic:</B> <A STYLE="color:black" HREF="CBaseObject.htm">CBaseObject Class</A>
<IMG SRC="../../art/yelbtn.gif" WIDTH="11" HEIGHT="11" ALIGN="MIDDLE" BORDER=0 ALT="*"><B>Next Topic:</B> <A  STYLE="color:black" HREF="CBasePin.htm">CBasePin Class</A>
</PRE></TD></TR></TABLE>
<!-- NAV_LINKS_END -->


<BLOCKQUOTE CLASS="body">


<!-- CONTENTS_START -->

<H1>CBaseOutputPin Class</H1>

<P><IMG SRC="../../art/filter06.gif" WIDTH="302" HEIGHT="202" ALT="CBaseOutputPin class hierarchy">

<P><B>CBaseOutputPin</B> is an abstract base class derived from the <A HREF="CBasePin.htm">CBasePin</A> class 
that provides support for the common memory <A CLASS="Glossary" HREF="javascript:Glossary(sRelPath + 'gloss/gloss_T.htm#transport')">transport</A>. <B>CBaseOutputPin</B> connects only 
to an <A CLASS="Glossary" HREF="javascript:Glossary(sRelPath + 'gloss/gloss_I.htm#input_pin')">input pin</A> that supplies an <A HREF="../iface/IMemInputPin.htm">IMemInputPin</A> interface (such as a <A CLASS="Glossary" HREF="javascript:Glossary(sRelPath + 'gloss/gloss_P.htm#pin')">pin</A> class derived from 
the <A HREF="CBaseInputPin.htm">CBaseInputPin</A> class), and provides methods for the <A CLASS="Glossary" HREF="javascript:Glossary(sRelPath + 'gloss/gloss_f.htm#filter')">filter</A> to access that interface. 
Derive your <A CLASS="Glossary" HREF="javascript:Glossary(sRelPath + 'gloss/gloss_O.htm#output_pin')">output pins</A> from this class for the easiest implementation.

<P>An output pin must provide one or more media types when connected to an
input pin. If the media type that returns an index size, for example,
is not currently available, the output pin should return S_FALSE in the
<A HREF="CBasePin.htm#GetMediaType">CBasePin::GetMediaType</A> member function, and the base class will skip it.

<P>Your output pin class methods (represented here with the class name CYourPin) should call
<B>CBaseOutputPin</B>. For example, CYourPin::Active should call <A HREF="CBaseOutputPin.htm#Active">CBaseOutputPin::Active</A>
first, to see if it should proceed. CYourPin::Inactive should call
<A HREF="CBaseOutputPin.htm#Inactive">CBaseOutputPin::Inactive</A> first, to decommit the sample
allocator and avoid deadlock problems with <A HREF="CBaseOutputPin.htm#GetDeliveryBuffer">CBaseOutputPin::GetDeliveryBuffer</A>.

<P>All member functions in this class that return <A HREF="../Error_Success_Codes.htm#HRESULT">HRESULT</A> and accept a pointer as a 
parameter return E_POINTER when passed a null pointer. 

<P>All <A HREF="../iface/IQualityControl.htm">IQualityControl</A> method implementations are inherited from the <A HREF="CBasePin.htm">CBasePin</A> 
class and are not overridden by this class. 

<A NAME="Protected_Data_Membe"></A><P CLASS="ref">Protected Data Members</P>
<TABLE><TR><TD><B><A NAME="CBaseOutputPin::m_pAllocator">m_pAllocator</A></B>
 </TD><TD>Pointer to the <A HREF="../iface/IMemAllocator.htm">IMemAllocator</A> interface for this pin.
</TD></TR><TR><TD><B><A NAME="CBaseOutputPin::m_pInputPin">m_pInputPin</A></B>
 </TD><TD>Pointer to the input pin to which this pin is connected.
</TD></TR></TABLE>
<A NAME="Member_Functions"></A><P CLASS="ref">Member Functions</P>

<TABLE><TR><TD><A HREF="CBaseOutputPin.htm#CBaseOutputPin_CBaseOutputPin">CBaseOutputPin</A>
 </TD><TD>Constructs a <A HREF="CBaseOutputPin.htm">CBaseOutputPin</A> object.
</TD></TR></TABLE>
<A NAME="Overridable_Member_F"></A><P CLASS="ref">Overridable Member Functions</P>

<TABLE><TR><TD><A HREF="CBaseOutputPin.htm#Active">Active</A>
 </TD><TD>Switches the pin to the active (running) mode.
</TD></TR><TR><TD><A HREF="CBaseOutputPin.htm#BreakConnect">BreakConnect</A>
 </TD><TD>Releases the allocator and the <A HREF="../iface/IMemInputPin.htm">IMemInputPin</A> interface.
</TD></TR><TR><TD><A HREF="CBaseOutputPin.htm#CheckConnect">CheckConnect</A>
 </TD><TD>Calls <A HREF="../iface/IUnknown.htm#QueryInterface">QueryInterface</A> to retrieve an <A HREF="../iface/IMemInputPin.htm">IMemInputPin</A> interface.
</TD></TR><TR><TD><A HREF="CBaseOutputPin.htm#CompleteConnect">CompleteConnect</A>
 </TD><TD>Completes the connection.
</TD></TR><TR><TD><A HREF="CBaseOutputPin.htm#DecideAllocator">DecideAllocator</A>
 </TD><TD>Negotiates the allocator.
</TD></TR><TR><TD><A HREF="CBaseOutputPin.htm#DecideBufferSize">DecideBufferSize</A>
 </TD><TD>Retrieves the number and size of buffers required for the transfer.
</TD></TR><TR><TD><A HREF="CBaseOutputPin.htm#Deliver">Deliver</A> 
 </TD><TD>Delivers an <A HREF="../iface/IMediaSample.htm">IMediaSample</A> buffer to the connecting pin.
</TD></TR><TR><TD><A HREF="CBaseOutputPin.htm#DeliverBeginFlush">DeliverBeginFlush</A>
 </TD><TD>Calls the <A HREF="../iface/IPin.htm#BeginFlush">IPin::BeginFlush</A> method on the connected pin.
</TD></TR><TR><TD><A HREF="CBaseOutputPin.htm#DeliverEndFlush">DeliverEndFlush</A> 
 </TD><TD>Calls <A HREF="../iface/IPin.htm#EndFlush">IPin::EndFlush</A> on the connected input pin to pass an end-flushing notification.
</TD></TR><TR><TD><A HREF="CBaseOutputPin.htm#DeliverEndOfStream">DeliverEndOfStream</A> 
 </TD><TD>Calls <A HREF="../iface/IPin.htm#EndOfStream">IPin::EndOfStream</A> on the connected input pin to pass an end-of-stream 
notification.
</TD></TR><TR><TD><A HREF="CBaseOutputPin.htm#DeliverNewSegment">DeliverNewSegment</A> 
 </TD><TD>Calls <A HREF="../iface/IPin.htm#NewSegment">IPin::NewSegment</A> on the connected input pin to pass a segment.
</TD></TR><TR><TD><A HREF="CBaseOutputPin.htm#GetDeliveryBuffer">GetDeliveryBuffer</A>
 </TD><TD>Returns an <A HREF="../iface/IMediaSample.htm">IMediaSample</A> buffer suitable for passing across the connection.
</TD></TR><TR><TD><A HREF="CBaseOutputPin.htm#Inactive">Inactive</A>
 </TD><TD>Switches the pin to the inactive (stopped) mode.
</TD></TR><TR><TD><A HREF="CBaseOutputPin.htm#InitAllocator">InitAllocator</A> 
 </TD><TD>Creates a default memory allocator. Override this to provide your
 own allocator or to provide no allocator.
</TD></TR></TABLE>
<P CLASS="ref"><A NAME="Implemented_IPin_Met"></A>Implemented IPin Methods</P>


<TABLE><TR><TD><A HREF="CBaseOutputPin.htm#BeginFlush">BeginFlush</A>
</TD><TD>Informs the pin to begin a flush operation. Implemented to return E_UNEXPECTED 
because it is an error to call this on an output pin.
</TD></TR><TR><TD><A HREF="CBaseOutputPin.htm#EndFlush">EndFlush</A>
</TD><TD>Informs the pin to end a flush operation. Implemented to return E_UNEXPECTED 
because it is an error to call this on an output pin.
</TD></TR><TR><TD><A HREF="CBaseOutputPin.htm#EndOfStream">EndOfStream</A>
</TD><TD>Informs the pin that no additional data is expected until a new run command is issued. 
Implemented to return E_UNEXPECTED because it is an error to call this on an output pin.
</TD></TR></TABLE>



<H1><A NAME="Active">CBaseOutputPin::Active</A><HR size=1></H1>
<A HREF="CBaseOutputPin.htm">CBaseOutputPin Class</A>
<P>Called by the <A HREF="CBaseFilter.htm">CBaseFilter</A> implementation when the state changes from stopped to either paused or running.

<P CLASS="ref">Syntax</P>
<BLOCKQUOTE><PRE>
<P><B>HRESULT</B> <B>Active</B><B>(</B><B>void</B><B>)</B><B>;</B>
</PRE></BLOCKQUOTE>
<P CLASS="ref">Return Value</P>
<BLOCKQUOTE>
<P>Returns <A HREF="../Error_Success_Codes.htm#VFW_E_NO_ALLOCATOR">VFW_E_NO_ALLOCATOR</A> if there is no allocator.
</BLOCKQUOTE>

<P CLASS="ref">Remarks</P>
<BLOCKQUOTE>
<P>This member function calls <A HREF="CBaseAllocator.htm#Commit">CMemAllocator::Commit</A> to commit memory required before becoming active.
</BLOCKQUOTE>


<H1><A NAME="BeginFlush">CBaseOutputPin::BeginFlush</A><HR size=1></H1>
<A HREF="CBaseOutputPin.htm">CBaseOutputPin Class</A>
<P>Informs the pin to begin a flush operation.

<P CLASS="ref">Syntax</P>
<BLOCKQUOTE><PRE>
<P><B>HRESULT</B> <B>BeginFlush</B><B>(</B><B>void</B><B>)</B><B>;</B>
</PRE></BLOCKQUOTE>
<P CLASS="ref">Return Value</P>
<BLOCKQUOTE>
<P>Returns E_UNEXPECTED.

</BLOCKQUOTE>

<P CLASS="ref">Remarks</P>
<BLOCKQUOTE>
<P>This member function implements the <A HREF="../iface/IPin.htm#BeginFlush">IPin::BeginFlush</A> method. It returns E_UNEXPECTED because this should be called only on input pins. 
</BLOCKQUOTE>


<H1><A NAME="BreakConnect">CBaseOutputPin::BreakConnect</A><HR size=1></H1>
<A HREF="CBaseOutputPin.htm">CBaseOutputPin Class</A>
<P>Releases <A HREF="../iface/IMemAllocator.htm">IMemAllocator</A> and <A HREF="../iface/IMemInputPin.htm">IMemInputPin</A> objects acquired by the pin.

<P CLASS="ref">Syntax</P>
<BLOCKQUOTE><PRE>
<P><B>HRESULT</B> <B>BreakConnect</B><B>(</B><B>void</B><B>)</B><B>;</B>
</PRE></BLOCKQUOTE>
<P CLASS="ref">Return Value</P>
<BLOCKQUOTE>
<P>Returns NOERROR by the default base class implementation.


</BLOCKQUOTE>

<P CLASS="ref">Remarks</P>
<BLOCKQUOTE>
<P>This member function releases the <A HREF="../iface/IMemAllocator.htm">IMemAllocator</A> and <A HREF="../iface/IPin.htm">IPin</A> interfaces used
during the connection.

<P>If you override this method, always call the base class <B>BreakConnect</B> or unexpected behavior will result, including reference count leaks.
</BLOCKQUOTE>


<H1><A NAME="CBaseOutputPin_CBaseOutputPin">CBaseOutputPin::CBaseOutputPin</A><HR size=1></H1>
<A HREF="CBaseOutputPin.htm">CBaseOutputPin Class</A>
<P>Constructs a <A HREF="CBaseOutputPin.htm">CBaseOutputPin</A> object.
<P CLASS="ref">Syntax</P><BLOCKQUOTE><PRE>
<P><B>CBaseOutputPin</B><B>(</B><BR>&nbsp;&nbsp;<B>TCHAR</B> <I>*pObjectName</I><B>,</B><BR>&nbsp;&nbsp;<B>CBaseFilter</B> <I>*pFilter</I><B>,</B><BR>&nbsp;&nbsp;<B>CCritSec</B> <I>*pLock</I><B>,</B><BR>&nbsp;&nbsp;<B>HRESULT</B> <B>*</B> <I>phr</I><B>,</B><BR>&nbsp;&nbsp;<B>LPCWSTR</B> <I>pName</I><BR>&nbsp;&nbsp;<B>)</B><B>;</B>
</PRE></BLOCKQUOTE>

<P CLASS="ref">Parameters</P>
<BLOCKQUOTE>
<DL><DT><I>pObjectName</I>
 </DT><DD>Name of the object used in the <A HREF="CBaseOutputPin.htm">CBaseOutputPin</A> constructor for debugging purposes.
</DD><DT><I>pFilter</I>
 </DT><DD>Filter to which the pin will be attached.
</DD><DT><I>pLock</I>
 </DT><DD>Pointer to a <A HREF="CBaseOutputPin.htm">CBaseOutputPin</A> object for locking.
</DD><DT><I>phr</I>
</DT><DD>Pointer to the general COM return value. This value is changed only if this function fails.
</DD><DT><I>pName</I>
 </DT><DD>Pin name.
</DD></DL>
</BLOCKQUOTE>

<P CLASS="ref">Return Value</P>
<BLOCKQUOTE>
<P>No return value.
</BLOCKQUOTE>


<H1><A NAME="CheckConnect">CBaseOutputPin::CheckConnect</A><HR size=1></H1>
<A HREF="CBaseOutputPin.htm">CBaseOutputPin Class</A>
<P>Calls <A HREF="../iface/IUnknown.htm#QueryInterface">QueryInterface</A> on the connected pin to retrieve an <A HREF="../iface/IMemInputPin.htm">IMemInputPin</A> interface.

<P CLASS="ref">Syntax</P>
<BLOCKQUOTE><PRE>
<P><B>HRESULT</B> <B>CheckConnect</B><B>(</B><BR>&nbsp;&nbsp;<B>IPin</B> <I>*pPin</I><BR>&nbsp;&nbsp;<B>)</B><B>;</B>
</PRE></BLOCKQUOTE>

<P CLASS="ref">Parameters</P>
<BLOCKQUOTE>
<DL><DT><I>pPin</I>
</DT><DD>Pointer to the <A HREF="../iface/IPin.htm">IPin</A> interface on the connecting pin.
</DD></DL>
</BLOCKQUOTE>

<P CLASS="ref">Return Value</P>
<BLOCKQUOTE>
<P>Returns NOERROR if successful; otherwise, returns an <A HREF="../Error_Success_Codes.htm#HRESULT">HRESULT</A> error value.


</BLOCKQUOTE>


<H1><A NAME="CompleteConnect">CBaseOutputPin::CompleteConnect</A><HR size=1></H1>
<A HREF="CBaseOutputPin.htm">CBaseOutputPin Class</A>
<P>Completes a connection to another filter.

<P CLASS="ref">Syntax</P>
<BLOCKQUOTE><PRE>
<P><B>virtual</B> <B>HRESULT</B> <B>CompleteConnect</B><B>(</B><BR>&nbsp;&nbsp;<B>IPin</B> <I>*pReceivePin</I><BR>&nbsp;&nbsp;<B>)</B><B>;</B>
</PRE></BLOCKQUOTE>

<P CLASS="ref">Parameters</P>
<BLOCKQUOTE>
<DL><DT><I>pReceivePin</I>
 </DT><DD>Pointer to the connected (receiving) pin.
</DD></DL>
</BLOCKQUOTE>

<P CLASS="ref">Return Value</P>
<BLOCKQUOTE>
<P>Returns an <A HREF="../Error_Success_Codes.htm#HRESULT">HRESULT</A> value. The default implementation returns NOERROR.


</BLOCKQUOTE>

<P CLASS="ref">Remarks</P>
<BLOCKQUOTE>
<P>This member function overrides the <A HREF="CBasePin.htm#CompleteConnect">CBasePin::CompleteConnect</A> member 
function and calls the <A HREF="CBaseOutputPin.htm#DecideAllocator">CBaseOutputPin::DecideAllocator</A> member function to finish 
completing the connection.
</BLOCKQUOTE>


<H1><A NAME="DecideAllocator">CBaseOutputPin::DecideAllocator</A><HR size=1></H1>
<A HREF="CBaseOutputPin.htm">CBaseOutputPin Class</A>
<P>Negotiates the allocator to use.

<P CLASS="ref">Syntax</P>
<BLOCKQUOTE><PRE>
<P><B>virtual</B> <B>HRESULT</B> <B>DecideAllocator</B><B>(</B><BR>&nbsp;&nbsp;<B>IMemInputPin</B> <B>*</B> <I>pPin</I><B>,</B><BR>&nbsp;&nbsp;<B>IMemAllocator</B> <B>**</B> <I>pAlloc</I><BR>&nbsp;&nbsp;<B>)</B><B>;</B>
</PRE></BLOCKQUOTE>

<P CLASS="ref">Parameters</P>
<BLOCKQUOTE>
<DL><DT><I>pPin</I>
</DT><DD>Pointer to the <A HREF="../iface/IPin.htm">IPin</A> interface of the connecting pin.
</DD><DT><I>pAlloc</I>
</DT><DD>Pointer to the negotiated <A HREF="../iface/IMemAllocator.htm">IMemAllocator</A> interface.
</DD></DL>
</BLOCKQUOTE>

<P CLASS="ref">Return Value</P>
<BLOCKQUOTE>
<P>Returns NOERROR if successful; otherwise, returns an <A HREF="../Error_Success_Codes.htm#HRESULT">HRESULT</A> value.


</BLOCKQUOTE>

<P CLASS="ref">Remarks</P>
<BLOCKQUOTE>
<P>This member function calls the <A HREF="CBaseOutputPin.htm#DecideBufferSize">CBaseOutputPin::DecideBufferSize</A> member 
function, which is not implemented by this base class.
Override <A HREF="CBaseOutputPin.htm#DecideBufferSize">DecideBufferSize</A>
to call <A HREF="../iface/IMemAllocator.htm#SetProperties">IMemAllocator::SetProperties</A>.

<P>If the connected input pin fails a call to <A HREF="../iface/IMemInputPin.htm#GetAllocator">IMemInputPin::GetAllocator</A>, 
this member function constructs a <A HREF="CMemAllocator.htm">CMemAllocator</A> object and calls 
<A HREF="CBaseOutputPin.htm#DecideBufferSize">CBaseOutputPin::DecideBufferSize</A> on that object. If the call to 
<A HREF="CBaseOutputPin.htm#DecideBufferSize">DecideBufferSize</A> is successful, this member 
function notifies the input pin of the selected allocator. This function is called by the base class 
implementation of the <A HREF="../iface/IPin.htm#Connect">IPin::Connect</A> method, which is responsible for locking the 
object's critical section.

<P>Override this member function if you want to use your own allocator. The input pin
gets the first choice for the allocator, and the output pin agrees or forces it to use
another allocator.
</BLOCKQUOTE>


<H1><A NAME="DecideBufferSize">CBaseOutputPin::DecideBufferSize</A><HR size=1></H1>
<A HREF="CBaseOutputPin.htm">CBaseOutputPin Class</A>
<P>Retrieves the number and size of buffers required for the transfer.

<P CLASS="ref">Syntax</P>
<BLOCKQUOTE><PRE>
<P><B>virtual</B> <B>HRESULT</B> <B>DecideBufferSize</B><B>(</B><BR>&nbsp;&nbsp;<B>IMemAllocator</B> <B>*</B> <I>pAlloc</I><B>,</B><BR>&nbsp;&nbsp;<B>ALLOCATOR_PROPERTIES</B> <B>*</B> <I>ppropInputRequest</I><BR>&nbsp;&nbsp;<B>)</B> <B>PURE;</B>
</PRE></BLOCKQUOTE>

<P CLASS="ref">Parameters</P>
<BLOCKQUOTE>
<DL><DT><I>pAlloc</I>
</DT><DD>Allocator assigned to the transfer.
</DD><DT><I>ppropInputRequest</I>
</DT><DD>Requested allocator properties for count, size, and alignment,
as specified by the <A HREF="../structs.htm#ALLOCATOR_PROPERTIES">ALLOCATOR_PROPERTIES</A> structure.
</DD></DL>
</BLOCKQUOTE>

<P CLASS="ref">Return Value</P>
<BLOCKQUOTE>
<P>Returns an <A HREF="../Error_Success_Codes.htm#HRESULT">HRESULT</A> value.


</BLOCKQUOTE>

<P CLASS="ref">Remarks</P>
<BLOCKQUOTE>
<P>The <A HREF="CBaseOutputPin.htm#DecideAllocator">CBaseOutputPin::DecideAllocator</A> member function calls this member function.
You must override this member function in your derived class and call
<A HREF="../iface/IMemAllocator.htm#SetProperties">IMemAllocator::SetProperties</A>.
</BLOCKQUOTE>


<H1><A NAME="Deliver">CBaseOutputPin::Deliver</A><HR size=1></H1>
<A HREF="CBaseOutputPin.htm">CBaseOutputPin Class</A>
<P>Delivers the <A HREF="../iface/IMediaSample.htm">IMediaSample</A> buffer to the connected pin.

<P CLASS="ref">Syntax</P>
<BLOCKQUOTE><PRE>
<P><B>virtual</B> <B>HRESULT</B> <B>Deliver</B><B>(</B><BR>&nbsp;&nbsp;<B>IMediaSample</B> <I>*pSample</I><BR>&nbsp;&nbsp;<B>)</B><B>;</B>
</PRE></BLOCKQUOTE>

<P CLASS="ref">Parameters</P>
<BLOCKQUOTE>
<DL><DT><I>pSample</I>
</DT><DD>Buffer to deliver.
</DD></DL>
</BLOCKQUOTE>

<P CLASS="ref">Return Value</P>
<BLOCKQUOTE>
<P>Returns <A HREF="../Error_Success_Codes.htm#VFW_E_NOT_CONNECTED">VFW_E_NOT_CONNECTED</A> if no input pin is found;
otherwise, returns an <A HREF="../Error_Success_Codes.htm#HRESULT">HRESULT</A> value.


</BLOCKQUOTE>

<P CLASS="ref">Remarks</P>
<BLOCKQUOTE>
<P>This member function delivers this buffer to the connected input pin by calling its
<A HREF="../iface/IMemInputPin.htm#Receive">IMemInputPin::Receive</A> method.
</BLOCKQUOTE>


<H1><A NAME="DeliverBeginFlush">CBaseOutputPin::DeliverBeginFlush</A><HR size=1></H1>
<A HREF="CBaseOutputPin.htm">CBaseOutputPin Class</A>
<P>Calls the <A HREF="../iface/IPin.htm#BeginFlush">IPin::BeginFlush</A> method on the connected input pin.

<P CLASS="ref">Syntax</P>
<BLOCKQUOTE><PRE>
<P><B>virtual</B> <B>HRESULT</B> <B>DeliverBeginFlush</B><B>(</B><B>void</B><B>)</B><B>;</B>
</PRE></BLOCKQUOTE>
<P CLASS="ref">Return Value</P>
<BLOCKQUOTE>
<P>Returns <A HREF="../Error_Success_Codes.htm#VFW_E_NOT_CONNECTED">VFW_E_NOT_CONNECTED</A> if no input pin is found; 
otherwise, returns the value that is returned by the <A HREF="../iface/IPin.htm#BeginFlush">IPin::BeginFlush</A> method.


</BLOCKQUOTE>

<P CLASS="ref">Remarks</P>
<BLOCKQUOTE>
<P>This member function delivers the BeginFlush notification downstream.
</BLOCKQUOTE>


<H1><A NAME="DeliverEndFlush">CBaseOutputPin::DeliverEndFlush</A><HR size=1></H1>
<A HREF="CBaseOutputPin.htm">CBaseOutputPin Class</A>
<P>Calls the <A HREF="../iface/IPin.htm#EndFlush">IPin::EndFlush</A> method on the connected input pin.

<P CLASS="ref">Syntax</P>
<BLOCKQUOTE><PRE>
<P><B>virtual</B> <B>HRESULT</B> <B>DeliverEndFlush</B><B>(</B><B>void</B><B>)</B><B>;</B>
</PRE></BLOCKQUOTE>
<P CLASS="ref">Return Value</P>
<BLOCKQUOTE>
<P>Returns <A HREF="../Error_Success_Codes.htm#VFW_E_NOT_CONNECTED">VFW_E_NOT_CONNECTED</A> if no input pin is found; otherwise,
returns the value that is returned by <A HREF="../iface/IPin.htm#EndFlush">IPin::EndFlush</A>.


</BLOCKQUOTE>

<P CLASS="ref">Remarks</P>
<BLOCKQUOTE>
<P>This member function delivers the EndFlush notification downstream.
</BLOCKQUOTE>


<H1><A NAME="DeliverEndOfStream">CBaseOutputPin::DeliverEndOfStream</A><HR size=1></H1>
<A HREF="CBaseOutputPin.htm">CBaseOutputPin Class</A>
<P>Calls the <A HREF="../iface/IPin.htm#EndOfStream">IPin::EndOfStream</A> method on the connected input pin.

<P CLASS="ref">Syntax</P>
<BLOCKQUOTE><PRE>
<P><B>virtual</B> <B>HRESULT</B> <B>DeliverEndOfStream</B><B>(</B><B>void</B><B>)</B><B>;</B>
</PRE></BLOCKQUOTE>
<P CLASS="ref">Return Value</P>
<BLOCKQUOTE>
<P>Returns <A HREF="../Error_Success_Codes.htm#VFW_E_NOT_CONNECTED">VFW_E_NOT_CONNECTED</A> if no input pin is found; 
otherwise, returns the value returned by the <A HREF="../iface/IPin.htm#EndOfStream">IPin::EndOfStream</A> call to the connected pin.


</BLOCKQUOTE>

<P CLASS="ref">Remarks</P>
<BLOCKQUOTE>
<P>This member function delivers the end-of-stream notification downstream by calling the
<A HREF="../iface/IPin.htm#EndOfStream">IPin::EndOfStream</A> method on the connected pin.
</BLOCKQUOTE>


<H1><A NAME="DeliverNewSegment">CBaseOutputPin::DeliverNewSegment</A><HR size=1></H1>
<A HREF="CBaseOutputPin.htm">CBaseOutputPin Class</A>
<P>Calls the <A HREF="../iface/IPin.htm#NewSegment">IPin::NewSegment</A> method on the connected input pin.

<P CLASS="ref">Syntax</P>
<BLOCKQUOTE><PRE>
<P><B>virtual</B> <B>HRESULT</B> <B>DeliverNewSegment</B><B>(</B><BR>&nbsp;&nbsp;<B>REFERENCE_TIME</B> <I>tStart</I><B>,</B><BR>&nbsp;&nbsp;<B>REFERENCE_TIME</B> <I>tStop</I><B>,</B><BR>&nbsp;&nbsp;<B>double</B> <I>dRate</I><BR>&nbsp;&nbsp;<B>)</B><B>;</B>
</PRE></BLOCKQUOTE>

<P CLASS="ref">Parameters</P>
<BLOCKQUOTE>
<DL><DT><I>tStart</I>
</DT><DD>Start time of the segment.
</DD><DT><I>tStop</I>
</DT><DD>Stop time of the segment.
</DD><DT><I>dRate</I>
</DT><DD>Rate of the segment.
</DD></DL>
</BLOCKQUOTE>

<P CLASS="ref">Return Value</P>
<BLOCKQUOTE>
<P>Returns an <A HREF="../Error_Success_Codes.htm#HRESULT">HRESULT</A> value.


</BLOCKQUOTE>

<P CLASS="ref">Remarks</P>
<BLOCKQUOTE>
<P>You will need to override this member function in your derived output pin class if your filter
queues any data in the output pin.
</BLOCKQUOTE>


<H1><A NAME="EndFlush">CBaseOutputPin::EndFlush</A><HR size=1></H1>
<A HREF="../iface/IPin.htm">IPin Interface</A>
<P>Informs the pin to end a flush operation.

<P CLASS="ref">Syntax</P>
<BLOCKQUOTE><PRE>
<P><B>HRESULT</B> <B>EndFlush</B><B>(</B><B>void</B><B>)</B><B>;</B>
</PRE></BLOCKQUOTE>
<P CLASS="ref">Return Value</P>
<BLOCKQUOTE>
<P>Returns E_UNEXPECTED.

</BLOCKQUOTE>

<P CLASS="ref">Remarks</P>
<BLOCKQUOTE>
<P>This member function implements the <A HREF="../iface/IPin.htm#EndFlush">IPin::EndFlush</A> method. It returns E_UNEXPECTED because this should be called only on input pins. 
</BLOCKQUOTE>


<H1><A NAME="EndOfStream">CBaseOutputPin::EndOfStream</A><HR size=1></H1>
<A HREF="../iface/IPin.htm">IPin Interface</A>
<P>Informs the input pin that no additional data is expected until a new run command is issued.

<P CLASS="ref">Syntax</P>
<BLOCKQUOTE><PRE>
<P><B>HRESULT</B> <B>EndOfStream</B><B>(</B><B>void</B><B>)</B><B>;</B>
</PRE></BLOCKQUOTE>

<P CLASS="ref">Return Value</P>
<BLOCKQUOTE>
<P>Returns E_UNEXPECTED.


</BLOCKQUOTE>

<P CLASS="ref">Remarks</P>
<BLOCKQUOTE>
<P>This member function implements the <A HREF="../iface/IPin.htm#EndOfStream">IPin::EndOfStream</A> method but isn't expected to be called on an output pin. 
</BLOCKQUOTE>


<H1><A NAME="GetDeliveryBuffer">CBaseOutputPin::GetDeliveryBuffer</A><HR size=1></H1>
<A HREF="CBaseOutputPin.htm">CBaseOutputPin Class</A>
<P>Retrieves an <A HREF="../iface/IMediaSample.htm">IMediaSample</A> buffer suitable for passing across the connection.

<P CLASS="ref">Syntax</P>
<BLOCKQUOTE><PRE>
<P><B>virtual</B> <B>HRESULT</B> <B>GetDeliveryBuffer</B><B>(</B><BR>&nbsp;&nbsp;<B>IMediaSample</B> <B>**</B> <I>ppSample</I><B>,</B><BR>&nbsp;&nbsp;<B>REFERENCE_TIME</B> <B>*</B> <I>pStartTime</I><B>,</B><BR>&nbsp;&nbsp;<B>REFERENCE_TIME</B> <B>*</B> <I>pEndTime</I><B>,</B><BR>&nbsp;&nbsp;<B>DWORD</B> <I>dwFlags</I><BR>&nbsp;&nbsp;<B>)</B><B>;</B>
</PRE></BLOCKQUOTE>

<P CLASS="ref">Parameters</P>
<BLOCKQUOTE>
<DL><DT><I>ppSample</I>
 </DT><DD><A HREF="../iface/IMediaSample.htm">IMediaSample</A> buffer to be provided.
</DD><DT><I>pStartTime</I>
 </DT><DD>Start time of the media sample (optional and can be NULL).
</DD><DT><I>pEndTime</I>
 </DT><DD>Stop time of the media sample (optional and can be NULL).
</DD><DT><I>dwFlags</I>
 </DT><DD>The following flags are supported.
 <TABLE>
<TR><TD>AM_GBF_NOTASYNCPOINT
 </TD><TD>Dynamic format changes are not allowed on this buffer because it is not a key frame. 
</TD></TR><TR><TD>AM_GBF_PREVFRAMESKIPPED
 </TD><TD>Buffer returned will not be filled with data contiguous with any previous data sent.
 </TD></TR></TABLE>
</DD></DL>
</BLOCKQUOTE>

<P CLASS="ref">Return Value</P>
<BLOCKQUOTE>
<P>Returns E_NOINTERFACE if an allocator is not found; otherwise, returns the 
value returned from calling the <A HREF="../iface/IMemAllocator.htm#GetBuffer">IMemAllocator::GetBuffer</A> method.


</BLOCKQUOTE>

<P CLASS="ref">Remarks</P>
<BLOCKQUOTE>
<P>The pin object must lock itself before calling this member function; otherwise,
the <A CLASS="Glossary" HREF="javascript:Glossary(sRelPath + 'gloss/gloss_F.htm#filter_graph')">filter graph</A> could disconnect this pin from the input pin midway through the process.
If the filter has no worker threads, the lock is best applied on the <A HREF="../iface/IMemInputPin.htm#Receive">IMemInputPin::Receive</A> call; 
otherwise, it should be done when the worker thread is ready to deliver the sample.

<P>This call can block; therefore, to avoid deadlocking with an <A HREF="../iface/IMediaFilter.htm#Stop">IMediaFilter::Stop</A> 
command, a two-tier locking scheme (such as that implemented in <A HREF="CTransformFilter.htm">CTransformFilter</A>) 
is required. Only the second-level lock is acquired here. The <A HREF="../iface/IBaseFilter.htm">IBaseFilter</A> base class 
implementation of <B>IMediaFilter::Stop</B> first gets the first-level lock and then calls 
<A HREF="../iface/IMemAllocator.htm#Decommit">IMemAllocator::Decommit</A> on the allocator. This has the effect of
making <B>GetDeliveryBuffer</B> return with a failure code. 
The <A HREF="CBaseFilter.htm#Stop">Stop</A> member function 
then gets the second-level lock and completes the command by calling <A HREF="CBaseOutputPin.htm#Inactive">Inactive</A> for this pin.

<P>No lock is needed when calling <B>CBaseOutputPin::GetDeliveryBuffer</B> when passing 
on samples using a worker thread. In this case, the <A HREF="CBaseFilter.htm#Stop">CBaseFilter::Stop</A> base class implementation 
acquires its filter-level lock and just calls <A HREF="../iface/IMemAllocator.htm#Decommit">IMemAllocator::Decommit</A> on the allocator, 
at which point the worker thread is freed up to listen for a command to stop.

<P>You must release the sample yourself after this function. If the connected
input pin needs to hold on to the sample beyond the function, it will add the reference for the 
sample itself through <A HREF="../iface/IUnknown.htm#AddRef">IUnknown::AddRef</A>. You must release this one and call 
<B>CBaseOutputPin::GetDeliveryBuffer</B> for the next. (You cannot reuse it directly.)
</BLOCKQUOTE>


<H1><A NAME="Inactive">CBaseOutputPin::Inactive</A><HR size=1></H1>
<A HREF="CBaseOutputPin.htm">CBaseOutputPin Class</A>
<P>Called by the <A HREF="CBaseFilter.htm">CBaseFilter</A> implementation when the state changes from either 
paused or running to stopped.

<P CLASS="ref">Syntax</P>
<BLOCKQUOTE><PRE>
<P><B>HRESULT</B> <B>Inactive</B><B>(</B><B>void</B><B>)</B><B>;</B>
</PRE></BLOCKQUOTE>

<P CLASS="ref">Return Value</P>
<BLOCKQUOTE>
<P>Returns <A HREF="../Error_Success_Codes.htm#VFW_E_NO_ALLOCATOR">VFW_E_NO_ALLOCATOR</A> if there is no allocator; 
otherwise, returns the value from calling the <A HREF="../iface/IMemAllocator.htm#Decommit">IMemAllocator::Decommit</A> method.


</BLOCKQUOTE>

<P CLASS="ref">Remarks</P>
<BLOCKQUOTE>
<P>This member function calls <A HREF="../iface/IMemAllocator.htm#Decommit">IMemAllocator::Decommit</A> to decommit memory before 
becoming inactive.
</BLOCKQUOTE>


<H1><A NAME="InitAllocator">CBaseOutputPin::InitAllocator</A><HR size=1></H1>
<A HREF="CBaseOutputPin.htm">CBaseOutputPin Class</A>
<P>Creates a default memory allocator. Override this to provide your
own allocator or to provide no allocator.

<P CLASS="ref">Syntax</P>
<BLOCKQUOTE><PRE>
<P><B>virtual</B> <B>HRESULT</B> <B>InitAllocator</B><B>(</B><BR>&nbsp;&nbsp;<B>IMemAllocator</B> <I>**ppAlloc</I><BR>&nbsp;&nbsp;<B>)</B><B>;</B>
</PRE></BLOCKQUOTE>

<P CLASS="ref">Parameters</P>
<BLOCKQUOTE>
<DL><DT><I>ppAlloc</I>
 </DT><DD>Returned memory allocator.
</DD></DL>
</BLOCKQUOTE>

<P CLASS="ref">Return Value</P>
<BLOCKQUOTE>
<P>Returns an <A HREF="../Error_Success_Codes.htm#HRESULT">HRESULT</A> value.


</BLOCKQUOTE>

<P CLASS="ref">Remarks</P>
<BLOCKQUOTE>
<P>The allocator should be released after use. This is typically handled in the 
<A HREF="CBaseOutputPin.htm#BreakConnect">CBaseOutputPin::BreakConnect</A> member function. 

</BLOCKQUOTE>
<!-- CONTENTS_END -->

<!-- START_PAGE_FOOTER -->


<H6><HR size=1></H6>
<P><A Class="line" HREF="#pagetop"><IMG src="../../art/arrowup1.gif" WIDTH="11" HEIGHT="11" ALIGN="MIDDLE" BORDER=0 ALT="Top of Page">&nbsp;Top of Page</A>
<BR><A Class="line" HREF="../../../cpyright.htm">&#169; 1998 Microsoft Corporation. All rights reserved. Terms of Use.</A>
<!-- END_PAGE_FOOTER -->

</BLOCKQUOTE>

<SCRIPT>if((g_isIE == true) && (g_iMaj > 3)) {window.self.document.writeln('<SCR' + 'IPT SRC="../../tip2.js"></SCR' + 'IPT><IFRAME ID="G_L_S" NAME="SecretBuffer" STYLE="display: none" SRC=""></IFRAME>')}</SCRIPT>

<!-- DACONTROL_START -->

	<DIV ID="HeadGraphAnim"></DIV>
	<SCRIPT>if((g_isIE == true) && (g_iMaj > 3)) {window.self.document.writeln('<SCR' + 'IPT SRC="../../anim.js"></SCR' + 'IPT>')}</SCRIPT>
<!-- DACONTROL_END -->

</BODY>
</HTML>
