<!-- DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN" -->

<HTML>
<HEAD><TITLE>CImageAllocator Class</TITLE>
<SCRIPT> var sRelPath = '../../' </SCRIPT>


<META NAME="Description" CONTENT="CImageAllocator Class">
<META NAME="Description" CONTENT="Alloc (CImageAllocator)">
<META NAME="Description" CONTENT="CImageAllocator::Alloc">
<META NAME="Description" CONTENT="CheckSizes (CImageAllocator)">
<META NAME="Description" CONTENT="CImageAllocator::CheckSizes">
<META NAME="Description" CONTENT="CImageAllocator (CImageAllocator)">
<META NAME="Description" CONTENT="CImageAllocator::CImageAllocator">
<META NAME="Description" CONTENT="CreateDIB (CImageAllocator)">
<META NAME="Description" CONTENT="CImageAllocator::CreateDIB">
<META NAME="Description" CONTENT="CreateImageSample (CImageAllocator)">
<META NAME="Description" CONTENT="CImageAllocator::CreateImageSample">
<META NAME="Description" CONTENT="Free (CImageAllocator)">
<META NAME="Description" CONTENT="CImageAllocator::Free">
<META NAME="Description" CONTENT="NonDelegatingAddRef (CImageAllocator)">
<META NAME="Description" CONTENT="CImageAllocator::NonDelegatingAddRef">
<META NAME="Description" CONTENT="NonDelegatingRelease (CImageAllocator)">
<META NAME="Description" CONTENT="CImageAllocator::NonDelegatingRelease">
<META NAME="Description" CONTENT="NotifyMediaType (CImageAllocator)">
<META NAME="Description" CONTENT="CImageAllocator::NotifyMediaType">
<META NAME="Description" CONTENT="SetProperties (CImageAllocator)">
<META NAME="Description" CONTENT="CImageAllocator::SetProperties">
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; CHARSET=iso8859-1">
<META NAME="MS.LOCALE" CONTENT="EN-US">
<META NAME="ROBOTS" CONTENT="all">

<!-- SNIFF_START -->

<SCRIPT>
//<!--
var g_isIE = false, g_isNav = false, g_iMaj = 0, g_sPlat = "";
// -->

</SCRIPT>
<SCRIPT SRC="../../ver.js"></SCRIPT>
<SCRIPT SRC="../../gloss.js"></SCRIPT>

<!-- SNIFF_END -->


<SCRIPT DEFER SRC="../../common.js"></SCRIPT>
<SCRIPT DEFER>
//<!--
function InitPage()
{
	if (g_isIE && g_iMaj >= 4)	
	{

		SetTOC();
	}
}
//-->

</SCRIPT>

<!-- SNIFF_END -->


<!-- STYLE_START -->

<SCRIPT>
//<!--
   var sVR = '../../'	// Set root for the style sheet
   var sCSS = '<LINK REL="stylesheet" HREF="' + sVR;

   if(g_isIE)
   {
	   if (g_iMaj >= 4) // For MSIE 4.0 or later
	   {
		   sCSS += 'dxm_basicsdkIE4';
		   if (g_sPlat == "Win") // Windows only for now
		   {
			   document.createStyleSheet(sVR + 'dxm_advSDKIE4.css');
		   }
	   }
	   else // For MSIE 3.0 or earlier
	   {
		   sCSS += 'dxm_basicsdkIE3';
	   }
   }
   else if (g_isNav) // For all Nav versions
   {
	   sCSS += 'dxm_basicsdkNAV';
   }
   else
   {
	   sCSS += 'dxm_basicsdkIE3'; // default to IE3 sheet
   }

   sCSS += (sCSS == '' ? '' : '.css" TYPE="text/css">');

   document.write(sCSS);
//-->

</SCRIPT>
<!-- STYLE_END -->


</HEAD>
<BODY onload="InitPage(); if (g_isIE && g_iMaj >= 4){HdgrphControl()}" BGCOLOR="#FFFFFF">
<A NAME="pagetop"></A><A NAME="CImageAllocator"></A>

<!-- HEADGRAPH_START -->

<TABLE CLASS="main" BORDER=0 CELLSPACING="0" CELLPADDING="0" WIDTH="*">
<TR>
<TD ROWSPAN="3" VALIGN="TOP" WIDTH="*">
<IMG SRC="../../art/header1.gif" WIDTH="107" HEIGHT="110" BORDER=0 ALT="DirectShow Animated Header -- CImageAllocator Class"></TD>
<TD ROWSPAN="2" VALIGN="TOP" WIDTH="217"><IMG SRC="../../art/hdrdshow.gif" WIDTH="217" HEIGHT="110" BORDER=0 ALT="DirectShow Animated Header -- CImageAllocator Class"></TD>
<TD VALIGN="TOP" WIDTH="383">
<IMG SRC="../../art/header3.gif" WIDTH="383" HEIGHT="95" BORDER=0 ALT="DirectShow Animated Header">
</TD>
<TD VALIGN="TOP" WIDTH="100%">
<IMG SRC="../../art/spacer1.gif" WIDTH="100%" HEIGHT="94" BORDER=0 ALT="Microsoft DirectShow SDK">
</TD>
</TR>
<!-- HEADGRAPH_END -->

<!-- NAV_LINKS_START -->

<TR><TD VALIGN="TOP"><PRE><IMG ID="TOC_" SRC="../../art/yelbtn.gif" WIDTH="11" HEIGHT="11" ALIGN="MIDDLE" BORDER=0 ALT="*"><A STYLE="color:black;font-weight:bold" ID="TOC" HREF="../../contents.htm">Contents</A>  <IMG SRC="../../art/yelbtn.gif" WIDTH="11" HEIGHT="11" ALIGN="MIDDLE" BORDER=0 ALT="*"><A STYLE="color:black;font-weight:bold" HREF="../../index.htm">Index</A>  <IMG SRC="../../art/yelbtn.gif" WIDTH="11" HEIGHT="11" ALIGN="MIDDLE" BORDER=0 ALT="*"><A STYLE="color:black;font-weight:bold" HREF="Classes_intro.htm">Topic Contents</A>
</PRE></TD></TR>
<TR><TD COLSPAN="2" VALIGN="TOP"><PRE><IMG SRC="../../art/yelbtn.gif" WIDTH="11" HEIGHT="11" ALIGN="MIDDLE" BORDER=0 ALT="*"><B>Previous Topic:</B> <A STYLE="color:black" HREF="CGuidNameList.htm">CGuidNameList Class</A>
<IMG SRC="../../art/yelbtn.gif" WIDTH="11" HEIGHT="11" ALIGN="MIDDLE" BORDER=0 ALT="*"><B>Next Topic:</B> <A  STYLE="color:black" HREF="CImageDisplay.htm">CImageDisplay Class</A>
</PRE></TD></TR></TABLE>
<!-- NAV_LINKS_END -->


<BLOCKQUOTE CLASS="body">


<!-- CONTENTS_START -->

<H1>CImageAllocator Class</H1>

<P><IMG SRC="../../art/wutil04.gif" WIDTH="307" HEIGHT="198" ALT="CImageAllocator class hierarchy">

<P>The <B>CImageAllocator</B> class is inherited from the <A HREF="CBaseAllocator.htm">CBaseAllocator</A> class,
which allocates sample buffers in shared memory. The number, size, and alignment
of blocks are determined when the connected <A CLASS="Glossary" HREF="javascript:Glossary(sRelPath + 'gloss/gloss_O.htm#output_pin')">output pin</A> calls <A HREF="CImageAllocator.htm#SetProperties">CImageAllocator::SetProperties</A> (which implements <A HREF="../iface/IMemAllocator.htm#SetProperties">IMemAllocator::SetProperties</A>). The shared memory blocks are used in
subsequent calls to the Microsoft&#174; Win32&#174; <A HREF="../../appendixes/Further_Reading.htm#CreateDIBSection">CreateDIBSection</A> function. The output pin
can then fill these buffers with data, and the buffers will be handed to GDI using <A HREF="../../appendixes/Further_Reading.htm#BitBlt">BitBlt</A>.

<A NAME="Protected_Data_Membe"></A><P CLASS="ref">Protected Data Members</P>
<TABLE><TR><TD><B><A NAME="m_pFilter">m_pFilter</A></B>
</TD><TD>Owning <A CLASS="Glossary" HREF="javascript:Glossary(sRelPath + 'gloss/gloss_f.htm#filter')">filter</A> of this object.
</TD></TR><TR><TD><B><A NAME="m_pMediaType">m_pMediaType</A></B>
</TD><TD>Current media type format.
</TD></TR></TABLE>
<A NAME="Member_Functions"></A><P CLASS="ref">Member Functions</P>

<TABLE><TR><TD><A HREF="CImageAllocator.htm#Alloc">Alloc</A>
 </TD><TD>Allocates the samples through <A HREF="../../appendixes/Further_Reading.htm#CreateDIBSection">CreateDIBSection</A>.
</TD></TR><TR><TD><A HREF="CImageAllocator.htm#CheckSizes">CheckSizes</A>
 </TD><TD>Checks the allocator requirements.
</TD></TR><TR><TD><A HREF="CImageAllocator.htm#CImageAllocator_CImageAllocator">CImageAllocator</A>
 </TD><TD>Constructs a <A HREF="CImageAllocator.htm">CImageAllocator</A> object.
</TD></TR><TR><TD><A HREF="CImageAllocator.htm#CreateDIB">CreateDIB</A>
 </TD><TD>Creates a device-independent bitmap (DIB).
</TD></TR><TR><TD><A HREF="CImageAllocator.htm#Free">Free</A>
 </TD><TD>Releases and deletes the resources for any samples allocated.
</TD></TR><TR><TD><A HREF="CImageAllocator.htm#NotifyMediaType">NotifyMediaType</A>
 </TD><TD>Notifies the allocator of the agreed media type.
</TD></TR></TABLE>
<A NAME="Overridable_Member_F"></A><P CLASS="ref">Overridable Member Functions</P>

<TABLE><TR><TD><A HREF="CImageAllocator.htm#CreateImageSample">CreateImageSample</A>
 </TD><TD>Creates a sample.
</TD></TR></TABLE>
<P CLASS="ref"><A NAME="Implemented_INonDele"></A>Implemented INonDelegatingUnknown Methods</P>

<TABLE><TR><TD><A HREF="CImageAllocator.htm#NonDelegatingAddRef">NonDelegatingAddRef</A>
 </TD><TD>Increments the reference count for an interface.
</TD></TR><TR><TD><A HREF="CImageAllocator.htm#NonDelegatingRelease">NonDelegatingRelease</A>
 </TD><TD>Decrements the reference count for an interface.
</TD></TR></TABLE>
<P CLASS="ref"><A NAME="Implemented_IMemAllo"></A>Implemented IMemAllocator Methods</P>
<TABLE><TR><TD><A HREF="CImageAllocator.htm#SetProperties">SetProperties</A>
 </TD><TD>Specifies the buffering requirements for the allocator.
</TD></TR></TABLE>



<H1><A NAME="Alloc">CImageAllocator::Alloc</A><HR size=1></H1>
<A HREF="CImageAllocator.htm">CImageAllocator Class</A>
<P>Creates image samples based around <A HREF="../../appendixes/Further_Reading.htm#CreateDIBSection">CreateDIBSection</A>.

<P CLASS="ref">Syntax</P>
<BLOCKQUOTE><PRE>
<P><B>HRESULT</B> <B>Alloc</B><B>(</B> <B>)</B><B>;</B>
</PRE></BLOCKQUOTE>

<P CLASS="ref">Return Value</P>
<BLOCKQUOTE>
<P>Returns an <A HREF="../Error_Success_Codes.htm#HRESULT">HRESULT</A> value.

</BLOCKQUOTE>

<P CLASS="ref">Remarks</P>
<BLOCKQUOTE>
<P>A filter defines the size and number of buffers required through
the <A HREF="CImageAllocator.htm#SetProperties">CImageAllocator::SetProperties</A> member function. The base allocator class that
this allocator derives from calls this internal virtual member function when it wants the
memory actually committed. For each sample it wants to create, this allocator
will create a <A HREF="../../appendixes/Further_Reading.htm#DIBSECTION">DIBSECTION</A> object for it (through the Microsoft Win32
<A HREF="../../appendixes/Further_Reading.htm#CreateDIBSection">CreateDIBSection</A> function). With the information it gets from that call, it will call the
virtual <A HREF="CImageAllocator.htm#CreateImageSample">CreateImageSample</A> member function, passing in the buffer pointer and length.
After successfully creating an image sample, it will then initialize it with the
<B>DIBSECTION</B> structure, among other information.

<P>This is a protected member function.
</BLOCKQUOTE>


<H1><A NAME="CheckSizes">CImageAllocator::CheckSizes</A><HR size=1></H1>
<A HREF="CImageAllocator.htm">CImageAllocator Class</A>
<P>Internal member function that checks the required buffering properties.

<P CLASS="ref">Syntax</P>
<BLOCKQUOTE><PRE>
<P><B>HRESULT</B> <B>CheckSizes</B><B>(</B><BR>&nbsp;&nbsp;<B>ALLOCATOR_PROPERTIES</B> <I>*pRequest</I><BR>&nbsp;&nbsp;<B>)</B><B>;</B>
</PRE></BLOCKQUOTE>

<P CLASS="ref">Parameters</P>
<BLOCKQUOTE>
<DL><DT><I>pRequest</I>
 </DT><DD>Requested allocator properties.
</DD></DL>
</BLOCKQUOTE>

<P CLASS="ref">Return Value</P>
<BLOCKQUOTE>
<P>Returns an <A HREF="../Error_Success_Codes.htm#HRESULT">HRESULT</A> value.


</BLOCKQUOTE>

<P CLASS="ref">Remarks</P>
<BLOCKQUOTE>
<P>The image allocator uses the Microsoft Win32 <A HREF="../../appendixes/Further_Reading.htm#CreateDIBSection">CreateDIBSection</A> function
to allocate its samples. That function accepts as input a pointer to a <A HREF="../../filtdev/DV_Data_AVI_File_Format.htm#BITMAPINFO">BITMAPINFO</A> structure that describes the
bitmap required. Because the size of the bitmap is therefore fixed according to the
<B>BITMAPINFO</B> structure for the video, requests to the allocator for a buffer larger
than that will not be granted. This member function, therefore, adjusts the requested size so that it is no larger than the size of the bitmap. If the requested size is smaller than the bitmap size, it returns E_INVALIDARG.

<P>This is a protected member function.
</BLOCKQUOTE>


<H1><A NAME="CImageAllocator_CImageAllocator">CImageAllocator::CImageAllocator</A><HR size=1></H1>
<A HREF="CImageAllocator.htm">CImageAllocator Class</A>
<P>Constructs a <A HREF="CImageAllocator.htm">CImageAllocator</A> object.
<P CLASS="ref">Syntax</P><BLOCKQUOTE><PRE>
<P><B>CImageAllocator</B><B>(</B><BR>&nbsp;&nbsp;<B>CBaseFilter</B> <I>*pFilter</I><B>,</B><BR>&nbsp;&nbsp;<B>TCHAR</B> <I>*pName</I><B>,</B><BR>&nbsp;&nbsp;<B>HRESULT</B> <I>*phr</I><BR>&nbsp;&nbsp;<B>)</B><B>;</B>
</PRE></BLOCKQUOTE>

<P CLASS="ref">Parameters</P>
<BLOCKQUOTE>
<DL><DT><I>pFilter</I>
 </DT><DD>Owning filter object.
</DD><DT><I>pName</I>
 </DT><DD>Debug-only string description.
</DD><DT><I>phr</I>
 </DT><DD>COM return code.
</DD></DL>
</BLOCKQUOTE>

<P CLASS="ref">Return Value</P>
<BLOCKQUOTE>
<P>No return value.
</BLOCKQUOTE>

<P CLASS="ref">Remarks</P>
<BLOCKQUOTE>
<P>The <A HREF="CImageAllocator.htm">CImageAllocator</A>, <A HREF="CImageSample.htm">CImageSample</A>, and
<A HREF="CDrawImage.htm">CDrawImage</A> classes are all tightly
associated. The buffers that the image allocator creates are made using the Microsoft
Win32 <A HREF="../../appendixes/Further_Reading.htm#CreateDIBSection">CreateDIBSection</A> function. The allocator then creates its own samples
(based on the <B>CImageSample</B> class). The image samples are initialized with
the buffer pointer and its length. The sample is also passed in a structure
(a <A HREF="../structs.htm#DIBDATA">DIBDATA</A> structure) that holds a number of pieces of information obtained
from the <B>CreateDIBSection</B> call.

<P>These samples can then be passed to the draw object. The draw object knows
the private format of the samples and how to get back the <A HREF="../structs.htm#DIBDATA">DIBDATA</A> structure
from them. Once it has obtained that information, it can pass a bitmap handle
that is stored in the <B>DIBDATA</B> structure down into GDI when it draws the image that
the sample contains. By using the bitmap handle from the sample in the
drawing, rather than just the buffer pointer (which is the alternative if
the sample is not a <A HREF="CImageSample.htm">CImageSample</A>), it gets a modest performance improvement.

<P>This is a protected member function.
</BLOCKQUOTE>


<H1><A NAME="CreateDIB">CImageAllocator::CreateDIB</A><HR size=1></H1>
<A HREF="CImageAllocator.htm">CImageAllocator Class</A>
<P>Calls the Win32 <A HREF="../../appendixes/Further_Reading.htm#CreateDIBSection">CreateDIBSection</A> function to create a device-independent bitmap (DIB).

<P CLASS="ref">Syntax</P>
<BLOCKQUOTE><PRE>
<P><B>HRESULT</B> <B>CreateDIB</B><B>(</B><BR>&nbsp;&nbsp;<B>LONG</B> <I>InSize</I><B>,</B><BR>&nbsp;&nbsp;<B>DIBDATA</B> <I>&amp;DibData</I><BR>&nbsp;&nbsp;<B>)</B><B>;</B>
</PRE></BLOCKQUOTE>

<P CLASS="ref">Parameters</P>
<BLOCKQUOTE>
<DL><DT><I>InSize</I>
 </DT><DD>Size of the bitmap required.
</DD><DT><I>DibData</I>
 </DT><DD>Structure to fill out with details.
</DD></DL>
</BLOCKQUOTE>

<P CLASS="ref">Return Value</P>
<BLOCKQUOTE>
<P>Returns an <A HREF="../Error_Success_Codes.htm#HRESULT">HRESULT</A> value.


</BLOCKQUOTE>

<P CLASS="ref">Remarks</P>
<BLOCKQUOTE>
<P>This is a protected member function.
</BLOCKQUOTE>


<H1><A NAME="CreateImageSample">CImageAllocator::CreateImageSample</A><HR size=1></H1>
<A HREF="CImageAllocator.htm">CImageAllocator Class</A>
<P>Creates a <A HREF="CImageSample.htm">CImageSample</A> object.

<P CLASS="ref">Syntax</P>
<BLOCKQUOTE><PRE>
<P><B>virtual</B> <B>CImageSample</B> <B>*CreateImageSample</B><B>(</B><BR>&nbsp;&nbsp;<B>LPBYTE</B> <I>pData</I><B>,</B><BR>&nbsp;&nbsp;<B>LONG</B> <I>Length</I><BR>&nbsp;&nbsp;<B>)</B><B>;</B>
</PRE></BLOCKQUOTE>

<P CLASS="ref">Parameters</P>
<BLOCKQUOTE>
<DL><DT><I>pData</I>
 </DT><DD>Pointer to the data buffer the sample looks after.
</DD><DT><I>Length</I>
 </DT><DD>Associated length of the buffer.
</DD></DL>
</BLOCKQUOTE>

<P CLASS="ref">Return Value</P>
<BLOCKQUOTE>
<P>Returns a new <A HREF="CImageSample.htm">CImageSample</A> sample object.


</BLOCKQUOTE>

<P CLASS="ref">Remarks</P>
<BLOCKQUOTE>
<P>This virtual member function creates the actual sample for the allocator. It is
passed the data buffer and its length to store. When the sample is
subsequently asked for the buffer (through <A HREF="../iface/IMediaSample.htm#GetPointer">IMediaSample::GetPointer</A>), this is
the pointer it will return. The primary reason for having this split out
into a separate virtual member function is so that derived classes from
<A HREF="CImageAllocator.htm">CImageAllocator</A> can also derive classes from <A HREF="CImageSample.htm">CImageSample</A> and have a
place to create them.

<P>This is a protected member function.
</BLOCKQUOTE>


<H1><A NAME="Free">CImageAllocator::Free</A><HR size=1></H1>
<A HREF="CImageAllocator.htm">CImageAllocator Class</A>
<P>Deletes the samples and frees their resources.


<P CLASS="ref">Syntax</P>
<BLOCKQUOTE><PRE>
<P><B>void</B> <B>Free</B><B>(</B> <B>)</B><B>;</B>
</PRE></BLOCKQUOTE>

<P CLASS="ref">Return Value</P>
<BLOCKQUOTE>
<P>No return value.
</BLOCKQUOTE>

<P CLASS="ref">Remarks</P>
<BLOCKQUOTE>
<P>The base allocator calls this internal virtual member function when it wants
to decommit the allocator.

<P>This is a protected member function.
</BLOCKQUOTE>


<H1><A NAME="NonDelegatingAddRef">CImageAllocator::NonDelegatingAddRef</A><HR size=1></H1>
<A HREF="CImageAllocator.htm">CImageAllocator Class</A>
<P>Increments the reference count for the owning filter.

<P CLASS="ref">Syntax</P>
<BLOCKQUOTE><PRE>
<P><B>HRESULT</B> <B>NonDelegatingAddRef</B><B>(</B> <B>)</B><B>;</B>
</PRE></BLOCKQUOTE>

<P CLASS="ref">Return Value</P>
<BLOCKQUOTE>
<P>Returns an <A HREF="../Error_Success_Codes.htm#HRESULT">HRESULT</A> value.


</BLOCKQUOTE>

<P CLASS="ref">Remarks</P>
<BLOCKQUOTE>
<P>An allocator is conceptually a separate object from the filter that
creates it. However, the image allocator is dependent on the filter that
created it to supply it with additional information (such as the media
type that it connected with). Therefore, although the allocator looks
after its own <B>NonDelegatingQueryInterface</B> function,
it delegates all reference counting
to the owning filter. So, when the allocator is subject to its
<B>NonDelegatingAddRef</B> function,
for example, it is the filter that owns the allocator that will actually be
reference counted.
</BLOCKQUOTE>


<H1><A NAME="NonDelegatingRelease">CImageAllocator::NonDelegatingRelease</A><HR size=1></H1>
<A HREF="CImageAllocator.htm">CImageAllocator Class</A>
<P>Decrements the reference count for the owning filter.

<P CLASS="ref">Syntax</P>
<BLOCKQUOTE><PRE>
<P><B>HRESULT</B> <B>NonDelegatingRelease</B><B>(</B> <B>)</B><B>;</B>
</PRE></BLOCKQUOTE>

<P CLASS="ref">Return Value</P>
<BLOCKQUOTE>
<P>Returns an <A HREF="../Error_Success_Codes.htm#HRESULT">HRESULT</A> value.


</BLOCKQUOTE>

<P CLASS="ref">Remarks</P>
<BLOCKQUOTE>
<P>An allocator is conceptually a separate object from the filter that
creates it. However, the image allocator is dependent on the filter that
created it to supply it with additional information (such as the media
type that it connected with). Therefore, although the allocator looks
after its own <B>NonDelegatingQueryInterface</B> function,
it delegates all reference counting
to the owning filter. So when the allocator is released, for example, it
is the filter that owns the allocator that will actually be released by the
<B>NonDelegatingRelease</B> function.
</BLOCKQUOTE>


<H1><A NAME="NotifyMediaType">CImageAllocator::NotifyMediaType</A><HR size=1></H1>
<A HREF="CImageAllocator.htm">CImageAllocator Class</A>
<P>Passes the media type from a filter to the allocator.

<P CLASS="ref">Syntax</P>
<BLOCKQUOTE><PRE>
<P><B>void</B> <B>NotifyMediaType</B><B>(</B><BR>&nbsp;&nbsp;<B>CMediaType</B> <I>*pMediaType</I><BR>&nbsp;&nbsp;<B>)</B><B>;</B>
</PRE></BLOCKQUOTE>

<P CLASS="ref">Parameters</P>
<BLOCKQUOTE>
<DL><DT><I>pMediaType</I>
 </DT><DD>Media type the filter established.
</DD></DL>
</BLOCKQUOTE>

<P CLASS="ref">Return Value</P>
<BLOCKQUOTE>
<P>No return value.
</BLOCKQUOTE>

<P CLASS="ref">Remarks</P>
<BLOCKQUOTE>
<P>The buffers that the image allocator creates are based around <A HREF="../../appendixes/Further_Reading.htm#CreateDIBSection">CreateDIBSection</A>,
which must be told what sort of bitmap the filter requires it to create. The
filter does this by calling this member function on the allocator. A filter will
usually call this member function after agreeing on a media type during a <A CLASS="Glossary" HREF="javascript:Glossary(sRelPath + 'gloss/gloss_P.htm#pin')">pin</A> connection.
The media type passed to this member function is a pointer; the allocator stores this
pointer (not a copy) of the media type it points to (for performance reasons,
copying media types is relatively slow). Therefore, the filter that calls this
member function should ensure that the media type is always valid until the media
type is next set on the allocator (or is called with a NULL type).
</BLOCKQUOTE>


<H1><A NAME="SetProperties">CImageAllocator::SetProperties</A><HR size=1></H1>
<A HREF="CImageAllocator.htm">CImageAllocator Class</A>
<P>Determines the size, number, and alignment of blocks.

<P CLASS="ref">Syntax</P>
<BLOCKQUOTE><PRE>
<P><B>HRESULT</B> <B>SetProperties</B><B>(</B><BR>&nbsp;&nbsp;<B>ALLOCATOR_PROPERTIES</B> <B>*</B> <I>pRequest</I><B>,</B><BR>&nbsp;&nbsp;<B>ALLOCATOR_PROPERTIES</B> <B>*</B> <I>pActual</I><BR>&nbsp;&nbsp;<B>)</B><B>;</B>
</PRE></BLOCKQUOTE>

<P CLASS="ref">Parameters</P>
<BLOCKQUOTE>
<DL><DT><I>pRequest</I>
 </DT><DD>Requested allocator properties.
</DD><DT><I>pActual</I>
 </DT><DD>Allocator properties actually set.
</DD></DL>
</BLOCKQUOTE>

<P CLASS="ref">Return Value</P>
<BLOCKQUOTE>
<P>Returns an <A HREF="../Error_Success_Codes.htm#HRESULT">HRESULT</A> value.


</BLOCKQUOTE>

<P CLASS="ref">Remarks</P>
<BLOCKQUOTE>
<P>The <I>pRequest</I> parameter is filled in by the caller with the requested values for
the count, number, and alignment as specified by the <A HREF="../structs.htm#ALLOCATOR_PROPERTIES">ALLOCATOR_PROPERTIES</A>
structure. The <I>pActual</I> parameter is filled in by the allocator with the closest
values that it can provide for the request. This member function cannot be called unless
the allocator has been decommitted by using the <A HREF="../iface/IMemAllocator.htm#Decommit">IMemAllocator::Decommit</A>
method.

</BLOCKQUOTE>
<!-- CONTENTS_END -->

<!-- START_PAGE_FOOTER -->


<H6><HR size=1></H6>
<P><A Class="line" HREF="#pagetop"><IMG src="../../art/arrowup1.gif" WIDTH="11" HEIGHT="11" ALIGN="MIDDLE" BORDER=0 ALT="Top of Page">&nbsp;Top of Page</A>
<BR><A Class="line" HREF="../../../cpyright.htm">&#169; 1998 Microsoft Corporation. All rights reserved. Terms of Use.</A>
<!-- END_PAGE_FOOTER -->

</BLOCKQUOTE>

<SCRIPT>if((g_isIE == true) && (g_iMaj > 3)) {window.self.document.writeln('<SCR' + 'IPT SRC="../../tip2.js"></SCR' + 'IPT><IFRAME ID="G_L_S" NAME="SecretBuffer" STYLE="display: none" SRC=""></IFRAME>')}</SCRIPT>

<!-- DACONTROL_START -->

	<DIV ID="HeadGraphAnim"></DIV>
	<SCRIPT>if((g_isIE == true) && (g_iMaj > 3)) {window.self.document.writeln('<SCR' + 'IPT SRC="../../anim.js"></SCR' + 'IPT>')}</SCRIPT>
<!-- DACONTROL_END -->

</BODY>
</HTML>
