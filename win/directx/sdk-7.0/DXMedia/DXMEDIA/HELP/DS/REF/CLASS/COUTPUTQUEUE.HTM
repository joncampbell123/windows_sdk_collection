<!-- DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN" -->

<HTML>
<HEAD><TITLE>COutputQueue Class</TITLE>
<SCRIPT> var sRelPath = '../../' </SCRIPT>


<META NAME="Description" CONTENT="COutputQueue Class">
<META NAME="Description" CONTENT="BeginFlush (COutputQueue)">
<META NAME="Description" CONTENT="COutputQueue::BeginFlush">
<META NAME="Description" CONTENT="COutputQueue (COutputQueue)">
<META NAME="Description" CONTENT="COutputQueue::COutputQueue">
<META NAME="Description" CONTENT="EndFlush (COutputQueue)">
<META NAME="Description" CONTENT="COutputQueue::EndFlush">
<META NAME="Description" CONTENT="EOS (COutputQueue)">
<META NAME="Description" CONTENT="COutputQueue::EOS">
<META NAME="Description" CONTENT="FreeSamples (COutputQueue)">
<META NAME="Description" CONTENT="COutputQueue::FreeSamples">
<META NAME="Description" CONTENT="InitialThreadProc (COutputQueue)">
<META NAME="Description" CONTENT="COutputQueue::InitialThreadProc">
<META NAME="Description" CONTENT="IsIdle (COutputQueue)">
<META NAME="Description" CONTENT="COutputQueue::IsIdle">
<META NAME="Description" CONTENT="IsQueued (COutputQueue)">
<META NAME="Description" CONTENT="COutputQueue::IsQueued">
<META NAME="Description" CONTENT="IsSpecialSample (COutputQueue)">
<META NAME="Description" CONTENT="COutputQueue::IsSpecialSample">
<META NAME="Description" CONTENT="NewSegment (COutputQueue)">
<META NAME="Description" CONTENT="COutputQueue::NewSegment">
<META NAME="Description" CONTENT="NotifyThread (COutputQueue)">
<META NAME="Description" CONTENT="COutputQueue::NotifyThread">
<META NAME="Description" CONTENT="QueueSample (COutputQueue)">
<META NAME="Description" CONTENT="COutputQueue::QueueSample">
<META NAME="Description" CONTENT="Receive (COutputQueue)">
<META NAME="Description" CONTENT="COutputQueue::Receive">
<META NAME="Description" CONTENT="ReceiveMultiple (COutputQueue)">
<META NAME="Description" CONTENT="COutputQueue::ReceiveMultiple">
<META NAME="Description" CONTENT="Reset (COutputQueue)">
<META NAME="Description" CONTENT="COutputQueue::Reset">
<META NAME="Description" CONTENT="SendAnyway (COutputQueue)">
<META NAME="Description" CONTENT="COutputQueue::SendAnyway">
<META NAME="Description" CONTENT="ThreadProc (COutputQueue)">
<META NAME="Description" CONTENT="COutputQueue::ThreadProc">
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; CHARSET=iso8859-1">
<META NAME="MS.LOCALE" CONTENT="EN-US">
<META NAME="ROBOTS" CONTENT="all">

<!-- SNIFF_START -->

<SCRIPT>
//<!--
var g_isIE = false, g_isNav = false, g_iMaj = 0, g_sPlat = "";
// -->

</SCRIPT>
<SCRIPT SRC="../../ver.js"></SCRIPT>
<SCRIPT SRC="../../gloss.js"></SCRIPT>

<!-- SNIFF_END -->


<SCRIPT DEFER SRC="../../common.js"></SCRIPT>
<SCRIPT DEFER>
//<!--
function InitPage()
{
	if (g_isIE && g_iMaj >= 4)	
	{

		SetTOC();
	}
}
//-->

</SCRIPT>

<!-- SNIFF_END -->


<!-- STYLE_START -->

<SCRIPT>
//<!--
   var sVR = '../../'	// Set root for the style sheet
   var sCSS = '<LINK REL="stylesheet" HREF="' + sVR;

   if(g_isIE)
   {
	   if (g_iMaj >= 4) // For MSIE 4.0 or later
	   {
		   sCSS += 'dxm_basicsdkIE4';
		   if (g_sPlat == "Win") // Windows only for now
		   {
			   document.createStyleSheet(sVR + 'dxm_advSDKIE4.css');
		   }
	   }
	   else // For MSIE 3.0 or earlier
	   {
		   sCSS += 'dxm_basicsdkIE3';
	   }
   }
   else if (g_isNav) // For all Nav versions
   {
	   sCSS += 'dxm_basicsdkNAV';
   }
   else
   {
	   sCSS += 'dxm_basicsdkIE3'; // default to IE3 sheet
   }

   sCSS += (sCSS == '' ? '' : '.css" TYPE="text/css">');

   document.write(sCSS);
//-->

</SCRIPT>
<!-- STYLE_END -->


</HEAD>
<BODY onload="InitPage(); if (g_isIE && g_iMaj >= 4){HdgrphControl()}" BGCOLOR="#FFFFFF">
<A NAME="pagetop"></A><A NAME="COutputQueue"></A>

<!-- HEADGRAPH_START -->

<TABLE CLASS="main" BORDER=0 CELLSPACING="0" CELLPADDING="0" WIDTH="*">
<TR>
<TD ROWSPAN="3" VALIGN="TOP" WIDTH="*">
<IMG SRC="../../art/header1.gif" WIDTH="107" HEIGHT="110" BORDER=0 ALT="DirectShow Animated Header -- COutputQueue Class"></TD>
<TD ROWSPAN="2" VALIGN="TOP" WIDTH="217"><IMG SRC="../../art/hdrdshow.gif" WIDTH="217" HEIGHT="110" BORDER=0 ALT="DirectShow Animated Header -- COutputQueue Class"></TD>
<TD VALIGN="TOP" WIDTH="383">
<IMG SRC="../../art/header3.gif" WIDTH="383" HEIGHT="95" BORDER=0 ALT="DirectShow Animated Header">
</TD>
<TD VALIGN="TOP" WIDTH="100%">
<IMG SRC="../../art/spacer1.gif" WIDTH="100%" HEIGHT="94" BORDER=0 ALT="Microsoft DirectShow SDK">
</TD>
</TR>
<!-- HEADGRAPH_END -->

<!-- NAV_LINKS_START -->

<TR><TD VALIGN="TOP"><PRE><IMG ID="TOC_" SRC="../../art/yelbtn.gif" WIDTH="11" HEIGHT="11" ALIGN="MIDDLE" BORDER=0 ALT="*"><A STYLE="color:black;font-weight:bold" ID="TOC" HREF="../../contents.htm">Contents</A>  <IMG SRC="../../art/yelbtn.gif" WIDTH="11" HEIGHT="11" ALIGN="MIDDLE" BORDER=0 ALT="*"><A STYLE="color:black;font-weight:bold" HREF="../../index.htm">Index</A>  <IMG SRC="../../art/yelbtn.gif" WIDTH="11" HEIGHT="11" ALIGN="MIDDLE" BORDER=0 ALT="*"><A STYLE="color:black;font-weight:bold" HREF="Classes_intro.htm">Topic Contents</A>
</PRE></TD></TR>
<TR><TD COLSPAN="2" VALIGN="TOP"><PRE><IMG SRC="../../art/yelbtn.gif" WIDTH="11" HEIGHT="11" ALIGN="MIDDLE" BORDER=0 ALT="*"><B>Previous Topic:</B> <A STYLE="color:black" HREF="COARefTime.htm">COARefTime Class</A>
<IMG SRC="../../art/yelbtn.gif" WIDTH="11" HEIGHT="11" ALIGN="MIDDLE" BORDER=0 ALT="*"><B>Next Topic:</B> <A  STYLE="color:black" HREF="CPersistStream.htm">CPersistStream Class</A>
</PRE></TD></TR></TABLE>
<!-- NAV_LINKS_END -->


<BLOCKQUOTE CLASS="body">


<!-- CONTENTS_START -->

<H1>COutputQueue Class</H1>

<P><IMG SRC="../../art/oput01.gif" WIDTH="205" HEIGHT="56" ALT="COutputQueue class hierarchy">

<P><A CLASS="Glossary" HREF="javascript:Glossary(sRelPath + 'gloss/gloss_O.htm#output_pin')">Output pins</A> use the <B>COutputQueue</B> to send samples to another <A CLASS="Glossary" HREF="javascript:Glossary(sRelPath + 'gloss/gloss_f.htm#filter')">filter</A> by using the local memory-based <A CLASS="Glossary" HREF="javascript:Glossary(sRelPath + 'gloss/gloss_T.htm#transport')">transport</A> (that is, to <A CLASS="Glossary" HREF="javascript:Glossary(sRelPath + 'gloss/gloss_I.htm#input_pin')">input pins</A> that support the <A HREF="../iface/IMemInputPin.htm">IMemInputPin</A> interface). <B>COutputQueue</B> uses <A HREF="../iface/IMemInputPin.htm#ReceiveCanBlock">IMemInputPin::ReceiveCanBlock</A> to determine if the connected input pin has a blocking implementation of <A HREF="../iface/IMemInputPin.htm#Receive">IMemInputPin::Receive</A>. If so, all samples are queued in <B>COutputQueue</B> and a thread is created to pass samples from the queue to the connected input pin. If the input pin's <B>IMemInputPin::Receive</B> method does
not block, samples are passed directly to <B>IMemInputPin::Receive</B>. <B>COutputQueue</B> can also batch samples to reduce the number of calls to the downstream pin.

<P><B>COutputQueue</B> is useful when the filter has other work to do while samples that it has already completed are being processed downstream. This occurs, for example, in a filter that can read more data off disk while data is being processed, or when it has more than one output pin and does not want to starve an output <A CLASS="Glossary" HREF="javascript:Glossary(sRelPath + 'gloss/gloss_P.htm#pin')">pin</A> because
<A HREF="../iface/IMemInputPin.htm#Receive">IMemInputPin::Receive</A> has no optional batching of samples.

<P>To use this class, create one <B>COutputQueue</B> object for every output pin for which it will be used. This can either be created when the <A CLASS="Glossary" HREF="javascript:Glossary(sRelPath + 'gloss/gloss_P.htm#pin')">pin</A> is created and deleted when the pin is disconnected, or it can be created when the pin goes active and deleted when the pin goes inactive.

<P>The samples sent to this object by calling its <A HREF="COutputQueue.htm#Receive">COutputQueue::Receive</A> or <A HREF="COutputQueue.htm#ReceiveMultiple">COutputQueue::ReceiveMultiple</A> member function should have references added by means of <A HREF="../iface/IUnknown.htm#AddRef">IUnknown::AddRef</A> (as they usually are if they were obtained directly from an allocator). This object then calls <A HREF="../iface/IUnknown.htm#Release">IUnknown::Release</A> on all samples it receives,
whether they were processed successfully or not. Note that <A HREF="../iface/IUnknown.htm#Release">Release</A> is not called for special (control) samples.

<P>Some control information, such as end of stream, needs to be queued with the data and processed once all the data has been delivered. This information is queued in the form of special control packets.

<B>COutputQueue</B> implements a sticky <A HREF="../Error_Success_Codes.htm#HRESULT">HRESULT</A> so it will not send any more data after it gets a return code that is not S_OK from the downstream <A HREF="COutputQueue.htm#ReceiveMultiple">ReceiveMultiple</A> call. (A sticky state setting is one that persists even after execution of operations that would usually reset the setting.)
This sticky state is reset by the <A HREF="COutputQueue.htm#EndFlush">EndFlush</A> and <A HREF="COutputQueue.htm#EOS">EOS</A> calls. However, if the sticky <B>HRESULT</B> is not S_OK, <B>EOS</B> itself is not sent downstream; the <B>HRESULT</B> is just reset. Because of this, if this object is not deleted when the pin goes inactive, <A HREF="COutputQueue.htm#BeginFlush">BeginFlush</A> and <B>EndFlush</B> should be called at that time to free the state.

<P>In many ways this object acts as a proxy for the connected input pin, supporting a similar set of methods for stream control.


<A NAME="Protected_Data_Membe"></A><P CLASS="ref">Protected Data Members</P>
<TABLE><TR><TD><B><A NAME="COutputQueue::m_bBatchExact">m_bBatchExact</A></B>
 </TD><TD>TRUE if commands are batched; FALSE if commands are sent singly.
</TD></TR><TR><TD><B><A NAME="COutputQueue::m_bFlushed">m_bFlushed</A></B>
 </TD><TD>Flag to signify if samples have been flushed.
</TD></TR><TR><TD><B><A NAME="COutputQueue::m_bFlushing">m_bFlushing</A></B>
 </TD><TD>Flag for flushing state.
</TD></TR><TR><TD><B><A NAME="COutputQueue::m_bSendAnyway">m_bSendAnyway</A></B>
 </TD><TD>Flag to override batch processing.
</TD></TR><TR><TD><B><A NAME="COutputQueue::m_bTerminate">m_bTerminate</A></B>
 </TD><TD>Termination flag.
</TD></TR><TR><TD><B><A NAME="COutputQueue::m_evFlushComplete">m_evFlushComplete</A></B>
 </TD><TD>Event signaling that flushing has finished.
</TD></TR><TR><TD><B><A NAME="COutputQueue::m_hSem">m_hSem</A></B>
 </TD><TD>Handle used for signaling.
</TD></TR><TR><TD><B><A NAME="COutputQueue::m_hr">m_hr</A></B>
 </TD><TD><A HREF="../Error_Success_Codes.htm#HRESULT">HRESULT</A> structure for return values; used to implement a sticky return value (one that persists even after operations that would usually change the value).

</TD></TR><TR><TD><B><A NAME="COutputQueue::m_hThread">m_hThread</A></B>
 </TD><TD>Worker thread handle.
</TD></TR><TR><TD><B><A NAME="COutputQueue::m_lBatchSize">m_lBatchSize</A></B>
 </TD><TD>Work in batches of this batch size. Ignored if <A HREF="COutputQueue.htm#COutputQueue::m_bBatchExact">m_bBatchExact</A> is not TRUE.
</TD></TR><TR><TD><B><A NAME="COutputQueue::m_List">m_List</A></B>
 </TD><TD>Pointer to a <B>CSampleList</B> object. The class <B>CSampleList</B> is a generic list (<A HREF="CGenericList.htm">CGenericList</A>) of objects of <A HREF="../iface/IMediaSample.htm">IMediaSample</A> type. It is defined as follows:
<PRE>typedef CGenericList&lt;IMediaSample&gt; CSampleList;
</PRE>
</TD></TR><TR><TD><B><A NAME="COutputQueue::m_lWaiting">m_lWaiting</A></B>
 </TD><TD>Variable set to nonzero value when waiting for a free element.
</TD></TR><TR><TD><B><A NAME="COutputQueue::m_nBatched">m_nBatched</A></B>
 </TD><TD>Number of samples currently batched awaiting processing.
</TD></TR><TR><TD><B><A NAME="COutputQueue::m_pInputPin">m_pInputPin</A></B>
 </TD><TD>Pointer to the connected input pin.
</TD></TR><TR><TD><B><A NAME="COutputQueue::m_pPin">m_pPin</A></B>
 </TD><TD>Pointer to the output pin.
</TD></TR><TR><TD><B><A NAME="COutputQueue::m_ppSamples">m_ppSamples</A></B>
 </TD><TD>Pointer to an array of batched samples.

</TD></TR></TABLE>
<A NAME="Member_Functions"></A><P CLASS="ref">Member Functions</P>

<TABLE><TR><TD><A HREF="COutputQueue.htm#BeginFlush">BeginFlush</A>
 </TD><TD>Causes all unsent samples to be discarded and sets flushing state.
</TD></TR><TR><TD><A HREF="COutputQueue.htm#COutputQueue_COutputQueue">COutputQueue</A>
 </TD><TD>Constructs a <A HREF="COutputQueue.htm">COutputQueue</A> object.
</TD></TR><TR><TD><A HREF="COutputQueue.htm#EndFlush">EndFlush</A>
 </TD><TD>Finalizes flush of batched or queued samples and resets flushing state.
</TD></TR><TR><TD><A HREF="COutputQueue.htm#EOS">EOS</A>
 </TD><TD>Queues an end-of-stream call to the connected input pin after all batched and queued samples have been passed to the input pin.
</TD></TR><TR><TD><A HREF="COutputQueue.htm#FreeSamples">FreeSamples</A>
 </TD><TD>Removes and releases batched and queued samples.
</TD></TR><TR><TD><A HREF="COutputQueue.htm#InitialThreadProc">InitialThreadProc</A>
 </TD><TD>Executed by the thread on thread creation.
</TD></TR><TR><TD><A HREF="COutputQueue.htm#IsIdle">IsIdle</A>
 </TD><TD>Determines if the output queue is idle.
</TD></TR><TR><TD><A HREF="COutputQueue.htm#IsQueued">IsQueued</A>
 </TD><TD>Determines if samples are being queued or being sent directly.
</TD></TR><TR><TD><A HREF="COutputQueue.htm#IsSpecialSample">IsSpecialSample</A>
 </TD><TD>Determines if the sample is a control sample. 
</TD></TR><TR><TD><A HREF="COutputQueue.htm#NotifyThread">NotifyThread</A>
 </TD><TD>Notifies the thread that there is something to do.
</TD></TR><TR><TD><A HREF="COutputQueue.htm#NewSegment">NewSegment</A>
 </TD><TD>Queues an <A HREF="../iface/IPin.htm#NewSegment">IPin::NewSegment</A> call to the connected input pin after all queued samples have been passed to the input pin.
</TD></TR><TR><TD><A HREF="COutputQueue.htm#QueueSample">QueueSample</A>
 </TD><TD>Queues the prepared sample.
</TD></TR><TR><TD><A HREF="COutputQueue.htm#Receive">Receive</A>
 </TD><TD>Passes in a single sample to send to the input pin.
</TD></TR><TR><TD><A HREF="COutputQueue.htm#ReceiveMultiple">ReceiveMultiple</A>
 </TD><TD>Passes a set of samples to send to the input pin.
</TD></TR><TR><TD><A HREF="COutputQueue.htm#Reset">Reset</A>
 </TD><TD>Resets the deferred return code <A HREF="COutputQueue.htm#COutputQueue::m_hr">m_hr</A> to allow the output queue to be ready for more data.
</TD></TR><TR><TD><A HREF="COutputQueue.htm#SendAnyway">SendAnyway</A>
 </TD><TD>Frees any batches samples to be sent to the input pin.
</TD></TR><TR><TD><A HREF="COutputQueue.htm#COutputQueue_ThreadProc">ThreadProc</A>
 </TD><TD>Implements the thread that sends samples downstream.
</TD></TR></TABLE>



<H1><A NAME="BeginFlush">COutputQueue::BeginFlush</A><HR size=1></H1>
<A HREF="COutputQueue.htm">COutputQueue Class</A>
<P>Causes all unsent samples to be discarded and sets the flushing state.

<P CLASS="ref">Syntax</P>
<BLOCKQUOTE><PRE>
<P><B>void</B> <B>BeginFlush</B><B>(</B> <B>)</B><B>;</B>
</PRE></BLOCKQUOTE>

<P CLASS="ref">Return Value</P>
<BLOCKQUOTE>
<P>No return value.
</BLOCKQUOTE>

<P CLASS="ref">Remarks</P>
<BLOCKQUOTE>
<P>This member function calls <B>BeginFlush</B> on the connected input pin.
</BLOCKQUOTE>


<H1><A NAME="COutputQueue_COutputQueue">COutputQueue::COutputQueue</A><HR size=1></H1>
<A HREF="COutputQueue.htm">COutputQueue Class</A>
<P>Constructs a <A HREF="COutputQueue.htm">COutputQueue</A> object.
<P CLASS="ref">Syntax</P><BLOCKQUOTE><PRE>
<P><B>COutputQueue</B><B>(</B><BR>&nbsp;&nbsp;<B>IPin</B> <I>*pInputPin</I><B>,</B><BR>&nbsp;&nbsp;<B>HRESULT</B> <I>*phr</I><B>,</B><BR>&nbsp;&nbsp;<B>BOOL</B> <I>bAuto</I> <B>=</B> <B>TRUE</B><B>,</B><BR>&nbsp;&nbsp;<B>BOOL</B> <I>bQueue</I> <B>=</B> <B>TRUE</B><B>,</B><BR>&nbsp;&nbsp;<B>LONG</B> <I>lBatchSize</I><B>,</B><BR>&nbsp;&nbsp;<B>BOOL</B> <I>bBatchExact</I><B>,</B><BR>&nbsp;&nbsp;<B>LONG</B> <I>lListSize</I><B>,</B><BR>&nbsp;&nbsp;<B>DWORD</B> <I>dwPriority</I><BR>&nbsp;&nbsp;<B>)</B><B>;</B>
</PRE></BLOCKQUOTE>

<P CLASS="ref">Parameters</P>
<BLOCKQUOTE>
<DL><DT><I>pInputPin</I>
 </DT><DD>Connected pin to which to send data.
</DD><DT><I>phr</I>
 </DT><DD><A HREF="../Error_Success_Codes.htm#HRESULT">HRESULT</A> return code.
</DD><DT><I>bAuto</I>
 </DT><DD>If TRUE, the queuing mode is determined by asking the connected
input pin if the pin can block (by calling <A HREF="../iface/IMemInputPin.htm#ReceiveCanBlock">IMemInputPin::ReceiveCanBlock</A>). If FALSE, 
queued or direct mode is set by the <I>bQueue</I> parameter.
</DD><DT><I>bQueue</I>
 </DT><DD>Determines if samples are queued for delivery by a worker thread or are being
sent directly. Ignored if <I>bAuto</I> is TRUE.
</DD><DT><I>lBatchSize</I>
 </DT><DD>Size of the batch (1 for no batching).
</DD><DT><I>bBatchExact</I>
 </DT><DD>Batch exactly to <I>lBatchSize</I> (but use <A HREF="COutputQueue.htm#SendAnyway">SendAnyway</A> to override batching).
</DD><DT><I>lListSize</I>
 </DT><DD>Likely number in the list.
</DD><DT><I>dwPriority</I>
 </DT><DD>Priority given to the created thread. 
</DD></DL>
</BLOCKQUOTE>

<P CLASS="ref">Return Value</P>
<BLOCKQUOTE>
<P>No return value.
</BLOCKQUOTE>

<P CLASS="ref">Remarks</P>
<BLOCKQUOTE>
<P>The <I>phr</I> parameter should be updated only to report errors. Usually <I>bAuto</I> will be TRUE. In that case, the constructor calls <A HREF="../iface/IMemInputPin.htm#ReceiveCanBlock">IMemInputPin::ReceiveCanBlock</A> on the downstream pin to determine whether to
create a thread, and so to send samples asynchronously. If <I>bAuto</I> is FALSE, a thread is created if, and only if,
<I>bQueue</I> is TRUE.

<P>If the batch size is not 1, data is not sent until <I>lBatchSize</I> samples have been received by the object. The exceptions are that, if fewer than <I>lBatchSize</I> samples are passed to <A HREF="COutputQueue.htm#Receive">COutputQueue::Receive</A> or 
<A HREF="COutputQueue.htm#ReceiveMultiple">COutputQueue::ReceiveMultiple</A> in this object and <I>bBatchExact</I> is FALSE, the samples will be sent anyway.

<P>If <I>bBatchExact</I> is TRUE, the <A HREF="COutputQueue.htm#SendAnyway">COutputQueue::SendAnyway</A> member function will cause the
samples to be sent to the thread (if the thread is created).
</BLOCKQUOTE>


<H1><A NAME="EndFlush">COutputQueue::EndFlush</A><HR size=1></H1>
<A HREF="COutputQueue.htm">COutputQueue Class</A>
<P>Finalizes flush of batched or queued samples and resets the flushing state.

<P CLASS="ref">Syntax</P>
<BLOCKQUOTE><PRE>
<P><B>void</B> <B>EndFlush</B><B>(</B> <B>)</B><B>;</B>
</PRE></BLOCKQUOTE>

<P CLASS="ref">Return Value</P>
<BLOCKQUOTE>
<P>No return value.
</BLOCKQUOTE>

<P CLASS="ref">Remarks</P>
<BLOCKQUOTE>
<P>The downstream pin is guaranteed not to block at this stage.
</BLOCKQUOTE>


<H1><A NAME="EOS">COutputQueue::EOS</A><HR size=1></H1>
<A HREF="COutputQueue.htm">COutputQueue Class</A>
<P>Queues an end-of-stream call to the connected input pin after all batched and
queued samples have been passed to the input pin. 

<P CLASS="ref">Syntax</P>
<BLOCKQUOTE><PRE>
<P><B>void</B> <B>EOS</B><B>(</B> <B>)</B><B>;</B>
</PRE></BLOCKQUOTE>

<P CLASS="ref">Return Value</P>
<BLOCKQUOTE>
<P>No return value.
</BLOCKQUOTE>

<P CLASS="ref">Remarks</P>
<BLOCKQUOTE>
<P> The end-of-stream call is queued as a special control packet when in a queued mode. This member function does not actually send an end-of-stream packet if the <A HREF="COutputQueue.htm#COutputQueue::m_hr">m_hr</A> <A HREF="../Error_Success_Codes.htm#HRESULT">HRESULT</A> value is not S_OK when it is time to make the call.
</BLOCKQUOTE>


<H1><A NAME="FreeSamples">COutputQueue::FreeSamples</A><HR size=1></H1>
<A HREF="COutputQueue.htm">COutputQueue Class</A>
<P>Removes and releases batched and queued samples.

<P CLASS="ref">Syntax</P>
<BLOCKQUOTE><PRE>
<P><B>void</B> <B>FreeSamples</B><B>(</B> <B>)</B><B>;</B>
</PRE></BLOCKQUOTE>

<P CLASS="ref">Return Value</P>
<BLOCKQUOTE>
<P>No return value.
</BLOCKQUOTE>


<H1><A NAME="InitialThreadProc">COutputQueue::InitialThreadProc</A><HR size=1></H1>
<A HREF="COutputQueue.htm">COutputQueue Class</A>
<P>Implements the static member function that the thread executes on thread creation.
<P CLASS="ref">Syntax</P>
<BLOCKQUOTE><PRE>
<P><B>static</B> <B>DWORD</B> <B>WINAPI</B> <B>InitialThreadProc</B><B>(</B><BR>&nbsp;&nbsp;<B>LPVOID</B> <I>pv</I><BR>&nbsp;&nbsp;<B>)</B><B>;</B>
</PRE></BLOCKQUOTE>

<P CLASS="ref">Parameters</P>
<BLOCKQUOTE>
<DL><DT><I>pv</I>
 </DT><DD>The <B>this</B> pointer for the <A HREF="COutputQueue.htm">COutputQueue</A> object.
</DD></DL>
</BLOCKQUOTE>

<P CLASS="ref">Return Value</P>
<BLOCKQUOTE>
<P>The derived class defines the meaning of the return value.


</BLOCKQUOTE>

<P CLASS="ref">Remarks</P>
<BLOCKQUOTE>
<P>On thread creation, the worker thread executes this static function with a pointer to the <A HREF="COutputQueue.htm">COutputQueue</A> object as the parameter. This function simply calls the <A HREF="COutputQueue.htm#COutputQueue_ThreadProc">COutputQueue::ThreadProc</A> member function of that object 
(that is, the function pointed to by <I>pv</I>).
</BLOCKQUOTE>


<H1><A NAME="IsIdle">COutputQueue::IsIdle</A><HR size=1></H1>
<A HREF="COutputQueue.htm">COutputQueue Class</A>
<P>Determines if the output pin is idle.

<P CLASS="ref">Syntax</P>
<BLOCKQUOTE><PRE>
<P><B>BOOL</B> <B>IsIdle</B><B>(</B> <B>)</B><B>;</B>
</PRE></BLOCKQUOTE>

<P CLASS="ref">Return Value</P>
<BLOCKQUOTE>
<P>Returns TRUE if no threads are in the queue, all data has been sent, and nothing is in the batch. Returns FALSE otherwise.

</BLOCKQUOTE>


<H1><A NAME="IsQueued">COutputQueue::IsQueued</A><HR size=1></H1>
<A HREF="COutputQueue.htm">COutputQueue Class</A>
<P>Determines if the <A HREF="COutputQueue.htm">COutputQueue</A> object is in queued or direct mode.

<P CLASS="ref">Syntax</P>
<BLOCKQUOTE><PRE>
<P><B>BOOL</B> <B>IsQueued</B><B>(</B> <B>)</B><B>;</B>
</PRE></BLOCKQUOTE>

<P CLASS="ref">Return Value</P>
<BLOCKQUOTE>
<P>Returns one of the following values.

<TABLE><TR><TD>TRUE </TD><TD>In queued mode. Samples are delivered asynchronously by a worker thread.
</TD></TR><TR><TD>FALSE </TD><TD>In direct mode. Receive calls are passed synchronously to the input pin.
</TD></TR></TABLE>
</BLOCKQUOTE>


<H1><A NAME="IsSpecialSample">COutputQueue::IsSpecialSample</A><HR size=1></H1>
<A HREF="COutputQueue.htm">COutputQueue Class</A>
<P>Determines if a sample is one of the special control samples (containing no data).

<P CLASS="ref">Syntax</P>
<BLOCKQUOTE><PRE>
<P><B>BOOL</B> <B>IsSpecialSample</B><B>(</B><BR>&nbsp;&nbsp;<B>IMediaSample</B> <I>*pSample</I><BR>&nbsp;&nbsp;<B>)</B><B>;</B>
</PRE></BLOCKQUOTE>

<P CLASS="ref">Parameters</P>
<BLOCKQUOTE>
<DL><DT><I>pSample</I>
</DT><DD>Pointer to the sample to be passed to the connected input pin.
</DD></DL>
</BLOCKQUOTE>

<P CLASS="ref">Return Value</P>
<BLOCKQUOTE>
<P>Returns one of the following values.
<TABLE><TR><TD>TRUE </TD><TD><I>pSample</I> is a special control sample.
</TD></TR><TR><TD>FALSE </TD><TD><I>pSample</I> is an <A HREF="../iface/IMediaSample.htm">IMediaSample</A> interface.
</TD></TR></TABLE>

</BLOCKQUOTE>

<P CLASS="ref">Remarks</P>
<BLOCKQUOTE>
<P>Special control samples are queued in line with the data by methods (such as <A HREF="COutputQueue.htm#EOS">COutputQueue::EOS</A>) that 
require processing once all queued data has been delivered. The <A HREF="COutputQueue.htm#COutputQueue_ThreadProc">COutputQueue::ThreadProc</A> member function detects these special samples on the queue by using <B>IsSpecialSample</B> and processes them appropriately.

<P>A special sample is one of following types and contains no media data.
<UL>
<LI>EOS_PACKET
<LI>NEW_SEGMENT
<LI>RESET_PACKET
<LI>SEND_PACKET
</UL>
<P>Special control samples are relevant only if you plan to change or extend the default base class implementation of <A HREF="COutputQueue.htm">COutputQueue</A> in a derived class. Normal use of the <B>COutputQueue</B> class does not require the use of control samples.
</BLOCKQUOTE>


<H1><A NAME="NewSegment">COutputQueue::NewSegment</A><HR size=1></H1>
<A HREF="COutputQueue.htm">COutputQueue Class</A>
<P>Queues an <A HREF="../iface/IPin.htm#NewSegment">IPin::NewSegment</A> call to the connected input pin after all queued samples have been passed to the input pin.

<P CLASS="ref">Syntax</P>
<BLOCKQUOTE><PRE>
<P><B>HRESULT</B> <B>NewSegment</B><B>(</B><BR>&nbsp;&nbsp;<B>REFERENCE_TIME</B> <I>tStart</I><B>,</B><BR>&nbsp;&nbsp;<B>REFERENCE_TIME</B> <I>tStop</I><B>,</B><BR>&nbsp;&nbsp;<B>double</B> <I>dRate</I><BR>&nbsp;&nbsp;<B>)</B><B>;</B>
</PRE></BLOCKQUOTE>

<P CLASS="ref">Parameters</P>
<BLOCKQUOTE>
<DL><DT><I>tStart</I>
</DT><DD>[in] Start time of the segment.
</DD><DT><I>tStop</I>
</DT><DD>[in] Stop time of the segment.
</DD><DT><I>dRate</I>
</DT><DD>[in] Rate of the segment.
</DD></DL>
</BLOCKQUOTE>

<P CLASS="ref">Return Value</P>
<BLOCKQUOTE>
<P>Returns an <A HREF="../Error_Success_Codes.htm#HRESULT">HRESULT</A> value.

</BLOCKQUOTE>

<P CLASS="ref">Remarks</P>
<BLOCKQUOTE>
<P>This member function calls the <A HREF="../iface/IPin.htm#NewSegment">IPin::NewSegment</A> method on the output pin once all previous data has been delivered. Like <A HREF="COutputQueue.htm#EOS">COutputQueue::EOS</A>, the <B>COutputQueue::NewSegment</B> call and its parameters are queued as a special control sample if the <A HREF="COutputQueue.htm">COutputQueue</A> object is in queued mode, and the <B>IPin::NewSegment</B> method is called from the worker thread in <A HREF="COutputQueue.htm#COutputQueue_ThreadProc">COutputQueue::ThreadProc</A>.

<P>Special control samples, as implemented by this member function, are only relevant if you plan to change or extend the default base class implementation of <A HREF="COutputQueue.htm">COutputQueue</A> in a derived class. Normal use of the <B>COutputQueue</B> class does not require the use of control samples. 

<P>This member function allows filters that process buffers containing more than one sample to delineate the rendering of the samples between start and stop time, as indicated by the <I>tStart</I> and <I>tStop</I> parameters.

<P><B>COutputQueue::NewSegment</B> is intended to be implemented on an input pin. A connected output pin on the <A CLASS="Glossary" HREF="javascript:Glossary(sRelPath + 'gloss/gloss_U.htm#upstream_filter')">upstream filter</A> calls this member function after completing delivery of previous data and before calling <A HREF="../iface/IMemInputPin.htm#Receive">IMemInputPin::Receive</A> with any new data. It indicates that all data arriving after this call is part of a segment delineated by the parameters.
</BLOCKQUOTE>


<H1><A NAME="NotifyThread">COutputQueue::NotifyThread</A><HR size=1></H1>
<A HREF="COutputQueue.htm">COutputQueue Class</A>
<P>Notifies the thread that there is data on the queue to process.

<P CLASS="ref">Syntax</P>
<BLOCKQUOTE><PRE>
<P><B>void</B> <B>NotifyThread</B><B>(</B> <B>)</B><B>;</B>
</PRE></BLOCKQUOTE>

<P CLASS="ref">Return Value</P>
<BLOCKQUOTE>
<P>No return value.
</BLOCKQUOTE>

<P CLASS="ref">Remarks</P>
<BLOCKQUOTE>
<P>The critical section must be held when this is called.
</BLOCKQUOTE>


<H1><A NAME="QueueSample">COutputQueue::QueueSample</A><HR size=1></H1>
<A HREF="COutputQueue.htm">COutputQueue Class</A>
<P>Queues a sample.

<P CLASS="ref">Syntax</P>
<BLOCKQUOTE><PRE>
<P><B>void</B> <B>QueueSample</B><B>(</B><BR>&nbsp;&nbsp;<B>IMediaSample</B> <I>*pSample</I><BR>&nbsp;&nbsp;<B>)</B><B>;</B>
</PRE></BLOCKQUOTE>

<P CLASS="ref">Parameters</P>
<BLOCKQUOTE>
<DL><DT><I>pSample</I>
 </DT><DD>Pointer to the sample to be passed to the connected input pin.
</DD></DL>
</BLOCKQUOTE>

<P CLASS="ref">Return Value</P>
<BLOCKQUOTE>
<P>No return value.
</BLOCKQUOTE>

<P CLASS="ref">Remarks</P>
<BLOCKQUOTE>
<P>The critical section must be held when this is called.
</BLOCKQUOTE>


<H1><A NAME="Receive">COutputQueue::Receive</A><HR size=1></H1>
<A HREF="COutputQueue.htm">COutputQueue Class</A>
<P>Passes in a single sample to send to the input pin.

<P CLASS="ref">Syntax</P>
<BLOCKQUOTE><PRE>
<P><B>HRESULT</B> <B>Receive</B><B>(</B><BR>&nbsp;&nbsp;<B>IMediaSample</B> <I>*pSample</I><BR>&nbsp;&nbsp;<B>)</B><B>;</B>
</PRE></BLOCKQUOTE>

<P CLASS="ref">Parameters</P>
<BLOCKQUOTE>
<DL><DT><I>pSample</I>
 </DT><DD>Pointer to the sample to be passed to the connected input pin.
</DD></DL>
</BLOCKQUOTE>

<P CLASS="ref">Return Value</P>
<BLOCKQUOTE>
<P>Returns an <A HREF="../Error_Success_Codes.htm#HRESULT">HRESULT</A> value, which can include the following values, or others.
<TABLE><TR><TD>S_FALSE </TD><TD>End of stream detected before or while processing sample;
any further samples will be discarded and this value returned.
</TD></TR><TR><TD>Other </TD><TD>An error occurred before or while processing sample;
any further samples will be discarded and this value returned.
</TD></TR><TR><TD>S_OK </TD><TD>Queued successfully or passed to the connected input pin if there is no queue.
</TD></TR></TABLE>

</BLOCKQUOTE>

<P CLASS="ref">Remarks</P>
<BLOCKQUOTE>
<P>If the sticky return code (<A HREF="COutputQueue.htm#COutputQueue::m_hr">m_hr</A>) is not S_OK, the sample is not sent and the sticky return code is returned. (A sticky return code is one that persists even after operations that would usually change its value.) The samples are all released (by means of <A HREF="../iface/IUnknown.htm#Release">Release</A>) after processing, regardless of whether the processing was successful.
</BLOCKQUOTE>


<H1><A NAME="ReceiveMultiple">COutputQueue::ReceiveMultiple</A><HR size=1></H1>
<A HREF="COutputQueue.htm">COutputQueue Class</A>
<P>Passes a set of samples to send to the input pin.

<P CLASS="ref">Syntax</P>
<BLOCKQUOTE><PRE>
<P><B>HRESULT</B> <B>ReceiveMultiple</B> <B>(</B><BR>&nbsp;&nbsp;<B>IMediaSample</B> <I>**ppSamples</I><B>,</B><BR>&nbsp;&nbsp;<B>long</B> <I>nSamples</I><B>,</B><BR>&nbsp;&nbsp;<B>long</B> <I>*nSamplesProcessed</I><BR>&nbsp;&nbsp;<B>)</B><B>;</B>
</PRE></BLOCKQUOTE>

<P CLASS="ref">Parameters</P>
<BLOCKQUOTE>
<DL><DT><I>ppSamples</I>
 </DT><DD>Pointer to the set of samples to be passed to the connected input pin.
</DD><DT><I>nSamples</I>
 </DT><DD>Number of samples pointed to by <I>ppSamples</I>.
</DD><DT><I>nSamplesProcessed</I>
 </DT><DD>Updated to be the number of samples processed.
</DD></DL>
</BLOCKQUOTE>

<P CLASS="ref">Return Value</P>
<BLOCKQUOTE>
<P>Returns an <A HREF="../Error_Success_Codes.htm#HRESULT">HRESULT</A> value, which can include the following values, or others.
<TABLE><TR><TD>Other </TD><TD>An error occurred before or while processing sample;
any further samples will be discarded and this value returned.
</TD></TR><TR><TD>S_FALSE </TD><TD>End of stream detected before or while processing sample;
any further samples will be discarded and this value returned.
</TD></TR><TR><TD>S_OK </TD><TD>Queued successfully or passed to the connected input
pin if there is no queue.
</TD></TR></TABLE>

</BLOCKQUOTE>

<P CLASS="ref">Remarks</P>
<BLOCKQUOTE>
<P>If the sticky return code is not S_OK, the sample is not sent and the sticky return code is returned. (A sticky return code is one that persists even after operations that would normally change its value.) The samples are all released (by means of <A HREF="../iface/IUnknown.htm#Release">Release</A>) after processing, regardless of whether the processing was successful.
</BLOCKQUOTE>


<H1><A NAME="Reset">COutputQueue::Reset</A><HR size=1></H1>
<A HREF="COutputQueue.htm">COutputQueue Class</A>
<P>Resets the deferred return code <A HREF="COutputQueue.htm#COutputQueue::m_hr">m_hr</A> to ready the output queue for more data.

<P CLASS="ref">Syntax</P>
<BLOCKQUOTE><PRE>
<P><B>void</B> <B>Reset</B><B>(</B> <B>)</B><B>;</B>
</PRE></BLOCKQUOTE>

<P CLASS="ref">Return Value</P>
<BLOCKQUOTE>
<P>No return value.
</BLOCKQUOTE>

<P CLASS="ref">Remarks</P>
<BLOCKQUOTE>
<P>The sticky return code <A HREF="COutputQueue.htm#COutputQueue::m_hr">m_hr</A> is set to S_OK if data is queued; otherwise, this function
queues the sample and notifies the thread. (A sticky return code is one that persists even after operations that would normally change its value.) 
</BLOCKQUOTE>


<H1><A NAME="SendAnyway">COutputQueue::SendAnyway</A><HR size=1></H1>
<A HREF="COutputQueue.htm">COutputQueue Class</A>
<P>If <I>bBatchExact</I> was specified on construction, frees batched samples so they can be sent to the input pin.

<P CLASS="ref">Syntax</P>
<BLOCKQUOTE><PRE>
<P><B>void</B> <B>SendAnyway</B><B>(</B> <B>)</B><B>;</B>
</PRE></BLOCKQUOTE>

<P CLASS="ref">Return Value</P>
<BLOCKQUOTE>
<P>No return value.
</BLOCKQUOTE>


<H1><A NAME="COutputQueue_ThreadProc">COutputQueue::ThreadProc</A><HR size=1></H1>
<A HREF="COutputQueue.htm">COutputQueue Class</A>
<P>Implements the thread that sends samples downstream.

<P CLASS="ref">Syntax</P>
<BLOCKQUOTE><PRE>
<P><B>DWORD</B> <B>ThreadProc</B><B>(</B> <B>)</B><B>;</B>
</PRE></BLOCKQUOTE>

<P CLASS="ref">Return Value</P>
<BLOCKQUOTE>
<P>Returns zero when DirectShow terminates the thread.


</BLOCKQUOTE>

<P CLASS="ref">Remarks</P>
<BLOCKQUOTE>
<P>This is the main thread procedure for the class, which is called from <A HREF="COutputQueue.htm#InitialThreadProc">COutputQueue::InitialThreadProc</A>. It sends a sample or a batch of samples to the connected input pin (depending on the <A HREF="COutputQueue.htm#COutputQueue::m_bBatchExact">m_bBatchExact</A>, <A HREF="COutputQueue.htm#COutputQueue::m_nBatched">m_nBatched</A>, and <A HREF="COutputQueue.htm#COutputQueue::m_lBatchSize">m_lBatchSize</A> data members) when conditions are met. Otherwise, it increments the 
<A HREF="COutputQueue.htm#COutputQueue::m_lWaiting">m_lWaiting</A> data member, while holding the critical section and waits for 
<A HREF="COutputQueue.htm#COutputQueue::m_hSem">m_hSem</A> to be set (not holding the critical section) to continue.

</BLOCKQUOTE>
<!-- CONTENTS_END -->

<!-- START_PAGE_FOOTER -->


<H6><HR size=1></H6>
<P><A Class="line" HREF="#pagetop"><IMG src="../../art/arrowup1.gif" WIDTH="11" HEIGHT="11" ALIGN="MIDDLE" BORDER=0 ALT="Top of Page">&nbsp;Top of Page</A>
<BR><A Class="line" HREF="../../../cpyright.htm">&#169; 1998 Microsoft Corporation. All rights reserved. Terms of Use.</A>
<!-- END_PAGE_FOOTER -->

</BLOCKQUOTE>

<SCRIPT>if((g_isIE == true) && (g_iMaj > 3)) {window.self.document.writeln('<SCR' + 'IPT SRC="../../tip2.js"></SCR' + 'IPT><IFRAME ID="G_L_S" NAME="SecretBuffer" STYLE="display: none" SRC=""></IFRAME>')}</SCRIPT>

<!-- DACONTROL_START -->

	<DIV ID="HeadGraphAnim"></DIV>
	<SCRIPT>if((g_isIE == true) && (g_iMaj > 3)) {window.self.document.writeln('<SCR' + 'IPT SRC="../../anim.js"></SCR' + 'IPT>')}</SCRIPT>
<!-- DACONTROL_END -->

</BODY>
</HTML>
