<!-- DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN" -->

<HTML>
<HEAD><TITLE>Debugging with DirectShow</TITLE>
<SCRIPT> var sRelPath = '../../' </SCRIPT>


<META NAME="Description" CONTENT="Debugging with DirectShow">
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; CHARSET=iso8859-1">
<META NAME="MS.LOCALE" CONTENT="EN-US">
<META NAME="ROBOTS" CONTENT="all">

<!-- SNIFF_START -->

<SCRIPT>
//<!--
var g_isIE = false, g_isNav = false, g_iMaj = 0, g_sPlat = "";
// -->

</SCRIPT>
<SCRIPT SRC="../../ver.js"></SCRIPT>
<SCRIPT SRC="../../gloss.js"></SCRIPT>

<!-- SNIFF_END -->


<SCRIPT DEFER SRC="../../common.js"></SCRIPT>
<SCRIPT DEFER>
//<!--
function InitPage()
{
	if (g_isIE && g_iMaj >= 4)	
	{

		SetTOC();
	}
}
//-->

</SCRIPT>

<!-- SNIFF_END -->


<!-- STYLE_START -->

<SCRIPT>
//<!--
   var sVR = '../../'	// Set root for the style sheet
   var sCSS = '<LINK REL="stylesheet" HREF="' + sVR;

   if(g_isIE)
   {
	   if (g_iMaj >= 4) // For MSIE 4.0 or later
	   {
		   sCSS += 'dxm_basicsdkIE4';
		   if (g_sPlat == "Win") // Windows only for now
		   {
			   document.createStyleSheet(sVR + 'dxm_advSDKIE4.css');
		   }
	   }
	   else // For MSIE 3.0 or earlier
	   {
		   sCSS += 'dxm_basicsdkIE3';
	   }
   }
   else if (g_isNav) // For all Nav versions
   {
	   sCSS += 'dxm_basicsdkNAV';
   }
   else
   {
	   sCSS += 'dxm_basicsdkIE3'; // default to IE3 sheet
   }

   sCSS += (sCSS == '' ? '' : '.css" TYPE="text/css">');

   document.write(sCSS);
//-->

</SCRIPT>
<!-- STYLE_END -->


</HEAD>
<BODY onload="InitPage(); if (g_isIE && g_iMaj >= 4){HdgrphControl()}" BGCOLOR="#FFFFFF">
<A NAME="pagetop"></A><A NAME="debug"></A>

<!-- HEADGRAPH_START -->

<TABLE CLASS="main" BORDER=0 CELLSPACING="0" CELLPADDING="0" WIDTH="*">
<TR>
<TD ROWSPAN="3" VALIGN="TOP" WIDTH="*">
<IMG SRC="../../art/header1.gif" WIDTH="107" HEIGHT="110" BORDER=0 ALT="DirectShow Animated Header"></TD>
<TD ROWSPAN="2" VALIGN="TOP" WIDTH="217"><IMG SRC="../../art/hdrdshow.gif" WIDTH="217" HEIGHT="110" BORDER=0 ALT="DirectShow Animated Header"></TD>
<TD VALIGN="TOP" WIDTH="383">
<IMG SRC="../../art/header3.gif" WIDTH="383" HEIGHT="95" BORDER=0 ALT="DirectShow Animated Header">
</TD>
<TD VALIGN="TOP" WIDTH="100%">
<IMG SRC="../../art/spacer1.gif" WIDTH="100%" HEIGHT="94" BORDER=0 ALT="Microsoft DirectShow SDK">
</TD>
</TR>
<!-- HEADGRAPH_END -->

<!-- NAV_LINKS_START -->

<TR><TD VALIGN="TOP"><PRE><IMG ID="TOC_" SRC="../../art/yelbtn.gif" WIDTH="11" HEIGHT="11" ALIGN="MIDDLE" BORDER=0 ALT="*"><A STYLE="color:black;font-weight:bold" ID="TOC" HREF="../../contents.htm">Contents</A>  <IMG SRC="../../art/yelbtn.gif" WIDTH="11" HEIGHT="11" ALIGN="MIDDLE" BORDER=0 ALT="*"><A STYLE="color:black;font-weight:bold" HREF="../../index.htm">Index</A>  <IMG SRC="../../art/yelbtn.gif" WIDTH="11" HEIGHT="11" ALIGN="MIDDLE" BORDER=0 ALT="*"><A STYLE="color:black;font-weight:bold" HREF="Debugging_intro.htm">Topic Contents</A>
</PRE></TD></TR>
<TR><TD COLSPAN="2" VALIGN="TOP"><PRE><IMG SRC="../../art/yelbtn.gif" WIDTH="11" HEIGHT="11" ALIGN="MIDDLE" BORDER=0 ALT="*"><B>Previous Topic:</B> <A STYLE="color:black" HREF="Debugging_intro.htm">Debugging</A>
<IMG SRC="../../art/yelbtn.gif" WIDTH="11" HEIGHT="11" ALIGN="MIDDLE" BORDER=0 ALT="*"><B>Next Topic:</B> <A  STYLE="color:black" HREF="Assert_Macros_Functions.htm">Assert Macros and Functions</A>
</PRE></TD></TR></TABLE>
<!-- NAV_LINKS_END -->


<BLOCKQUOTE CLASS="body">


<!-- CONTENTS_START -->



<H1>Debugging with DirectShow</H1>

<P>This article discusses debugging practices in Microsoft&#174; DirectShow&#153; for the C and C++ languages. Many of these practices apply both to writing <A CLASS="Glossary" HREF="javascript:Glossary(sRelPath + 'gloss/gloss_f.htm#filter')">filters</A> and to writing applications that use the DirectShow <A CLASS="Glossary" HREF="javascript:Glossary(sRelPath + 'gloss/gloss_R.htm#run_time')">run time</A>. The article provides some tips on writing code that can be easily debugged and some general debugging topics. This article also provides some hints about detecting memory leaks.

<P>This article contains the following sections.
<UL>
<LI><A HREF="Debugging_DS.htm#debug_1">Writing Code You Can Test and Debug</A>
<LI><A HREF="Debugging_DS.htm#debug_9">Using Different Kinds of Builds</A>
<LI><A HREF="Debugging_DS.htm#debug_16">Debugging New Filters</A>
<LI><A HREF="Debugging_DS.htm#debug_20">Detecting Leaks</A>
</UL>

<H2><A NAME="debug_1">Writing Code You Can Test and Debug</A></H2>
<P>Debugging code in the DirectShow environment can be easier if it's written to be easily tested and debugged in the first place. Some techniques that DirectShow supports include the following, which are discussed in this section.

<UL>
<LI><A HREF="Debugging_DS.htm#debug_2">Assertion Checking</A>
<LI><A HREF="Debugging_DS.htm#debug_3">Pass Debugging Names</A>
<LI><A HREF="Debugging_DS.htm#debug_4">Debug Logging</A>
<LI><A HREF="Debugging_DS.htm#debug_5">IOStream Sample Code</A>
<LI><A HREF="Debugging_DS.htm#debug_6">Critical Section Usage</A>
<LI><A HREF="Debugging_DS.htm#debug_7">Pointer Validation</A>
<LI><A HREF="Debugging_DS.htm#debug_8">DLL Base Address Conflicts</A>
</UL>

<H3><A NAME="debug_2">Assertion Checking</A></H3>
<P>Use assertion checking liberally. If you're not familiar with asserts, they're a popular way to isolate potential programming errors. DirectShow provides a number of assertion macros and functions, including <A HREF="Assert_Macros_Functions.htm#ASSERT">ASSERT</A>. The Microsoft Foundation Classes (MFC) have an equivalent <B>ASSERT</B> macro. For example the following displays a message box if the value of <I>First</I> does not equal NULL:

<PRE>
    ASSERT( First != NULL );
</PRE>

<P>For more information about assertion, see <A HREF="Assert_Macros_Functions.htm">Assert Macros and Functions</A>.

<H3><A NAME="debug_3">Pass Debugging Names</A></H3>
<P>Pass the debugging name to the constructors that support it. Tracking object creation and destruction is provided in debugging builds for the <A HREF="../class/CBaseObject.htm">CBaseObject</A> class and classes derived from it. The <I><A CLASS="Glossary" HREF="javascript:Glossary(sRelPath + 'gloss/gloss_O.htm#object_register')">object register</A></I> is the list of objects that have been created but not yet destroyed in those classes. The debugging name that is passed to the constructors of those classes is stored in the object register. For more information about debugging object registers and the <A HREF="Object_Register_debug.htm#DbgDumpObjectRegister">DbgDumpObjectRegister</A> function, see <A HREF="Object_Register_debug.htm">Object Register Debugging</A>.

<H3><A NAME="debug_4">Debug Logging</A></H3>
<P>Use the DirectShow <A HREF="Logging_Module_Level.htm#DbgLog">DbgLog</A> function to display debugging messages on a debugger as your program executes. The following example is from the bouncing ball <A CLASS="Glossary" HREF="javascript:Glossary(sRelPath + 'gloss/gloss_S.htm#source_filter')">source filter</A>.

<PRE>
    DbgLog(( LOG_TRACE, 1, TEXT("New time: %d, Proportion: %d"),
        m_iRepeatTime, q.Proportion));
</PRE>

<P>For more information on the following topics, see <A HREF="Logging_Module_Level.htm">Debug Logging by Module Level</A>. 
<UL>
<LI>The macros and functions you can call to do debugging logging from
code you write.
<LI>How to enable and disable debugging logging by module level at run time.
<LI>How to indicate the destination of the output of the debugging log.
</UL>

<H3><A NAME="debug_5">IOStream Sample Code</A></H3>
<P>The C and C++ helpers provided in the IOStream helper library, SampIOS.lib, provide text output of the <A HREF="../iface/IBaseFilter.htm">IBaseFilter</A> interface and other DirectShow objects. The output from these helpers might be useful during debugging, to help understand the details of a given <A CLASS="Glossary" HREF="javascript:Glossary(sRelPath + 'gloss/gloss_P.htm#pin')">pin</A> or filter. You can use these helpers in your DirectShow filters and applications. For more information about this library, see 
<A HREF="../../filtsamp/SampIOS_Sample.htm#IOStreamHelper">SampIOS Sample (IOStream Helper Library)</A>.

<H3><A NAME="debug_6">Critical Section Use</A></H3>
<P>To make deadlocks easier to track, insert assertions in the code that determine whether a critical section is owned by the calling code. The <A HREF="../utilfunct/CCritSec_Debug.htm#CritCheckIn">CritCheckIn</A> and <A HREF="../utilfunct/CCritSec_Debug.htm#CritCheckOut">CritCheckOut</A> functions indicate whether the calling thread owns the given critical sections, and are generally called in <A HREF="Assert_Macros_Functions.htm#ASSERT">ASSERT</A> macros. For more information about these functions, see <A HREF="../utilfunct/CCritSec_Debug.htm">CCritSec Debug Functions</A>.

<P>For debug logging of each lock and unlock of a given critical section, you might want to use the DirectShow <A HREF="../utilfunct/CCritSec_Debug.htm#DbgLockTrace">DbgLockTrace</A> function.

<P><B>Note</B> Logging can affect performance.

<H3><A NAME="debug_7">Pointer Validation</A></H3>
<P>Consider using the pointer validation macros. For example, you can call <A HREF="Pointer_Validation_Macros.htm#ValidateReadPtr">ValidateReadPtr</A> to ensure that the given pointer actually points to readable memory. Note the performance cost of each of these calls. Currently, the DirectShow pointer validation macros are built on top of the Win32 pointer validation functions such as <A HREF="../../appendixes/Further_Reading.htm#IsBadReadPtr">IsBadReadPtr</A>. On some systems, the Win32 pointer validation functions swap in every page in the range specified. For more information about validation macros, see <A HREF="Pointer_Validation_Macros.htm">Pointer Validation Macros</A>.

<H3><A NAME="debug_8">DLL Base Address Conflicts</A></H3>
<P>If you copy any sample makefile to create any new DLL, including filters and <A CLASS="Glossary" HREF="javascript:Glossary(sRelPath + 'gloss/gloss_P.htm#plug_in_distributor')">plug-in distributors</A> (PIDs), ensure you change the base address to avoid collisions with other DLLs. A <I>collision</I> of DLL load address results in one of the DLLs having to be relocated during the time of loading. This increases the load time for that DLL.

<P>In the sample makefiles, the DLL base address is set in DLL_BASE, which is used in ActiveX.mak. Do not let ActiveX.mak use the default value for DLL_BASE, because this will cause collisions.


<H2><A NAME="debug_9" IDX_CONCEPT="noindex; builds, retail, debug and performance, using; debug builds, using; retail builds, using">Using Different Kinds of Builds</A></H2>
<P>DirectShow can be built for three kinds of builds: retail, debug, and performance. See <A HREF="../../appendixes/Reserved_Identifiers.htm#Reserved">Reserved Identifiers</A> for information on the kinds of builds. Debugging has varying degrees of difficulty for the three kinds of builds, depending on the situation. For instance, the <A CLASS="Glossary" HREF="javascript:Glossary(sRelPath + 'gloss/gloss_D.htm#debug_build')">debug build</A> can provide much more information, but it can run so slowly as to make real-time debugging impossible.

<P>The binaries you create must match the kind of build you're using. The makefiles provided for each sample use ActiveX.mak, which comes with the DirectShow SDK. Comments at the head of ActiveX.mak explain the various nmake command-line parameters to use to obtain binaries compatible with the different DirectShow builds. Some of these parameters define identifiers like <A HREF="../../appendixes/Reserved_Identifiers.htm#DEBUG">DEBUG</A> and <A HREF="../../appendixes/Reserved_Identifiers.htm#PERF">PERF</A> when compiling the C or C++ code.

<P>If you must have build-dependent code, you can conditionally compile with the same identifiers that the DirectShow headers use for that purpose. For a list of the identifiers reserved for that purpose, see <A HREF="../../appendixes/Reserved_Identifiers.htm#Reserved">Reserved Identifiers</A>. 

<P>For instance, in C or C++, you can conditionally compile code like the following:

<PRE>
    ...   /* normal processing */
#ifdef DEBUG
    ...   /* debug only code */
#endif
    ...   /* resume normal processing */
</PRE>

<H2><A NAME="debug_16" IDX_CONCEPT="noindex; debugging new filters">Debugging New Filters</A></H2>
<P>This section contains the following topics that discuss points you should be aware of when debugging new filters.
<UL>
<LI><A HREF="Debugging_DS.htm#debug_17">Avoid GUID Conflicts</A>
<LI><A HREF="Debugging_DS.htm#debug_18">Test With the Filter Graph Editor and Other Sample Filters</A>
<LI><A HREF="Debugging_DS.htm#debug_19">Add the Filter as an Additional DLL in Developer Studio</A>
</UL>

<H3><A NAME="debug_17" IDX_CONCEPT="noindex; GUID conflicts, avoiding">Avoid GUID Conflicts</A></H3>
<P>DirectShow uses globally unique identifiers (<A CLASS="Glossary" HREF="javascript:Glossary(sRelPath + 'gloss/gloss_G.htm#GUID')">GUIDs</A>) to find each filter, pin, and property page. Avoid reusing any of the same <B>GUID</B>s when copying from the DirectShow sample code. The Guidgen.exe and Uuidgen.exe utilities generate unique <B>GUID</B>s.

<H3><A NAME="debug_18">Test With the Filter Graph Editor and Other Sample Filters</A></H3>
<P>Register your new filter. For information about registering a filter, see <A HREF="../../appdev/Register_DS_Objects.htm">Register DirectShow Objects</A> and <A HREF="../utilfunct/DLL_Setup_functs.htm#AMovieDllRegisterServer2">AMovieDllRegisterServer2</A>. 

<P>After you have registered your filter, you can use a tool called the <A CLASS="Glossary" HREF="javascript:Glossary(sRelPath + 'gloss/gloss_F.htm#Filter_Graph_Editor')">Filter Graph Editor</A> (also called GraphEdit, or Graphedt.exe) to insert your filter into a <A CLASS="Glossary" HREF="javascript:Glossary(sRelPath + 'gloss/gloss_F.htm#filter_graph')">filter graph</A> and connect it to other filters. You can access GraphEdit from the DXMedia SDK program group. Run GraphEdit and choose Insert Filters from the Graph menu to insert your filter. 

<P>If you are debugging an audio filter, there are two sample filters you might consider connecting to your filter to make sure it behaves as expected. You can also look at the source code for those samples to see how they implement methods and member functions. For overviews of those code samples, see <A HREF="../../filtsamp/Source_Filters.htm#SampleSynth">Synth Sample (Audio Synthesizer Filter)</A> and <A HREF="../../filtsamp/Renderer_Filters.htm#SampleScope">Scope Sample (Oscilloscope Filter)</A>.

<P>After you have the Filter Graph Editor successfully loading your new filter, you can use the File Dump Filter (Dump.ax) as a useful debugging tool. For instance, it can be used to verify, bit by bit, the results of a <A CLASS="Glossary" HREF="javascript:Glossary(sRelPath + 'gloss/gloss_T.htm#transform_filter')">transform filter</A>. Build a graph manually using the Filter Graph Editor and hook the File Dump Filter onto the output of a transform or any other pin. You can also hook up the <A HREF="../../filtsamp/Transform_Filters.htm#Infinite_Pin_Tee">Inftee Sample (Infinite-Pin Tee Filter)</A> (InfTee.ax), and put the File Dump Filter on one leg of the tee and the "normal" output on another to monitor what happens in the real-time case. For more information, see <A HREF="../../filtsamp/Renderer_Filters.htm#SampleDump">Dump Sample (Dump Filter)</A>.


<H3><A NAME="debug_19" IDX_CONCEPT="filters, adding as DLLs in Developer Studio">Add a Filter as an Additional DLL in Developer Studio</A></H3>
<P>If you're going to debug your filter with Microsoft Developer Studio version 5.0, you must tell the debugger about your filter. You should perform the following steps in Developer Studio to identify your filter as a debuggable DLL.

<OL>
<LI>From the Project menu, choose Settings.
<LI>Select the Debug tab.
<LI>Choose "Additional DLLs" from the Category drop-down list.
<LI>Add "myfilter.ax" to the list, where "myfilter" is the name of your filter.
</OL>

<H2><A NAME="debug_20" IDX_CONCEPT="noindex; leaks, detecting">Detecting Leaks</A></H2>
<P>Detecting and fixing memory leaks is another important debugging topic.

<P>Visual C++ has an optional debug heap, which can be useful in tracking down memory leaks. (See the "Using the Debug Heap" section of the Visual C++ documentation for more information.) For example, the Visual C++ <A HREF="../../appendixes/Further_Reading.htm#_CrtSetDbgFlag">_CrtSetDbgFlag</A> function enables you to turn on the memory-leak-checking flag bit.

<P>Other providers of memory leak tools can be found in the Microsoft Enterprise Development Partners directory.

<P>Another kind of leak is of COM object references. You can track down object reference leaks by performing the following steps.
<OL>
<LI>Put a break point on the <A HREF="../class/CUnknown.htm#NonDelegatingAddRef">NonDelegatingAddRef</A> and <A HREF="../class/CUnknown.htm#NonDelegatingRelease">NonDelegatingRelease</A> methods of that object.
<LI>Use Developer Studio (or another debugger) and step through every reference count change, trying to pair them up.
<LI>Look at the call stack for each change.
</OL>

<!-- CONTENTS_END -->

<!-- START_PAGE_FOOTER -->


<H6><HR size=1></H6>
<P><A Class="line" HREF="#pagetop"><IMG src="../../art/arrowup1.gif" WIDTH="11" HEIGHT="11" ALIGN="MIDDLE" BORDER=0 ALT="Top of Page">&nbsp;Top of Page</A>
<BR><A Class="line" HREF="../../../cpyright.htm">&#169; 1998 Microsoft Corporation. All rights reserved. Terms of Use.</A>
<!-- END_PAGE_FOOTER -->

</BLOCKQUOTE>

<SCRIPT>if((g_isIE == true) && (g_iMaj > 3)) {window.self.document.writeln('<SCR' + 'IPT SRC="../../tip2.js"></SCR' + 'IPT><IFRAME ID="G_L_S" NAME="SecretBuffer" STYLE="display: none" SRC=""></IFRAME>')}</SCRIPT>

<!-- DACONTROL_START -->

	<DIV ID="HeadGraphAnim"></DIV>
	<SCRIPT>if((g_isIE == true) && (g_iMaj > 3)) {window.self.document.writeln('<SCR' + 'IPT SRC="../../anim.js"></SCR' + 'IPT>')}</SCRIPT>
<!-- DACONTROL_END -->

</BODY>
</HTML>
