<!-- DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN" -->

<HTML>
<HEAD><TITLE>COM Overview</TITLE>
<SCRIPT> var sRelPath = '../' </SCRIPT>


<META NAME="Description" CONTENT="COM Overview">
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; CHARSET=iso8859-1">
<META NAME="MS.LOCALE" CONTENT="EN-US">
<META NAME="ROBOTS" CONTENT="all">

<!-- SNIFF_START -->

<SCRIPT>
//<!--
var g_isIE = false, g_isNav = false, g_iMaj = 0, g_sPlat = "";
// -->

</SCRIPT>
<SCRIPT SRC="../ver.js"></SCRIPT>
<SCRIPT SRC="../gloss.js"></SCRIPT>

<!-- SNIFF_END -->


<SCRIPT DEFER SRC="../common.js"></SCRIPT>
<SCRIPT DEFER>
//<!--
function InitPage()
{
	if (g_isIE && g_iMaj >= 4)	
	{

		SetTOC();
	}
}
//-->

</SCRIPT>

<!-- SNIFF_END -->


<!-- STYLE_START -->

<SCRIPT>
//<!--
   var sVR = '../'	// Set root for the style sheet
   var sCSS = '<LINK REL="stylesheet" HREF="' + sVR;

   if(g_isIE)
   {
	   if (g_iMaj >= 4) // For MSIE 4.0 or later
	   {
		   sCSS += 'dxm_basicsdkIE4';
		   if (g_sPlat == "Win") // Windows only for now
		   {
			   document.createStyleSheet(sVR + 'dxm_advSDKIE4.css');
		   }
	   }
	   else // For MSIE 3.0 or earlier
	   {
		   sCSS += 'dxm_basicsdkIE3';
	   }
   }
   else if (g_isNav) // For all Nav versions
   {
	   sCSS += 'dxm_basicsdkNAV';
   }
   else
   {
	   sCSS += 'dxm_basicsdkIE3'; // default to IE3 sheet
   }

   sCSS += (sCSS == '' ? '' : '.css" TYPE="text/css">');

   document.write(sCSS);
//-->

</SCRIPT>
<!-- STYLE_END -->


</HEAD>
<BODY onload="InitPage(); if (g_isIE && g_iMaj >= 4){HdgrphControl()}" BGCOLOR="#FFFFFF">
<A NAME="pagetop"></A><A NAME="COM_Overview"></A>

<!-- HEADGRAPH_START -->

<TABLE CLASS="main" BORDER=0 CELLSPACING="0" CELLPADDING="0" WIDTH="*">
<TR>
<TD ROWSPAN="3" VALIGN="TOP" WIDTH="*">
<IMG SRC="../art/header1.gif" WIDTH="107" HEIGHT="110" BORDER=0 ALT="DirectShow Animated Header -- COM Overview"></TD>
<TD ROWSPAN="2" VALIGN="TOP" WIDTH="217"><IMG SRC="../art/hdrdshow.gif" WIDTH="217" HEIGHT="110" BORDER=0 ALT="DirectShow Animated Header -- COM Overview"></TD>
<TD VALIGN="TOP" WIDTH="383">
<IMG SRC="../art/header3.gif" WIDTH="383" HEIGHT="95" BORDER=0 ALT="DirectShow Animated Header">
</TD>
<TD VALIGN="TOP" WIDTH="100%">
<IMG SRC="../art/spacer1.gif" WIDTH="100%" HEIGHT="94" BORDER=0 ALT="Microsoft DirectShow SDK">
</TD>
</TR>
<!-- HEADGRAPH_END -->

<!-- NAV_LINKS_START -->

<TR><TD VALIGN="TOP"><PRE><IMG ID="TOC_" SRC="../art/yelbtn.gif" WIDTH="11" HEIGHT="11" ALIGN="MIDDLE" BORDER=0 ALT="*"><A STYLE="color:black;font-weight:bold" ID="TOC" HREF="../contents.htm">Contents</A>  <IMG SRC="../art/yelbtn.gif" WIDTH="11" HEIGHT="11" ALIGN="MIDDLE" BORDER=0 ALT="*"><A STYLE="color:black;font-weight:bold" HREF="../index.htm">Index</A>  <IMG SRC="../art/yelbtn.gif" WIDTH="11" HEIGHT="11" ALIGN="MIDDLE" BORDER=0 ALT="*"><A STYLE="color:black;font-weight:bold" HREF="Basics_Intro.htm">Topic Contents</A>
</PRE></TD></TR>
<TR><TD COLSPAN="2" VALIGN="TOP"><PRE><IMG SRC="../art/yelbtn.gif" WIDTH="11" HEIGHT="11" ALIGN="MIDDLE" BORDER=0 ALT="*"><B>Previous Topic:</B> <A STYLE="color:black" HREF="Using_Filter_Graph_Editor.htm">Using the Filter Graph Editor</A>
<IMG SRC="../art/yelbtn.gif" WIDTH="11" HEIGHT="11" ALIGN="MIDDLE" BORDER=0 ALT="*"><B>Next Topic:</B> <A  STYLE="color:black" HREF="About_WDM_Video_Capture.htm">About WDM Video Capture</A>
</PRE></TD></TR></TABLE>
<!-- NAV_LINKS_END -->


<BLOCKQUOTE CLASS="body">
<!-- CONTENTS_START -->

<H1>COM Overview</H1>

<P>The Component Object Model (COM) is a binary standard that defines how objects are created and destroyed and, most importantly, how they interact with each other. As long as applications follow the COM standard, different applications from different sources can communicate with each other across process boundaries. People use COM to make communication with other applications easy.

<P>Because COM is a binary standard, it is language independent. You do not have to use C++ to implement COM. You can use any language that supports tables of function pointers. 

<P>A COM <I>interface</I> is a collection of logically related methods that express a single functionality. For example, the <A HREF="../ref/iface/IAsyncReader.htm#IAsyncReader">IAsyncReader</A> interface enables reading of MEDIATYPE_Stream data. All COM interfaces derive from <A HREF="../ref/iface/IUnknown.htm#IUnknown">IUnknown</A>, and all are named by a globally unique interface identifier (IID).

<P>A COM <I>class</I> is an implementation of one or more COM interfaces, and a COM object is an instance of a COM class. A Microsoft&#174; DirectShow&#153; <A CLASS="Glossary" HREF="javascript:Glossary(sRelPath + 'gloss/gloss_f.htm#filter')">filter</A>, for example, is a COM object. Each object has a globally unique class identifier (CLSID). 

<P>Globally unique identifiers (<A CLASS="Glossary" HREF="javascript:Glossary(sRelPath + 'gloss/gloss_G.htm#GUID')">GUIDs</A>) are extremely long integers that identify COM interfaces and objects, and are used to eliminate name collisions across applications. 

<P>All access to a COM object is through pointers to its interfaces. Interface methods are purely virtual and are stored in a table called a <I>vtable</I>. The interface pointer points to the vtable's beginning. A COM interface defines the parameter types and the syntax for each of its methods. The COM class provides an implementation for each method of the interface. 

<P>After a COM class has been defined and assigned a CLSID, you can create an instance of the object. There are several ways to create an instance of the class, including using the COM <A HREF="../appendixes/Further_Reading.htm#CoCreateInstance">CoCreateInstance</A> or <A HREF="../appendixes/Further_Reading.htm#IClassFactory__Creat">IClassFactory::CreateInstance</A> methods, or the C++ <B>new</B> operator. 

<P>When you create an instance of an object, the call returns a pointer to one of the object's interfaces. Once you have an initial pointer to an interface on the object, you can use the <A HREF="../ref/iface/IUnknown.htm#QueryInterface">IUnknown::QueryInterface</A> method to find out whether the object supports another specific interface, and, if so, to get a pointer to that interface. COM supplies many standard interfaces that support data storage and transfer, notification, and basic connectivity with other objects, including <A HREF="../appendixes/Further_Reading.htm#IStream">IStream</A>, <A HREF="../appendixes/Further_Reading.htm#IPropertyPage">IPropertyPage</A>, and <A HREF="../appendixes/Further_Reading.htm#IMoniker">IMoniker</A>. DirectShow, in turn, adds its own COM interfaces, such as <A HREF="../ref/iface/IAMDirectSound.htm#IAMDirectSound">IAMDirectSound</A>, that clients of DirectShow objects can query for to determine if the object supports a particular functionality. To use COM interfaces, clients must know the interface definitions and the IID to query for (IID_<I>interfacename</I>). For example, assume you have a pointer to a COM object's <A HREF="../ref/iface/IUnknown.htm#IUnknown">IUnknown</A> interface in the <I>pUnknown</I> variable. You can query to see if the object supports <B>IAMDirectSound</B> with the following code.

<PRE>hr=pUnknown-&gt;QueryInterface(IID_IAMDirectSound, (void **)&amp;pIAMDSound);
</PRE>

<P><A HREF="../ref/iface/IUnknown.htm#IUnknown">IUnknown</A> is the basic COM interface on which all others are based. <B>IUnknown</B> has three methods&#151;<A HREF="../ref/iface/IUnknown.htm#QueryInterface">QueryInterface</A>, <A HREF="../ref/iface/IUnknown.htm#AddRef">AddRef</A>, and <A HREF="../ref/iface/IUnknown.htm#Release">Release</A>&#151;that implement interface querying and reference counting. All COM interfaces inherit these three methods from <B>IUnknown</B>.

<P><I>Reference counting</I> is the technique by which an object (or, strictly, an interface) decides when it is no longer being used and can therefore destroy itself. COM objects are dynamically allocated from within the object and multiple clients can use them simultaneously. To avoid wasting memory, the COM object must keep track of the number of clients using it, and destroy itself when clients no longer need it. The number of clients using the object is maintained in the reference count. Every time a new interface pointer to the COM object is created, the client using the object must increase the reference count by calling <A HREF="../ref/iface/IUnknown.htm#AddRef">AddRef</A> on the interface pointer. Every time a client destroys an interface pointer to the object, it must first decrease the reference count by calling <A HREF="../ref/iface/IUnknown.htm#Release">Release</A> on the interface pointer. 

<P>Binding associates a method with a pointer to its memory location. At compile time, a COM object's client is bound to the vtable locations of the object's interface methods. This is called <I>early binding</I>. With some languages, such as Microsoft&#174; Visual Basic&#174;, a vtable interface is difficult to access. Dispatch interfaces, identified by dispatch identifiers (DISPIDs), allow clients to access member functions not by position in a vtable, but by a human-readable name. Dispatch interfaces are accessed through the COM <A HREF="../appendixes/Further_Reading.htm#IDispatch">IDispatch</A> interface and its <B>Invoke</B> method, which converts the names of the dispatch interface's functions to DISPIDs. The client retrieves the DISPIDs at <A CLASS="Glossary" HREF="javascript:Glossary(sRelPath + 'gloss/gloss_R.htm#run_time')">run time</A>. This is called <I>late binding</I>. To allow late binding, a COM object must implement the <B>IDispatch</B> interface and a mapping of function names and function parameters to a set of DISPIDs. In DirectShow, <A HREF="../ref/class/CBaseDispatch.htm#CBaseDispatch">CBaseDispatch</A> implements the <B>IDispatch</B> interface.

<P>Marshaling is the process of passing function arguments and return values among processes and machines. An in-process proxy packages arguments for the member function of an object in another process, and generates a remote procedure call to the other process. In the other process, a stub receives the call and unpacks the data, and calls the object through its interface. Dispatch interfaces do not need proxies and stubs and so are easier to use than vtable interfaces in out-of-process applications. Vtable interfaces, however, can be considerably faster, particularly in in-process applications. You can also write dual interfaces that have both tables of function pointers and dispatch interfaces. Dual interfaces can be nearly as fast as vtable interfaces, while allowing the flexibility of dispatch interfaces.

<P>For more information about how DirectShow uses COM, see <A HREF="../filtdev/DSandCOM.htm#com">DirectShow and COM</A>. For general information about COM, see the "COM" section in the Microsoft Platform SDK, or an introductory book such as <I>ActiveX OLE</I> by David Chappell.


<!-- CONTENTS_END -->

<!-- START_PAGE_FOOTER -->


<H6><HR size=1></H6>
<P><A Class="line" HREF="#pagetop"><IMG src="../art/arrowup1.gif" WIDTH="11" HEIGHT="11" ALIGN="MIDDLE" BORDER=0 ALT="Top of Page">&nbsp;Top of Page</A>
<BR><A HREF="../../cpyright.htm">&#169; 1998 Microsoft Corporation. All rights reserved. Terms of Use.</A>
<!-- END_PAGE_FOOTER -->

</BLOCKQUOTE>

<SCRIPT>if((g_isIE == true) && (g_iMaj > 3)) {window.self.document.writeln('<SCR' + 'IPT SRC="../tip2.js"></SCR' + 'IPT><IFRAME ID="G_L_S" NAME="SecretBuffer" STYLE="display: none" SRC=""></IFRAME>')}</SCRIPT>

<!-- DACONTROL_START -->

	<DIV ID="HeadGraphAnim"></DIV>
	<SCRIPT>if((g_isIE == true) && (g_iMaj > 3)) {window.self.document.writeln('<SCR' + 'IPT SRC="../anim.js"></SCR' + 'IPT>')}</SCRIPT>
<!-- DACONTROL_END -->

</BODY>
</HTML>
