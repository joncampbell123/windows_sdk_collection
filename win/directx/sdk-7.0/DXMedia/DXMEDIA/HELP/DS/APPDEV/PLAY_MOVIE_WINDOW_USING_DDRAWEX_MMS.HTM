<!-- DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN" -->

<HTML>
<HEAD><TITLE>Play a Movie in a Window Using DirectDrawEx and Multimedia Streaming</TITLE>
<SCRIPT> var sRelPath = '../' </SCRIPT>


<META NAME="Description" CONTENT="Play a Movie in a Window Using DirectDrawEx and Multimedia Streaming">
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; CHARSET=iso8859-1">
<META NAME="MS.LOCALE" CONTENT="EN-US">
<META NAME="ROBOTS" CONTENT="all">

<!-- SNIFF_START -->

<SCRIPT>
//<!--
var g_isIE = false, g_isNav = false, g_iMaj = 0, g_sPlat = "";
// -->

</SCRIPT>
<SCRIPT SRC="../ver.js"></SCRIPT>
<SCRIPT SRC="../gloss.js"></SCRIPT>

<!-- SNIFF_END -->


<SCRIPT DEFER SRC="../common.js"></SCRIPT>
<SCRIPT DEFER>
//<!--
function InitPage()
{
	if (g_isIE && g_iMaj >= 4)	
	{

		SetTOC();
	}
}
//-->

</SCRIPT>

<!-- SNIFF_END -->


<!-- STYLE_START -->

<SCRIPT>
//<!--
   var sVR = '../'	// Set root for the style sheet
   var sCSS = '<LINK REL="stylesheet" HREF="' + sVR;

   if(g_isIE)
   {
	   if (g_iMaj >= 4) // For MSIE 4.0 or later
	   {
		   sCSS += 'dxm_basicsdkIE4';
		   if (g_sPlat == "Win") // Windows only for now
		   {
			   document.createStyleSheet(sVR + 'dxm_advSDKIE4.css');
		   }
	   }
	   else // For MSIE 3.0 or earlier
	   {
		   sCSS += 'dxm_basicsdkIE3';
	   }
   }
   else if (g_isNav) // For all Nav versions
   {
	   sCSS += 'dxm_basicsdkNAV';
   }
   else
   {
	   sCSS += 'dxm_basicsdkIE3'; // default to IE3 sheet
   }

   sCSS += (sCSS == '' ? '' : '.css" TYPE="text/css">');

   document.write(sCSS);
//-->

</SCRIPT>
<!-- STYLE_END -->


</HEAD>
<BODY onload="InitPage(); if (g_isIE && g_iMaj >= 4){HdgrphControl()}" BGCOLOR="#FFFFFF">
<A NAME="pagetop"></A><A NAME="moviewin_sample"></A>

<!-- HEADGRAPH_START -->

<TABLE CLASS="main" BORDER=0 CELLSPACING="0" CELLPADDING="0" WIDTH="*">
<TR>
<TD ROWSPAN="3" VALIGN="TOP" WIDTH="*">
<IMG SRC="../art/header1.gif" WIDTH="107" HEIGHT="110" BORDER=0 ALT="DirectShow Animated Header -- Play a Movie in a Window Using DirectDrawEx and Multimedia Streaming"></TD>
<TD ROWSPAN="2" VALIGN="TOP" WIDTH="217"><IMG SRC="../art/hdrdshow.gif" WIDTH="217" HEIGHT="110" BORDER=0 ALT="DirectShow Animated Header -- Play a Movie in a Window Using DirectDrawEx and Multimedia Streaming"></TD>
<TD VALIGN="TOP" WIDTH="383">
<IMG SRC="../art/header3.gif" WIDTH="383" HEIGHT="95" BORDER=0 ALT="DirectShow Animated Header">
</TD>
<TD VALIGN="TOP" WIDTH="100%">
<IMG SRC="../art/spacer1.gif" WIDTH="100%" HEIGHT="94" BORDER=0 ALT="Microsoft DirectShow SDK">
</TD>
</TR>
<!-- HEADGRAPH_END -->

<!-- NAV_LINKS_START -->

<TR><TD VALIGN="TOP"><PRE><IMG ID="TOC_" SRC="../art/yelbtn.gif" WIDTH="11" HEIGHT="11" ALIGN="MIDDLE" BORDER=0 ALT="*"><A STYLE="color:black;font-weight:bold" ID="TOC" HREF="../contents.htm">Contents</A>  <IMG SRC="../art/yelbtn.gif" WIDTH="11" HEIGHT="11" ALIGN="MIDDLE" BORDER=0 ALT="*"><A STYLE="color:black;font-weight:bold" HREF="../index.htm">Index</A>  <IMG SRC="../art/yelbtn.gif" WIDTH="11" HEIGHT="11" ALIGN="MIDDLE" BORDER=0 ALT="*"><A STYLE="color:black;font-weight:bold" HREF="How_to_AppDev.htm">Topic Contents</A>
</PRE></TD></TR>
<TR><TD COLSPAN="2" VALIGN="TOP"><PRE><IMG SRC="../art/yelbtn.gif" WIDTH="11" HEIGHT="11" ALIGN="MIDDLE" BORDER=0 ALT="*"><B>Previous Topic:</B> <A STYLE="color:black" HREF="Use_MMS_DS_Apps.htm">Use Multimedia Streaming in DirectShow Applications</A>
<IMG SRC="../art/yelbtn.gif" WIDTH="11" HEIGHT="11" ALIGN="MIDDLE" BORDER=0 ALT="*"><B>Next Topic:</B> <A  STYLE="color:black" HREF="Control_External_Device.htm">Control an External Device in DirectShow</A>
</PRE></TD></TR></TABLE>
<!-- NAV_LINKS_END -->


<BLOCKQUOTE CLASS="body">


<!-- CONTENTS_START -->

<H1>Play a Movie in a Window Using DirectDrawEx and Multimedia Streaming</H1>

<P>This article walks through the <B>MovieWin</B> C++ example code, which plays movies in a window by rendering to a Microsoft DirectDraw&reg; surface. The MovieWin example code is a Microsoft&reg; Windows&reg; 9<I>x</I> application that is an extension of the <A HREF="../filtsamp/C_C++_Samp_Apps.htm#ShowStrm">ShowStrm Sample (Multimedia Streaming Application)</A> sample. MovieWin uses multimedia streaming to render a video file to a DirectDraw surface created through <A HREF="../ddrawex/DDrawEx_intro.htm#fm_whatis_ddrawex">DirectDrawEx</A>. It implements a primary DirectDraw surface and an off-screen DirectDraw surface to optimize frame <A CLASS="Glossary" HREF="javascript:Glossary(sRelPath + 'gloss/gloss_B.htm#blit')">blitting</A>. It also attaches a DirectDraw clipper to the window to process window overlapping.

<P>This article contains the following sections.
<UL>
<LI><A HREF="Play_Movie_Window_Using_DDrawEx_MMS.htm#nec_headers">Necessary Header Files and Libraries</A>
<LI><A HREF="Play_Movie_Window_Using_DDrawEx_MMS.htm#win_mainfunc">WinMain Function</A>
<LI><A HREF="Play_Movie_Window_Using_DDrawEx_MMS.htm#init_ddex">Initialize DirectDraw Surfaces and Create the Clipper</A>
<LI><A HREF="Play_Movie_Window_Using_DDrawEx_MMS.htm#open_movie">Open a Movie File</A>
<LI><A HREF="Play_Movie_Window_Using_DDrawEx_MMS.htm#file_to_stream">Create the Multimedia Stream Object</A>
<LI><A HREF="Play_Movie_Window_Using_DDrawEx_MMS.htm#init_render_surf">Create the Stream Sample Object</A>
<LI><A HREF="Play_Movie_Window_Using_DDrawEx_MMS.htm#render_surf">Render the Multimedia Stream to the DirectDraw Surface</A>
<LI><A HREF="Play_Movie_Window_Using_DDrawEx_MMS.htm#exit_code">Release Objects</A>
<LI><A HREF="Play_Movie_Window_Using_DDrawEx_MMS.htm#moviewnd_proc">WndMainProc Function</A>
<LI><A HREF="Play_Movie_Window_Using_DDrawEx_MMS.htm#entire_code">Entire MovieWin Example Code</A>
</UL>

<P>The example demonstrates a way to render a movie that differs from the traditional method of instantiating a <A CLASS="Glossary" HREF="javascript:Glossary(sRelPath + 'gloss/gloss_F.htm#filter_graph')">filter graph</A> directly in your application. The MovieWin example code uses the multimedia streaming interfaces to automatically negotiate the transfer and conversion of data from the source to the application, so you don't have to write code to handle the connection, transfer of data, data conversion, or actual data rendering.

<P>Additionally, the example demonstrates how to create DirectDraw surfaces and how to add code for a <A HREF="../appendixes/Further_Reading.htm#DirectDrawClipper">DirectDrawClipper</A> object through DirectDrawEx.

<P>Note that all error checking has been left out of the code walk-through. The <A HREF="Play_Movie_Window_Using_DDrawEx_MMS.htm#entire_code">Entire MovieWin Example Code</A> section provides all of the code with complete error checking.




<h2><A NAME="nec_headers"></A>Necessary Header Files and Libraries</h2>
<P>This section discusses necessary headers and libraries that need to be included and examines each function in the MovieWin example code in detail.

<P>To compile the MovieWin example code you must have DirectX Media SDK 5.<I>x</I> or later installed and you will need to set your include path under Tools/Options/Directories/Include to c:\DXMedia\Include and your library path to c:\DXMedia\Lib. Also link with the Amstrmid.lib, the Quartz.lib, the Strmbase.lib, and the Ddraw.lib (DirectDrawEx does not provide its own library) libraries under Project/Settings/Link.

<P>Include the necessary header files and define the window's name and the window class name.

<PRE>
#include &lt;windows.h&gt;
#include &lt;mmstream.h&gt;    // Multimedia stream interfaces
#include &lt;amstream.h&gt;    // DirectShow multimedia stream interfaces
#include &lt;ddstream.h&gt;    // DirectDraw multimedia stream interfaces
#include &lt;initguid.h&gt;   // Defines DEFINE_GUID macro and enables GUID initialization
#include &lt;ddrawex.h&gt;    // DirectDrawEx interfaces
#include "resource.h"   // Resources for the menu bar

#define APPLICATIONNAME "Multimedia Stream In Window"
#define CLASSNAME "MMSDDRAWEXWINDOW"
</PRE>

<P>Then declare the following global variables:

<PRE>
HWND              ghWnd;
HINSTANCE         ghInst;
BOOL              g_bAppactive=FALSE,    // The window is active
                  g_bFileLoaded = FALSE, // There is a file loaded
                  g_bPaused=FALSE;       // The movie has been paused
RECT              rect, rect2;          // Rectangles for screen coordinates
</PRE>

<P>The ghWnd variable is the handle of the window to send messages to. The ghInst variable is the handle of the instance of the window. The three Boolean values g_bAppactive, g_bFileLoaded, g_bPaused variables are used to determine the various states of the application and are used extensively by the WndMainProc function. They are declared as global variables to retain their TRUE or FALSE status. Finally, rect and rect2 are rectangle structures that will contain the original movie coordinates and the coordinates of the window to show the movie in, respectively.

<P>Next, declare the DirectDrawEx and multimedia streaming interfaces. The reference count of the interfaces is automatically incremented on initialization, so you don't need to call the <A HREF="../ref/iface/IUnknown.htm#AddRef">IUnknown::AddRef</A> method to increment them. For more information on these interfaces, see <A HREF="../ddrawex/DDrawEx_intro.htm#fm_whatis_ddrawex">DirectDrawEx</A>, <A HREF="../mms/MMS_intro.htm#fm_mm">Multimedia Streaming</A>, and the Microsoft DirectX&reg; SDK.

<PRE>
//DirectDrawEx Global interfaces
IDirectDraw            *g_pDD=NULL;   
IDirectDraw3           *g_pDD3=NULL; 
IDirectDrawFactory     *g_pDDF=NULL;
IDirectDrawSurface     *g_pPrimarySurface=NULL,
                       *g_pDDSoff-screen=NULL;
IDirectDrawClipper     *g_pDDClipper=NULL;

//Global MultiMedia streaming interfaces
IMultiMediaStream        *g_pMMStream=NULL;
IMediaStream             *g_pPrimaryVidStream=NULL;    
IDirectDrawMediaStream   *g_pDDStream=NULL;
IDirectDrawStreamSample  *g_pSample=NULL;
</PRE>
<P>Finally, declare the function prototypes.

<PRE>
//Function prototypes
int PASCAL WinMain(HINSTANCE hInstC, HINSTANCE hInstP, LPSTR lpCmdLine, int nCmdShow);
LRESULT CALLBACK WndMainProc (HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam);
HRESULT InitDDrawEx();
BOOL GetOpenMovieFile(LPSTR szName);
HRESULT RenderFileToMMStream(LPCTSTR szFilename);        
HRESULT InitRenderToSurface();
void RenderToSurface();
void ExitCode();
</PRE>

<h2><A NAME="win_mainfunc">WinMain Function</A></h2>
<P>First, you need to create a <B>WinMain</B> function. The <A HREF="../appendixes/Further_Reading.htm#WinMain">WinMain</A> function is a generic Windows function. You need to revise the <B>WinMain</B> function if 1) your application needs to know when another instance of the application is running, or 2) you need to access the command line. Otherwise, the code in this standard function generally needs no change. See the <A HREF="Play_Movie_Window_Using_DDrawEx_MMS.htm#entire_code">MovieWin Example Code</A> for an example of a generic <B>WinMain</B> function. 

<P>One of the functions in <B>WinMain</B> is the Win32 <A HREF="../appendixes/Further_Reading.htm#CreateWindowEx">CreateWindowEx</A> function. Immediately after the call to <B>CreateWindowEx</B>, the <A HREF="Play_Movie_Window_Using_DDrawEx_MMS.htm#init_ddex">InitDDrawEx function</A> is called to initialize the DirectDrawEx surfaces that the movie will play on and to create a <A HREF="../appendixes/Further_Reading.htm#clipper">clipper</A> to attach to the window. The clipper can only be created after it has a global handle to the window (ghWnd), and so must be created after the call to the <B>CreateWindowEx</B> function has returned.

<P>The message pump is a standard Windows message pump containing the <A HREF="../appendixes/Further_Reading.htm#TranslateMessage">TranslateMessage</A> and the <A HREF="../appendixes/Further_Reading.htm#DispatchMessage">DispatchMessage</A> functions. A message pump cycles through a message loop, checking the message queue for available messages. If a message is available, the message pump dispatches it for action. Before the code reaches the <B>TranslateMessage</B> and <B>DispatchMessage</B> functions, it calls the <A HREF="../appendixes/Further_Reading.htm#PeekMessage">PeekMessage</A> function. The <B>PeekMessage</B> function checks a thread message queue for a message and places the message (if any) in the specified structure. If there are messages being passed to the window, the code proceeds to the regular <A HREF="../appendixes/Further_Reading.htm#GetMessage">GetMessage</A>, <B>TranslateMessage</B>, and <B>DispatchMessage</B> functions respectively. However, if there are no messages in the message queue, the process will check for the g_bFileLoaded Boolean value, which specifies whether a file has been loaded. Initially, the value in g_bFileLoaded is FALSE so the code maintains its loop, waiting for new messages.

<P>After a file has been loaded and rendered to a multimedia stream (see <A HREF="Play_Movie_Window_Using_DDrawEx_MMS.htm#open_movie">GetOpenMovieFile function</A> and <A HREF="Play_Movie_Window_Using_DDrawEx_MMS.htm#file_to_stream">RenderFileToMMStream function</A>) the g_bFileLoaded value and the g_bAppactive values are set to TRUE and the message pump will call the <A HREF="Play_Movie_Window_Using_DDrawEx_MMS.htm#render_surf">RenderToSurface function</A>, which blits one frame of the movie to the window's coordinates. As the loop continues, the movie continues to render frame by frame until completion or until it is interrupted the <A HREF="../appendixes/Further_Reading.htm#PeekMessage">PeekMessage</A> function with an outside message to the window. If the movie is paused, stopped, or if it completes on its own, the g_bAppactive variable is set to FALSE, which causes the call to RenderToSurface to be skipped until g_bAppactive is set to TRUE again.

<P>The following code shows how to create the message pump.

<PRE>while(1){
        //The PeekMessage function checks a thread message queue 
        //for a message and places the message (if any) in the specified structure. 
        if(PeekMessage(&amp;msg, NULL, 0,0,PM_NOREMOVE)){
            
            // Quit if WM_QUIT found
            if(!GetMessage(&amp;msg,NULL, 0, 0)) return (msg.wParam);

            // Otherwise handle the messages
                TranslateMessage(&amp;msg);        // Allow input
                DispatchMessage(&amp;msg);        // Send to appropriate process.
        }
        else{
            // If there are no other windows messages...
            // Render frame by frame (but only if the application is the active
            // window and a file is actually loaded)
            if (g_bFileLoaded &amp;&amp; g_bAppactive) {    
                RenderToSurface();    
                }
            }
        }
      return msg.wParam;
</PRE>
<h2><A NAME="init_ddex"></A>Initialize DirectDraw Surfaces and Create the Clipper</h2>
<P>The InitDDrawEx function initializes a primary DirectDraw surface and an off-screen DirectDraw surface, as well as a clipper object that is attached to the window. The following code shows how to do this.

<OL><LI>Declare local variables and initialize the COM subsystem.

<PRE>HRESULT            hr=NOERROR;
DDSURFACEDESC    ddsd, ddsd2;

CoInitialize(NULL);
</PRE>
<LI>Create the DirectDrawFactory object and expose the <A HREF="../ddrawex/IDirectDrawFactory.htm#IDirectDrawFactory">IDirectDrawFactory</A> interface.

<PRE>
CoCreateInstance(CLSID_DirectDrawFactory, NULL, CLSCTX_INPROC_SERVER, 
                            IID_IDirectDrawFactory, (void **)&amp;g_pDDF);
</PRE>
<P>Use the pointer to the <A HREF="../ddrawex/IDirectDrawFactory.htm#IDirectDrawFactory">IDirectDrawFactory</A> interface to call the <A HREF="../ddrawex/IDirectDrawFactory.htm#CreateDirectDraw">IDirectDrawFactory::CreateDirectDraw</A> method, which you use to create the DirectDraw object, set the cooperative level, and get the address of an <A HREF="../appendixes/Further_Reading.htm#IDirectDraw">IDirectDraw</A> interface pointer.

<PRE>
g_pDDF-&gt;CreateDirectDraw(NULL, GetDesktopWindow(), DDSCL_NORMAL, 
                NULL, NULL, &amp;g_pDD);
</PRE>
<LI>Query for the <A HREF="../ddrawex/IDirectDraw3.htm#IDirectDraw3">IDirectDraw3</A> interface, which you use to create the DirectDraw surfaces.

<PRE>g_pDD-&gt;QueryInterface(IID_IDirectDraw3, (LPVOID*)&amp;g_pDD3);
</PRE>
<LI>Initialize the <A HREF="../appendixes/Further_Reading.htm#DDSURFACEDESC">DDSURFACEDESC</A> structure for the <A CLASS="Glossary" HREF="javascript:Glossary(sRelPath + 'gloss/gloss_P.htm#primary_surface')">primary surface</A>. The following is the minimum code needed to accomplish this. You should also initialize other members of the structure here if your code must create more sophisticated applications.

<PRE>ZeroMemory(&amp;ddsd, sizeof(ddsd));
ddsd.dwSize = sizeof(ddsd);    
ddsd.dwFlags = DDSD_CAPS;
ddsd.ddsCaps.dwCaps = DDSCAPS_PRIMARYSURFACE;
</PRE>
<LI>Call the <A HREF="../ddrawex/IDirectDraw3.htm#CreateSurface">IDirectDraw3::CreateSurface</A> method to create the primary DirectDraw surface and return a pointer to <A HREF="../appendixes/Further_Reading.htm#IDirectDrawSurface">IDirectDrawSurface</A> interface.

<PRE>g_pDD3-&gt;CreateSurface(&amp;ddsd, &amp;g_pPrimarySurface, NULL);</PRE>
<LI>Create the off-screen surface where the <A HREF="../mms/IStreamSample.htm#Update">IStreamSample::Update</A> method will send the individual movie frames before they are blitted onto the screen. Using an off-screen surface optimizes the performance of the video and enables the blits to be processed at a faster rate. Also the video remains in memory and can be called upon in the event of a repaint notification.
<P>You must create the off-screen surface with the identical height, width, and pixel format to the primary surface in order to blit from one to the other. Do this by first getting the <A HREF="../appendixes/Further_Reading.htm#DDSURFACEDESC">DDSURFACEDESC</A> structure from the primary surface through a call to the <A HREF="../appendixes/Further_Reading.htm#IDirectDrawSurface__">IDirectDrawSurface::GetSurfaceDesc</A> method.

<PRE>g_pPrimarySurface-&gt;GetSurfaceDesc(&amp;ddsd);</PRE>
<LI>Now you can initialize the <A HREF="../appendixes/Further_Reading.htm#DDSURFACEDESC">DDSURFACEDESC</A> structure for the off-screen surface with the same parameters as the primary surface:

<PRE>
ZeroMemory(&amp;ddsd2, sizeof(ddsd2));
ddsd2.dwSize = sizeof(ddsd2);    
ddsd2.dwFlags = DDSD_CAPS | DDSD_HEIGHT | DDSD_WIDTH | DDSD_PIXELFORMAT;
ddsd2.ddsCaps.dwCaps = DDSCAPS_off-screenPLAIN;
ddsd2.dwHeight = ddsd.dwHeight;    //set the height of the surfaces equal
ddsd2.dwWidth  = ddsd.dwWidth;    //set the width of the surfaces equal
ddsd2.ddpfPixelFormat = ddsd.ddpfPixelFormat; //set the pixel formats equal
</PRE>
<LI>Call the <A HREF="../ddrawex/IDirectDraw3.htm#CreateSurface">IDirectDraw3::CreateSurface</A> method to create the off-screen surface.

<PRE>g_pDD3-&gt;CreateSurface(&amp;ddsd2, &amp;g_pDDSoff-screen, NULL)</PRE>
<P>At this point, you should have two identical DirectDraw surfaces: the off-screen surface that will be used to update the movie frames on, and the primary surface, which your user will see. The primary surface will contain the video after the data has been blitted from the off-screen surface to the primary surface.

<LI>To give the window the look and feel of a regular window, you must add code for a clipper. The <A HREF="../appendixes/Further_Reading.htm#DirectDrawClipper">DirectDrawClipper</A> object (casually referred to as a "clipper") helps you prevent blitting to certain portions of a surface or beyond the bounds of a surface. DirectDrawClipper objects expose their functionality through the <A HREF="../appendixes/Further_Reading.htm#IDirectDrawClipper">IDirectDrawClipper</A> interface. You can create a clipper by calling the <A HREF="../appendixes/Further_Reading.htm#IDirectDraw3__Create">IDirectDraw3::CreateClipper</A> method. 

<P>Use the following code to create the clipper object and retrieve a pointer to the <A HREF="../appendixes/Further_Reading.htm#IDirectDrawClipper">IDirectDrawClipper</A> interface.

<PRE>g_pDD3-&gt;CreateClipper(0, &amp;g_pDDClipper, NULL);</PRE>
<LI>Use the <A HREF="../appendixes/Further_Reading.htm#IDirectDrawSurface">IDirectDrawSurface</A> interface to attach the clipper to the primary surface.

<PRE>g_pPrimarySurface-&gt;SetClipper(g_pDDClipper);</PRE>
<LI>Finally, associate the clipper with the window by calling the <A HREF="../appendixes/Further_Reading.htm#IDirectDrawClipper__">IDirectDrawClipper::SetHWnd</A> method.

<PRE>g_pDDClipper-&gt;SetHWnd(0, ghWnd);</PRE>
</OL>
<P>At this point, you should have two DirectDraw surfaces, and a clipper attached to the primary surface and to the applications window. The DirectDrawEx initialization is complete and all the objects are available to the process until the <A HREF="Play_Movie_Window_Using_DDrawEx_MMS.htm#exit_code">ExitCode function</A> is called to release the objects.

<P>For more information on DirectDrawEx, see <A HREF="../ddrawex/DDrawEx_intro.htm#fm_whatis_ddrawex">DirectDrawEx</A>.


<h2><A NAME="open_movie"></A>Open a Movie File</h2>
<P>The following code shows how to use the GetOpenMovieFile function to display the Open file dialog box. It initializes the <A HREF="../appendixes/Further_Reading.htm#OPENFILENAME">OPENFILENAME</A> structure and calls the <A HREF="../appendixes/Further_Reading.htm#GetOpenFileName">GetOpenFileName</A> API.

<PRE>BOOL GetOpenMovieFile(LPSTR szName)
{
    OPENFILENAME    ofn;
    
    ofn.lStructSize       = sizeof(OPENFILENAME);
    ofn.hwndOwner         = ghWnd;
    ofn.lpstrFilter       = NULL;
    ofn.lpstrFilter       = "Video (*.avi;*.mpg;*.mpeg)\0*.avi;*.mpg;*.mpeg\0All Files (*.*)\0*.*\0";
    ofn.lpstrCustomFilter = NULL;
    ofn.nFilterIndex      = 1;
    *szName = 0;
    ofn.lpstrFile         = szName;
    ofn.nMaxFile          = MAX_PATH;
    ofn.lpstrInitialDir   = NULL;
    ofn.lpstrTitle        = NULL;
    ofn.lpstrFileTitle    = NULL;
    ofn.lpstrDefExt       = NULL;
    ofn.Flags             = OFN_FILEMUSTEXIST | OFN_READONLY | OFN_PATHMUSTEXIST;
    return GetOpenFileName((LPOPENFILENAME)&amp;ofn);
}
</PRE>
<h2><A NAME="file_to_stream"></A>Create the Multimedia Stream Object</h2>
<P>The RenderFileToMMStream function creates a multimedia stream and attaches the stream to the file retrieved by the GetOpenMovieFile function. This function uses the <A HREF="../mms/IAMMultiMediaStream.htm#IAMMultiMediaStream">IAMMultiMediaStream</A> interface to expose DirectShow functionality to the application. After the address of a pointer to the <B>IAMMultiMediaStream</B> interface is retrieved, it will be used to initialize the stream, add specific media streams to the current filter graph, and open and automatically create a filter graph for the specified media file.
<P>The following steps show how to do this.

<OL><LI>Declare the local variables hr and pAMStream, and convert the provided file name to a wide (Unicode) string.

<PRE>HRESULT hr;
IAMMultiMediaStream *pAMStream=NULL;
WCHAR wFile[MAX_PATH];
MultiByteToWideChar(CP_ACP, 0, szFilename, -1, wFile,    
            sizeof(wFile)/sizeof(wFile[0]));</PRE>
<LI>Create the AMMultiMediaStream object and initialize it.

<PRE>hr =CoCreateInstance(CLSID_AMMultiMediaStream, NULL, CLSCTX_INPROC_SERVER,
                                      IID_IAMMultiMediaStream, (void **)&amp;pAMStream);
hr = pAMStream-&gt;Initialize(STREAMTYPE_READ, 0, NULL);</PRE>
<LI>Now that you have a stream object, add a single audio and video stream to it; typically, you need only these two streams for media file playback. When the <A HREF="../mms/IAMMultiMediaStream.htm#AddMediaStream">IAMMultiMediaStream::AddMediaStream</A> method receives the MSPID_PrimaryVideo flag as its second parameter, it uses the pointer in the first parameter as the destination surface for video playback. The audio stream needs no such surface, however, so pass NULL as the first parameter when you add audio streams. The AMMSF_ADDDEFAULTRENDERER flag automatically adds the default sound <A CLASS="Glossary" HREF="javascript:Glossary(sRelPath + 'gloss/gloss_R.htm#renderer')">renderer</A> to the current filter graph.

<PRE>
hr = pAMStream-&gt;AddMediaStream(g_pDD3, &amp;MSPID_PrimaryVideo, 0, NULL);
hr = pAMStream-&gt;AddMediaStream(NULL, &amp;MSPID_PrimaryAudio, AMMSF_ADDDEFAULTRENDERER, NULL);</PRE>
<LI>Finally, open and create a filter graph for the specified media file and save the local stream to the global variable g_pMMStream. Don't forget to increase the reference count on the <A HREF="../mms/IAMMultiMediaStream.htm#IAMMultiMediaStream">IAMMultiMediaStream</A> object.

<PRE>//Opens and automatically creates a filter graph for the specified media file
hr = pAMStream-&gt;OpenFile(wFile, 0); 
//save the local stream to the global variable
g_pMMStream = pAMStream;    
// Add a reference to the file
pAMStream-&gt;AddRef();
</PRE>
</OL>
<P>Now that you have valid streams and a pointer to them, this function is complete. For more information on multimedia streams see <A HREF="../mms/MMS_intro.htm#fm_mm">Multimedia Streaming</A> and <A HREF="Use_MMS_DS_Apps.htm">Use Multimedia Streaming in DirectShow Applications</A>.


<h2><A NAME="init_render_surf"></A>Create the Stream Sample Object</h2>
<P>The InitRenderToSurface function creates the stream sample that will be associated with the off-screen <A HREF="../appendixes/Further_Reading.htm#DirectDrawSurface">DirectDrawSurface</A> object. The stream sample will be used later by the <A HREF="Play_Movie_Window_Using_DDrawEx_MMS.htm#render_surf">RenderToSurface function</A> to call the <A HREF="../mms/IStreamSample.htm#Update">IStreamSample::Update</A> method to perform frame-by-frame updates of the sample.

<P>The following steps show how to do this.

<OL><LI>To create and initialize the stream sample, declare the local variables, and then get the primary video media stream by using the <A HREF="../mms/IMultiMediaStream.htm#GetMediaStream">IMultiMediaStream::GetMediaStream</A> method.

<PRE>HRESULT            hr;
DDSURFACEDESC    ddsd;
    
//Use the multimedia stream to get the primary video media stream
hr = g_pMMStream-&gt;GetMediaStream(MSPID_PrimaryVideo, &amp;g_pPrimaryVidStream);
</PRE>
<LI>After you obtain the primary video stream interface (<A HREF="../mms/IMediaStream.htm#IMediaStream">IMediaStream</A>), you can use it to query for the <A HREF="../mms/IDirectDrawMediaStream.htm#IDirectDrawMediaStream">IDirectDrawMediaStream</A> interface, which you'll use to create the stream sample.

<PRE>hr = g_pPrimaryVidStream-&gt;QueryInterface(IID_IDirectDrawMediaStream, (void **)&amp;g_pDDStream);</PRE>
<LI>Before you can create the stream sample, you must call the <A HREF="../mms/IDirectDrawMediaStream.htm#GetFormat">IDirectDrawMediaStream::GetFormat</A> method. The trick to watch on this call is that you must set the <B>dwSize</B> member of the <A HREF="../appendixes/Further_Reading.htm#DDSURFACEDESC">DDSURFACEDESC</A> structure. After the stream sample has retrieved the height and width of the movie file, you can set the rectangle that the off-screen surface will use to contain the video data.

<PRE>ddsd.dwSize = sizeof(ddsd);
hr = g_pDDStream-&gt;GetFormat(&amp;ddsd, NULL, NULL, NULL);
rect.top = rect.left = 0;            
rect.bottom = ddsd.dwHeight;
rect.right = ddsd.dwWidth;</PRE>
<LI>Create the stream sample by calling the <A HREF="../mms/IDirectDrawMediaStream.htm#CreateSample">IDirectDrawMediaStream::CreateSample</A> method with the off-screen surface and the <A HREF="../appendixes/Further_Reading.htm#RECT">RECT</A> structure, which was just initialized with the movie coordinates. This method will retrieve a pointer to the global <A HREF="../mms/IDirectDrawStreamSample.htm#IDirectDrawStreamSample">IDirectDrawStreamSample</A> interface <I>g_pSample</I>.

<PRE>hr = g_pDDStream-&gt;CreateSample(g_pDDSoff-screen, &amp;rect, 0, &amp;g_pSample);</PRE>
</OL>
<P>At this point, the <A HREF="../mms/IDirectDrawMediaStream.htm#CreateSample">IDirectDrawMediaStream::CreateSample</A> method has created a global <A HREF="../mms/IDirectDrawStreamSample.htm#IDirectDrawStreamSample">IDirectDrawStreamSample</A> stream sample and returned a pointer to <I>g_pSample</I>, its interface, which the <A HREF="Play_Movie_Window_Using_DDrawEx_MMS.htm#render_surf">RenderToSurface function</A> can use.

<h2><A NAME="render_surf"></A>Render the Multimedia Stream to the DirectDraw Surface</h2>
<P>The RenderToSurface function handles the actual rendering and blits the video stream's data to the primary surface. The main message pump in the <A HREF="Play_Movie_Window_Using_DDrawEx_MMS.htm#win_mainfunc"><B>WinMain</B> function</A> calls this method. The RenderToSurface function performs one individual frame update at a time and one blit from the off-screen surface to the primary surface. When the movie is complete, it will set the stream state to STOP.
<P>The following steps show how to do this.

<OL><LI>Declare the local variables.

<PRE>HRESULT        hr;
POINT        point;</PRE>
<LI>Call the <A HREF="../mms/IStreamSample.htm#Update">IStreamSample::Update</A> method. Each loop iteration throws out the previous video image and grabs the next image from the stream. 

<P>If the update is successful, the Microsoft Win32&reg; <A HREF="../appendixes/Further_Reading.htm#GetClientRect">GetClientRect</A> and the <A HREF="../appendixes/Further_Reading.htm#ClientToScreen">ClientToScreen</A> functions are called to get the rectangle coordinates of the window into which the video will be displayed. These functions must be called after each update, in case a user has moved or resized the window. 

<LI>After the window's coordinates have been retrieved, call the <A HREF="../appendixes/Further_Reading.htm#IDirectDrawSurface3_">IDirectDrawSurface3::Blt</A> method to perform a bit block transfer of the movie's video data from the off-screen surface to the primary surface. The loop breaks and the stream state is set to STOP when no renderable video data remains.

<PRE>if (g_pSample-&gt;Update(0, NULL, NULL, 0) != S_OK) {
        g_bAppactive = FALSE;
        g_pMMStream-&gt;SetState(STREAMSTATE_STOP);        
    }
    else {
    //get window coordinates to blit into
    GetClientRect(ghWnd, &amp;rect2);
    point.x = rect2.top;
    point.y = rect2.left;
    ClientToScreen(ghWnd, &amp;point);
    rect2.left = point.x;
    rect2.top = point.y;
    point.x = rect2.right;
    point.y = rect2.bottom;
    ClientToScreen(ghWnd, &amp;point);
    rect2.right = point.x;
    rect2.bottom= point.y;
    
//Blit from the off-screen surface to the primary surface
    hr = g_pPrimarySurface-&gt;Blt(&amp;rect2, g_pDDSoff-screen, &amp;rect, DDBLT_WAIT, NULL);</PRE>
<P>This function will be called repeatedly from the <A HREF="Play_Movie_Window_Using_DDrawEx_MMS.htm#win_mainfunc"><B>WinMain</B> function</A>'s message pump as long as the g_bAppactive and g_bFileLoaded Boolean values are TRUE.
</OL>
<h2><A NAME="exit_code"></A>Release Objects</h2>
<P>The ExitCode function releases all objects that the MovieWin application creates, destroys the window, and closes the COM library.

<P>Call this function if the application fails or the user quits the program.

<PRE>void ExitCode()
{
    //Release MultiMedia streaming Objects
    if (g_pMMStream != NULL) {
        g_pMMStream-&gt;Release();
        g_pMMStream= NULL;
    }
    if (g_pSample != NULL) {
        g_pSample-&gt;Release();   
        g_pSample = NULL;
    }
    if (g_pDDStream != NULL) {
        g_pDDStream-&gt;Release();
        g_pDDStream= NULL;
    }
    if (g_pPrimaryVidStream != NULL) {
        g_pPrimaryVidStream-&gt;Release();
        g_pPrimaryVidStream= NULL;
    }
    //Release DirectDraw Objects
    if (g_pDDF !=NULL) {
        g_pDDF-&gt;Release();
        g_pDDF = NULL;
    }
    if (g_pPrimarySurface!=NULL) {
        g_pPrimarySurface-&gt;Release();   
        g_pPrimarySurface=NULL;
    }
    if (g_pDDSoff-screen !=NULL) {
        g_pDDSoff-screen-&gt;Release();
        g_pDDSoff-screen= NULL;
    }
    if (g_pDDClipper !=NULL) {
        g_pDDClipper-&gt;Release();
        g_pDDClipper=NULL;
    }
    if (g_pDD3 != NULL) {
        g_pDD3-&gt;Release();
        g_pDD3 = NULL;
    }
    if (g_pDD != NULL) {
        g_pDD-&gt;Release(); 
        g_pDD = NULL;
    }
    
    PostQuitMessage(0);
    CoUninitialize();
}</PRE>
<h2><A NAME="moviewnd_proc"></A>WndMainProc Function</h2>
<P>The WndMainProc callback function handles any messages sent to the window and calls the <A HREF="Play_Movie_Window_Using_DDrawEx_MMS.htm#exit_code">ExitCode function</A> when the user quits the application. Users generate messages by selecting various items from the menu, including Open, Start, Stop, Pause, About, and Exit.

<P>If the user chooses Open, an IDM_OPEN message is generated and the following code runs.

<PRE>//If a file is already open - call STOP first
                    if (g_bAppactive &amp;&amp; g_bFileLoaded) {
                        g_pMMStream-&gt;SetState(STREAMSTATE_STOP);
                    }
                    
                    bOpen = GetOpenMovieFile(szFilename);
                    if (bOpen) {
                        hr = RenderFileToMMStream(szFilename);  
                        hr = InitRenderToSurface();
                        g_bAppactive = g_bFileLoaded = TRUE;
                        g_bPaused = FALSE;        //Take care of any old pauses
                        //Now set the multimedia stream to RUN
                        hr = g_pMMStream-&gt;SetState(STREAMSTATE_RUN);
                    }    
                    break;</PRE>
<P>This code first checks whether a file is loaded (g_bFileLoaded) and if it is in a running state (g_bAppactive). If this is the case, the <A HREF="../mms/IMultiMediaStream.htm#SetState">IMultiMediaStream::SetState</A> method is called to stop the stream before another one is loaded through a call to the <A HREF="Play_Movie_Window_Using_DDrawEx_MMS.htm#open_movie">GetOpenMovieFile function</A>. After the call to GetOpenMovieFile has returned successfully, the <A HREF="Play_Movie_Window_Using_DDrawEx_MMS.htm#file_to_stream">RenderFileToMMStream function</A> is called, followed by the <A HREF="Play_Movie_Window_Using_DDrawEx_MMS.htm#init_render_surf">InitRenderToSurface function</A>. If both of these functions are successful, the g_bFileLoaded and g_bAppactive Boolean values are set to TRUE and g_bPaused is set to FALSE in case the old file was in a paused state. Finally, the <B>IMultiMediaStream::SetState</B> method is called to set the state to RUN and now the <A HREF="Play_Movie_Window_Using_DDrawEx_MMS.htm#render_surf">RenderToSurface function</A> will automatically be called through the <A HREF="Play_Movie_Window_Using_DDrawEx_MMS.htm#win_mainfunc"><B>WinMain</B> function</A>'s message pump.

<P>If the user chooses Play from the application's menu, an IDM_START message is generated and the following code runs.

<PRE>if (g_bAppactive &amp;&amp; g_bFileLoaded)    
                    {break;                    // If its already playing get out of here
                    }
                    else {
                        if (g_bPaused) {    // If its in a paused state, seek and run
                            g_pMMStream-&gt;Seek(StreamTime);
                            g_pMMStream-&gt;SetState(STREAMSTATE_RUN);
                            g_bAppactive = TRUE;
                            g_bPaused = FALSE;
                            }
                        else {

                    if (g_bFileLoaded) {    // If a file is actually loaded
                        g_bAppactive = g_bFileLoaded = TRUE;
                        hr = g_pMMStream-&gt;SetState(STREAMSTATE_RUN);
                    }
                    else {
                        MessageBox(hWnd, "Please select a movie file first.", "Error", MB_OK);
                    }
                    }
                    }
                    break;</PRE>
<P>This code first checks if a file is loaded (g_bFileLoaded) and if it is in a running state (g_bAppactive). If this is the case, <B>break</B> is called to ignore the message. If the movie is in a paused state, the <A HREF="../mms/IMultiMediaStream.htm#Seek">IMultiMediaStream::Seek</A> method is called to seek to the correct location in the file, and then the <A HREF="../mms/IMultiMediaStream.htm#SetState">IMultiMediaStream::SetState</A> method is called to set the state to RUN again. The Boolean values g_bAppactive and g_bPaused are reset again to TRUE and FALSE respectively.

<P>If a file is loaded but not in a paused state, it must be in a stopped state. Therefore, if this code succeeds on the
if (g_bFileLoaded) call it must restart the movie from the beginning. This involves resetting the g_bAppactive Boolean value to TRUE and calling the <A HREF="../mms/IMultiMediaStream.htm#SetState">IMultiMediaStream::SetState</A> method to set the stream state to RUN.

<P>If the user chooses Pause from MovieWin's menu, an IDM_PAUSE message is generated and the following code runs.

<PRE>// Pause if not already in a paused state and you have a file loaded
                    if (!g_bPaused &amp;&amp;g_bFileLoaded) {    
                        hr = g_pMMStream-&gt;GetTime(&amp;StreamTime);
                        hr = g_pMMStream-&gt;SetState(STREAMSTATE_STOP);
                        g_bAppactive = FALSE;
                        g_bPaused    = TRUE;
                    }
                    break;                // If its already paused, just break</PRE>
<P>In order for the pause key to do anything, the application must not already be in a paused stated (!g_bPaused) and a file must be loaded (g_bFileLoaded). If these two conditions are both TRUE, the <A HREF="../mms/IMultiMediaStream.htm#GetTime">IMultiMediaStream::GetTime</A> method is called to store the <A HREF="../mms/Data_types_mms.htm#STREAM_TIME">STREAM_TIME</A> at which the application was paused in the static StreamTime variable, and then the <A HREF="../mms/IMultiMediaStream.htm#SetState">IMultiMediaStream::SetState</A> method set the stream state to STOP. Finally, the g_bAppactive and the g_bPaused global Boolean values must be set to FALSE and TRUE respectively.

<P>If a file is loaded (g_bFileLoaded) and the user chooses Stop from the application's menu, an IDM_STOP message is generated and the following code executes.

<PRE>if (g_bFileLoaded) {
                        g_pMMStream-&gt;SetState(STREAMSTATE_STOP);
                        StreamTime = 0;    // Reset the stream time to 0
                        g_pMMStream-&gt;Seek(StreamTime);    // Run one frame to reset video
                        g_pMMStream-&gt;SetState(STREAMSTATE_RUN);
                        RenderToSurface();
                        g_pMMStream-&gt;SetState(STREAMSTATE_STOP); // Stop for real this time
                        StreamTime = 0;
                    }
                    g_bAppactive = FALSE;</PRE>

<P>In such a case, the <A HREF="../mms/IMultiMediaStream.htm#SetState">IMultiMediaStream::SetState</A> method sets the stream state to STOP and the global <A HREF="../mms/Data_types_mms.htm#STREAM_TIME">STREAM_TIME</A> value is set to zero.

 Next, the <A HREF="../mms/IMultiMediaStream.htm#Seek">IMultiMediaStream::Seek</A> method and the <B>IMultiMediaStream::SetState</B> method are called to run one frame of the video before the true stop is called. After the <A HREF="Play_Movie_Window_Using_DDrawEx_MMS.htm#render_surf">RenderToSurface function</A> renders the frame, the <B>IMultiMediaStream::SetState</B> method is called a final time to stop the video. This gives the user the visual experience of seeing the movie rewind to the beginning.

<P>Finally, if the user chooses <B>Exit</B> from the application's menu, an IDM_EXIT message is generated and the following code runs.

<PRE>response = MessageBox(hWnd, "Quit the Program?", "Quit", MB_YESNO);
                    if (response==IDYES) SendMessage(ghWnd, WM_DESTROY,0,0);
                    break;</PRE>
<P>When it runs, this code will prompt the user if he or she really wants to quit the application. If the user chooses Yes, a WM_DESTROY message is sent, which calls the <A HREF="Play_Movie_Window_Using_DDrawEx_MMS.htm#exit_code">ExitCode function</A>.

<h2><A NAME="entire_code"></A>Entire MovieWin Example Code</h2>
<P>This is the entire code for the MovieWin example code. To compile this code in Microsoft Visual Studio&#153;, create a new Win32 application project and add this code into the project. Follow the directions in the following code comments on how to set your project libraries and include paths.

<PRE>// This application uses a Multimedia stream to render
// a video file to a DirectDrawEx surface contained in 
// a window. It implements a primary DirectDraw surface 
// and an off-screen DirectDraw surface to optimize individual 
// frame blits. It also attaches a DirectDraw clipper to the 
// window to process window overlapping.


//To compile this program you must have DXMedia SDK 5.1 installed 
//and you will need set your include path under tools/options/directories/include
//to c:\DXMedia\include and your library path to c:\DXMedia\lib
//Also link with the following libraries under project/settings/link...
//amstrmid.lib quartz.lib strmbase.lib ddraw.lib 

#include &lt;windows.h&gt;
#include &lt;mmstream.h&gt;    // Multimedia stream interfaces
#include &lt;amstream.h&gt;    // DirectShow multimedia stream interfaces
#include &lt;ddstream.h&gt;    // DirectDraw multimedia stream interfaces
#include &lt;initguid.h&gt;   // Defines DEFINE_GUID macro and enables GUID initialization
#include &lt;ddrawex.h&gt;    // DirectDrawEx interfaces
#include "resource.h"    // Resources for the menu bar

#define APPLICATIONNAME "Multimedia Stream In Window"
#define CLASSNAME "MMSDDRAWEXWINDOW"


//Global variables
HWND              ghWnd;
HINSTANCE        ghInst;
BOOL              g_bAppactive=FALSE,        // The window is active
                    g_bFileLoaded = FALSE,  // There is a file loaded
                    g_bPaused=FALSE;        // The movie has been paused
RECT              rect, rect2;            // Rectangles for screen coordinates

//DirectDrawEx Global interfaces
IDirectDraw            *g_pDD=NULL;   
IDirectDraw3        *g_pDD3=NULL; 
IDirectDrawFactory    *g_pDDF=NULL;
IDirectDrawSurface    *g_pPrimarySurface=NULL,
                    *g_pDDSoff-screen=NULL;
IDirectDrawClipper    *g_pDDClipper=NULL;

//Global MultiMedia streaming interfaces
IMultiMediaStream        *g_pMMStream=NULL;
IMediaStream            *g_pPrimaryVidStream=NULL;    
IDirectDrawMediaStream    *g_pDDStream=NULL;
IDirectDrawStreamSample *g_pSample=NULL;

//Function prototypes
int PASCAL WinMain(HINSTANCE hInstC, HINSTANCE hInstP, LPSTR lpCmdLine, int nCmdShow);
LRESULT CALLBACK WndMainProc (HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam);
HRESULT InitDDrawEx();
BOOL GetOpenMovieFile(LPSTR szName);
HRESULT RenderFileToMMStream(LPCTSTR szFilename);    
HRESULT InitRenderToSurface();
void RenderToSurface();
void ExitCode();


void ExitCode()
{
    //Release MultiMedia streaming Objects
    if (g_pMMStream != NULL) {
        g_pMMStream-&gt;Release();
        g_pMMStream= NULL;
    }
    if (g_pSample != NULL) {
        g_pSample-&gt;Release();   
        g_pSample = NULL;
    }
    if (g_pDDStream != NULL) {
        g_pDDStream-&gt;Release();
        g_pDDStream= NULL;
    }
    if (g_pPrimaryVidStream != NULL) {
        g_pPrimaryVidStream-&gt;Release();
        g_pPrimaryVidStream= NULL;
    }
    //Release DirectDraw Objects
    if (g_pDDF !=NULL) {
        g_pDDF-&gt;Release();
        g_pDDF = NULL;
    }
    if (g_pPrimarySurface!=NULL) {
        g_pPrimarySurface-&gt;Release();   
        g_pPrimarySurface=NULL;
    }
    if (g_pDDSoff-screen !=NULL) {
        g_pDDSoff-screen-&gt;Release();
        g_pDDSoff-screen= NULL;
    }
    if (g_pDDClipper !=NULL) {
        g_pDDClipper-&gt;Release();
        g_pDDClipper=NULL;
    }
    if (g_pDD3 != NULL) {
        g_pDD3-&gt;Release();
        g_pDD3 = NULL;
    }
    if (g_pDD != NULL) {
        g_pDD-&gt;Release(); 
        g_pDD = NULL;
    }
    
    PostQuitMessage(0);
    CoUninitialize();
}

//Create the stream sample which will be used to call updates on the video
HRESULT InitRenderToSurface()
{    
    HRESULT            hr;
    DDSURFACEDESC    ddsd;
    
    //Use the multimedia stream to get the primary video media stream
    hr = g_pMMStream-&gt;GetMediaStream(MSPID_PrimaryVideo, &amp;g_pPrimaryVidStream);
    if (FAILED(hr))
    {   goto Exit;
    }
    //Use the media stream to get the IDirectDrawMediaStream
    hr = g_pPrimaryVidStream-&gt;QueryInterface(IID_IDirectDrawMediaStream, (void **)&amp;g_pDDStream);
    if (FAILED(hr))
    {   goto Exit;
    }
    //Must set dwSize before calling GetFormat
    ddsd.dwSize = sizeof(ddsd);
    hr = g_pDDStream-&gt;GetFormat(&amp;ddsd, NULL, NULL, NULL);
    if (FAILED(hr))
    {   goto Exit;
    }

      rect.top = rect.left = 0;            
    rect.bottom = ddsd.dwHeight;
    rect.right = ddsd.dwWidth;

    //Create the stream sample
    hr = g_pDDStream-&gt;CreateSample(g_pDDSoff-screen, &amp;rect, 0, &amp;g_pSample);
    if (FAILED(hr))
    {   goto Exit;
    }
Exit:
    if (FAILED(hr)) 
    {    MessageBox(ghWnd, "Initialization failure in InitRenderToSurface", "Error", MB_OK);
        return E_FAIL;
    }
    return NOERROR;
}

//Perform frame by frame updates and blits. Set the stream 
//state to STOP if there are no more frames to update.
void RenderToSurface()
{
    HRESULT        hr;
    POINT        point;
                           
    //update each frame
    if (g_pSample-&gt;Update(0, NULL, NULL, 0) != S_OK) {
        g_bAppactive = FALSE;
        g_pMMStream-&gt;SetState(STREAMSTATE_STOP);        
    }
    else {
    //get window coordinates to blit into
    GetClientRect(ghWnd, &amp;rect2);
    point.x = rect2.top;
    point.y = rect2.left;
    ClientToScreen(ghWnd, &amp;point);
    rect2.left = point.x;
    rect2.top = point.y;
    point.x = rect2.right;
    point.y = rect2.bottom;
    ClientToScreen(ghWnd, &amp;point);
    rect2.right = point.x;
    rect2.bottom= point.y;
    
    //blit from the off-screen surface to the primary surface
    hr = g_pPrimarySurface-&gt;Blt(&amp;rect2, g_pDDSoff-screen, &amp;rect, DDBLT_WAIT, NULL); 
    if(FAILED(hr))
    {   MessageBox(ghWnd, "Blt failed", "Error", MB_OK);
            ExitCode();
    }
    }    
}

//Renders a file to a multimedia stream
HRESULT RenderFileToMMStream(LPCTSTR szFilename)        //IMultiMediaStream **ppMMStream
{    
    HRESULT hr;
    IAMMultiMediaStream *pAMStream=NULL;

//Convert filename to Unicode
    WCHAR wFile[MAX_PATH];
    MultiByteToWideChar(CP_ACP, 0, szFilename, -1, wFile,    
                                sizeof(wFile)/sizeof(wFile[0]));

    //Create the AMMultiMediaStream object
    hr =CoCreateInstance(CLSID_AMMultiMediaStream, NULL, CLSCTX_INPROC_SERVER,
                                      IID_IAMMultiMediaStream, (void **)&amp;pAMStream);
    if (FAILED(hr))
    {   MessageBox(ghWnd, "Could not create a CLSID_MultiMediaStream object\n"
        "Check you have run regsvr32 amstream.dll\n", "Error", MB_OK);
          return E_FAIL;
    }

    //Initialize stream
    hr = pAMStream-&gt;Initialize(STREAMTYPE_READ, 0, NULL);
    if (FAILED(hr))
    {   MessageBox(ghWnd, "Initialize failed.", "Error", MB_OK);
          return E_FAIL;
    }
    //Add primary video stream
    hr = pAMStream-&gt;AddMediaStream(g_pDD3, &amp;MSPID_PrimaryVideo, 0, NULL);
    if (FAILED(hr))
    {   MessageBox(ghWnd, "AddMediaStream failed.", "Error", MB_OK);
          return E_FAIL;
    }
    //Add primary audio stream
    hr = pAMStream-&gt;AddMediaStream(NULL, &amp;MSPID_PrimaryAudio, AMMSF_ADDDEFAULTRENDERER, NULL);
    if (FAILED(hr))
    {   MessageBox(ghWnd, "AddMediaStream failed.", "Error", MB_OK);
          return E_FAIL;
    }
    //Opens and automatically creates a filter graph for the specified media file
    hr = pAMStream-&gt;OpenFile(wFile, 0); 
    if (FAILED(hr))
    {   MessageBox(ghWnd, "File format not supported.", "Error", MB_OK);
          return E_FAIL;
    }

    //save the local stream to the global variable
    g_pMMStream = pAMStream;    
    // Add a reference to the file
    pAMStream-&gt;AddRef();

    return NOERROR;
}

HRESULT InitDDrawEx()
{    
    HRESULT            hr=NOERROR;
    DDSURFACEDESC    ddsd, ddsd2;

    CoInitialize(NULL);
    
    //Create a DirectDrawFactory object
    hr = CoCreateInstance(CLSID_DirectDrawFactory, NULL, CLSCTX_INPROC_SERVER, 
                            IID_IDirectDrawFactory, (void **)&amp;g_pDDF);
    if (FAILED(hr))
    {   MessageBox(ghWnd, "Couldn't create DirectDrawFactory", "Error", MB_OK);
          return E_FAIL;
    }


    //Call the IDirectDrawFactory::CreateDirectDraw method to create the 
    //DirectDraw object, set the cooperative level, and get the address 
    //of an IDirectDraw interface pointer
    hr = (g_pDDF-&gt;CreateDirectDraw(NULL, GetDesktopWindow(), DDSCL_NORMAL, 
                NULL, NULL, &amp;g_pDD));   

    if (FAILED(hr))
    {   MessageBox(ghWnd, "Couldn't create DirectDraw object", "Error", MB_OK);
          return E_FAIL;
    }
    
    //Now query for the new IDirectDraw3 interface
    hr =(g_pDD-&gt;QueryInterface(IID_IDirectDraw3, (LPVOID*)&amp;g_pDD3));
    
    if (FAILED(hr))
    {   MessageBox(ghWnd, "Couldn't get IDirectDraw3", "Error", MB_OK);
          return E_FAIL;
    }

    //Initialize the DDSURFACEDESC structure for the primary surface
      ZeroMemory(&amp;ddsd, sizeof(ddsd));
    ddsd.dwSize = sizeof(ddsd);    
      ddsd.dwFlags = DDSD_CAPS;
    ddsd.ddsCaps.dwCaps = DDSCAPS_PRIMARYSURFACE; 
    hr = g_pDD3-&gt;CreateSurface(&amp;ddsd, &amp;g_pPrimarySurface, NULL);
    
    if(FAILED(hr))
    {   MessageBox(ghWnd, "Couldn't create Primary Surface", "Error", MB_OK);
          return E_FAIL;
    }


    // Now, do the same for the off-screen surface.

    // The off-screen surface needs to use the same pixel format as the primary.
    // Query the primary surface to for its pixel format.
    hr = g_pPrimarySurface-&gt;GetSurfaceDesc(&amp;ddsd);
    if(FAILED(hr))
    {   MessageBox(ghWnd, "Couldn't GetSurfaceDesc", "Error", MB_OK);
            return E_FAIL;
    }

    // Now, set the info for the off-screen surface, using the primary's pixel format.
    ZeroMemory(&amp;ddsd2, sizeof(ddsd2));
    ddsd2.dwSize = sizeof(ddsd2);    
    ddsd2.dwFlags = DDSD_CAPS | DDSD_HEIGHT | DDSD_WIDTH | DDSD_PIXELFORMAT;
    ddsd2.ddsCaps.dwCaps = DDSCAPS_off-screenPLAIN;
    ddsd2.dwHeight = ddsd.dwHeight;    //set the height of the surfaces equal
    ddsd2.dwWidth  = ddsd.dwWidth;    //set the width of the surfaces equal
    ddsd2.ddpfPixelFormat = ddsd.ddpfPixelFormat; //set the pixel formats equal


    // Now, create the off-screen surface and query for the latest interface.
    hr = g_pDD3-&gt;CreateSurface(&amp;ddsd2, &amp;g_pDDSoff-screen, NULL);
    if(FAILED(hr))
    {   MessageBox(ghWnd, "Couldn't create off-screen Surface", "Error", MB_OK);
            return E_FAIL;
    }


    //Add code for Clipper
    hr = g_pDD3-&gt;CreateClipper(0, &amp;g_pDDClipper, NULL);
    if(FAILED(hr))
    {   MessageBox(ghWnd, "Couldn't create Clipper", "Error", MB_OK);
            return E_FAIL;
    }
    
    hr = g_pPrimarySurface-&gt;SetClipper(g_pDDClipper);
    if(FAILED(hr))
    {   MessageBox(ghWnd, "Call to SetClipper failed", "Error", MB_OK);
            return E_FAIL;
    }

    hr = g_pDDClipper-&gt;SetHWnd(0, ghWnd);
    if(FAILED(hr))
    {   MessageBox(ghWnd, "Call to SetHWnd failed", "Error", MB_OK);
            return E_FAIL;
    }

    return NOERROR;    
}

// Display the open dialog box to retrieve the user-selected movie file
BOOL GetOpenMovieFile(LPSTR szName)//LPSTR szName
{
    OPENFILENAME    ofn;
    
    ofn.lStructSize       = sizeof(OPENFILENAME);
    ofn.hwndOwner         = ghWnd;
    ofn.lpstrFilter       = NULL;
    ofn.lpstrFilter       = "Video (*.avi;*.mpg;*.mpeg)\0*.avi;*.mpg;*.mpeg\0All Files (*.*)\0*.*\0";
    ofn.lpstrCustomFilter = NULL;
    ofn.nFilterIndex      = 1;
    *szName = 0;
    ofn.lpstrFile         = szName;
    ofn.nMaxFile          = MAX_PATH;
    ofn.lpstrInitialDir   = NULL;
    ofn.lpstrTitle        = NULL;
    ofn.lpstrFileTitle    = NULL;
    ofn.lpstrDefExt       = NULL;
    ofn.Flags             = OFN_FILEMUSTEXIST | OFN_READONLY | OFN_PATHMUSTEXIST;
    return GetOpenFileName((LPOPENFILENAME)&amp;ofn);
}

LRESULT CALLBACK WndMainProc (HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)

   {  // WndMainProc //

    int                        response;
    HRESULT                    hr;
    BOOL                    bOpen;
    static TCHAR            szFilename[MAX_PATH];
    static STREAM_TIME        StreamTime;        // Stream time of the movie file
        
    switch(message)
    {
        case WM_COMMAND:
            {
               switch(wParam)
               //Program menu option
               {
                case IDM_OPEN:
                    //If a file is already open - call STOP first
                    if (g_bAppactive &amp;&amp; g_bFileLoaded) {
                        g_pMMStream-&gt;SetState(STREAMSTATE_STOP);
                    }
                    
                    bOpen = GetOpenMovieFile(szFilename);
                    if (bOpen) {
                        hr = RenderFileToMMStream(szFilename);  
                        if (FAILED(hr)) {
                            ExitCode();
                            break;
                            }
                        hr = InitRenderToSurface();
                        if (FAILED(hr)) {
                            ExitCode();
                            break;
                            }
                        g_bAppactive = g_bFileLoaded = TRUE;
                        g_bPaused = FALSE;        //Take care of any old pauses
                        //Now set the multimedia stream to RUN
                        hr = g_pMMStream-&gt;SetState(STREAMSTATE_RUN);
                        if (FAILED(hr))
                        {   ExitCode();
                        }
                    }    
                    break;

                case IDM_START:
                    if (g_bAppactive &amp;&amp; g_bFileLoaded)    
                    {break;                    // If its already playing get out of here
                    }
                    else {
                        if (g_bPaused) {    // If its in a paused state, seek and run
                            g_pMMStream-&gt;Seek(StreamTime);
                            g_pMMStream-&gt;SetState(STREAMSTATE_RUN);
                            g_bAppactive = TRUE;
                            g_bPaused = FALSE;
                            }
                        else {

                    if (g_bFileLoaded) {    // If a file is actually loaded
                        hr = RenderFileToMMStream(szFilename);    // Render file to stream
                        if (FAILED(hr)) {
                            ExitCode();
                            break;
                            }
                        hr = InitRenderToSurface();        // Render stream
                        if (FAILED(hr)) {
                            ExitCode();
                            break;
                            }
                        g_bAppactive = g_bFileLoaded = TRUE;
                        //Now set the multimedia stream to RUN
                        hr = g_pMMStream-&gt;SetState(STREAMSTATE_RUN);
                        if (FAILED(hr))
                        {   ExitCode();
                        }
                    }
                    else {
                        MessageBox(hWnd, "Please select a movie file first.", "Error", MB_OK);
                    }
                    }
                    }
                    break;
                    
                case IDM_PAUSE:
                    // Pause if not already in a paused state and you have a file loaded
                    if (!g_bPaused &amp;&amp;g_bFileLoaded) {    
                        hr = g_pMMStream-&gt;GetTime(&amp;StreamTime);
                        hr = g_pMMStream-&gt;SetState(STREAMSTATE_STOP);
                        g_bAppactive = FALSE;
                        g_bPaused    = TRUE;
                    }
                    break;                // If its already paused, just break

                case IDM_STOP:
                    if (g_bFileLoaded) {
                        g_pMMStream-&gt;SetState(STREAMSTATE_STOP);
                        StreamTime = 0;    // Reset the stream time to 0
                        g_pMMStream-&gt;Seek(StreamTime);    //Run one frame to reset video
                        g_pMMStream-&gt;SetState(STREAMSTATE_RUN);
                        RenderToSurface();
                        g_pMMStream-&gt;SetState(STREAMSTATE_STOP); // Stop for real this time
                        StreamTime = 0;
                    }
                    g_bAppactive = FALSE;
                    break;

                case IDM_ABOUT:
                    MessageBox(hWnd, "This application uses multimedia streaming to"
                        " render a video file to a DirectDraw surface created through DirectDrawEx.",
                        "About", MB_OK);
                    break;
            
                case IDM_EXIT:
                    response = MessageBox(hWnd, "Quit the Program?", "Quit", MB_YESNO);
                    if (response==IDYES) SendMessage(ghWnd, WM_DESTROY,0,0);
                    break;
            }
           break;
            }
        break;
            
        case WM_DESTROY:
           ExitCode();
           break;

        case WM_ACTIVATE:
            if((BOOL)LOWORD(wParam) == WA_INACTIVE)
            {
                //App is not active
                g_bAppactive = FALSE;    
            }
            else
            {
                //Set application to active if a file is loaded
                g_bAppactive = (g_bFileLoaded)?TRUE:FALSE;    
            }
            break;
    
        default:
           return DefWindowProc(hWnd, message, wParam, lParam);
    
      }  // Window messages handling

      return FALSE;

   }  // WndMainProc //

int PASCAL WinMain(HINSTANCE hInstC, HINSTANCE hInstP, LPSTR lpCmdLine, int nCmdShow)

   {  // WinMain //
    
      MSG        msg;
      WNDCLASS  wc;
        HRESULT    hr;

      ZeroMemory(&amp;wc, sizeof wc);
      wc.lpfnWndProc = WndMainProc;
      ghInst = wc.hInstance = hInstC;
        wc.hbrBackground = (HBRUSH)GetStockObject(BLACK_BRUSH);
      wc.lpszClassName = CLASSNAME;
      wc.lpszMenuName = MAKEINTRESOURCE(IDR_MENU);
      wc.hCursor = LoadCursor(NULL, IDC_ARROW);
      RegisterClass(&amp;wc);

      ghWnd = CreateWindowEx(WS_EX_WINDOWEDGE,
        CLASSNAME,
        APPLICATIONNAME,
        WS_VISIBLE |WS_POPUP |WS_OVERLAPPEDWINDOW,
        150,    
        150,
        280,
        250,
        0,
        0,
        ghInst,
        0);
      if (ghWnd) {                // If the call to create window succeeds,
          hr = InitDDrawEx();    // initialize DirectDrawEx
          if (FAILED(hr)) {
              ExitCode();
          }
      }
      else {
          MessageBox(ghWnd, "Couldn't create window.", "Error", MB_OK);
          return 0;
      }



      ShowWindow(ghWnd, SW_NORMAL);   
      UpdateWindow(ghWnd);

      while(1){
        //The PeekMessage function checks a thread message queue 
        //for a message and places the message (if any) in the specified structure. 
        if(PeekMessage(&amp;msg, NULL, 0,0,PM_NOREMOVE)){
            
            // Quit if WM_QUIT found
            if(!GetMessage(&amp;msg,NULL, 0, 0)) return (msg.wParam);

            // Otherwise handle the messages
                TranslateMessage(&amp;msg);        // Allow input
                DispatchMessage(&amp;msg);        // Send to appropriate process.
        }
        else{
            // If there are no other windows messages...
            // Render frame by frame (but only if the application is the active
            // window and a file is actually loaded)
            if (g_bFileLoaded &amp;&amp; g_bAppactive) {    
                RenderToSurface();    
                }
            }
        }
      return msg.wParam;

      

}  // WinMain //
</PRE>

<!-- CONTENTS_END -->

<!-- START_PAGE_FOOTER -->


<H6><HR size=1></H6>
<P><A Class="line" HREF="#pagetop"><IMG src="../art/arrowup1.gif" WIDTH="11" HEIGHT="11" ALIGN="MIDDLE" BORDER=0 ALT="Top of Page">&nbsp;Top of Page</A>
<BR><A HREF="../../cpyright.htm">&#169; 1998 Microsoft Corporation. All rights reserved. Terms of Use.</A>
<!-- END_PAGE_FOOTER -->

</BLOCKQUOTE>

<SCRIPT>if((g_isIE == true) && (g_iMaj > 3)) {window.self.document.writeln('<SCR' + 'IPT SRC="../tip2.js"></SCR' + 'IPT><IFRAME ID="G_L_S" NAME="SecretBuffer" STYLE="display: none" SRC=""></IFRAME>')}</SCRIPT>

<!-- DACONTROL_START -->

	<DIV ID="HeadGraphAnim"></DIV>
	<SCRIPT>if((g_isIE == true) && (g_iMaj > 3)) {window.self.document.writeln('<SCR' + 'IPT SRC="../anim.js"></SCR' + 'IPT>')}</SCRIPT>
<!-- DACONTROL_END -->

</BODY>
</HTML>
