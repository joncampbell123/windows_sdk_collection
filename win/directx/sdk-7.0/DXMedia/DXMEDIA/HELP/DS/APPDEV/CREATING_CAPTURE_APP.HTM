<!-- DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN" -->

<HTML>
<HEAD><TITLE>Creating a Capture Application</TITLE>
<SCRIPT> var sRelPath = '../' </SCRIPT>


<META NAME="DESCRIPTION" CONTENT="Creating a Capture Application">
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; CHARSET=iso8859-1">
<META NAME="MS.LOCALE" CONTENT="EN-US">
<META NAME="ROBOTS" CONTENT="all">



<SCRIPT>
//<!--
var g_isIE = false, g_isNav = false, g_iMaj = 0, g_sPlat = "";
// -->

</SCRIPT>
<SCRIPT SRC="../ver.js"></SCRIPT>
<SCRIPT SRC="../gloss.js"></SCRIPT>

<!-- SNIFF_END -->


<SCRIPT DEFER SRC="../common.js"></SCRIPT>
<SCRIPT DEFER>
//<!--
function InitPage()
{
	if (g_isIE && g_iMaj >= 4)	
	{

		SetTOC();
	}
}
//-->

</SCRIPT>

<!-- SNIFF_END -->


<!-- STYLE_START -->

<SCRIPT>
//<!--
   var sVR = '../'	// Set root for the style sheet
   var sCSS = '<LINK REL="stylesheet" HREF="' + sVR;

   if(g_isIE)
   {
	   if (g_iMaj >= 4) // For MSIE 4.0 or later
	   {
		   sCSS += 'dxm_basicsdkIE4';
		   if (g_sPlat == "Win") // Windows only for now
		   {
			   document.createStyleSheet(sVR + 'dxm_advSDKIE4.css');
		   }
	   }
	   else // For MSIE 3.0 or earlier
	   {
		   sCSS += 'dxm_basicsdkIE3';
	   }
   }
   else if (g_isNav) // For all Nav versions
   {
	   sCSS += 'dxm_basicsdkNAV';
   }
   else
   {
	   sCSS += 'dxm_basicsdkIE3'; // default to IE3 sheet
   }

   sCSS += (sCSS == '' ? '' : '.css" TYPE="text/css">');

   document.write(sCSS);
//-->

</SCRIPT>
<!-- STYLE_END -->


</HEAD>
<BODY onload="InitPage(); if (g_isIE && g_iMaj >= 4){HdgrphControl()}" BGCOLOR="#FFFFFF">
<A NAME="pagetop"></A><A NAME="Creating_a_Capture_Application"></A>

<!-- HEADGRAPH_START -->

<TABLE CLASS="main" BORDER=0 CELLSPACING="0" CELLPADDING="0" WIDTH="*">
<TR>
<TD ROWSPAN="3" VALIGN="TOP" WIDTH="*">
<IMG SRC="../art/header1.gif" WIDTH="107" HEIGHT="110" BORDER=0 ALT="DirectShow Animated Header -- Creating a Capture Application"></TD>
<TD ROWSPAN="2" VALIGN="TOP" WIDTH="217"><IMG SRC="../art/hdrdshow.gif" WIDTH="217" HEIGHT="110" BORDER=0 ALT="DirectShow Animated Header -- Creating a Capture Application"></TD>
<TD VALIGN="TOP" WIDTH="383">
<IMG SRC="../art/header3.gif" WIDTH="383" HEIGHT="95" BORDER=0 ALT="DirectShow Animated Header">
</TD>
<TD VALIGN="TOP" WIDTH="100%">
<IMG SRC="../art/spacer1.gif" WIDTH="100%" HEIGHT="94" BORDER=0 ALT="Microsoft DirectShow SDK">
</TD>
</TR>
<!-- HEADGRAPH_END -->

<!-- NAV_LINKS_START -->

<TR><TD VALIGN="TOP"><PRE><IMG ID="TOC_" SRC="../art/yelbtn.gif" WIDTH="11" HEIGHT="11" ALIGN="MIDDLE" BORDER=0 ALT="*"><A STYLE="color:black;font-weight:bold" ID="TOC" HREF="../contents.htm">Contents</A>  <IMG SRC="../art/yelbtn.gif" WIDTH="11" HEIGHT="11" ALIGN="MIDDLE" BORDER=0 ALT="*"><A STYLE="color:black;font-weight:bold" HREF="../index.htm">Index</A>  <IMG SRC="../art/yelbtn.gif" WIDTH="11" HEIGHT="11" ALIGN="MIDDLE" BORDER=0 ALT="*"><A STYLE="color:black;font-weight:bold" HREF="AppDev_intro.htm">Topic Contents</A>
</PRE></TD></TR>
<TR><TD COLSPAN="2" VALIGN="TOP"><PRE><IMG SRC="../art/yelbtn.gif" WIDTH="11" HEIGHT="11" ALIGN="MIDDLE" BORDER=0 ALT="*"><B>Previous Topic:</B> <A STYLE="color:black" HREF="Controlling_Filter_Graphs_Using_C.htm">Controlling Filter Graphs Using C</A>
<IMG SRC="../art/yelbtn.gif" WIDTH="11" HEIGHT="11" ALIGN="MIDDLE" BORDER=0 ALT="*"><B>Next Topic:</B> <A STYLE="color:black" HREF="Filter_Categories.htm">Filter Categories</A>
</PRE></TD></TR></TABLE>
<!-- NAV_LINKS_END -->


<BLOCKQUOTE CLASS="body">


<!-- CONTENTS_START -->

<H1>Creating a Capture Application</H1>

<P>Microsoft&#174; DirectShow&#153; provides the capability to capture and preview both video and audio data from an application, when combined with the appropriate capture hardware. The data source might include a VCR, camera, TV tuner, microphone, or other source. An application can display the captured data immediately (preview) or save it to a file for later viewing either inside or outside of the application. 

<P>DirectShow takes advantage of new capture drivers that are written as DirectShow <A CLASS="Glossary" HREF="javascript:Glossary(sRelPath + 'gloss/gloss_f.htm#filter')">filters</A>, and also uses existing Video for Windows-style drivers.

<P><B>Note</B>  This article relies heavily on the <A HREF="../filtsamp/C_C++_Samp_Apps.htm#AMCap">AMCap Sample (DirectShow Capture Application)</A> sample application. See the AMCap sample code (Amcap.cpp) in the Samples\Multimedia\DShow\src\Capture directory of the DirectX Media SDK for complete sample code, because this article does not present <A HREF="../filtsamp/C_C++_Samp_Apps.htm#AMCap">AMCap Sample (DirectShow Capture Application)</A> in its entirety. 
<P>The <A HREF="../filtsamp/C_C++_Samp_Apps.htm#AMCap">AMCap Sample (DirectShow Capture Application)</A> sample application performs video and audio capture, similar to the VidCap sample from Video for Windows&#174;. It uses the <A HREF="../ref/iface/ICaptureGraphBuilder.htm#ICaptureGraphBuilder">ICaptureGraphBuilder</A> interface to handle the majority of the capture work. In your own capture application, you'll use the same methods and interfaces that AMCap uses. This article focuses on AMCap's use of <B>ICaptureGraphBuilder</B> to perform video and audio capture and presents relevant code excerpts from AMCap. 

<P>This article assumes you are familiar with the DirectShow <A CLASS="Glossary" HREF="javascript:Glossary(sRelPath + 'gloss/gloss_F.htm#filter_graph')">filter graph</A> architecture and the general layout of a capture filter graph. See <A HREF="../oview/Filter_Graph_Manager.htm">Filter Graph Manager and Filter Graphs</A> and <A HREF="../oview/About_Capture_Filt_Graphs.htm">About Capture Filter Graphs</A> for more information.

<P>This article contains the following sections:
<UL><LI><A HREF="Creating_Capture_App.htm#Introduction_to_ICaptureGraphBuilder">Introduction to ICaptureGraphBuilder</A>
<LI><A HREF="Creating_Capture_App.htm#Device_Enumeration_and_Capture_Interfaces">Device Enumeration and Capture Interfaces</A> 
<LI><A HREF="Creating_Capture_App.htm#Building_the_capture_and_preview_filter_graph">Building the Capture and Preview Filter Graph</A>
<LI><A HREF="Creating_Capture_App.htm#Controlling_the_capture_filter_graph">Controlling the Capture Filter Graph</A>
<LI><A HREF="Creating_Capture_App.htm#Obtaining_capture_statistics">Obtaining Capture Statistics</A>
<LI><A HREF="Creating_Capture_App.htm#Saving_the_captured_file">Saving the Captured File</A>
<LI><A HREF="Creating_Capture_App.htm#Display_prop_pages">Displaying Property Pages</A>
<LI><A HREF="Creating_Capture_App.htm#Additional_Notes">Additional Notes</A>
</UL>
<h2><A NAME="Introduction_to_ICaptureGraphBuilder" IDX_CONCEPT="noindex; ICaptureGraphBuilder, article on using"></A>Introduction to ICaptureGraphBuilder</h2>
<P>The <A HREF="../ref/iface/ICaptureGraphBuilder.htm#ICaptureGraphBuilder">ICaptureGraphBuilder</A> interface provides a filter graph builder object that applications use to handle some of the more tedious tasks involved in building a capture filter graph, which frees the application to focus on capture. You access the graph builder object by calling methods on <B>ICaptureGraphBuilder</B>. The variety of methods satisfies the basic requirements for capture and preview functionality. 

<P>The <A HREF="../ref/iface/ICaptureGraphBuilder.htm#FindInterface">FindInterface</A> method searches for a particular capture-related interface in the filter graph. The method handles the complexities of filter graph traversal for you, which enables you to access the functionality of a particular interface without having to enumerate pins and filters in the filter graph looking for the interface. The <A HREF="../ref/iface/ICaptureGraphBuilder.htm#RenderStream">RenderStream</A> method connects <A CLASS="Glossary" HREF="javascript:Glossary(sRelPath + 'gloss/gloss_S.htm#source_filter')">source filters</A> to rendering filters, optionally adding other needed intermediate filters. The 
<A HREF="../ref/iface/ICaptureGraphBuilder.htm#ControlStream">ControlStream</A> method independently control sections of the graph for frame-accurate start and stop. 

<P>Additional methods deal with allocating space for the capture file (<A HREF="../ref/iface/ICaptureGraphBuilder.htm#AllocCapFile">AllocCapFile</A>), specifying a name for it and building up the <I>file writer</I> section of the graph, which consists of the multiplexer and file writer filters (<A HREF="../ref/iface/ICaptureGraphBuilder.htm#SetOutputFileName">SetOutputFileName</A>), and saving the captured data to another file (<A HREF="../ref/iface/ICaptureGraphBuilder.htm#CopyCaptureFile">CopyCaptureFile</A>). Finally, <A HREF="../ref/iface/ICaptureGraphBuilder.htm#SetFiltergraph">SetFiltergraph</A> and <A HREF="../ref/iface/ICaptureGraphBuilder.htm#GetFiltergraph">GetFiltergraph</A> enable the application to provide a filter graph for the graph builder to use or retrieve the filter graph already in use.

<h2><A NAME="Device_Enumeration_and_Capture_Interfaces"></A>Device Enumeration and Capture Interfaces</h2>
<P>AMCap's InitCapFilters function enumerates the capture devices on the system by using the <A HREF="../ref/iface/ICreateDevEnum.htm#CreateClassEnumerator">ICreateDevEnum::CreateClassEnumerator</A> method. After enumerating a capture device and instantiating a DirectShow filter to use that device, the sample calls the <A HREF="../ref/iface/ICaptureGraphBuilder.htm#FindInterface">ICaptureGraphBuilder::FindInterface</A> method several times to obtain interface pointers for the <A HREF="../ref/iface/IAMDroppedFrames.htm#IAMDroppedFrames">IAMDroppedFrames</A>, <A HREF="../ref/iface/IAMVideoCompression.htm#IAMVideoCompression">IAMVideoCompression</A>, <A HREF="../ref/iface/IAMStreamConfig.htm#IAMStreamConfig">IAMStreamConfig</A>, and <A HREF="../ref/iface/IAMVfwCaptureDialogs.htm#IAMVfwCaptureDialogs">IAMVfwCaptureDialogs</A> capture-related interfaces. The AMCap code saves all of these interface pointers for later use in the gcap global structure and uses gcap structure members throughout the code. 

<P><B>Note:</B>  <A HREF="../ref/iface/IAMVfwCaptureDialogs.htm#IAMVfwCaptureDialogs">IAMVfwCaptureDialogs</A> is designed for you to use only with the Microsoft-supplied video capture filter and only when using a former Video for Windows device.<P>For your convenience, the declaration of the gcap structure follows:

<PRE>
struct _capstuff {
    char szCaptureFile[_MAX_PATH];
    WORD wCapFileSize;  // size in Meg
    ICaptureGraphBuilder *pBuilder;
    IVideoWindow *pVW;
    IMediaEventEx *pME;
    IAMDroppedFrames *pDF;
    IAMVideoCompression *pVC;
    IAMVfwCaptureDialogs *pDlg;
    IAMStreamConfig *pASC;      // for audio cap
    IAMStreamConfig *pVSC;      // for video cap
    IBaseFilter *pRender;
    IBaseFilter *pVCap, *pACap;
    IGraphBuilder *pFg;
    IFileSinkFilter *pSink;
    IConfigAviMux *pConfigAviMux;
    int  iMasterStream;
    BOOL fCaptureGraphBuilt;
    BOOL fPreviewGraphBuilt;
    BOOL fCapturing;
    BOOL fPreviewing;
    BOOL fCapAudio;
    int  iVideoDevice;
    int  iAudioDevice;
    double FrameRate;
    BOOL fWantPreview;
    long lCapStartTime;
    long lCapStopTime;
    char achFriendlyName[120];
    BOOL fUseTimeLimit;
    DWORD dwTimeLimit;
} gcap;
</PRE>
<P>AMCap's InitCapFilters function stores several interface pointers in the gcap structure. Be sure to properly release all interface pointers when they are no longer needed as shown in the following example.

<PRE>
    if (gcap.pBuilder)
      gcap.pBuilder-&gt;Release();
    gcap.pBuilder = NULL;
    if (gcap.pSink)
      gcap.pSink-&gt;Release();
    gcap.pSink = NULL;
    if (gcap.pConfigAviMux)
      gcap.pConfigAviMux-&gt;Release();
    gcap.pConfigAviMux = NULL;
    if (gcap.pRender)
      gcap.pRender-&gt;Release();
    gcap.pRender = NULL;
    if (gcap.pVW)
      gcap.pVW-&gt;Release();
    gcap.pVW = NULL;
    if (gcap.pME)
      gcap.pME-&gt;Release();
    gcap.pME = NULL;
    if (gcap.pFg)
      gcap.pFg-&gt;Release();
    gcap.pFg = NULL;
</PRE>
<P>See <A HREF="Enumerate_Access_Hardware_Devices.htm">Enumerate and Access Hardware Devices in DirectShow Applications</A> for more information about device enumeration.

<h2><A NAME="Building_the_capture_and_preview_filter_graph"></A>Building the Capture and Preview Filter Graph</h2>
<P>AMCap includes a BuildCaptureGraph function that builds up a capture graph with both capture and preview components. Most applications will perform the same tasks sequentially as described in the following topics contained in this section.

<UL><LI><A HREF="Creating_Capture_App.htm#capapp_build_1">Set the Capture File Name</A>
<LI><A HREF="Creating_Capture_App.htm#capapp_build_2">Create a Graph Builder Object</A>
<LI><A HREF="Creating_Capture_App.htm#capapp_build_3">Set the Output File Name</A>
<LI><A HREF="Creating_Capture_App.htm#capapp_build_4">Retrieve the Current Filter Graph</A>
<LI><A HREF="Creating_Capture_App.htm#capapp_build_5">Add the Capture Filters to the Filter Graph</A>
<LI><A HREF="Creating_Capture_App.htm#capapp_build_6">Render the Capture Pins</A>
<LI><A HREF="Creating_Capture_App.htm#capapp_build_7">Render the Video Preview Pin</A>
<LI><A HREF="Creating_Capture_App.htm#capapp_build_8">Configure the Video Preview Window</A>
</UL>
<P>These tasks are explained in greater detail later in this section.

<P>AMCap also includes a BuildPreviewGraph function that is essentially a version of BuildCaptureGraph that deals only with preview. Another difference between BuildCaptureGraph and BuildPreviewGraph is that the latter uses <A HREF="../ref/iface/ICaptureGraphBuilder.htm#SetFiltergraph">ICaptureGraphBuilder::SetFiltergraph</A> to provide a filter graph object (<A HREF="../ref/iface/IGraphBuilder.htm#IGraphBuilder">IGraphBuilder</A> interface) for the capture graph builder object (<A HREF="../ref/iface/ICaptureGraphBuilder.htm#ICaptureGraphBuilder">ICaptureGraphBuilder</A> interface) to use. You probably won't need to call <A HREF="../ref/iface/ICaptureGraphBuilder.htm#SetFiltergraph">SetFiltergraph</A> as the graph builder object creates a filter graph to use by default. Use this method only if you have already created your own filter graph and want the graph builder to use your filter graph. If you call this method after the graph builder has created a filter graph, this method will fail.

 BuildPreviewGraph calls <A HREF="../appendixes/Further_Reading.htm#CoCreateInstance">CoCreateInstance</A> to create a new filter graph object, if necessary, as shown in the following example.


<PRE>
hr = CoCreateInstance(CLSID_FilterGraph, NULL, CLSCTX_INPROC,
                      IID_IGraphBuilder, (LPVOID *)&amp;gcap.pFg);


hr = gcap.pBuilder-&gt;SetFiltergraph(gcap.pFg);
    if (hr != NOERROR) {
      ErrMsg("Cannot give graph to builder");
      goto SetupPreviewFail;
    }
</PRE>
<P>The details of each important task performed by BuildCaptureGraph follow. 

<h3><A NAME="capapp_build_1" IDX_CONCEPT="noindex; capture file name, setting"></A>Set the Capture File Name</h3>
<P>AMCap's SetCaptureFile function displays the common Open File dialog box to enable the user to select a capture file. If the specified file is a new file, it calls the application-defined AllocCaptureFile function that prompts the user to allocate space for the capture file. This "preallocation" of file space is important, because it reserves a large block of space on disk. This speeds up the capture operation when it occurs, because the file space doesn't have to be allocated while capture takes place (it has been preallocated). The <A HREF="../ref/iface/ICaptureGraphBuilder.htm#AllocCapFile">ICaptureGraphBuilder::AllocCapFile</A> method performs the actual file allocation. <A HREF="../ref/iface/IFileSinkFilter.htm#SetFileName">IFileSinkFilter::SetFileName</A> instructs the file writer filter to use the file name that the user chose. The code assumes you've called <A HREF="../ref/iface/ICaptureGraphBuilder.htm#SetOutputFileName">ICaptureGraphBuilder::SetOutputFileName</A> to add the file writer to the filter graph. See <A HREF="Creating_Capture_App.htm#capapp_build_3">Set the Output File Name</A> for more information.

<P>The AMCap-defined SetCaptureFile and AllocCaptureFile functions follow:


<PRE>
/*
 * Put up a dialog to allow the user to select a capture file.
 */
BOOL SetCaptureFile(HWND hWnd)
{
    if (OpenFileDialog(hWnd, gcap.szCaptureFile, _MAX_PATH)) {
        OFSTRUCT os;

      // We have a capture file name.

        /*
         * If this is a new file, then invite the user to
         * allocate some space.
         */
        if (OpenFile(gcap.szCaptureFile, &amp;os, OF_EXIST) == HFILE_ERROR) {

          // Bring up dialog, and set new file size.
          BOOL f = AllocCaptureFile(hWnd);
          if (!f)
            return FALSE;
        }
    } else {
      return FALSE;
    }

    SetAppCaption();      // Need a new app caption.

    // Tell the file writer to use the new file name.
    if (gcap.pSink) {
        WCHAR wach[_MAX_PATH];
        MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, gcap.szCaptureFile, -1,
                            wach, _MAX_PATH);
        gcap.pSink-&gt;SetFileName(wach, NULL);
    }

    return TRUE;
}

// Preallocate the capture file.
// 
BOOL AllocCaptureFile(HWND hWnd)
{
// We'll get into an infinite loop in the dlg proc setting a value.
    if (gcap.szCaptureFile[0] == 0)
      return FALSE;

    /*
     * Show the allocate file space dialog to encourage
     * the user to pre-allocate space.
     */
    if (DoDialog(hWnd, IDD_AllocCapFileSpace, AllocCapFileProc, 0)) {

      // Ensure repaint after dismissing dialog before
      // possibly lengthy operation.
      UpdateWindow(ghwndApp);

      // User has hit OK. Alloc requested capture file space.
      BOOL f = MakeBuilder();
      if (!f)
        return FALSE;
      WCHAR wach[_MAX_PATH];
      MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, gcap.szCaptureFile, -1,
                          wach, _MAX_PATH);
      if (gcap.pBuilder-&gt;AllocCapFile(wach,
                                gcap.wCapFileSize * 1024L * 1024L) != NOERROR) {
        MessageBoxA(ghwndApp, "Error",
                    "Failed to pre-allocate capture file space",
                    MB_OK | MB_ICONEXCLAMATION);
        return FALSE;
        }
    return TRUE;
    } else {
        return FALSE;
        }
}
</PRE>
<h3><A NAME="capapp_build_2" IDX_CONCEPT="noindex; capture graph builder object, creating"></A>Create a Graph Builder Object</h3>
<P>AMCap's MakeBuilder function creates a capture graph builder object and obtains an <A HREF="../ref/iface/ICaptureGraphBuilder.htm#ICaptureGraphBuilder">ICaptureGraphBuilder</A> interface pointer by calling <A HREF="../appendixes/Further_Reading.htm#CoCreateInstance">CoCreateInstance</A>. If you already have a capture graph builder object, you can call <A HREF="../ref/iface/IUnknown.htm#QueryInterface">QueryInterface</A> to obtain an interface pointer. AMCap stores the object pointer in the pBuilder member of the global gcap structure. 

<PRE>
// Make a graph builder object we can use for capture graph building.
//
BOOL MakeBuilder()
{
    // We have one already.
    if (gcap.pBuilder)
      return TRUE;

    HRESULT hr = CoCreateInstance((REFCLSID)CLSID_CaptureGraphBuilder,
                    NULL, CLSCTX_INPROC, (REFIID)IID_ICaptureGraphBuilder,
                    (void **)&amp;gcap.pBuilder);
    return (hr == NOERROR) ? TRUE : FALSE;
}
</PRE>
<h3><A NAME="capapp_build_3" IDX_CONCEPT="noindex; SetOutputFileName, article on using"></A>Set the Output File Name</h3>
<P>AMCap creates the rendering section of the filter graph, consisting of the <A HREF="../filtsamp/AVI_MUX.htm#AVI_Mux">AVI MUX</A> (multiplexer) and the <A HREF="../filtsamp/File_Writer.htm#File_Writer">File Writer</A>. It also provides the filter graph with the previously specified file name to which to save the captured data. See <A HREF="../oview/About_Capture_Filt_Graphs.htm">About Capture Filter Graphs</A> for more information about capture filter graph in general. 

<P><A HREF="../ref/iface/ICaptureGraphBuilder.htm#SetOutputFileName">ICaptureGraphBuilder::SetOutputFileName</A> signals to add the multiplexer and file writer to the filter graph, connects them, and sets the file name. The following example illustrates a call to <A HREF="../ref/iface/ICaptureGraphBuilder.htm#SetOutputFileName">SetOutputFileName</A>.

<PRE>
//
// We need a rendering section that will write the capture file out in AVI
// file format.
//

    WCHAR wach[_MAX_PATH];
    MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, gcap.szCaptureFile, -1, wach,
                        _MAX_PATH);
    GUID guid = MEDIASUBTYPE_Avi;
    hr = gcap.pBuilder-&gt;SetOutputFileName(&amp;guid, wach, &amp;gcap.pRender,
                                          &amp;gcap.pSink);
    if (hr != NOERROR) {
      ErrMsg("Error %x: Cannot set output file", hr);
      goto SetupCaptureFail;
    }
</PRE>
<P>In the above code fragment the value of the first parameter, <I>pType</I>, in the call to <A HREF="../ref/iface/ICaptureGraphBuilder.htm#SetOutputFileName">SetOutputFileName</A> is MEDIASUBTYPE_Avi, indicating that the capture graph builder object will insert an AVI multiplexer filter. Consequently, the file writer that is connected to the multiplexer will write the data to the capture file in AVI file format. 

<P>The second parameter, <I>lpwstrFile</I>, specifies the file name. The last two parameters contain pointers to the multiplexer filter and the file writer filter, respectively, and are initialized for you by the capture graph builder object upon return from <A HREF="../ref/iface/ICaptureGraphBuilder.htm#SetOutputFileName">SetOutputFileName</A>. AMCap stores these pointers in the pRender and pSink members of its gcap structure. Internally, the capture graph builder object creates a filter graph object which exposes the <A HREF="../ref/iface/IGraphBuilder.htm#IGraphBuilder">IGraphBuilder</A> interface and inserts these two filters into that filter graph. It tells the file writer to use the specified file when writing to disk. 

<P>Alternatively, if you want filters besides the multiplexer and file writer in the rendering section of your filter graph, call <A HREF="../ref/iface/IFilterGraph.htm#AddFilter">IFilterGraph::AddFilter</A> to explicitly add the necessary filters. You might need to remember the pointer to the <A HREF="../ref/iface/IBaseFilter.htm#IBaseFilter">IBaseFilter</A> interface of the first filter in your custom rendering chain so you can use it in calls such as <A HREF="../ref/iface/ICaptureGraphBuilder.htm#RenderStream">RenderStream</A>.

<h3><A NAME="capapp_build_4" IDX_CONCEPT="current filter graph, retrieving; filter graph, retrieving the current one"></A>Retrieve the Current Filter Graph</h3>
<P>Because the capture graph builder object created a filter graph in response to 
<A HREF="../ref/iface/ICaptureGraphBuilder.htm#SetOutputFileName">SetOutputFileName</A> and you must put the necessary filters in the same filter graph, call the <A HREF="../ref/iface/ICaptureGraphBuilder.htm#GetFiltergraph">ICaptureGraphBuilder::GetFiltergraph</A> method to retrieve the newly created filter graph. The pointer to the filter graph's <A HREF="../ref/iface/IGraphBuilder.htm#IGraphBuilder">IGraphBuilder</A> interface is returned in the function's parameter.

<PRE>
//
// The graph builder created a filter graph to do that.  Find out what it is,
// and put the video capture filter in the graph too.
//

    hr = gcap.pBuilder-&gt;GetFiltergraph(&amp;gcap.pFg);
    if (hr != NOERROR) {
      ErrMsg("Error %x: Cannot get filtergraph", hr);
      goto SetupCaptureFail;
    }
</PRE>
<h3><A NAME="capapp_build_5" IDX_CONCEPT="noindex; caputer filters, adding to the filter graph; filter graph, adding capture filters to"></A>Add the Capture Filters to the Filter Graph</h3>
<P>Call <A HREF="../ref/iface/IFilterGraph.htm#AddFilter">IFilterGraph::AddFilter</A> to add the capture filters to the filter graph as shown in the following example. 

<PRE>
    hr = gcap.pFg-&gt;AddFilter(gcap.pVCap, NULL);
    if (hr != NOERROR) {
      ErrMsg("Error %x: Cannot add vidcap to filtergraph", hr);
      goto SetupPreviewFail;
    }

    hr = gcap.pFg-&gt;AddFilter(gcap.pACap, NULL);
      if (hr != NOERROR) {
          ErrMsg("Error %x: Cannot add audcap to filtergraph", hr);
          goto SetupCaptureFail;
      }
</PRE>
<h3><A NAME="capapp_build_6" IDX_CONCEPT="noindex; capture pins, rendering"></A>Render the Capture Pins</h3>
<P>The <A HREF="../ref/iface/ICaptureGraphBuilder.htm#RenderStream">ICaptureGraphBuilder::RenderStream</A> method connects the source filter's <A CLASS="Glossary" HREF="javascript:Glossary(sRelPath + 'gloss/gloss_P.htm#pin')">pin</A> to the rendering filter. It connects intermediate filters if necessary. The pin category is optional, but typically specifies either a capture pin (<A HREF="../ref/propset_Pin.htm#PIN_CATEGORY_CAPTURE">PIN_CATEGORY_CAPTURE</A>) or a preview pin (<A HREF="../ref/propset_Pin.htm#PIN_CATEGORY_PREVIEW">PIN_CATEGORY_PREVIEW</A>). The following example connects the capture pin on the video capture filter (represented by the gcap.pVCap variable) to the <A CLASS="Glossary" HREF="javascript:Glossary(sRelPath + 'gloss/gloss_R.htm#renderer')">renderer</A> (represented by gcap.pRender).
 
<PRE>
//
// Render the video capture and preview pins - we may not have preview, so
// don't worry if it doesn't work.
//

    hr = gcap.pBuilder-&gt;RenderStream(&amp;PIN_CATEGORY_CAPTURE, gcap.pVCap,
                                     NULL, gcap.pRender);
    // Error checking.
</PRE>
<P>Call <A HREF="../ref/iface/ICaptureGraphBuilder.htm#RenderStream">ICaptureGraphBuilder::RenderStream</A> again to connect the audio capture filter (represented by gcap.pACap) to the audio renderer as in the following example.

<PRE>
//
// Render the audio capture pin?
//

    if (gcap.fCapAudio) {
      hr = gcap.pBuilder-&gt;RenderStream(&amp;PIN_CATEGORY_CAPTURE, gcap.pACap, NULL, gcap.pRender);
    // Error checking.
</PRE>
<h3><A NAME="capapp_build_7" IDX_CONCEPT="noindex; video preview pin, rendering; preview pin, rendering"></A>Render the Video Preview Pin</h3>
<P>Call <A HREF="../ref/iface/ICaptureGraphBuilder.htm#RenderStream">ICaptureGraphBuilder::RenderStream</A> again to render the graph from the capture filter's preview pin to a video renderer as in the following example. 
<PRE>
    hr = gcap.pBuilder-&gt;RenderStream(&amp;PIN_CATEGORY_PREVIEW, gcap.pVCap,
                                     NULL, NULL);
</PRE>
<h3><A NAME="capapp_build_8" IDX_CONCEPT="noindex; video preview window, configuring; preview window, configuring"></A>Configure the Video Preview Window</h3>
<P>By default, the video preview window will be a separate window from your application window. If you want to change the default behavior, call <A HREF="../ref/iface/ICaptureGraphBuilder.htm#FindInterface">ICaptureGraphBuilder::FindInterface</A> to obtain a pointer to the <A HREF="../ref/iface/IVideoWindow.htm#IVideoWindow">IVideoWindow</A> interface. The first parameter, <I>pCategory</I> specifies the <A CLASS="Glossary" HREF="javascript:Glossary(sRelPath + 'gloss/gloss_O.htm#output_pin')">output pin</A> category to search for a connected filter that supports the desired interface. The code fragment below uses <A HREF="../ref/propset_Pin.htm#PIN_CATEGORY_PREVIEW">PIN_CATEGORY_PREVIEW</A> to indicate a search beginning with all preview pins, and continuing to any pins and filters that connect to the preview pins. If that fails, the code then tries to call <A HREF="../ref/iface/ICaptureGraphBuilder.htm#FindInterface">FindInterface</A> again, with PIN_CATEGORY_CAPTURE, because some capture filters do not have a preview pin, only a capture pin, and the graph builder may have used a <A HREF="../FiltSamp/Smart_Tee.htm">Smart Tee</A> filter to provide a preview, which means the IVideoWindow interface will be found connected to the capture pin. See the documentation on the <A HREF="../FiltSamp/Smart_Tee.htm">Smart Tee</A> filter for more information.
<p>The second parameter, specified by the gcap.pVCap variable below, represents the video capture filter. The third (<I>riid</I>) is the identifier for the desired interface (IID_IVideoWindow), and the last will be filled upon return from this function to give you the <B>IVideoWindow</B> interface. After you have the <B>IVideoWindow</B> interface, you can call <B>IVideoWindow</B> methods such as 
<A HREF="../ref/iface/IVideoWindow.htm#put_Owner">put_Owner</A>, <A HREF="../ref/iface/IVideoWindow.htm#put_WindowStyle">put_WindowStyle</A>, or 
<A HREF="../ref/iface/IVideoWindow.htm#SetWindowPosition">SetWindowPosition</A> to take ownership of the video preview window, make it a child of your application, or to position it as desired. 

<PRE>
// This will go through a possible decoder, find the video renderer it's
// connected to, and get the IVideoWindow interface on it.
   hr = gcap.pBuilder-&gt;FindInterface(&amp;PIN_CATEGORY_PREVIEW, gcap.pVCap,
                    IID_IVideoWindow, (void **)&amp;gcap.pVW);
    if (hr != NOERROR) {
	   hr = gcap.pBuilder-&gt;FindInterface(&amp;PIN_CATEGORY_CAPTURE, gcap.pVCap,
                    IID_IVideoWindow, (void **)&amp;gcap.pVW);
    }
    if (hr != NOERROR) {

      ErrMsg("This graph cannot preview");
    } else {
      RECT rc;
      gcap.pVW-&gt;put_Owner((long)ghwndApp);    // We own the window now.
      gcap.pVW-&gt;put_WindowStyle(WS_CHILD);    // You are now a child.
      // Give the preview window all our space but where the status bar is.
      GetClientRect(ghwndApp, &amp;rc);
      cyBorder = GetSystemMetrics(SM_CYBORDER);
      cy = statusGetHeight() + cyBorder;
      rc.bottom -= cy;
      gcap.pVW-&gt;SetWindowPosition(0, 0, rc.right, rc.bottom); // Be this big.
      gcap.pVW-&gt;put_Visible(OATRUE);
    }
</PRE>
<P>Now that you've built the entire capture filter graph, you can preview video, audio, or actually capture data.

<h2><A NAME="Controlling_the_capture_filter_graph"></A>Controlling the Capture Filter Graph</h2>
<P>Because a capture filter graph constructed by the <A HREF="../ref/iface/ICaptureGraphBuilder.htm#ICaptureGraphBuilder">ICaptureGraphBuilder</A> interface is simply a specialized filter graph, controlling a capture filter graph is much like controlling any other kind of filter graph: you use the <A HREF="../ref/iface/IMediaControl.htm#IMediaControl">IMediaControl</A> interface's <A HREF="../ref/iface/IMediaControl.htm#Run">Run</A>, <A HREF="../ref/iface/IMediaControl.htm#Pause">Pause</A>, and <A HREF="../ref/iface/IMediaControl.htm#Stop">Stop</A> methods. You can use the <A HREF="../ref/class/CBaseFilter.htm#Pause">CBaseFilter::Pause</A> method to cue things up, but remember that capture and recompression only happen when the graph is running. In addition, <B>ICaptureGraphBuilder</B> provides the <A HREF="../ref/iface/ICaptureGraphBuilder.htm#ControlStream">ControlStream</A> method to control the start and stop times of the capture filter graph's streams. Internally, <B>ControlStream</B> calls the <A HREF="../ref/iface/IAMStreamControl.htm#StartAt">IAMStreamControl::StartAt</A> and <A HREF="../ref/iface/IAMStreamControl.htm#StopAt">IAMStreamControl::StopAt</A> methods to start and stop the capture and preview portions of the filter graph for frame-accurate control.

<P><B>Note:</B>  This method might not work on every capture filter because not every capture filter supports <A HREF="../ref/iface/IAMStreamControl.htm#IAMStreamControl">IAMStreamControl</A> on its pins.
<P>The <A HREF="../ref/iface/ICaptureGraphBuilder.htm#ControlStream">ICaptureGraphBuilder::ControlStream</A> method's first parameter (<I>pCategory</I>) is a pointer to a <A CLASS="Glossary" HREF="javascript:Glossary(sRelPath + 'gloss/gloss_G.htm#GUID')">GUID</A> that specifies the output pin category. This value is normally either <A HREF="../ref/propset_Pin.htm#PIN_CATEGORY_CAPTURE">PIN_CATEGORY_CAPTURE</A> or <A HREF="../ref/propset_Pin.htm#PIN_CATEGORY_PREVIEW">PIN_CATEGORY_PREVIEW</A>. See the <A HREF="../ref/propset_Pin.htm#Propset_3">Pin Property Set</A> for a complete list of categories. Specify NULL to control all capture filters in the graph.

<P>The second parameter (<I>pFilter</I>) in <A HREF="../ref/iface/ICaptureGraphBuilder.htm#ControlStream">ICaptureGraphBuilder::ControlStream</A> indicates which filter to control. Specify NULL to control the whole filter graph as AMCap does.

<P>To run only the preview portion of the capture filter graph, prevent capture by calling <A HREF="../ref/iface/ICaptureGraphBuilder.htm#ControlStream">ICaptureGraphBuilder::ControlStream</A> with the capture pin category and the value MAX_TIME as the start time (third parameter, <I>pstart</I>). Call the method again with preview as the pin category, and a NULL start value to start preview immediately. The fourth parameter indicates the desired stop time (<I>pstop</I>, as with start time, NULL means immediately). MAX_TIME is defined in the DirectShow base classes as the maximum <A CLASS="Glossary" HREF="javascript:Glossary(sRelPath + 'gloss/gloss_R.htm#reference_time')">reference time</A>, and in this case means to ignore or cancel the specified operation. 

<P>The last two parameters, <I>wStartCookie</I> and <I>wStopCookie</I> are start and stop cookies respectively. These cookies are arbitrary values set by the application so that it can differentiate between start and stop times and tell when specific actions have been completed. AMCap doesn't use a specific time in <A HREF="../ref/iface/ICaptureGraphBuilder.htm#ControlStream">ICaptureGraphBuilder::ControlStream</A>, so it doesn't need any cookies. If you use a cookie, use <A HREF="../ref/iface/IMediaEvent.htm#IMediaEvent">IMediaEvent</A> to get <A CLASS="Glossary" HREF="javascript:Glossary(sRelPath + 'gloss/gloss_E.htm#event_notification')">event notifications</A>. See <A HREF="../ref/iface/IAMStreamControl.htm#IAMStreamControl">IAMStreamControl</A> for more information.

<P>The following code fragment sets preview to start immediately, but ignores capture.
<PRE>
    // Let the preview section run, but not the capture section.
    // (There might not be a capture section.)
    REFERENCE_TIME start = MAX_TIME, stop = MAX_TIME;
    // Show us a preview first? but don't capture quite yet...
    hr = gcap.pBuilder-&gt;ControlStream(&amp;PIN_CATEGORY_PREVIEW, NULL,
                                      gcap.fWantPreview ? NULL : &amp;start,
                                      gcap.fWantPreview ? &amp;stop : NULL, 0, 0);
    if (SUCCEEDED(hr))
        hr = gcap.pBuilder-&gt;ControlStream(&amp;PIN_CATEGORY_CAPTURE, NULL, &amp;start,
                                          NULL, 0, 0);
</PRE>
<P>The same concept applies if you want only to capture and not preview. Set the capture start time to NULL to capture immediately and set the capture stop time to MAX_TIME. Set the preview start time to MAX_TIME, with an immediate (NULL) stop time.

<P>The following example tells the filter graph to start the preview stream now (the <I>pstart</I> (third) parameter is NULL). Specifying MAX_TIME for the stop time (<I>pstop</I>) means disregard the stop time.
<PRE>
    gcap.pBuilder-&gt;ControlStream(&amp;PIN_CATEGORY_PREVIEW, NULL, NULL, MAX_TIME, 0, 0); 
</PRE>
<P>Calling <A HREF="../ref/iface/IMediaControl.htm#Run">IMediaControl::Run</A> runs the graph.
<PRE>
// Run the graph.
    IMediaControl *pMC = NULL;
    HRESULT hr = gcap.pFg-&gt;QueryInterface(IID_IMediaControl, (void **)&amp;pMC);
    if (SUCCEEDED(hr)) {
      hr = pMC-&gt;Run();
      if (FAILED(hr)) {
          // Stop parts that ran.
          pMC-&gt;Stop();
      }
      pMC-&gt;Release();
    }
    if (FAILED(hr)) {
      ErrMsg("Error %x: Cannot run preview graph", hr);
      return FALSE;
</PRE>
<P>If the graph is already running, start capture immediately with another call to <A HREF="../ref/iface/ICaptureGraphBuilder.htm#ControlStream">ICaptureGraphBuilder::ControlStream</A>. For example, the following call controls the whole filter graph (NULL <I>pFilter</I> (second) parameter), starts now (NULL <I>pstart</I> (third) parameter), and never stops (<I>pstop</I> (fourth) parameter initialized to MAX_TIME).

<PRE>
    REFERENCE_TIME stop = MAX_TIME;

    // NOW!
    gcap.pBuilder-&gt;ControlStream(&amp;PIN_CATEGORY_CAPTURE, NULL, NULL, &amp;stop, 0, 0);
</PRE>
<P>AMCap uses this approach to start capture in response to the user clicking a button.

<P>To stop the capture or preview operation, call <A HREF="../ref/iface/IMediaControl.htm#Stop">IMediaControl::Stop</A>, much as you called <A HREF="../ref/iface/IMediaControl.htm#Run">IMediaControl::Run</A> to run the filter graph.
<PRE>
// Stop the graph.
    IMediaControl *pMC = NULL;
    HRESULT hr = gcap.pFg-&gt;QueryInterface(IID_IMediaControl, (void **)&amp;pMC);
    if (SUCCEEDED(hr)) {
      hr = pMC-&gt;Stop();
      pMC-&gt;Release();
    }
</PRE>
<h2><A NAME="Obtaining_capture_statistics"></A>Obtaining Capture Statistics</h2>
<P>AMCap calls methods on the <A HREF="../ref/iface/IAMDroppedFrames.htm#IAMDroppedFrames">IAMDroppedFrames</A> interface to obtain capture statistics. It determines the number of frames dropped (<A HREF="../ref/iface/IAMDroppedFrames.htm#GetNumDropped">IAMDroppedFrames::GetNumDropped</A>) and captured (<A HREF="../ref/iface/IAMDroppedFrames.htm#GetNumNotDropped">IAMDroppedFrames::GetNumNotDropped</A>), and uses the Win32 <A HREF="../appendixes/Further_Reading.htm#timeGetTime">timeGetTime</A> function at the beginning and end of capture to determine the capture operation's duration. The <A HREF="../ref/iface/IAMDroppedFrames.htm#GetAverageFrameSize">IAMDroppedFrames::GetAverageFrameSize</A> method provides the average size of captured frames in bytes. Use the information from <B>IAMDroppedFrames::GetNumNotDropped</B>, <B>timeGetTime</B>, and <B>IAMDroppedFrames::GetAverageFrameSize</B> to obtain the total bytes captured and calculate the sustained frames per second for the capture operation.

<h2><A NAME="Saving_the_captured_file"></A>Saving the Captured File</h2>
<P>The original preallocated capture file temporarily holds capture data so you can capture as quickly as possible. When you want to save the data you captured to a more permanent location, call <A HREF="../ref/iface/ICaptureGraphBuilder.htm#CopyCaptureFile">ICaptureGraphBuilder::CopyCaptureFile</A>. This method transfers the captured data out of the previously allocated capture file to another file you choose. The resulting new file size matches the size of the actual captured data rather than the preallocated file size, which is usually very large.

<P>The <A HREF="../ref/iface/ICaptureGraphBuilder.htm#CopyCaptureFile">ICaptureGraphBuilder::CopyCaptureFile</A> method's first parameter, <I>lpwstrOld</I>, is the file you're copying from (typically the very large, preallocated file you always use for capture). The second parameter, <I>lpwstrNew</I>, is the file to which you want to save your captured data. Setting the third parameter, <I>fAllowEscAbort</I>, to TRUE indicates that the user is allowed to abort the copy operation by pressing <SMALL>ESC</SMALL>. The last parameter, <I>pCallback</I>, is optional and enables you to supply a progress indicator, if desired, by implementing the <A HREF="../ref/iface/IAMCopyCaptureFileProgress.htm#IAMCopyCaptureFileProgress">IAMCopyCaptureFileProgress</A> interface. The following example demonstrates a call to <A HREF="../ref/iface/ICaptureGraphBuilder.htm#CopyCaptureFile">CopyCaptureFile</A>.

<PRE>
    hr = pBuilder-&gt;CopyCaptureFile(wachSrcFile, wachDstFile,TRUE,NULL);
</PRE>
<P>The SaveCaptureFile function defined by AMCap prompts the to enter a new file name in the Open File common dialog box, uses the Win32 <A HREF="../appendixes/Further_Reading.htm#MultiByteToWideChar">MultiByteToWideChar</A> function to convert the file name to a wide string, and saves the captured data to the specified file using <A HREF="../ref/iface/ICaptureGraphBuilder.htm#CopyCaptureFile">ICaptureGraphBuilder::CopyCaptureFile</A>.

<PRE>
/*
 * Put up a dialog to allow the user to save the contents of the capture file
 * elsewhere.
 */
BOOL SaveCaptureFile(HWND hWnd)
{
    HRESULT hr;
    char achDstFile[_MAX_PATH];
    WCHAR wachDstFile[_MAX_PATH];
    WCHAR wachSrcFile[_MAX_PATH];

    if (gcap.pBuilder == NULL)
      return FALSE;

    if (OpenFileDialog(hWnd, achDstFile, _MAX_PATH)) {

      // We have a capture file name.
      MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, gcap.szCaptureFile, -1,
                          wachSrcFile, _MAX_PATH);
      MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, achDstFile, -1,
                          wachDstFile, _MAX_PATH);
      statusUpdateStatus(ghwndStatus, "Saving capture file - please wait...");

      // We need our own graph builder because the main one might not exist.
      ICaptureGraphBuilder *pBuilder;
      hr = CoCreateInstance((REFCLSID)CLSID_CaptureGraphBuilder,
                            NULL, CLSCTX_INPROC, (REFIID)IID_ICaptureGraphBuilder,
                            (void **)&amp;pBuilder);
      if (hr == NOERROR) {
          // Allow the user to press ESC to abort... don't ask for progress.
          hr = pBuilder-&gt;CopyCaptureFile(wachSrcFile, wachDstFile,TRUE,NULL);
          pBuilder-&gt;Release();
      }
      if (hr == S_OK)
          statusUpdateStatus(ghwndStatus, "Capture file saved");
      else if (hr == S_FALSE)
          statusUpdateStatus(ghwndStatus, "Capture file save aborted");
      else
          statusUpdateStatus(ghwndStatus, "Capture file save ERROR");
      return (hr == NOERROR ? TRUE : FALSE); 

    } else {
return TRUE;    // They canceled or something.
    }
}
</PRE>
<P>See Amcap.cpp and Status.cpp from the AMCap sample for more details about capturing media files and obtaining capture statistics.

<h2><A NAME="Display_prop_pages" IDX_CONCEPT="noindex; capture filter graph property pages, displaying; property pages in capture filter graph, displaying"></A>Displaying Property Pages</h2>
<P>DirectShow provides a number of interfaces to customize the settings of a capture filter graph, including: <A HREF="../ref/iface/IAMStreamConfig.htm#IAMStreamConfig">IAMStreamConfig</A>, <A HREF="../ref/iface/IAMVideoCompression.htm#IAMVideoCompression">IAMVideoCompression</A>, <A HREF="../ref/iface/IAMCrossbar.htm#IAMCrossbar">IAMCrossbar</A>, <A HREF="../ref/iface/IAMTVTuner.htm#IAMTVTuner">IAMTVTuner</A>, <B>IAMTVAudio</B>, <B>IAMAnalogVideoDecoder</B>, <B>IAMCameraControl</B>, and <A HREF="../ref/iface/IAMVideoProcAmp.htm#IAMVideoProcAmp">IAMVideoProcAmp</A>. Creating a property page is one way of enabling users to interact with these settings.

<P>To bring up the settings associated with an object on a property page, use an interface on the object to query for the <A HREF="../appendixes/Further_Reading.htm#ISpecifyPropertyPage">ISpecifyPropertyPages</A> interface. Use this interface to obtain a list of property page CLSIDs that this object supports. The CLSID list can be later passed to the <A HREF="../appendixes/Further_Reading.htm#OleCreatePropertyFra">OleCreatePropertyFrame</A> or <B>OleCreatePropertyFrameIndirect</B> functions to invoke a property sheet. This will supply your application with the custom property pages a filter has in addition to the standard pages.

<P>There are at least nine objects that can have property pages in capture applications. Capture applications usually have two of these objects at least; the video capture filter and the audio capture filter (call them pVCap and pACap). These objects expose the <A HREF="../ref/iface/IBaseFilter.htm#IBaseFilter">IBaseFilter</A> interface, which can be used to query for the <A HREF="../appendixes/Further_Reading.htm#ISpecifyPropertyPage">ISpecifyPropertyPages</A> interface. You can obtain a pointer to the other seven objects as follows:
<OL><LI>The video capture filter's capture pin. Get this by calling :
<PRE>FindInterface(&amp;PIN_CATEGORY_CAPTURE, pVCap, IID_IPin, &amp;pX);</PRE>
<LI>The video capture filter's preview pin. Get this by calling:
<PRE>FindInterface(&amp;PIN_CATEGORY_PREVIEW, pVCap, IID_IPin, &amp;pX);</PRE>
<LI>The audio capture filter's capture pin. Get this by calling:
<PRE>FindInterface(&amp;PIN_CATEGORY_CAPTURE, pACap, IID_IPin, &amp;pX);</PRE>
<LI>The crossbar connected to the video capture filter. Get this by calling:
<PRE>FindInterface(NULL, pVCap, IID_IAMCrossbar, &amp;pX);</PRE>
<LI>A possible second crossbar, that controls both audio and video. This crossbar, if it exists, will be upstream of the crossbar found in #4.  Get this by calling:
<pre>pX-&gt;QueryInterface(IID_IBaseFilter, (void **)&amp;pBaseFilter);
FindInterface(&amp;LOOK_UPSTREAM_ONLY, pBaseFilter, IID_IAMCrossbar, &amp;pX2);
pBaseFilter-&gt;Release();
</pre><p>
<LI>The TV Tuner connected to the video capture filter. Get this by calling:
<PRE>FindInterface(NULL, pVCap, IID_IAMTVTuner, &amp;pX);</PRE>
<LI>The TV Audio connected to the audio capture filter. Get this by calling:
<PRE>FindInterface(NULL, pACap, IID_IAMTVAudio, &amp;pX);</PRE>
</OL>
<P>If you do not want to create your property page by using the <A HREF="../appendixes/Further_Reading.htm#ISpecifyPropertyPage">ISpecifyPropertyPages</A> interface and the <A HREF="../appendixes/Further_Reading.htm#OleCreatePropertyFra">OleCreatePropertyFrame</A> function, you can create your own custom property pages and use the results of your page to call the interfaces programmatically.


<h2><A NAME="Additional_Notes" IDX_CONCEPT="noindex; RenderStream, notes on using; capture graph, customizing"></A>Additional Notes</h2>
<p>The following section provides some additional notes on using the <A HREF="../ref/iface/ICaptureGraphBuilder.htm#RenderStream">ICaptureGraphBuilder::RenderStream</A> method. It details specific examples of how to customize a capture graph from your application.

<ol>
<li>The following example renders the preview pin of a video capture filter, connecting it to a default set of filters (usually a video renderer, possibly through a decompression filter) and creating a graph that can be used to watch live video in a window (<I>pCaptureFilter</I> is the <B>IBaseFilter</B> interface of a video capture filter). Note that if the capture filter does not have a preview pin, this example code will still succeed and provide you with a preview by using a <A HREF="../FiltSamp/Smart_Tee.htm">Smart Tee</A>  filter. See the <A HREF="../FiltSamp/Smart_Tee.htm">Smart Tee</A> documentation for more information. 

<pre>RenderStream(&amp;PIN_CATEGORY_PREVIEW, pCaptureFilter, NULL, NULL);</pre>

<li>The following example renders the capture pin of a video capture filter to an AVI Mux filter, creating a graph that creates an AVI file out of live video data (<I>pCaptureFilte</I>r is the <B>IBaseFilter</B> interface of a video capture filter and pAVIMuxFilter is the <B>IBaseFilter</B> interface of an AVI Mux filter created using the <A HREF="../ref/iface/ICaptureGraphBuilder.htm#SetOutputFileName">ICaptureGraphBuilder::SetOutputFileName</A> method). 


<pre>RenderStream(&amp;PIN_CATEGORY_CAPTURE, pCaptureFilter, NULL, pAVIMuxFilter);</pre>

<li>The following example creates a graph that recompresses the video of an AVI file into Cinepak format, leaves the audio as it is, and creates a new AVI file (<I>pSourceFilter</I> is the <B>IBaseFilter</B> interface of a File Source Filter that is reading from an AVI file. <I>pCinepakCompressor</I> is the <B>IBaseFilter</B> interface of a Cinepak Video Compressor filter, and <I>pAVIMuxFilter</I> is the <B>IBaseFilter</B> interface of an AVI Mux filter created using the <A HREF="../ref/iface/ICaptureGraphBuilder.htm#SetOutputFileName">ICaptureGraphBuilder::SetOutputFileName</A> method).

<pre>RenderStream(NULL, pSourceFilter, pCinepakCompressor, pAVIMuxFilter);</pre>

<li>Finally, in the last example, the source filter can provide two outputs (through an AVI splitter): a video stream and an output stream. 
<pre>RenderStream(NULL, pSourceFilter, NULL, pAVIMuxFilter);</pre>

<p><B>Note</B>  With the <B>RenderStream</B> method, you cannot specify which stream you want, because the category is NULL in both cases. Therefore, you should connect the stream that is going through a compressor first, because only the video stream will successfully connect through the Cinepak compressor, ensuring the right stream is chosen. After using the compressor to choose the right stream, the only stream left unconnected is the audio stream, so the second call to <B>RenderStream</B> will correctly connect the audio stream to the AVI Mux. If you are dealing with AVI files or other files with more than two streams, this method will be unreliable for connecting the stream you want, and you will want to build your graph step-by-step.
</ol>

<!-- CONTENTS_END -->

<!-- START_PAGE_FOOTER -->


<H6><HR size=1></H6>
<P><A Class="line" HREF="#pagetop"><IMG src="../art/yelbtn.gif" WIDTH="11" HEIGHT="11" ALIGN="MIDDLE" BORDER=0 ALT="Top of Page">&nbsp;Top of Page</A>
<BR><A HREF="../../cpyright.htm">&#169; 1998 Microsoft Corporation. All rights reserved. Terms of Use.</A>
<!-- END_PAGE_FOOTER -->

</BLOCKQUOTE>


<SCRIPT>if((g_isIE == true) && (g_iMaj > 3)) {window.self.document.writeln('<SCR' + 'IPT SRC="../tip2.js"></SCR' + 'IPT><IFRAME ID="G_L_S" NAME="SecretBuffer" STYLE="display: none" SRC=""></IFRAME>')}</SCRIPT>
<!-- DACONTROL_START -->

	<DIV ID="HeadGraphAnim"></DIV>
	<SCRIPT>if((g_isIE == true) && (g_iMaj > 3)) {window.self.document.writeln('<SCR' + 'IPT SRC="../anim.js"></SCR' + 'IPT>')}</SCRIPT>
<!-- DACONTROL_END -->

</BODY>
</HTML>
