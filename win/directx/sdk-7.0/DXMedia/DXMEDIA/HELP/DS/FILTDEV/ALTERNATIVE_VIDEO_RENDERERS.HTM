<!-- DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN" -->

<HTML>
<HEAD><TITLE>Alternative Video Renderers</TITLE>
<SCRIPT> var sRelPath = '../' </SCRIPT>


<META NAME="Description" CONTENT="Alternative Video Renderers">
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; CHARSET=iso8859-1">
<META NAME="MS.LOCALE" CONTENT="EN-US">
<META NAME="ROBOTS" CONTENT="all">

<!-- SNIFF_START -->

<SCRIPT>
//<!--
var g_isIE = false, g_isNav = false, g_iMaj = 0, g_sPlat = "";
// -->

</SCRIPT>
<SCRIPT SRC="../ver.js"></SCRIPT>
<SCRIPT SRC="../gloss.js"></SCRIPT>

<!-- SNIFF_END -->


<SCRIPT DEFER SRC="../common.js"></SCRIPT>
<SCRIPT DEFER>
//<!--
function InitPage()
{
	if (g_isIE && g_iMaj >= 4)	
	{

		SetTOC();
	}
}
//-->

</SCRIPT>

<!-- SNIFF_END -->


<!-- STYLE_START -->

<SCRIPT>
//<!--
   var sVR = '../'	// Set root for the style sheet
   var sCSS = '<LINK REL="stylesheet" HREF="' + sVR;

   if(g_isIE)
   {
	   if (g_iMaj >= 4) // For MSIE 4.0 or later
	   {
		   sCSS += 'dxm_basicsdkIE4';
		   if (g_sPlat == "Win") // Windows only for now
		   {
			   document.createStyleSheet(sVR + 'dxm_advSDKIE4.css');
		   }
	   }
	   else // For MSIE 3.0 or earlier
	   {
		   sCSS += 'dxm_basicsdkIE3';
	   }
   }
   else if (g_isNav) // For all Nav versions
   {
	   sCSS += 'dxm_basicsdkNAV';
   }
   else
   {
	   sCSS += 'dxm_basicsdkIE3'; // default to IE3 sheet
   }

   sCSS += (sCSS == '' ? '' : '.css" TYPE="text/css">');

   document.write(sCSS);
//-->

</SCRIPT>
<!-- STYLE_END -->


</HEAD>
<BODY onload="InitPage(); if (g_isIE && g_iMaj >= 4){HdgrphControl()}" BGCOLOR="#FFFFFF">
<A NAME="pagetop"></A><A NAME="vidrendr"></A>

<!-- HEADGRAPH_START -->

<TABLE CLASS="main" BORDER=0 CELLSPACING="0" CELLPADDING="0" WIDTH="*">
<TR>
<TD ROWSPAN="3" VALIGN="TOP" WIDTH="*">
<IMG SRC="../art/header1.gif" WIDTH="107" HEIGHT="110" BORDER=0 ALT="DirectShow Animated Header -- Alternative Video Renderers"></TD>
<TD ROWSPAN="2" VALIGN="TOP" WIDTH="217"><IMG SRC="../art/hdrdshow.gif" WIDTH="217" HEIGHT="110" BORDER=0 ALT="DirectShow Animated Header -- Alternative Video Renderers"></TD>
<TD VALIGN="TOP" WIDTH="383">
<IMG SRC="../art/header3.gif" WIDTH="383" HEIGHT="95" BORDER=0 ALT="DirectShow Animated Header">
</TD>
<TD VALIGN="TOP" WIDTH="100%">
<IMG SRC="../art/spacer1.gif" WIDTH="100%" HEIGHT="94" BORDER=0 ALT="Microsoft DirectShow SDK">
</TD>
</TR>
<!-- HEADGRAPH_END -->

<!-- NAV_LINKS_START -->

<TR><TD VALIGN="TOP"><PRE><IMG ID="TOC_" SRC="../art/yelbtn.gif" WIDTH="11" HEIGHT="11" ALIGN="MIDDLE" BORDER=0 ALT="*"><A STYLE="color:black;font-weight:bold" ID="TOC" HREF="../contents.htm">Contents</A>  <IMG SRC="../art/yelbtn.gif" WIDTH="11" HEIGHT="11" ALIGN="MIDDLE" BORDER=0 ALT="*"><A STYLE="color:black;font-weight:bold" HREF="../index.htm">Index</A>  <IMG SRC="../art/yelbtn.gif" WIDTH="11" HEIGHT="11" ALIGN="MIDDLE" BORDER=0 ALT="*"><A STYLE="color:black;font-weight:bold" HREF="Video_Renderers.htm">Topic Contents</A>
</PRE></TD></TR>
<TR><TD COLSPAN="2" VALIGN="TOP"><PRE><IMG SRC="../art/yelbtn.gif" WIDTH="11" HEIGHT="11" ALIGN="MIDDLE" BORDER=0 ALT="*"><B>Previous Topic:</B> <A STYLE="color:black" HREF="FullScreen_Video_Renderer.htm">Full-Screen Video Renderer</A>
<IMG SRC="../art/yelbtn.gif" WIDTH="11" HEIGHT="11" ALIGN="MIDDLE" BORDER=0 ALT="*"><B>Next Topic:</B> <A  STYLE="color:black" HREF="Rectangles.htm">Source and Target Rectangles in Video Renderers</A>
</PRE></TD></TR></TABLE>
<!-- NAV_LINKS_END -->


<BLOCKQUOTE CLASS="body">


<!-- CONTENTS_START -->

<H1>Alternative Video Renderers</H1>

<P>This article describes some of the more complicated implementation requirements of a <A CLASS="Glossary" HREF="javascript:Glossary(sRelPath + 'gloss/gloss_R.htm#renderer')">renderer</A>; these apply to most renderers, although some aspects are video-specific (such as <A HREF="../ref/Event_Notification_Codes.htm#EC_REPAINT">EC_REPAINT</A> and other notifications). In particular, it discusses how to handle various notifications, state changes, and format changes. It also provides a summary of the notifications that a renderer is responsible for sending to the <A CLASS="Glossary" HREF="javascript:Glossary(sRelPath + 'gloss/gloss_F.htm#filter_graph_manager')">filter graph manager</A>. 
 
<P>This article contains the following topics:
<UL><LI><A HREF="Alternative_Video_Renderers.htm#vidrendr_1">Writing an Alternative Renderer</A>
<LI><A HREF="Alternative_Video_Renderers.htm#vidrendr_2">Handling End-of-stream and Flushing Notifications</A>
<LI><A HREF="Alternative_Video_Renderers.htm#vidrendr_3">Handling State Changes and Pause Completion</A>
<LI><A HREF="Alternative_Video_Renderers.htm#vidrendr_4">Handling Termination</A>
<LI><A HREF="Alternative_Video_Renderers.htm#vidrendr_5">Handling Dynamic Format Changes</A>
<LI><A HREF="Alternative_Video_Renderers.htm#vidrendr_6">Handling Persistent Properties</A>
<LI><A HREF="Alternative_Video_Renderers.htm#vidrendr_7">Handling EC_REPAINT Notifications</A>
<LI><A HREF="Alternative_Video_Renderers.htm#vidrendr_8">Handling Notifications in Full-Screen Mode</A>
<LI><A HREF="Alternative_Video_Renderers.htm#vidrendr_9">Summary of Notifications</A>
</UL>
<h2><A NAME="vidrendr_1"></A>Writing an Alternative Renderer</h2>
<P>Microsoft&#174; DirectShow&#153; provides a window-based video renderer; it also provides a full-screen renderer in the run-time installation. You can use the C++ classes in the DirectShow SDK to write alternative video renderers. For alternative renderers to interact correctly with DirectShow-based applications, the renderers must adhere to the guidelines outlined in this article. You can use the <A HREF="../ref/class/CBaseRenderer.htm#CBaseRenderer">CBaseRenderer</A> and <A HREF="../ref/class/CBaseVideoRenderer.htm#CBaseVideoRenderer">CBaseVideoRenderer</A> classes to help follow these guidelines when implementing an alternative video render. Consult the SampVid sample in the DirectShow SDK for an example of an alternative video renderer that uses these classes. Because of the ongoing development of DirectShow, review your implementation periodically to ensure that the renderers are compatible with the most recent version of DirectShow.

<P>This article discusses many notifications that a renderer is responsible for handling. A brief review of DirectShow notifications might help to set the stage. There are essentially three kinds of notifications that occur in DirectShow: 

<UL><LI><I><A CLASS="Glossary" HREF="javascript:Glossary(sRelPath + 'gloss/gloss_S.htm#stream_notification')">Stream notifications</A></I>, which are events that occur in the media stream and are passed from one <A CLASS="Glossary" HREF="javascript:Glossary(sRelPath + 'gloss/gloss_f.htm#filter')">filter</A> to the next. These can be begin-flushing, end-flushing or end-of-stream notifications and are sent by calling the appropriate method on the <A CLASS="Glossary" HREF="javascript:Glossary(sRelPath + 'gloss/gloss_D.htm#downstream_filter')">downstream filter's</A> <A CLASS="Glossary" HREF="javascript:Glossary(sRelPath + 'gloss/gloss_I.htm#input_pin')">input pin</A> (for example <A HREF="../ref/iface/IPin.htm#BeginFlush">IPin::BeginFlush</A>).

<LI><I><A CLASS="Glossary" HREF="javascript:Glossary(sRelPath + 'gloss/gloss_F.htm#filter_graph_manager')">Filter graph manager</A> notifications</I>, which are events sent from a filter to the filter graph manager such as <A HREF="../ref/Event_Notification_Codes.htm#EC_COMPLETE">EC_COMPLETE</A>. This is accomplished by calling the <A HREF="../ref/iface/IMediaEventSink.htm#Notify">IMediaEventSink::Notify</A> method on the filter graph manager.

<LI><I><A CLASS="Glossary" HREF="javascript:Glossary(sRelPath + 'gloss/gloss_A.htm#application_notifica')">Application notifications</A></I>, which are retrieved from the filter graph manager by the controlling application. An application calls the <A HREF="../ref/iface/IMediaEvent.htm#GetEvent">IMediaEvent::GetEvent</A> method on the filter graph manager to retrieve these events. Often, the filter graph manager passes through the events it receives to the application. 
</UL>
<P>This article discusses the responsibility of the renderer filter in handling stream notifications it receives and in sending appropriate filter graph manager notifications. 



<h2><A NAME="vidrendr_2"></A>Handling End-of-stream and Flushing Notifications</h2>
<P>An end-of-stream notification begins at an <A CLASS="Glossary" HREF="javascript:Glossary(sRelPath + 'gloss/gloss_U.htm#upstream_filter')">upstream filter</A> (such as the <A CLASS="Glossary" HREF="javascript:Glossary(sRelPath + 'gloss/gloss_S.htm#source_filter')">source filter</A>) when that filter detects that it can send no more data. It is passed through every filter in the graph and eventually ends at the renderer, which is responsible for subsequently sending an <A HREF="../ref/Event_Notification_Codes.htm#EC_COMPLETE">EC_COMPLETE</A> notification to the filter graph manager. Renderers have special responsibilities when it comes to handling these notifications.

<P>A renderer receives an end-of-stream notification when its input pin's <A HREF="../ref/iface/IPin.htm#EndOfStream">IPin::EndOfStream</A> method is called by the upstream filter. A renderer should note this notification and continue to render any data it has already received. Once all remaining data has been received, the renderer should send an <A HREF="../ref/Event_Notification_Codes.htm#EC_COMPLETE">EC_COMPLETE</A> notification to the filter graph manager. The <B>EC_COMPLETE</B> notification should be sent only once by a renderer each time it reaches the end of a stream. Furthermore, <B>EC_COMPLETE</B> notifications must never be sent except when the <A CLASS="Glossary" HREF="javascript:Glossary(sRelPath + 'gloss/gloss_F.htm#filter_graph')">filter graph</A> is running. Therefore, if the filter graph is paused when a source filter sends an end-of-stream notification, then <B>EC_COMPLETE</B> should not be sent until the filter graph is finally run.

<P>Any calls to the <A HREF="../ref/iface/IMemInputPin.htm#Receive">IMemInputPin::Receive</A> or <A HREF="../ref/iface/IMemInputPin.htm#ReceiveMultiple">IMemInputPin::ReceiveMultiple</A> methods after an end-of-stream notification is signaled should be rejected. E_UNEXPECTED is the most appropriate error message to return in this case. 

<P>When a filter graph is stopped, any cached end-of-stream notification should be cleared and not resent when next started. This is because the filter graph manager always pauses all filters just before running them so that proper flushing occurs. So, for example, if the filter graph is paused and an end-of-stream notification is received, and then the filter graph is stopped, the renderer should not send an <A HREF="../ref/Event_Notification_Codes.htm#EC_COMPLETE">EC_COMPLETE</A> notification when it is subsequently run. If no seeks have occurred, 
the source filter will automatically send another end-of-stream notification during the pause state that precedes a run state. 
If, on the other hand, a seek has occurred while the filter graph is stopped, then the source filter might have data to send, so it won't send an end-of-stream notification.

<P>Video renderers often depend on end-of-stream notifications for more than the sending of <A HREF="../ref/Event_Notification_Codes.htm#EC_COMPLETE">EC_COMPLETE</A> notifications. For example, if a stream has finished playing (that is, an end-of-stream notification is sent) and another window is dragged over a video renderer window, a number of WM_PAINT window messages will be generated. The typical practice for running video renderers is to refrain from repainting the current frame upon receipt of WM_PAINT messages (based on the assumption that another frame to be drawn will be received). However, when the end-of-stream notification has been sent, the renderer is in a waiting state; it is still running but is aware that it will not receive any additional data. Under these circumstances, the renderer customarily draws the playback area black.

<P>Handling flushing is an additional complication for renderers. Flushing is carried out through a pair of <A HREF="../ref/iface/IPin.htm#IPin">IPin</A> methods called <A HREF="../ref/iface/IPin.htm#BeginFlush">BeginFlush</A> and <A HREF="../ref/iface/IPin.htm#EndFlush">EndFlush</A>. Flushing is essentially an additional state that the renderer must handle. It is illegal for a source filter to call <B>BeginFlush</B> without calling <B>EndFlush</B>, so hopefully the state is short and discrete; however, the renderer must correctly handle data or notifications it receives during the flush transition.

<P>Any data received after calling <A HREF="../ref/iface/IPin.htm#BeginFlush">BeginFlush</A> should be rejected immediately by returning E_UNEXPECTED. Furthermore, any cached end-of-stream notification should also be cleared when a renderer is flushed. A renderer will typically be flushed in response to a seek. The flush ensures that old data is cleared from the filter graph before fresh samples are sent. (Typically, the playing of two sections of a stream, one after another, is best handled through deferred commands rather than waiting for one section to finish and then issuing a seek command.) 

<h2><A NAME="vidrendr_3"></A>Handling State Changes and Pause Completion</h2>
<P>A renderer filter behaves the same as any other filter in the filter graph when its state is changed, with the following exception. After being paused, the renderer will have some data queued, ready to be rendered when subsequently run. When the video renderer is stopped, it holds on to this queued data. This is an exception to the DirectShow rule that no resources should be held by filters while the filter graph is stopped.

<P>The reason for this exception is that by holding resources, the renderer will always have an image with which to repaint the window if it receives a WM_PAINT message. It also has an image to satisfy methods, such as <A HREF="../ref/class/CBaseControlVideo.htm#GetStaticImage">CBaseControlVideo::GetStaticImage</A>, that request a copy of the current image. Another effect of holding resources is that holding on to the image stops the allocator from being decommitted, which in turn makes the next state change occur much faster because the image buffers are already allocated.

<P>A video renderer should render and release samples only while running. While paused, the filter might render them (for example, when drawing a static poster image in a window), but should not release them. Audio renderers will do no rendering while paused (although they can perform other activities, such as preparing the wave device, for example). The time at which the samples should be rendered 
is obtained by combining the <A CLASS="Glossary" HREF="javascript:Glossary(sRelPath + 'gloss/gloss_S.htm#stream_time')">stream time</A> in the sample with the <A CLASS="Glossary" HREF="javascript:Glossary(sRelPath + 'gloss/gloss_R.htm#reference_time')">reference time</A> passed as a parameter to the <A HREF="../ref/iface/IMediaControl.htm#Run">IMediaControl::Run</A> method. Renderers should reject samples with start times less than or equal to end times.

<P>When an application pauses a filter graph, the filter graph does not return from its <A HREF="../ref/iface/IMediaControl.htm#Pause">IMediaControl::Pause</A> method until there is data queued at the renderers. In order to ensure this, when a renderer is paused, it should return S_FALSE if there is no data waiting to be rendered. If it has data queued, then it can return S_OK. 

<P>The filter graph manager checks all return values when pausing a filter graph, to ensure that the renderers have data queued. If one or more filters are not ready, then the filter graph manager polls the filters in the graph by calling 
<A HREF="../ref/iface/IMediaFilter.htm#GetState">GetState</A>. The <B>GetState</B> method takes a time-out parameter. A filter (typically a renderer) that is still waiting for data to arrive before completing the state change returns <A HREF="../ref/Error_Success_Codes.htm#VFW_S_STATE_INTERMED">VFW_S_STATE_INTERMEDIATE</A> if the <B>GetState</B> method expires. Once data arrives at the renderer, <B>GetState</B> should be returned immediately with S_OK.

<P>In both the intermediate and completed state, the reported filter state will be <A HREF="../ref/dtypes.htm#State_Paused">State_Paused</A>. Only the return value indicates whether the filter is really ready or not. If, while a renderer is waiting for data to arrive, its source filter sends an end-of-stream notification, then that should also complete the state change.

<P>Once all filters actually have data waiting to be rendered, the filter graph will complete its pause state change.


<h2><A NAME="vidrendr_4"></A>Handling Termination</h2>
<P>Video renderers must correctly handle termination events from the user. This implies correctly hiding the window and knowing what to do if a window is subsequently forced to be displayed. Also, video renderers must notify the filter graph manager when its window is destroyed (or more accurately, when the renderer is removed from the filter graph) to free resources.

<P>If the user closes the video window (for instance by pressing <SMALL>ALT+F4</SMALL>), the convention is to hide the window immediately and send an <A HREF="../ref/Event_Notification_Codes.htm#EC_USERABORT">EC_USERABORT</A> notification to the filter graph manager. This notification is passed through to the application, which will stop the graph playing. After sending <B>EC_USERABORT</B>, a video renderer should reject any additional samples delivered to it. 



<P>The abort flag should be left on by the renderer until it is subsequently stopped, at which point it should be reset so that an 
application can override the user action and continue playing the graph if it desires. If <SMALL>ALT+F4</SMALL> is pressed while the video is running, the window will be hidden and all further samples delivered will be rejected. If the window is subsequently shown (perhaps through <A HREF="../ref/iface/IVideoWindow.htm#put_Visible">IVideoWindow::put_Visible</A>), then no <A HREF="../ref/Event_Notification_Codes.htm#EC_REPAINT">EC_REPAINT</A> notifications should be generated.

<P>The video renderer should also send the <A HREF="../ref/Event_Notification_Codes.htm#EC_WINDOW_DESTROYED">EC_WINDOW_DESTROYED</A> notification to the filter graph when the video renderer is terminating. In fact, it is best to handle this when the renderer's <A HREF="../ref/iface/IBaseFilter.htm#JoinFilterGraph">IBaseFilter::JoinFilterGraph</A> method is called with a null parameter (indicating that the renderer is about to be removed from the filter graph), rather than waiting until the actual video window is destroyed. Sending this notification allows the <A CLASS="Glossary" HREF="javascript:Glossary(sRelPath + 'gloss/gloss_P.htm#plug_in_distributor')">plug-in distributor</A> in the filter graph manager
to pass on resources that depend on window focus to other filters (such as audio devices).


<h2><A NAME="vidrendr_5"></A>Handling Dynamic Format Changes</h2>
<P>Video renderers in DirectShow accept only video formats that can be drawn efficiently. For example, the window-based run-time renderer will accept only the RGB format that matches the current display device mode (for example, RGB565 when the display is set to 65,536 colors). As a last resort, it also accepts 8-bit palettized formats, as most display cards can draw this format efficiently. When the renderer has Microsoft&#174; DirectDraw&#174; loaded, it might later ask the source filter to switch to something that can be written onto a DirectDraw surface and drawn directly through display hardware.
In some cases, the renderer's upstream filter might try to change the video format while the video is playing. This often occurs when a video stream has a palette change. It is most often the video decompressor that initiates a dynamic
format change. 

<P>An upstream filter attempting to change formats dynamically should always call the <A HREF="../ref/iface/IPin.htm#QueryAccept">IPin::QueryAccept</A> method on the renderer input pin (for filters based on <A HREF="../ref/class/CTransformFilter.htm#CTransformFilter">CTransformFilter</A>, this is implemented in 
<A HREF="../ref/class/CTransformFilter.htm#CheckInputType">CTransformFilter::CheckInputType</A>).  The formats a renderer will allow an upstream filter to change dynamically are undefined. However, at a very minimum, it should allow the upstream filter to change palettes. When an upstream filter changes media types, it will attach the format to the first sample delivered in that new type. If the renderer holds many samples in a queue waiting to be rendered, it should delay changing the format until the sample with the type change is actually about to be rendered.

<P>Whenever a format change is detected by the video renderer, it should send an <A HREF="../ref/Event_Notification_Codes.htm#EC_DISPLAY_CHANGED">EC_DISPLAY_CHANGED</A> notification. Most video renderers pick a format during connection so that the format can be drawn efficiently through GDI. If the user changes the current display mode without restarting the computer, a renderer might find itself with a bad image format connection and should send this notification. The first parameter should be the <A CLASS="Glossary" HREF="javascript:Glossary(sRelPath + 'gloss/gloss_P.htm#pin')">pin</A> that needs reconnecting. The filter graph manager will arrange for the filter graph to be stopped and the pin reconnected. During the subsequent reconnection, the renderer can accept a more appropriate format.

<P>Whenever a video renderer detects a palette change in the stream it should send the <A HREF="../ref/Event_Notification_Codes.htm#EC_PALETTE_CHANGED">EC_PALETTE_CHANGED</A> notification to the filter graph manager. The DirectShow video renderers detect whether a palette has really changed in dynamic format or not. The video renderers do this not only to filter out the number 
of <B>EC_PALETTE_CHANGED</B> notifications sent but also to reduce the amount of palette creation, installation, and deletion required.

<P>Finally, the video renderer might also detect that the size of the video has changed, in which case, it should send the <A HREF="../ref/Event_Notification_Codes.htm#EC_VIDEO_SIZE_CHANGED">EC_VIDEO_SIZE_CHANGED</A> notification. An application might use this notification to negotiate space in a compound document. The actual video dimensions are available through the <A HREF="../ref/iface/IBasicVideo.htm#IBasicVideo">IBasicVideo</A> control interface. The DirectShow renderers detect whether the video has actually changed size or not prior to sending these events.


<h2><A NAME="vidrendr_6"></A>Handling Persistent Properties</h2>
<P>All properties set through the <A HREF="../ref/iface/IBasicVideo.htm#IBasicVideo">IBasicVideo</A> and <A HREF="../ref/iface/IVideoWindow.htm#IVideoWindow">IVideoWindow</A> interfaces are meant to be persistent across connections. Therefore, disconnecting and reconnecting a renderer should show no effects on the window size, position, or styles. However, if the video dimensions change between connections, the renderer should reset the source 
and destination rectangles to their defaults. The source and destination positions are set through the <B>IBasicVideo</B> interface.

<P>Both <A HREF="../ref/iface/IBasicVideo.htm#IBasicVideo">IBasicVideo</A> and <A HREF="../ref/iface/IVideoWindow.htm#IVideoWindow">IVideoWindow</A> provide enough access to properties to allow an application to save and restore all the data in the interface in a persistent format. This will be useful to applications that must save the exact configuration and properties of filter graphs during an editing session and restore them later.


<h2><A NAME="vidrendr_7"></A>Handling EC_REPAINT Notifications</h2>
<P>The <A HREF="../ref/Event_Notification_Codes.htm#EC_REPAINT">EC_REPAINT</A> notification is sent only when the renderer is either paused or stopped. This notification signals to the filter graph manager that the renderer needs data. If the filter graph is stopped when it receives one of these notifications, it will pause the filter graph, wait for all filters to receive data (by calling 
<A HREF="../ref/iface/IMediaFilter.htm#GetState">GetState</A>), and then stop it again. When stopped, a video renderer should hold on to the image so that subsequent WM_PAINT messages can be handled.

<P>Therefore, if a video renderer receives a WM_PAINT message when stopped or paused, and it has nothing with which to paint its window, then it should send <A HREF="../ref/Event_Notification_Codes.htm#EC_REPAINT">EC_REPAINT</A> to the filter graph manager. If an <B>EC_REPAINT</B> notification is received while paused, then the filter graph manager calls <A HREF="../ref/iface/IMediaPosition.htm#put_CurrentPosition">IMediaPosition::put_CurrentPosition</A> with the current position (that is, seeks to the current position). This causes the source filters to flush the filter graph and causes new data to be sent through the filter graph.

<P>A renderer must send only one of these notifications at a time. Therefore, once the renderer sends a notification, it should ensure no more are sent until some samples are delivered. The conventional way to do this is to have a flag to signify that a repaint can be sent, which is turned off after an <A HREF="../ref/Event_Notification_Codes.htm#EC_REPAINT">EC_REPAINT</A> notification is sent. This flag should be reset once data is delivered or when the input pin is flushed, but not if end-of-stream is signaled on the input pin.

<P>If the renderer does not monitor its <A HREF="../ref/Event_Notification_Codes.htm#EC_REPAINT">EC_REPAINT</A> notifications, it will flood the filter graph manager with <B>EC_REPAINT</B> requests (which are relatively expensive to process). For example, if a renderer has no image to draw, and another window is dragged across the window of the renderer in a full-drag operation, the renderer receives multiple WM_PAINT messages. Only the first of these should generate an <B>EC_REPAINT</B> <A CLASS="Glossary" HREF="javascript:Glossary(sRelPath + 'gloss/gloss_E.htm#event_notification')">event notification</A> from the renderer to the filter graph manager.

<P>A renderer should send its input pin as the first parameter to the <A HREF="../ref/Event_Notification_Codes.htm#EC_REPAINT">EC_REPAINT</A> notification. By doing this, the attached <A CLASS="Glossary" HREF="javascript:Glossary(sRelPath + 'gloss/gloss_O.htm#output_pin')">output pin</A> will be queried for <A HREF="../ref/iface/IMediaEventSink.htm#IMediaEventSink">IMediaEventSink</A>, and if supported, the <B>EC_REPAINT</B> notification will be sent there first. This allows output pins to handle repaints before the filter graph must be touched. This will not be done if the filter graph is stopped, because no buffers would be available from the decommitted renderer allocator.

<P>If the output pin cannot handle the request and the filter graph is running, then the <A HREF="../ref/Event_Notification_Codes.htm#EC_REPAINT">EC_REPAINT</A> notification is ignored. An output pin must return NOERROR (S_OK) from <A HREF="../ref/iface/IMediaEventSink.htm#Notify">IMediaEventSink::Notify</A> to signal that it processed 
the repaint request successfully. The output pin will be called on the filter graph manager worker thread, which avoids having the renderer call the output pin directly, and so sidesteps any deadlock issues. If the filter graph is stopped or paused and the output doesn't handle the request, then the default processing is done.


<h2><A NAME="vidrendr_8"></A>Handling Notifications in Full-Screen Mode</h2>
<P>The <A HREF="../ref/iface/IVideoWindow.htm#IVideoWindow">IVideoWindow</A> plug-in distributor (PID) in the filter graph manages full-screen playback. It will swap a video renderer out for a specialist full-screen renderer, stretch a window of a renderer to full screen, or have the renderer 
implement full-screen playback directly. To interact in full-screen protocols, a video renderer should send an <A HREF="../ref/Event_Notification_Codes.htm#EC_ACTIVATE">EC_ACTIVATE</A> notification whenever its window is either activated or deactivated. In other words, an <B>EC_ACTIVATE</B> notification should be sent for each WM_ACTIVATEAPP message a renderer receives.

<P>When a renderer is being used in full-screen mode, these notifications manage the switching into and out of that full-screen mode. Window deactivation typically occurs when a user presses <SMALL>ALT+TAB</SMALL> to switch to another window, which the DirectShow full-screen renderer uses as a cue to return to typical rendering mode.

<P>When the <A HREF="../ref/Event_Notification_Codes.htm#EC_ACTIVATE">EC_ACTIVATE</A> notification is sent to the filter graph manager upon switching out of full-screen mode, the filter graph manager sends an <A HREF="../ref/Event_Notification_Codes.htm#EC_FULLSCREEN_LOST">EC_FULLSCREEN_LOST</A> notification to the controlling application. The application might use this notification to restore the state of a full-screen button, for example. The <B>EC_ACTIVATE</B> notifications are used internally by DirectShow to manage full-screen switching on cues from the video renderers. 


<h2><A NAME="vidrendr_9" IDX_CONCEPT="noindex; renderer notifications; notifications, renderer"></A>Summary of Notifications</h2>
<P>This section lists the filter graph notifications that a renderer can send.</p>

<TABLE>
<TR><TH>Event notification</TH><TH>Description</TH></TR>
<TR><TD><A HREF="../ref/Event_Notification_Codes.htm#EC_ACTIVATE">EC_ACTIVATE</A>
</TD><TD>Sent by video renderers in full-screen rendering mode for each WM_ACTIVATEAPP message received. 
</TD></TR><TR><TD><A HREF="../ref/Event_Notification_Codes.htm#EC_COMPLETE">EC_COMPLETE</A>
</TD><TD>Sent by renderers after all data has been rendered. 
</TD></TR><TR><TD><A HREF="../ref/Event_Notification_Codes.htm#EC_DISPLAY_CHANGED">EC_DISPLAY_CHANGED</A>
</TD><TD>Sent by video renderers when a display format changes.
</TD></TR><TR><TD><A HREF="../ref/Event_Notification_Codes.htm#EC_PALETTE_CHANGED">EC_PALETTE_CHANGED</A>
</TD><TD>Sent whenever a video renderer detects a palette change in the stream. 
</TD></TR><TR><TD><A HREF="../ref/Event_Notification_Codes.htm#EC_REPAINT">EC_REPAINT</A>
</TD><TD>Sent by stopped or paused video renderers when a WM_PAINT message is received and there is no data to display. This causes the filter graph manager to generate a frame to paint to the display. 
</TD></TR><TR><TD><A HREF="../ref/Event_Notification_Codes.htm#EC_USERABORT">EC_USERABORT</A>
</TD><TD>Sent by video renderers to signal a closure that the user requested (for example, a user closing the video window). 
</TD></TR><TR><TD><A HREF="../ref/Event_Notification_Codes.htm#EC_VIDEO_SIZE_CHANGED">EC_VIDEO_SIZE_CHANGED</A>
</TD><TD>Sent by video renderers whenever a change in native video size is detected. 
</TD></TR><TR><TD><A HREF="../ref/Event_Notification_Codes.htm#EC_WINDOW_DESTROYED">EC_WINDOW_DESTROYED</A>
</TD><TD>Sent by video renderers when the filter is removed or destroyed so that resources that depend on window focus can be passed to other filters.
</TD></TR></TABLE>

<!-- CONTENTS_END -->

<!-- START_PAGE_FOOTER -->


<H6><HR size=1></H6>
<P><A Class="line" HREF="#pagetop"><IMG src="../art/arrowup1.gif" WIDTH="11" HEIGHT="11" ALIGN="MIDDLE" BORDER=0 ALT="Top of Page">&nbsp;Top of Page</A>
<BR><A HREF="../../cpyright.htm">&#169; 1998 Microsoft Corporation. All rights reserved. Terms of Use.</A>
<!-- END_PAGE_FOOTER -->

</BLOCKQUOTE>

<SCRIPT>if((g_isIE == true) && (g_iMaj > 3)) {window.self.document.writeln('<SCR' + 'IPT SRC="../tip2.js"></SCR' + 'IPT><IFRAME ID="G_L_S" NAME="SecretBuffer" STYLE="display: none" SRC=""></IFRAME>')}</SCRIPT>

<!-- DACONTROL_START -->

	<DIV ID="HeadGraphAnim"></DIV>
	<SCRIPT>if((g_isIE == true) && (g_iMaj > 3)) {window.self.document.writeln('<SCR' + 'IPT SRC="../anim.js"></SCR' + 'IPT>')}</SCRIPT>
<!-- DACONTROL_END -->

</BODY>
</HTML>
