<!-- DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN" -->

<HTML>
<HEAD><TITLE>Write a Video Capture Filter</TITLE>
<SCRIPT> var sRelPath = '../' </SCRIPT>


<META NAME="Description" CONTENT="Write a Video Capture Filter">
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; CHARSET=iso8859-1">
<META NAME="MS.LOCALE" CONTENT="EN-US">
<META NAME="ROBOTS" CONTENT="all">

<!-- SNIFF_START -->

<SCRIPT>
//<!--
var g_isIE = false, g_isNav = false, g_iMaj = 0, g_sPlat = "";
// -->

</SCRIPT>
<SCRIPT SRC="../ver.js"></SCRIPT>
<SCRIPT SRC="../gloss.js"></SCRIPT>

<!-- SNIFF_END -->


<SCRIPT DEFER SRC="../common.js"></SCRIPT>
<SCRIPT DEFER>
//<!--
function InitPage()
{
	if (g_isIE && g_iMaj >= 4)	
	{

		SetTOC();
	}
}
//-->

</SCRIPT>

<!-- SNIFF_END -->


<!-- STYLE_START -->

<SCRIPT>
//<!--
   var sVR = '../'	// Set root for the style sheet
   var sCSS = '<LINK REL="stylesheet" HREF="' + sVR;

   if(g_isIE)
   {
	   if (g_iMaj >= 4) // For MSIE 4.0 or later
	   {
		   sCSS += 'dxm_basicsdkIE4';
		   if (g_sPlat == "Win") // Windows only for now
		   {
			   document.createStyleSheet(sVR + 'dxm_advSDKIE4.css');
		   }
	   }
	   else // For MSIE 3.0 or earlier
	   {
		   sCSS += 'dxm_basicsdkIE3';
	   }
   }
   else if (g_isNav) // For all Nav versions
   {
	   sCSS += 'dxm_basicsdkNAV';
   }
   else
   {
	   sCSS += 'dxm_basicsdkIE3'; // default to IE3 sheet
   }

   sCSS += (sCSS == '' ? '' : '.css" TYPE="text/css">');

   document.write(sCSS);
//-->

</SCRIPT>
<!-- STYLE_END -->


</HEAD>
<BODY onload="InitPage(); if (g_isIE && g_iMaj >= 4){HdgrphControl()}" BGCOLOR="#FFFFFF">
<A NAME="pagetop"></A><A NAME="caprules"></A>

<!-- HEADGRAPH_START -->

<TABLE CLASS="main" BORDER=0 CELLSPACING="0" CELLPADDING="0" WIDTH="*">
<TR>
<TD ROWSPAN="3" VALIGN="TOP" WIDTH="*">
<IMG SRC="../art/header1.gif" WIDTH="107" HEIGHT="110" BORDER=0 ALT="DirectShow Animated Header -- Write a Video Capture Filter"></TD>
<TD ROWSPAN="2" VALIGN="TOP" WIDTH="217"><IMG SRC="../art/hdrdshow.gif" WIDTH="217" HEIGHT="110" BORDER=0 ALT="DirectShow Animated Header -- Write a Video Capture Filter"></TD>
<TD VALIGN="TOP" WIDTH="383">
<IMG SRC="../art/header3.gif" WIDTH="383" HEIGHT="95" BORDER=0 ALT="DirectShow Animated Header">
</TD>
<TD VALIGN="TOP" WIDTH="100%">
<IMG SRC="../art/spacer1.gif" WIDTH="100%" HEIGHT="94" BORDER=0 ALT="Microsoft DirectShow SDK">
</TD>
</TR>
<!-- HEADGRAPH_END -->

<!-- NAV_LINKS_START -->

<TR><TD VALIGN="TOP"><PRE><IMG ID="TOC_" SRC="../art/yelbtn.gif" WIDTH="11" HEIGHT="11" ALIGN="MIDDLE" BORDER=0 ALT="*"><A STYLE="color:black;font-weight:bold" ID="TOC" HREF="../contents.htm">Contents</A>  <IMG SRC="../art/yelbtn.gif" WIDTH="11" HEIGHT="11" ALIGN="MIDDLE" BORDER=0 ALT="*"><A STYLE="color:black;font-weight:bold" HREF="../index.htm">Index</A>  <IMG SRC="../art/yelbtn.gif" WIDTH="11" HEIGHT="11" ALIGN="MIDDLE" BORDER=0 ALT="*"><A STYLE="color:black;font-weight:bold" HREF="How_to_FiltDev.htm">Topic Contents</A>
</PRE></TD></TR>
<TR><TD COLSPAN="2" VALIGN="TOP"><PRE><IMG SRC="../art/yelbtn.gif" WIDTH="11" HEIGHT="11" ALIGN="MIDDLE" BORDER=0 ALT="*"><B>Previous Topic:</B> <A STYLE="color:black" HREF="How_to_FiltDev.htm">How to...</A>
<IMG SRC="../art/yelbtn.gif" WIDTH="11" HEIGHT="11" ALIGN="MIDDLE" BORDER=0 ALT="*"><B>Next Topic:</B> <A  STYLE="color:black" HREF="Write_Audio_Capture_Filter.htm">Write an Audio Capture Filter</A>
</PRE></TD></TR></TABLE>
<!-- NAV_LINKS_END -->


<BLOCKQUOTE CLASS="body">


<!-- CONTENTS_START -->

<H1>Write a Video Capture Filter</H1>

<P>This article outlines important points to consider when writing a video capture <A CLASS="Glossary" HREF="javascript:Glossary(sRelPath + 'gloss/gloss_f.htm#filter')">filter</A>. The Microsoft&#174; DirectShow&#153; SDK includes a standard <A HREF="../filtsamp/VFW_Video_Capture.htm#VFW_Video_Capture">VFW Video Capture</A> filter.

<P>This article contains the following topics:
<UL><LI><A HREF="Write_Video_Capture_Filter.htm#caprules_1">Capture and Preview Pin Requirements</A>
<LI><A HREF="Write_Video_Capture_Filter.htm#caprules_2">Optimizing Capture Versus Preview (Optional)</A>
<LI><A HREF="Write_Video_Capture_Filter.htm#caprules_3">Registering a Video Capture Filter</A>
<LI><A HREF="Write_Video_Capture_Filter.htm#caprules_4">Producing Data</A>
<LI><A HREF="Write_Video_Capture_Filter.htm#caprules_5">Controlling Individual Streams</A>
<LI><A HREF="Write_Video_Capture_Filter.htm#caprules_6">Time Stamping</A>
<LI><A HREF="Write_Video_Capture_Filter.htm#Frame_Rates">Frame Rates</A>
<LI><A HREF="Write_Video_Capture_Filter.htm#caprules_7">Implementing IAMDroppedFrames</A>
<LI><A HREF="Write_Video_Capture_Filter.htm#caprules_8">Necessary Interfaces</A>
</UL>
<h2><A NAME="caprules_1"></A>Capture and Preview Pin Requirements</h2>
<P>The capture <A CLASS="Glossary" HREF="javascript:Glossary(sRelPath + 'gloss/gloss_P.htm#pin')">pin</A> and preview pin (if there is one) of the capture filter must support the <A HREF="../ref/iface/IKsPropertySet.htm#IKsPropertySet">IKsPropertySet</A> interface. Applications call this interface to ask &quot;what category of pin are you?&quot; by getting the <A HREF="../ref/propset_Pin.htm#AMPROPERTY_PIN_CATEG">AMPROPERTY_PIN_CATEGORY</A> value of the <A HREF="../ref/propset_Pin.htm#AMPROPSETID_Pin">AMPROPSETID_Pin</A> property set. The value you return is typically either the <A HREF="../ref/propset_Pin.htm#PIN_CATEGORY_CAPTURE">PIN_CATEGORY_CAPTURE</A> or <A HREF="../ref/propset_Pin.htm#PIN_CATEGORY_PREVIEW">PIN_CATEGORY_PREVIEW</A> <A CLASS="Glossary" HREF="javascript:Glossary(sRelPath + 'gloss/gloss_G.htm#GUID')">GUID</A>. (See <A HREF="../ref/propset_Pin.htm#Propset_3">Pin Property Set</A> for a complete list of pin categories.) A capture filter must support <B>IKsPropertySet</B> or an application can't tell how to connect the filter in a <A CLASS="Glossary" HREF="javascript:Glossary(sRelPath + 'gloss/gloss_F.htm#filter_graph')">filter graph</A>. 

<P>You can name the pin anything you want and you can have other <A CLASS="Glossary" HREF="javascript:Glossary(sRelPath + 'gloss/gloss_O.htm#output_pin')">output pins</A> for any additional purposes that you want. If your pin name begins with the tilde (~) character, the filter graph will not automatically render that pin when an application calls <A HREF="../ref/iface/IGraphBuilder.htm#RenderFile">IGraphBuilder::RenderFile</A>. For instance, if you have a capture filter with both a capture pin and a preview pin, you might want to name the capture pin &quot;~capture&quot; and the preview pin &quot;preview.&quot; Given those names, if an application renders that filter in a graph, the preview pin will be connected to a video <A CLASS="Glossary" HREF="javascript:Glossary(sRelPath + 'gloss/gloss_R.htm#renderer')">renderer</A>, and nothing will be connected to the capture filter, which is probably what you want to happen by default. This can also apply to pins that are just informational and are not meant to be rendered, or need to be enumerated so that their properties can be set. 

<P>The tilde (~) prefix only affects the behavior of <A HREF="../ref/iface/IGraphBuilder.htm#RenderFile">RenderFile</A> and intelligent connect (<A HREF="../ref/iface/IGraphBuilder.htm#Connect">IGraphBuilder::Connect</A>). Note that intelligent connect can still be used to connect pins with this property if they implement the <A HREF="../ref/iface/IPin.htm#Connect">IPin::Connect</A> method. However, output pins of intermediate filters which are being used to complete the connection which have the tilde at the start of their name will not be connected as part of the intelligent connection attempt.

<P>See <A HREF="Write_Audio_Capture_Filter.htm#audcap_1">Audio Capture Pin Requirements</A> for more details about audio capture filters.

<P>The following sample code demonstrates how to implement <A HREF="../ref/iface/IKsPropertySet.htm#IKsPropertySet">IKsPropertySet</A> on a capture pin.


<PRE>
//
// PIN CATEGORIES - let the world know that we are a CAPTURE pin
//

HRESULT CMyCapturePin::Set(REFGUID guidPropSet, DWORD dwPropID, LPVOID pInstanceData, DWORD cbInstanceData, LPVOID pPropData, DWORD cbPropData)
{
    return E_NOTIMPL;
}

// To get a property, the caller allocates a buffer which the called
// function fills in. To determine necessary buffer size, call Get with
// pPropData=NULL and cbPropData=0.
HRESULT CMyCapturePin::Get(REFGUID guidPropSet, DWORD dwPropID, LPVOID pInstanceData, DWORD cbInstanceData, LPVOID pPropData, DWORD cbPropData, DWORD *pcbReturned)
{
    if (guidPropSet != AMPROPSETID_Pin)
&#009;return E_PROP_SET_UNSUPPORTED;

    if (dwPropID != AMPROPERTY_PIN_CATEGORY)
&#009;return E_PROP_ID_UNSUPPORTED;

    if (pPropData == NULL &amp;&amp; pcbReturned == NULL)
&#009;return E_POINTER;

    if (pcbReturned)
&#009;*pcbReturned = sizeof(GUID);

    if (pPropData == NULL)
&#009;return S_OK;

    if (cbPropData &lt; sizeof(GUID))
&#009;return E_UNEXPECTED;

    *(GUID *)pPropData = PIN_CATEGORY_CAPTURE;
    return S_OK;
}


// QuerySupported must either return E_NOTIMPL or correctly indicate
// if getting or setting the property set and property is supported.
// S_OK indicates the property set and property ID combination is
HRESULT CMyCapturePin::QuerySupported(REFGUID guidPropSet, DWORD dwPropID, DWORD *pTypeSupport)
{
    if (guidPropSet != AMPROPSETID_Pin)
&#009;return E_PROP_SET_UNSUPPORTED;

    if (dwPropID != AMPROPERTY_PIN_CATEGORY)
&#009;return E_PROP_ID_UNSUPPORTED;

    if (pTypeSupport)
&#009;*pTypeSupport = KSPROPERTY_SUPPORT_GET;
    return S_OK;
}
</PRE>
<h2><A NAME="caprules_2"></A>Optimizing Capture Versus Preview (Optional)</h2>
<P>When your filter is running and capturing data, you must send a copy of the frame from your preview pin as well as from your capture pin. If you can do hardware-assisted preview - through an overlay, for example - and if you have a preview pin, you can use the <A HREF="../ref/iface/IOverlay.htm#IOverlay">IOverlay</A> interface <A CLASS="Glossary" HREF="javascript:Glossary(sRelPath + 'gloss/gloss_T.htm#transport')">transport</A> for your preview pin instead of the <A HREF="../ref/iface/IMemInputPin.htm#IMemInputPin">IMemInputPin</A> interface. Using <B>IOverlay</B> is optional. If you can't do hardware-assisted preview, only send a frame out the preview pin if you have some spare time. Don't do it if it will make you drop any frames - the capture pin has priority.

<P>For example, you might deliver a frame from the preview pin only if you have nothing to send from the capture pin right now and the <A CLASS="Glossary" HREF="javascript:Glossary(sRelPath + 'gloss/gloss_D.htm#downstream_filter')">downstream filter</A> has released all buffers previously delivered from the capture pin.

<P>If you can capture only one format of data, and the preview and capture pins must therefore produce the same media type, or if you want information about how to properly reconnect pins, read on. Otherwise, skip this section.

<P>Send data of the same format from the preview and capture pins. If the <A CLASS="Glossary" HREF="javascript:Glossary(sRelPath + 'gloss/gloss_F.htm#filter_graph_manager')">filter graph manager</A> reconnects your capture pin with a different format, you must reconnect your preview pin with the same format to make it work. If your capture pin is connected but your preview pin is not, you must allow only your preview pin to connect with the same media type as the capture pin. They must match.

<P>The following sample code shows how the reconnection should work. 
<PRE>
// The capture pin cannot accept a media type if the preview pin is connected to a filter 
// that won't accept the new media type. The preview pin must always output the same type as 
// the capture pin.
//
CCapturePin::CheckMediaType(CMediaType *pmt)
{
	if (m_pMyPreviewPin->IsConnected()) {
		// Does the preview pin's connection like this type?
  		if (m_pMyPreviewPin->GetConnected()->QueryAccept(pmt) != NOERROR) {
			// Sorry, the preview pin can't reconnect with this new type.
			return E_INVALIDARG;
		}
	}

	// You decide if you like this media type or not, maybe by
	// knowing what the capture pin will connect with. But don't
	// worry; when the capture pin is connected, you will be 
	// reconnected to use the same format.

	return NOERROR;
}


// The preview pin can only accept the media type that the capture pin is using.
//
CPreviewPin::CheckMediaType(CMediaType *pmt)
{
	CMediaType cmt = m_pMyCapturePin->m_mt;
 	if (m_pMyCapturePin->IsConnected() && *pmt != cmt)
		// Sorry, the preview pin is only allowed to connect with
		// the same format as the capture pin.
		return E_INVALIDARG;

	else if (!m_pMyCapturePin->IsConnected())
		// You decide if you like this media type or not, maybe by
		// knowing what the capture pin will connect with. But don't
		// worry; when the capture pin is connected, you will be 
		// reconnected to use the same format.

	// If the capture pin is connected, and this is the same media type,
	// you are OK.
	return NOERROR;
}

// The capture pin is being told to use a certain media type. Now the preview pin
// must be made to use that same mediatype.
//
CCapturePin::SetMediaType(CMediaType *pmt);
{
    if (m_pMyPreviewPin->IsConnected()) {

	// You need to reconnect the preview pin with this media type.
  	if (m_pMyPreviewPin->GetConnected()->QueryAccept(pmt) == NOERROR) {

		// The other filter that the preview pin is connected to
		// can accept this new media type, so simply reconnect.
		m_pFilter->m_pGraph->Reconnect(m_pMyPreviewPin);
	}
    }
}
</PRE>
<h2><A NAME="caprules_3"></A>Registering a Video Capture Filter</h2>
<P>You must register your filter in the video capture filter category. See <A HREF="../ref/utilfunct/DLL_Setup_functs.htm#AMovieDllRegisterServer2">AMovieDllRegisterServer2</A> for more information. 

<h2><A NAME="caprules_4"></A>Producing Data</h2>
<P>Produce data on capture and preview pins only when the filter graph is in a running state. You do not send data from your pins when the filter graph is paused. This will confuse the filter graph unless you return <A HREF="../ref/Error_Success_Codes.htm#VFW_S_CANT_CUE">VFW_S_CANT_CUE</A> from the <A HREF="../ref/class/CBaseFilter.htm#GetState">CBaseFilter::GetState</A> function, warning the filter graph that you do not send data when paused. The following code shows you what to do.

<PRE>
CMyVidcapFilter::GetState(DWORD dw, FILTER_STATE *State)
{
&#009;*State = m_State;
&#009;if (m_State == State_Paused)
&#009;&#009;return VFW_S_CANT_CUE;
&#009;else
&#009;&#009;return S_OK;
}
</PRE>
<h2><A NAME="caprules_5"></A>Controlling Individual Streams</h2>
<P>All output pins should support the <A HREF="../ref/iface/IAMStreamControl.htm#IAMStreamControl">IAMStreamControl</A> interface, so an application can turn each pin on or off individually (for instance, to preview without capturing). <B>IAMStreamControl</B> enables you to switch between preview and capture without rebuilding a different graph.

<h2><A NAME="caprules_6"></A>Time Stamping</h2>
<P>When you capture a frame and are sending it, <A CLASS="Glossary" HREF="javascript:Glossary(sRelPath + 'gloss/gloss_T.htm#time_stamp')">time stamp</A> the frame with the time the graph's clock says it is when the frame is captured. The end time is the start time plus the duration. For example, if you are capturing at 10 frames per second, and the graph's clock says 200,000,000 units at the time the frame is captured, the sample is stamped (200000000, 201000000) (there are 10,000,000 units per second).

<P>A preview frame should have no time stamp because of latency problems. The latency is due to the fact that, if the time of the sample is the graph's time when it leaves the preview pin, by the time the sample gets to the renderer, it will be late. Therefore the renderer may choose not to draw the sample in order to save time and &quot;catch up,&quot; which can't happen for a live stream. Implementing <A HREF="../ref/iface/IAMStreamControl.htm#IAMStreamControl">IAMStreamControl</A> requires time stamps, so you can choose not to implement stream control on the preview pin, only time stamp the preview pin sample when there are outstanding requests to start or stop, or live with the latency problem. See the source code for the <A HREF="../filtsamp/Source_Filters.htm#VidCap">VidCap Sample (Video Capture Filter)</A> sample for details.

<P>You should set the <A CLASS="Glossary" HREF="javascript:Glossary(sRelPath + 'gloss/gloss_M.htm#media_time')">media time</A> of the sample you deliver; also set the regular time stamp for your capture pin. The media time is the frame number of the sample. For example, if you are capturing and sending frames and frame 3 gets dropped, you would set the media time values to be (0,1) (1,2) (2,3) (4,5) (5,6) and so on. This informs the downstream filters if any video frames were dropped even when the regular time stamps are a little random because the clock being used is not the video digitizing clock.

<P>Also, if you are in a running state, and then pause, and then run again, you must not send a sample with a time stamp less than the last one you sent before pausing. Time stamps can never go back in time, not even back to before a pause occurred.

<h2><A NAME="Frame_Rates"></A>Frame Rates</H2>
<p>The frame rate at which your filter should produce data is determined by the <A HREF="../ref/structs.htm#VIDEOINFOHEADER_AvgTimePerFrame">AvgTimePerFrame</A> <A CLASS="Glossary" HREF="javascript:Glossary(sRelPath + 'gloss/gloss_f.htm#field')">field</A> of the <A HREF="../ref/structs.htm#VIDEOINFOHEADER">VIDEOINFOHEADER</A> of the media type your output pin is connected with. You may not be able to capture at any arbitrary frame rate, but only certain rates. If your pin is connected with a media type that asks for a frame rate you can't provide, you should provide frames at the next lowest frame rate possible.  For instance, if your media type has <B>AvgTimePerFrame</B>=333333 (approx 1/30 of a second, meaning 30 frames per second), and you can only capture 29.97 or 35 frames per second, you should provide frames at 29.97 frames per second, since that is the closest value lower than 30 that you can provide. You can provide a higher frame rate than asked if the frame rate you provide does not create frame durations more than 1 microsecond shorter than requested, since the <B>AvgTimePerFrame</B> may simply have rounding errors. If the <B>AvgTimePerFrame</B> field is 0, you can supply frames at any default frame rate that you like.
<h2><A NAME="caprules_7"></A>Implementing IAMDroppedFrames</H2>
<P>
<P>A capture filter's video output pin should always implement the <A HREF="../ref/iface/IAMDroppedFrames.htm">IAMDroppedFrames</A> interface.

<P>When a capture filter runs, it sends frame numbers beginning with the sequence 0, 1, 2, 3 (numbers will be missing if frames were dropped). The time stamp of each frame sent corresponds to the filter graph clock's time when the image was digitized. The end time is the start time plus the video frame's duration.

<P>Set the media time of each sample by using <A HREF="../ref/class/CMediaSample.htm#SetMediaTime">CMediaSample::SetMediaTime</A> and using frame numbers for the start and end times. For example, the start-time and end-time sequence might appear as follows: (0,1) (1,2) (2,3).
A downstream filter can easily tell that a frame was dropped by checking for gaps in the frame number sequence rather than by looking for gaps in the regular time stamps. The following start-time and end-time sequence reveals that frame number 3 was dropped: (1,2) (2,3) (4,5) (5,6).

<P>Every time a capture filter goes from <A HREF="../ref/dtypes.htm#State_Stopped">State_Stopped</A> to <A HREF="../ref/dtypes.htm#State_Paused">State_Paused</A>, it should reset all counts to zero.

<P>If your filter runs, pauses, and then runs again, you must continue to deliver frames as if it never paused. The first frame after the second run can't be time stamped earlier than the last frame sent before the pause. That is, your filter must always increment the media time of each sample sent. Never send the same frame number twice, and never go back in time. 




<h2><A NAME="caprules_8"></A>Necessary Interfaces</h2>
<P>Read about the following interfaces and consider implementing them. You should implement these interfaces to provide functionality that applications might rely on, so these interfaces are strongly recommended.

<UL><LI>Implement <A HREF="../ref/iface/IAMDroppedFrames.htm#IAMDroppedFrames">IAMDroppedFrames</A> on your filter or on each output pin that sends data.
<LI>Implement <A HREF="../ref/iface/IAMStreamConfig.htm#IAMStreamConfig">IAMStreamConfig</A> on each output pin that sends video data.
<LI>Implement <A HREF="../ref/iface/IAMStreamControl.htm#IAMStreamControl">IAMStreamControl</A> on each output pin that sends data.
<LI>Implement <A HREF="../ref/iface/IAMVideoCompression.htm#IAMVideoCompression">IAMVideoCompression</A> on each output pin that sends video data.
</UL>

<!-- CONTENTS_END -->

<!-- START_PAGE_FOOTER -->


<H6><HR size=1></H6>
<P><A Class="line" HREF="#pagetop"><IMG src="../art/arrowup1.gif" WIDTH="11" HEIGHT="11" ALIGN="MIDDLE" BORDER=0 ALT="Top of Page">&nbsp;Top of Page</A>
<BR><A HREF="../../cpyright.htm">&#169; 1998 Microsoft Corporation. All rights reserved. Terms of Use.</A>
<!-- END_PAGE_FOOTER -->

</BLOCKQUOTE>

<SCRIPT>if((g_isIE == true) && (g_iMaj > 3)) {window.self.document.writeln('<SCR' + 'IPT SRC="../tip2.js"></SCR' + 'IPT><IFRAME ID="G_L_S" NAME="SecretBuffer" STYLE="display: none" SRC=""></IFRAME>')}</SCRIPT>

<!-- DACONTROL_START -->

	<DIV ID="HeadGraphAnim"></DIV>
	<SCRIPT>if((g_isIE == true) && (g_iMaj > 3)) {window.self.document.writeln('<SCR' + 'IPT SRC="../anim.js"></SCR' + 'IPT>')}</SCRIPT>
<!-- DACONTROL_END -->

</BODY>
</HTML>
