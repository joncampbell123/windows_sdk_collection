<!-- DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN" -->

<HTML>
<HEAD><TITLE>Creating a Transform Filter</TITLE>
<SCRIPT> var sRelPath = '../' </SCRIPT>


<META NAME="Description" CONTENT="Creating a Transform Filter">
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; CHARSET=iso8859-1">
<META NAME="MS.LOCALE" CONTENT="EN-US">
<META NAME="ROBOTS" CONTENT="all">

<!-- SNIFF_START -->

<SCRIPT>
//<!--
var g_isIE = false, g_isNav = false, g_iMaj = 0, g_sPlat = "";
// -->

</SCRIPT>
<SCRIPT SRC="../ver.js"></SCRIPT>
<SCRIPT SRC="../gloss.js"></SCRIPT>

<!-- SNIFF_END -->


<SCRIPT DEFER SRC="../common.js"></SCRIPT>
<SCRIPT DEFER>
//<!--
function InitPage()
{
	if (g_isIE && g_iMaj >= 4)	
	{

		SetTOC();
	}
}
//-->

</SCRIPT>

<!-- SNIFF_END -->


<!-- STYLE_START -->

<SCRIPT>
//<!--
   var sVR = '../'	// Set root for the style sheet
   var sCSS = '<LINK REL="stylesheet" HREF="' + sVR;

   if(g_isIE)
   {
	   if (g_iMaj >= 4) // For MSIE 4.0 or later
	   {
		   sCSS += 'dxm_basicsdkIE4';
		   if (g_sPlat == "Win") // Windows only for now
		   {
			   document.createStyleSheet(sVR + 'dxm_advSDKIE4.css');
		   }
	   }
	   else // For MSIE 3.0 or earlier
	   {
		   sCSS += 'dxm_basicsdkIE3';
	   }
   }
   else if (g_isNav) // For all Nav versions
   {
	   sCSS += 'dxm_basicsdkNAV';
   }
   else
   {
	   sCSS += 'dxm_basicsdkIE3'; // default to IE3 sheet
   }

   sCSS += (sCSS == '' ? '' : '.css" TYPE="text/css">');

   document.write(sCSS);
//-->

</SCRIPT>
<!-- STYLE_END -->


</HEAD>
<BODY onload="InitPage(); if (g_isIE && g_iMaj >= 4){HdgrphControl()}" BGCOLOR="#FFFFFF">
<A NAME="pagetop"></A><A NAME="tfilt"></A>

<!-- HEADGRAPH_START -->

<TABLE CLASS="main" BORDER=0 CELLSPACING="0" CELLPADDING="0" WIDTH="*">
<TR>
<TD ROWSPAN="3" VALIGN="TOP" WIDTH="*">
<IMG SRC="../art/header1.gif" WIDTH="107" HEIGHT="110" BORDER=0 ALT="DirectShow Animated Header"></TD>
<TD ROWSPAN="2" VALIGN="TOP" WIDTH="217"><IMG SRC="../art/hdrdshow.gif" WIDTH="217" HEIGHT="110" BORDER=0 ALT="DirectShow Animated Header"></TD>
<TD VALIGN="TOP" WIDTH="383">
<IMG SRC="../art/header3.gif" WIDTH="383" HEIGHT="95" BORDER=0 ALT="DirectShow Animated Header">
</TD>
<TD VALIGN="TOP" WIDTH="100%">
<IMG SRC="../art/spacer1.gif" WIDTH="100%" HEIGHT="94" BORDER=0 ALT="Microsoft DirectShow SDK">
</TD>
</TR>
<!-- HEADGRAPH_END -->

<!-- NAV_LINKS_START -->

<TR><TD VALIGN="TOP"><PRE><IMG ID="TOC_" SRC="../art/yelbtn.gif" WIDTH="11" HEIGHT="11" ALIGN="MIDDLE" BORDER=0 ALT="*"><A STYLE="color:black;font-weight:bold" ID="TOC" HREF="../contents.htm">Contents</A>  <IMG SRC="../art/yelbtn.gif" WIDTH="11" HEIGHT="11" ALIGN="MIDDLE" BORDER=0 ALT="*"><A STYLE="color:black;font-weight:bold" HREF="../index.htm">Index</A>  <IMG SRC="../art/yelbtn.gif" WIDTH="11" HEIGHT="11" ALIGN="MIDDLE" BORDER=0 ALT="*"><A STYLE="color:black;font-weight:bold" HREF="Transform_Filters.htm">Topic Contents</A>
</PRE></TD></TR>
<TR><TD COLSPAN="2" VALIGN="TOP"><PRE><IMG SRC="../art/yelbtn.gif" WIDTH="11" HEIGHT="11" ALIGN="MIDDLE" BORDER=0 ALT="*"><B>Previous Topic:</B> <A STYLE="color:black" HREF="Transform_Filters.htm">Transform Filters</A>
<IMG SRC="../art/yelbtn.gif" WIDTH="11" HEIGHT="11" ALIGN="MIDDLE" BORDER=0 ALT="*"><B>Next Topic:</B> <A  STYLE="color:black" HREF="Using_CTransformFilter_CTransInPlaceFilter.htm">Using the CTransformFilter and CTransInPlaceFilter Transform Base Classes</A>
</PRE></TD></TR></TABLE>
<!-- NAV_LINKS_END -->


<BLOCKQUOTE CLASS="body">


<!-- CONTENTS_START -->

<H1>Creating a Transform Filter</H1>

<P><A CLASS="Glossary" HREF="javascript:Glossary(sRelPath + 'gloss/gloss_T.htm#transform_filter')">Transform filters</A> transform the media data that comes into their <A CLASS="Glossary" HREF="javascript:Glossary(sRelPath + 'gloss/gloss_I.htm#input_pin')">input pins</A> and send the transformed data out their <A CLASS="Glossary" HREF="javascript:Glossary(sRelPath + 'gloss/gloss_O.htm#output_pin')">output pins</A>. Transform <A CLASS="Glossary" HREF="javascript:Glossary(sRelPath + 'gloss/gloss_f.htm#filter')">filters</A> can be used to compress and decompress data, to split audio and visual data, or to apply effects, such as contrast or warbling, to media data. DirectShow contains several sample transform filters that perform different kinds of transformations. See <A HREF="../filtsamp/DS_Filters_intro.htm">DirectShow Filters</A> for a description of the transform filters supplied by DirectShow. See <A HREF="Write_Transform_Filter_C_C++.htm">Write a Transform Filter in C/C++</A> for instructions on how to write your own transform filters in C++. See <A HREF="Using_CTransformFilter_CTransInPlaceFilter.htm">Using the CTransformFilter and CTransInPlaceFilter Transform Base Classes</A> for a discussion of the <A HREF="../ref/class/CTransformFilter.htm#CTransformFilter">CTransformFilter</A> and <A HREF="../ref/class/CTransInPlaceFilter.htm#CTransInPlaceFilter">CTransInPlaceFilter</A> transform filter base classes. See <A HREF="Connecting_Transform_Filters.htm">Connecting Transform Filters</A> for a discussion of connecting to a transform filter. 

<P>This article steps through the process of creating a transform filter for a 
Microsoft&#174; DirectShow&#153; <A CLASS="Glossary" HREF="javascript:Glossary(sRelPath + 'gloss/gloss_F.htm#filter_graph')">filter graph</A> that uses the DirectShow C++ class library. It covers five basic steps, and in the last step shows how to override the required member functions in your derived class to implement the transform filter. It answers two common questions that arise when creating transform filters: Which base class do I use? and How do I override member functions? 

<P>This article contains the following sections.
<UL>
<LI><A HREF="Creating_Transform_Filter.htm#tfilt_1">Write a Transform Filter</A>
<LI><A HREF="Creating_Transform_Filter.htm#tfilt_2">Determine if the Filter Must Copy Media Samples</A>
<LI><A HREF="Creating_Transform_Filter.htm#Determining_Which_Base_Classes_to_Use">Determine Which Base Classes to Use</A>
<LI><A HREF="Creating_Transform_Filter.htm#tfilt_4">Instantiate the Filter</A>
<LI><A HREF="Creating_Transform_Filter.htm#tfilt_5">Make Added Interfaces Available Through NonDelegatingQueryInterface</A>
<LI><A HREF="Creating_Transform_Filter.htm#Determining_Which_Member_Functions_to_Override">Override the Base Class Member Functions</A>
</UL>

<h2><A NAME="tfilt_1"></A>Write a Transform Filter</h2>
<P>Writing a transform filter can be broken into the following discrete steps.
<OL><LI>Determine if the filter must copy media samples or can handle them in place. 
<P>The fewer copies in the media stream, the better. However, some filters require a copy 
operation; this influences the choice of base classes. 

<LI>Determine which base classes to use and derive the filter class (and <A CLASS="Glossary" HREF="javascript:Glossary(sRelPath + 'gloss/gloss_P.htm#pin')">pin</A> classes, if necessary) from the base classes.
<P>In this step, create the header or headers for your filter. In many cases, you can use the transform base 
classes, derive your class from the correct transform filter class, and override a few member functions. In 
other cases, you can use the more generic base classes. These classes implement most of the connection 
and negotiation mechanism; but these classes also allow more flexibility at the cost of overriding more 
member functions.

<LI>Add the code necessary to instantiate the filter.
<P>This step requires adding a static <B>CreateInstance</B> member function to your derived class and also a global array that contains the name of the filter, a CLSID, and a pointer to that member function.


<LI>Add a <B>NonDelegatingQueryInterface</B> member function to pass out any unique interfaces in your filter. 
<P>This step addresses the Component Object Model (COM) aspects of implementing interfaces, other than those in the base classes. 

<LI>Override the appropriate base class member functions. 
<P>This includes writing the transform function that is unique to your filter and overriding a few member 
functions that are necessary for the connection process, such as setting the allocator size or providing 
media types.
</OL>
<h2><A NAME="tfilt_2" IDX_CONCEPT="noindex; media samples, determining if the filter must copy; copying media samples, determining if the filter should"></A>Determine if the Filter Must Copy Media Samples</h2>
<P>Because every copy operation uses valuable CPU cycles, filter developers are encouraged to avoid 
copying the media samples, if possible. It is best to write the filter to modify media samples in place on an 
allocator acquired from another filter. In some cases, this is not possible, and a copy operation must be 
performed. 

<P>Where no copy is needed, the run-time overhead of a <A CLASS="Glossary" HREF="javascript:Glossary(sRelPath + 'gloss/gloss_T.htm#transform_inplace_fi')">transform-inplace filter</A> is scarcely more than that of a function; however, by packaging the transform as a filter, you get the full flexibility of the filter graph architecture.

<P>Some reasons that a filter might be written as a copy transform filter rather than a transform-inplace 
filter
 include the following:
<UL><LI>If the transformation generates more data on output than space provided in the allocator of the 
 input (for example, a decompressor filter), or if the transformation generates less data on output and 
 must consolidate memory.

<LI>If the original media data must be preserved; this is the case with the splitter, 
where the transform filter splits off a stream of data.

<LI>If a decompressor filter is performing temporal compression, relying on adjacent frames for delta 
information. In this case, a separate copy must be made, primarily because the decompressor cannot 
allow another filter to have access to the original data to modify it. 

<LI>If the filter relies on a queue; for example, a filter that creates a queue to help smooth the delivery of irregularly spaced video frames would need to copy the samples.
</UL>
<h2><A NAME="Determining_Which_Base_Classes_to_Use" IDX_CONCEPT="noindex; Base Classes, determining which to use"></A>Determine Which Base Classes to Use</h2>
<P>Before choosing a base class for your transform filter, you must first decide whether your filter needs more than one input and output pin. If it does, you should derive your filter class from <A HREF="../ref/class/CBaseFilter.htm#CBaseFilter">CBaseFilter</A>.

<P>If your filter needs to perform a video transform, you should derive your filter class from <A HREF="../ref/class/CVideoTransformFilter.htm#CVideoTransformFilter">CVideoTransformFilter</A>.

<P>Otherwise, you should derive your filter class from <A HREF="../ref/class/CTransformFilter.htm#CTransformFilter">CTransformFilter</A> or <A HREF="../ref/class/CTransInPlaceFilter.htm#CTransInPlaceFilter">CTransInPlaceFilter</A>. To determine which one to use, you must decide whether your filter must copy media samples or can transform them in place. Because every copy operation uses valuable CPU cycles, filter developers should avoid copying media samples, if possible. It is best to write a filter to modify media samples in place on an allocator acquired from another filter. In some cases, this isn't possible, and you must perform a copy operation.

<P>Where no copy is needed, the run-time overhead of a transform-inplace filter isn't much more than that of a function. However, by packaging the transform as a filter, you get the full flexibility of the filter graph architecture.

<P>Some reasons that you might write a filter as a copy transform filter rather than a transform-inplace filter are:

<UL><LI>If the transformation generates more data on output than there is space already allocated for the input (for example, a decompressor filter), or if the transformation generates less data on output and must consolidate memory.
<LI>If the original media data must be preserved. This is the case with the splitter, where the transform filter splits off a stream of data.
<LI>If a decompressor filter is performing temporal compression, relying on adjacent frames for information about what has changed frame to frame. In this case, you must make a separate copy, primarily because the decompressor can't allow another filter to have access to the original data to modify it. 
<LI>If the filter relies on a queue; for example, a filter that creates a queue to help smooth the delivery of irregularly spaced video frames would need to copy the samples.
</UL>
<P>Once you determine whether the transform filter will copy media samples or transform them in place, you must decide which base class or classes to use and which member functions you must override and implement. You can then define your derived classes. 

<P>Some member functions in the base classes must be overridden in your derived class because they are either declared as pure virtual in the base classes (they have no implementation), or have default implementations that do nothing but return an error value.

<P>You derive your filter class from the transform base classes <A HREF="../ref/class/CTransformFilter.htm#CTransformFilter">CTransformFilter</A>, <A HREF="../ref/class/CTransInPlaceFilter.htm#CTransInPlaceFilter">CTransInPlaceFilter</A>, or <A HREF="../ref/class/CVideoTransformFilter.htm#CVideoTransformFilter">CVideoTransformFilter</A>, or from the more generic <A HREF="../ref/class/CBaseFilter.htm#CBaseFilter">CBaseFilter</A> filter class. Most of the connection, media type, and allocator negotiation code is handled in the base classes and inherited by the transform classes. The transform classes make it possible to create a filter by deriving just one filter class (no pin classes). The transform classes make assumptions about the workings of transform filters that make the process of creating a transform filter easier. 

<P>To learn more about <A HREF="../ref/class/CTransformFilter.htm#CTransformFilter">CTransformFilter</A> and <A HREF="../ref/class/CTransInPlaceFilter.htm#CTransInPlaceFilter">CTransInPlaceFilter</A> and which of their member functions are typically overridden by the derived class, see <A HREF="Using_CTransformFilter_CTransInPlaceFilter.htm">Using the CTransformFilter and CTransInPlaceFilter Transform Base Classes</A>.
<h2><A NAME="tfilt_4"></A>Instantiate the Filter</h2>
<P>All filters must add code to let the base classes instantiate the filter. To instantiate a filter, 
you must include two pieces of code in your filter: a static <B>CreateInstance</B> member function 
in the derived filter class, and a means of informing the <A CLASS="Glossary" HREF="javascript:Glossary(sRelPath + 'gloss/gloss_C.htm#class_factory')">class factory</A> in the base classes 
how to access this function. 

<P>Typically, the <B>CreateInstance</B> member function calls the constructor for the derived 
filter class. The following is the <B>CreateInstance</B> member function from the Gargle sample filter.

<PRE>
CUnknown *CGargle::CreateInstance(LPUNKNOWN punk, HRESULT *phr) {

    CGargle *pNewObject = new CGargle(NAME("Gargle Filter"), punk, phr);
    if (pNewObject == NULL) {
        *phr = E_OUTOFMEMORY;
    }

    return pNewObject;
} // CreateInstance

</PRE>
<P>To communicate with the class factory, declare a global array of <A HREF="../ref/class/CFactoryTemplate.htm#CFactoryTemplate">CFactoryTemplate</A> objects as 
g_Templates and provide the name of your filter, the class identifier (CLSID) of your filter, and a pointer 
to the static <B>CreateInstance</B> member function that creates your filter object. The Gargle sample 
filter does this as follows:
<PRE>
// Needed for the CreateInstance mechanism
CFactoryTemplate g_Templates[2]=
    { { L"Gargle filter"              , &amp;CLSID_Gargle , CGargle::CreateInstance          }
    , { L"Gargle filter Property Page", &amp;CLSID_GargProp, CGargleProperties::CreateInstance}
    };

int g_cTemplates = sizeof(g_Templates)/sizeof(g_Templates[0]);

</PRE>
<P>You can add additional parameters to the <A HREF="../ref/class/CFactoryTemplate.htm#CFactoryTemplate">CFactoryTemplate</A> templates if you want your 
filter to be self-registering. For more information on this, see <A HREF="../appdev/Register_DS_Objects.htm">Register DirectShow Objects</A>. 


<P>Finally, link your filter to strmbase.lib and export <A HREF="../appendixes/Further_Reading.htm#DllGetClassObject">DllGetClassObject</A> and 
<A HREF="../appendixes/Further_Reading.htm#DllCanUnloadNow">DllCanUnloadNow</A> using a .def file.

<h2><A NAME="tfilt_5" IDX_CONCEPT="NonDelegatingQueryInterface, making interfaces available through"></A>Make Added Interfaces Available Through NonDelegatingQueryInterface</h2>
<P> Only filters that add interfaces that are not in the base classes, such as those 
required for creating property pages, need implement the <A HREF="../ref/iface/IUnknown.htm#IUnknown">IUnknown</A> member 
functions (called <A HREF="../ref/utilfunct/INonDelegatingUnknown_iface.htm#INonDelegatingUnknown">INonDelegatingUnknown</A> in the base classes). The base classes 
provide default implementations of the <B>IUnknown</B> methods. <B>IUnknown</B> 
methods in any COM-based code retrieve interfaces from an object, and increment and 
decrement the reference counts of those interfaces. For example, the 
<A HREF="../ref/iface/IUnknown.htm#QueryInterface">IUnknown::QueryInterface</A> method retrieves interfaces from an object. 

<P>DirectShow defines a special <A HREF="../ref/iface/IUnknown.htm#IUnknown">IUnknown</A> class called <A HREF="../ref/utilfunct/INonDelegatingUnknown_iface.htm#INonDelegatingUnknown">INonDelegatingUnknown</A>, 
whose methods do the same thing as <B>IUnknown</B>. (The reason for the name change is so that 
objects can be aggregated.) The <A HREF="../ref/utilfunct/INonDelegatingUnknown_iface.htm#INonDelegatingUnknow">NonDelegatingQueryInterface</A> 
method is called whenever some object or application wants to query a pin or filter for any interfaces
 it implements. If your filter implements any interface outside those listed in the base class 
implementation, you will need to override the <B>NonDelegatingQueryInterface</B> method
 to return a pointer to the implemented interface. For example, the following code example illustrates how 
the Gargle sample overrides the member function to distribute references to the 
<A HREF="../appendixes/Further_Reading.htm#ISpecifyPropertyPage">ISpecifyPropertyPages</A> and <A HREF="../appendixes/Further_Reading.htm#IPersistStream">IPersistStream</A> interfaces. 

<PRE>
// Reveal our persistent stream, property pages, and IGargle interfaces
STDMETHODIMP CGargle::NonDelegatingQueryInterface(REFIID riid, void **ppv) {

    if (riid == IID_IGargle) {
        return GetInterface((IGargle *) this, ppv);
    } else if (riid == IID_ISpecifyPropertyPages) {
        return GetInterface((ISpecifyPropertyPages *) this, ppv);
    } else if (riid == IID_IPersistStream) {
        AddRef();     // Add a reference count to ourselves
        *ppv = (void *)(IPersistStream *)this;
        return NOERROR;

    } else {
        return CTransInPlaceFilter::NonDelegatingQueryInterface(riid, ppv);
    }
} // NonDelegatingQueryInterface
</PRE>
<P><B>Note</B>  This sample calls the <A HREF="../ref/class/CTransInPlaceFilter.htm#CTransInPlaceFilter">CTransInPlaceFilter</A> implementation of the member 
function to finish up.
<h2><A NAME="Determining_Which_Member_Functions_to_Override" IDX_CONCEPT="Base Class Member Functions, Overriding; Member Functions of Base Classes, Overriding"></A>Override the Base Class Member Functions</h2>
<P>When you determine which base class to use( see <A HREF="Creating_Transform_Filter.htm#Determining_Which_Base_Classes_to_Use">Determine Which Base Classes to Use</A>), you write the header and define which member function to 
implement. You decide either to derive your filter class from the transform base classes 
(<A HREF="../ref/class/CTransformFilter.htm#CTransformFilter">CTransformFilter</A> or 
<A HREF="../ref/class/CTransInPlaceFilter.htm#CTransInPlaceFilter">CTransInPlaceFilter</A>), or from the more generic <A HREF="../ref/class/CBaseFilter.htm#CBaseFilter">CBaseFilter</A> filter class. 
In this section, you learn how to override the following member functions.
<UL><LI><A HREF="Creating_Transform_Filter.htm#Override_the_Transform_Member_Function">Override the Transform Member Function</A>
<LI><A HREF="Creating_Transform_Filter.htm#Override_the_CheckInputType_Member_Function">Override the CheckInputType Member Function</A>
<LI><A HREF="Creating_Transform_Filter.htm#Override_the_CheckTransform_Member_Function">Override the CheckTransform Member Function</A>
<LI><A HREF="Creating_Transform_Filter.htm#Override_the_DecideBufferSize_Member_Function">Override the DecideBufferSize Member Function</A>
<LI><A HREF="Creating_Transform_Filter.htm#Override_the_GetMediaType_Member_Function">Override the GetMediaType Member Function</A>
<LI><A HREF="Creating_Transform_Filter.htm#Override_Pin_Member_Functions">Overrideg Pin Member Functions</A>
<LI><A HREF="Creating_Transform_Filter.htm#Override_CBaseOutput_DecideAllocator_Member_Function">Override the CBaseOutput::DecideAllocator Member Function</A>
</UL>
<h3><A NAME="Override_the_Transform_Member_Function" IDX_CONCEPT="Transform Member Function, Overriding"></A>Override the Transform Member Function</h3>
<P>The <B>Transform</B> member function in your derived class is called each time the 
<A HREF="../ref/iface/IMemInputPin.htm#Receive">IMemInputPin::Receive</A> method on the input pin of the filter is called to transfer another sample. 
Place the code that performs the actual purpose of the filter in this member function, or in the functions 
called from here. Copy transform filters will likely have a private <B>Copy</B> member function associated with the transform code, while transform-inplace functions will simply modify the code in one buffer.

<h3><A NAME="Override_the_CheckInputType_Member_Function" IDX_CONCEPT="CheckMediaType Member Function, Overriding"></A>Override the CheckInputType Member Function</h3>
<P>During the pin connection, the <A HREF="../ref/class/CTransformInputPin.htm#CheckMediaType">CheckMediaType</A> 
member function of the input pin is called to determine whether the proposed media type is acceptable. The 
<A HREF="../ref/class/CTransformInputPin.htm#CheckMediaType">CTransformInputPin::CheckMediaType</A> member function is implemented to call the 
<A HREF="../ref/class/CTransformFilter.htm#CheckInputType">CheckInputType</A> member function of the derived filter 
class with the media type. You must implement this to accommodate the media types your filter can handle. The following code sample outlines part of the CGargle::CheckInputType member function, which rejects any media type but MEDIATYPE_Audio.

<PRE>HRESULT CGargle::CheckInputType(const CMediaType *pmt) {    
&#009;...
    // reject non-Audio type
    if (pmt-&gt;majortype != MEDIATYPE_Audio) {
        return E_INVALIDARG;
    }</PRE>
<h3><A NAME="Override_the_CheckTransform_Member_Function" IDX_CONCEPT="CheckTransform Member Function, Overriding"></A>Override the CheckTransform Member Function</h3>
<P>Copy transform filters can transform the media type from the input pin to output pin. Therefore, if the output pin is connected (so its media type is known), when the <A HREF="../ref/class/CTransformInputPin.htm#CheckMediaType">CTransformInputPin::CheckMediaType</A> member function is called during connection, the <B>CheckTransform</B> member function of the derived class is called to verify that the transform from the input type to the output type is valid. It is also called when <A HREF="../ref/class/CTransformOutputPin.htm#CheckMediaType">CTransformOutputPin::CheckMediaType</A> is called.

<P>In the <A HREF="../ref/class/CTransInPlaceFilter.htm#CTransInPlaceFilter">CTransInPlaceFilter</A> class, this member function is implemented in the base class header file to simply return S_OK, because the functions from <A HREF="../ref/class/CTransformFilter.htm#CTransformFilter">CTransformFilter</A> that call this member function are overridden in <B>CTransInPlaceFilter</B> to call <B>CheckInputType</B> instead. This assumes that the media type doesn't change in a transform-inplace filter, as it might in a copy transform filter. 


<h3><A NAME="Override_the_DecideBufferSize_Member_Function" IDX_CONCEPT="DecideBufferSize Member Function, Overriding"></A>Override the DecideBufferSize Member Function</h3>
<P>Copy transform filters might be required to set the properties of the allocator into which they are copying. This is likely if the <A CLASS="Glossary" HREF="javascript:Glossary(sRelPath + 'gloss/gloss_D.htm#downstream_filter')">downstream filter</A> has provided a newly created allocator (that is, one that hasn't passed an allocator from farther downstream), or if the output pin is forced to create its own allocator. In this case, the pure virtual <A HREF="../ref/class/CBaseOutputPin.htm#DecideBufferSize">CBaseOutputPin::DecideBufferSize</A> member function is called from the <A HREF="../ref/class/CBaseOutputPin.htm#DecideAllocator">CBaseOutputPin::DecideAllocator</A> member function, and the derived class fills in the requirements for the buffer by calling the <A HREF="../ref/iface/IMemAllocator.htm#SetProperties">IMemAllocator::SetProperties</A> method on the allocator object to which it has a reference.

<P>The <A HREF="../ref/class/CTransInPlaceFilter.htm#DecideBufferSize">CTransInPlaceFilter::DecideBufferSize</A> method is never called, because the allocator of another filter is always in use. It is implemented in the base class header file to return E_UNEXPECTED. 

<h3><A NAME="Override_the_GetMediaType_Member_Function" IDX_CONCEPT="GetMediaType Member Function, Overriding"></A>Override the GetMediaType Member Function</h3>
<P>Pins provide enumerators to enable other objects to determine the pin's media type. A pin provides the media type enumerator (the <A HREF="../ref/iface/IEnumMediaTypes.htm#IEnumMediaTypes">IEnumMediaTypes</A> interface), which the pin base classes implement to call the <B>GetMediaType</B> member function in the pin class. In the copy transform filter classes, each pin's <A HREF="../ref/class/CTransformOutputPin.htm#GetMediaType">CTransformOutputPin::GetMediaType</A> member function simply calls the virtual <A HREF="../ref/class/CTransformFilter.htm#GetMediaType">CTransformFilter::GetMediaType</A> member function in the filter class. Your derived class must implement this member function to provide each supported media type in a list of media types. 

<P>In the transform-inplace classes, the enumerators form a transparent channel between the filters upstream and downstream from the transform filter. If the transform filter's input pin must perform an enumeration, it obtains an enumerator from the downstream filter's input pin. If the output pin must perform an enumeration, it obtains an enumerator from the <A CLASS="Glossary" HREF="javascript:Glossary(sRelPath + 'gloss/gloss_U.htm#upstream_filter')">upstream filter's</A> output pin. One consequence of this is that transform-inplace filters can't connect to each other unless at least one of them is connected to something else, because neither of the transform-inplace filters can propose any media type for the connection.

<H3><A NAME="Override_Pin_Member_Functions" IDX_CONCEPT="Pin Member Functions, Overriding">Override Pin Member Functions</A></H3>
<P>If you derived your filter class from the transform classes and want more than one input or output pin, you must override the pin class (for example, <A HREF="../ref/class/CTransformInputPin.htm#CTransformInputPin">CTransformInputPin</A> or <A HREF="../ref/class/CTransformOutputPin.htm#CTransformOutputPin">CTransformOutputPin</A>). If you override the pin class, you must also override the <B>GetPin</B> member function of <A HREF="../ref/class/CTransformFilter.htm#CTransformFilter">CTransformFilter</A> or <A HREF="../ref/class/CTransInPlaceFilter.htm#CTransInPlaceFilter">CTransInPlaceFilter</A>, so that you can create pin objects from your derived classes. If you override one of the pin classes (for example, <B>CTransformInputPin</B>) and override <B>GetPin</B> to create the pin object, you must also override <B>GetPin</B> to create the other pin object of the same base class (for example, <B>CTransformOutputPin</B>). 
<P>If you want more than one input or output pin, it is often simpler to derive your filter from <A HREF="../ref/class/CBaseFilter.htm#CBaseFilter">CBaseFilter</A> rather than from one of the transform classes.

<H3><A NAME="Override_CBaseOutput_DecideAllocator_Member_Function" IDX_CONCEPT="DecideAllocator Member Function, Overriding">Override the CBaseOutput::DecideAllocator Member Function</A></H3>
<P>The base classes implement <A HREF="../ref/class/CBaseOutputPin.htm#DecideAllocator">CBaseOutputPin::DecideAllocator</A> to let the output pin automatically use the downstream pin's allocator. One of the most common alterations in the derived class is to force the use of an object's own allocator (or one from an upstream filter). In the DirectShow model, for example, a <A CLASS="Glossary" HREF="javascript:Glossary(sRelPath + 'gloss/gloss_S.htm#source_filter')">source filter</A> pushes media samples onto the next filter and requires its own allocator. For example, if you write a transform-inplace filter and insert it between a source filter and a decompressor filter, the transform filter must present the source filter's allocator to the decompressor. Therefore, you must override the <B>CBaseOutputPin::DecideAllocator</B> member function. 



<!-- CONTENTS_END -->

<!-- START_PAGE_FOOTER -->


<H6><HR size=1></H6>
<P><A Class="line" HREF="#pagetop"><IMG src="../art/arrowup1.gif" WIDTH="11" HEIGHT="11" ALIGN="MIDDLE" BORDER=0 ALT="Top of Page">&nbsp;Top of Page</A>
<BR><A HREF="../../cpyright.htm">&#169; 1998 Microsoft Corporation. All rights reserved. Terms of Use.</A>
<!-- END_PAGE_FOOTER -->

</BLOCKQUOTE>

<SCRIPT>if((g_isIE == true) && (g_iMaj > 3)) {window.self.document.writeln('<SCR' + 'IPT SRC="../tip2.js"></SCR' + 'IPT><IFRAME ID="G_L_S" NAME="SecretBuffer" STYLE="display: none" SRC=""></IFRAME>')}</SCRIPT>

<!-- DACONTROL_START -->

	<DIV ID="HeadGraphAnim"></DIV>
	<SCRIPT>if((g_isIE == true) && (g_iMaj > 3)) {window.self.document.writeln('<SCR' + 'IPT SRC="../anim.js"></SCR' + 'IPT>')}</SCRIPT>
<!-- DACONTROL_END -->

</BODY>
</HTML>
