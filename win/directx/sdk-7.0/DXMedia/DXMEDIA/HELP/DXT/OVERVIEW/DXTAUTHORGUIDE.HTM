<!-- DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN" -->
<HTML>
<HEAD><TITLE>DirectX Transform Author's Guide</TITLE>
<SCRIPT LANGUAGE="JavaScript"> var sRelPath = '../' </SCRIPT>

<META NAME="KEYWORDS" CONTENT="DirectX Transform Author Guide">
<META NAME="PRODUCT" CONTENT="DirectX Transform Author Guide">
<META NAME="CATEGORY" CONTENT="Technical documentation; download">
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; CHARSET=iso8859-1">
<META NAME="MS.LOCALE" CONTENT="EN-US">
<META NAME="ROBOTS" CONTENT="all">

<!-- SNIFF_START -->
<SCRIPT LANGUAGE="JAVASCRIPT">
//<!--
var g_isIE = false, g_isNav = false, g_iMaj = 0, g_sPlat = "";
// -->
</SCRIPT>
<SCRIPT SRC="../ver.js"></SCRIPT>
<SCRIPT SRC="../gloss.js"></SCRIPT>
<!-- SNIFF_END -->

<SCRIPT DEFER SRC="../common.js"></SCRIPT>
<SCRIPT DEFER>
//<!--
function InitPage()
{
    if (g_isIE && g_iMaj >= 4)    
    {

        SetTOC();
    }
}
//-->
</SCRIPT>

<!-- STYLE_START -->
<SCRIPT LANGUAGE="JAVASCRIPT">
//<!--
   var sVR = '../'    // Set root for the style sheet
   var sCSS = '<LINK REL="stylesheet" HREF="' + sVR;

   if(g_isIE)
   {
       if (g_iMaj >= 4) // For MSIE 4.0 or later
       {
           sCSS += 'dxm_basicSDKIE4';
           if (g_sPlat == "Win") // Windows only for now
           {
               document.createStyleSheet(sVR + 'dxm_advSDKIE4.css');
           }
       }
       else // For MSIE 3.0 or earlier
       {
           sCSS += 'dxm_basicSDKIE3';
       }
   }
   else if (g_isNav) // For all Nav versions
   {
       sCSS += 'dxm_basicSDKNAV';
   }
   else
   {
       sCSS += 'dxm_basicSDKIE3'; // default to IE3 sheet
   }

   sCSS += (sCSS == '' ? '' : '.css" TYPE="text/css">');

   document.write(sCSS);
//-->
</SCRIPT>
<!-- STYLE_END -->

</HEAD>
<BODY onload="InitPage(); if (g_isIE && g_iMaj >= 4){HdgrphControl()}" BGCOLOR="#FFFFFF">
<A NAME="pagetop"></A><A NAME="Pixel_Formats"></A>
<!--TOOLBAR_START-->
<!--TOOLBAR_EXEMPT-->
<!--TOOLBAR_END-->

<!-- HEADGRAPH_START -->
<TABLE CLASS="main" BORDER=0 CELLSPACING="0" CELLPADDING="0" WIDTH="*">
<TR>
<TD ROWSPAN="3" VALIGN="TOP" WIDTH="*">
<IMG SRC="../art/header1.gif" WIDTH="107" HEIGHT="110" BORDER=0 ALT="DirectX Transform Animated Header -- Microsoft DirectX Transform SDK"></TD>
<TD ROWSPAN="2" VALIGN="TOP" WIDTH="217"><IMG SRC="../art/hdrdtrns.gif" WIDTH="217" HEIGHT="110" BORDER=0 ALT="Microsoft DirectX Transform SDK"></TD>
<TD VALIGN="TOP" WIDTH="383">
<IMG SRC="../art/header3.gif" WIDTH="383" HEIGHT="95" BORDER=0 ALT="DirectX Transform Animated Header">
</TD>
<TD VALIGN="TOP" WIDTH="100%">
<IMG SRC="../art/spacer1.gif" WIDTH="100%" HEIGHT="94" BORDER=0 ALT="Microsoft DirectX Transform SDK">
</TD>
</TR>
<!-- HEADGRAPH_END -->
<!-- NAV_LINKS_START -->
<TR><TD VALIGN="TOP"><PRE><IMG ID="TOC_" SRC="../art/yelbtn.gif" WIDTH="11" HEIGHT="11" ALIGN="MIDDLE" BORDER=0 ALT="*"><A STYLE="color:black;font-weight:bold" ID="TOC" HREF="../contents.htm">Contents</A>  <IMG SRC="../art/yelbtn.gif" WIDTH="11" HEIGHT="11" ALIGN="MIDDLE" BORDER=0 ALT="*"><A STYLE="color:black;font-weight:bold" HREF="../index.htm">Index</A>  <IMG SRC="../art/yelbtn.gif" WIDTH="11" HEIGHT="11" ALIGN="MIDDLE" BORDER=0 ALT="*"><A STYLE="color:black;font-weight:bold" HREF="writingtransforms.htm">Topic Contents</A>
</PRE></TD></TR>

<TR><TD COLSPAN="2" VALIGN="TOP"><PRE><IMG SRC="../art/yelbtn.gif" WIDTH="11" HEIGHT="11" ALIGN="MIDDLE" BORDER=0 ALT="*"><B>Previous Topic:</B> <A STYLE="color:black" HREF="about_dxtrans.htm">About Transforms and DXSurfaces</A>
<IMG SRC="../art/yelbtn.gif" WIDTH="11" HEIGHT="11" ALIGN="MIDDLE" BORDER=0 ALT="*"><B>Next Topic:</B> <A STYLE="color:black" HREF="implementation.htm">Implementation Guide</A>
</PRE></TD></TR></TABLE>

<!-- NAV_LINKS_END -->




<BLOCKQUOTE class="body">
<!-- CONTENTS_START -->

<H1>Author's Guide to Transforms</H1>


<P>
This section should be considered &quot;required reading&quot; for transform authors. It contains important information that you need to use in order for your transform to function correctly under Microsoft&reg; DirectX&reg; Transform containers. It also includes conventions and hints that are useful for writing transforms. 
<p>
The information is organized in the following three sections.

<ul>
    <li><a href="#all_transform_topics">Things You Need to Know About All Transforms</a>
    <li><a href="#2d_topics">Things You Need to Know About 2-D Image Transforms</a>
    <li><a href="#3d_topics">Things You Need to Know About 3-D Transforms</a>
</ul>

<h2><a name="all_transform_topics" IDX_CONCEPT="Transforms, Things You Need to Know About">Things You Need to Know About All Transforms</a></h2>
<P>This section contains the following topics.
<ul>
<li><A HREF="#name">Name</a>
<li><A HREF="#progids">ProgIDs</a>
<li><A HREF="#component_categories">Component Categories</a>
<li><A HREF="#property_pages">Property Pages</a>
<li><A HREF="#idxeffect_iface">IDXEffect Interface</a>
<li><A HREF="#quality_property">Quality Property on IDXTransform</a>
<li><A HREF="#mapboundsin2out">MapBoundsIn2Out</a>
<li><A HREF="#generationids">Generation IDs</a>
<li><A HREF="#authortime">Author-time vs. Run-time Transforms</a>
<li><A HREF="#security">DirectX Transform Security Mechanism</a>
<li><A HREF="#optional_inputs">Checking for Optional Inputs</a>
<li><A HREF="#relative_urls">Supporting Relative URLs</a>
<li><A HREF="#collisions">Property Names and Name Space Collisions</a>
<li><A HREF="#quick_setup">Quick Setup</a>
</ul>

<h3><A NAME="name"></A>Name</h3>
<P>Use a user-friendly name for the component. This is the name that visual authoring tools will expose to users. Good names such as Slide, Explode, and Fade describe what the transform does and are easy to remember.


<h3><A NAME="progids"></A>ProgIDs</h3>

<P>Programmatic identifiers (ProgIDs) are used for hosting transforms in Microsoft DirectAnimation&#153;. They are constructed in the following format.

<UL>
    <LI>Specify the prefix of component categories: DXImageTransform, DX3DTransform, or <A CLASS="Glossary" HREF="javascript:Glossary(sRelPath + 'gloss/gloss_D.htm#gloss_dxsurface')">DXSurface</A>. In the case of transforms, this indicates the type of output.
    <LI>Specify the source company.
    <LI>Specify the name of the effect.
    <LI>Specify the version.
</UL>

<P>For example: Microsoft.DX3DTransform.explode.1

<P>You also need to make provisions for the version number to be optional when a ProgID is used. In that case, if the version is not specified in the ProgID, the latest available one will be used. It is important that you use the following .rgs file as a template in order for the version-independent ProgID to work correctly. 

<PRE>
HKCR
{
    DX3DTransform.Microsoft.Explode.1 = s 'Explode'
    {
        CLSID = s '{141DBAF1-55FB-11D1-B83E-00A0C933BE86}'
    }
    DX3DTransform.Microsoft.Explode = s 'Explode'
    {
        CurVer = s 'DX3DTransform.Microsoft.Explode.1'
        CLSID = s '{141DBAF1-55FB-11D1-B83E-00A0C933BE86}'
    }
    NoRemove CLSID
    {
        ForceRemove {141DBAF1-55FB-11D1-B83E-00A0C933BE86} =
        s 'Explode'
        {
            ProgID = s 'DX3DTransform.Microsoft.Explode.1'
            VersionIndependentProgID =
            s 'DX3DTransform.Microsoft.Explode'
            ForceRemove 'Programmable'
            InprocServer32 = s '%MODULE%'
            {
                 val ThreadingModel = s 'Both'
            }
        }
    }
}
</PRE>

<h3><A NAME="component_categories"></A>Component Categories</h3>
<P>Transforms can declare themselves in the following categories.

<ol>
<li>CATID_DXImageTransform
<li>CATID_DX3DTransform
<li>CATID_DXSurface
<li>CATID_DXAuthoringTransform
</ol>
<p>
The third and fourth categories are unrelated to the first two. Transforms are either in the first or second category, and optionally in the third and/or fourth. The third category is useful for <A CLASS="Glossary" HREF="javascript:Glossary(sRelPath + 'gloss/gloss_P.htm#gloss_proceduralsurface')">procedural surfaces</a>, which also function as image transforms. Procedural surfaces are useful when categorized distinctly because they can be used as surface inputs to transforms. For details on the fourth category, see the following on the distinction between authoring and run-time transforms.

<P>For corresponding GUID values, refer to DXTGUID.C in the <b>include</b> directory.


<h3><A NAME="property_pages"></A>Property Pages</h3>

<P>If you want your transform to have user-set variables that define properties specific to your transform, you will need to define a custom interface. If you define a custom interface, inherit from <b>IDispatch</b> if your transform is not time-based; or inherit from <b>IDXEffect</b> if your transform performs modifications over time.
<p>
After you write a custom interface, you need to design a property page, which is a user interface used to change the properties specific to your transform.
For example, if your transform is like the <a href="../reference/effects/wipe.htm">Wipe</a> sample transform, you might want to define a custom interface that sets the width of the alpha blend used with the transform. In this case, you would also want to create a property page with a dialog box used to enter the percentage of the output width to use for the alpha blend.

<h3><A NAME="idxeffect_iface"></A>IDXEffect Interface</h3>
<P>The following code shows how the <B>IDXEffect</B> interface is declared in the Dxtrans.idl file.
<pre>
interface IDXEffect : IDispatch
{
    HRESULT get_Capabilities([out, retval] long *pVal);
    HRESULT get_Progress([out, retval] float *pVal);
    HRESULT put_Progress([in] float newVal);
    HRESULT get_StepResolution([out, retval] float *pVal);
    HRESULT get_Duration([out, retval] float *pVal);
    HRESULT put_Duration([in] float newVal);
};
</pre>
<P>This is an optional interface for your transform. It exposes a standard way for controlling animated effects. This makes it convenient for external applications like Microsoft DirectAnimation&#153; and Microsoft Chromeffects&#153; to control animations through Extensible Markup Language (XML) and scripting. The transform might have other animation parameters that would be exposed through custom interfaces. 
<p>
The <i>Capabilities</i>

are a way for the transform to indicate whether the animation is periodic. If so, the transform output at <i>Progress</i> = 0 is the same as the output at <i>Progress</i> = 1. It is also a way to indicate that the transform is a morph. A morph transform takes two inputs; the result is the first input at <I>Progress</I> = 0 and the second input at <I>Progress</I> = 1.
<p>
The <i>Progress</i> is the primary animation parameter, which has a range from 0.0 to 1.0. To produce an animated effect, you would step sequentially through values of <i>Progress</i>, displaying transform output at each step. Typically, at each step you would set <i>Progress</i> to the desired value and then call the <a href="../reference/ifaces/idxtransform.htm#Execute">IDXTransform::Execute</a> method to obtain the corresponding result.

<p>
<i>StepResolution</i> is optional but is useful if the primary animation parameter will lead to different results at discrete points in the [0,1] range. For example, if step resolution is 0.25, the transform will only produce five distinct results. If <i>StepResolution</i> is set to zero, the transform produces a continuous range of results.
<p>
<i>Duration</i> is a recommended amount of time for the primary animation parameter to change from zero to one. It is optional for a container to use this recommended duration. There is also a <a href="../reference/Ifaces/idxeffect.htm#put_Duration">put_Duration</a> method for use by visual authoring tools. This allows the transform to persist a modified duration value from the originally specified one.

<h3><A NAME="quality_property"></A>Quality Property on IDXTransform</h3>

<P>The <i>Quality</i> property for a transform exists so that the performance of a transform that requires many calculations can be adjusted. The <i>Quality</i> property is represented by a floating point number that should be set between 0.0 and 1.0, with 1.0 indicating the highest quality. The value can be set and retrieved using the <a href="../reference/ifaces/idxtransform.htm#SetQuality">IDXTransform::SetQuality</a> and <a href="../reference/ifaces/idxtransform.htm#GetQuality">IDXTransform::GetQuality</a> methods. 

<p>
For instance, if you want to create a three-dimensional (3-D) transform that creates a sphere, you might use the <I>Quality </I>parameter to set the number of faces you'll use. Lower quality would mean fewer faces and would result in higher performance. The <I>Quality</I> property defaults to 0.5 and is set by the container of the transform.


<h3><A NAME="mapboundsin2out"></A>MapBoundsIn2Out</h3>
<P>This method takes an array of <a href="../reference/structs/DXBNDS_struct.htm">DXBNDS</a> objects (<i>inBnds</i>) whose number is equal to the number of inputs the transform accepts on Setup, and in the corresponding order. The transform fills an output <b>DXBNDS</b> structure (<i>outBnds</i>), which represents the bounds of the output of the transform, resulting from a call to <b>Execute</b>. These bounds are based on the current property settings where the inputs passed to <b>Setup</b> have the bounds specified in <i>inBnds</i>. If NULL is passed for the input bounds parameter, this method uses the bounds of the current input data objects.
<p>
This method is important because containers of transforms typically need to obtain bounds of the transform outputs based on the extents of their inputs before the specific inputs are available. Extent analysis is done before actual inputs are available for a variety of optimizations, including culling, pruning, and dirty rectangle techniques. It is also used for setting the z-resolution in the rendering device, which tends to be a critical resource that should be used carefully.
<p>
Therefore, transforms need to have a way to report their output extents based on the settings of their parameters and the bounds of their inputs. These bounds do not need to be tight because it is acceptable if they describe a bounding box that is larger than the actual box. They do, however, need to be true bounds that are guaranteed not to be exceeded by the object. If they are not true bounds, a variety of rendering artifacts might result. These can include dirty pixels because of dirty rectangle optimization and front/back clipping because of underestimates of the z-range.
<p>
To simplify DirectX Transform, an implementation of <b>MapBoundsIn2Out</b> is provided in the base class.

It calls a <a href="../reference/cdxbasento1/cdxbasento1_virtuals.htm#DetermineBnds_D">DetermineBnds</a> method on the transform and passes a bound as an in/out parameter. The result is determined from the input bounds in one of the following two ways.
<ol>
    <li>The union of the provided input bounds.
    <li>The [-1,1] normalized cube in case the transform has no 3-D inputs (either zero inputs or image inputs).
</ol>

<p>
The transform then needs to manipulate the provided bound any way it desires into a bound for the output. There are two helper functions of the <a href="../reference/cdxbnds/cdxbnds_intro.htm">CDXBnds</a> class that operate on bounds and that are provided for transforms. One is <a href="../reference/cdxbnds/scaling_functions.htm#Expand_1">Expand</a> and the other is <a href="../reference/cdxbnds/scaling_functions.htm#Scale_1">Scale</a>. The former is additive, the latter is multiplicative, and both are in relation to the center of the bound. That is, <B>Expand</B> will add half the given x-, y-, and z-values to the maximum component and subtract this value from the minimum component of the corresponding bounds. <B>Scale</B> will multiply the given x-, y-, and z-components of the bounds relative to the midpoint of these components. In most cases an application of one or both operations with proper parameters will suffice for determining the output bound. The bound parameter to <a href="../reference/cdxbasento1/cdxbasento1_virtuals.htm#DetermineBnds_D">DetermineBnds</a> that carried the input bound is intended to be overwritten with the resulting output bound.

<p>One simplifying approach that a transform might use is to determine a lifetime maximum x-, y-, and z-scale across the whole progression of an effect and repeatedly scale the input bound by these same scale factors. This lends itself to simplicity, but in certain cases, it results in overly exaggerated bounds that will render the container's optimizations ineffective. 
<p>
Alternatively, a sophisticated transform can implement its own <b>MapBoundsIn2Out</b> to estimate the output bound based on the presently set parameters and input extents. Remember that the tighter the reported bound is, the more effective the container optimizations will be.
<p>
The <b>DXETool</b> application provides a way to test the correctness of the reported bounds at the time of an execute by checking them against the actual bounds as obtained from the resulting output. The application is located in the Dxmedia/Bin/X86 folder of the Software Development Kit (SDK).


<h3><A NAME="generationids"></A>Generation IDs</h3>

<p>The generation ID associated with any surface or mesh represents a &quot;version number&quot; of the object. To make sure your transform is using the most recent version of the inputs, you should check their generation IDs at the beginning of your execution function. When you modify your transform's output, you should increment the output's generation ID. See the <a href="../reference/cdxbasento1/cdxbasento1_helpers.htm">CDXBaseNTo1 helper functions</a> for methods to manage generation IDs for your transform.

<P>
On a call to <b>Execute</b>, a transform needs to check these generation IDs and determine if one of its inputs has changed since the last execution. If the transform caches its inputs (which they often do as an optimization) and the input's generation ID has changed, the transform needs to regenerate its input cache. 
<p>
Furthermore, a transform needs to increment the generation ID of its output every time the output changes. A container needs to check the generation ID of the output to control any optimization scheme it might have. Generation IDs are also useful for cases of asynchronous loads, where a container makes the request for a new resolution and learns that the resulting new output is ready based on checking its generation ID. This can be the case for progressive meshes downloads or images from the Internet.

<h3><A NAME="authortime"></A>Author-time vs. Run-time Transforms</h3>

<p>Certain parties might be interested in this distinction because they want to sell the author-time version of their transforms, but freely distribute their run-time version. The typical distinction between the two is as follows:
<ol>
<li>The author-time version is copyrighted, so that when a user hosts it in a visual authoring tool, the user knows that it is copyrighted. See the following section and the <b>Wipe</b> example for details on how this is done. 

<li>The author-time version typically will include property pages for ease of use in a visual authoring tool; the run-time version will not include property pages. This also helps keep the size of the run-time version smaller. 

<li>The author-time version is capable of saving persistent properties, including its custom properties (important for visual authoring tools). The run-time version cannot save its properties.
</ol>

<P>The <B>Wipe</B> sample shows how to produce both an author-time and a run-time version of a transform from a common source. It also illustrates how to tag an author-time transform with a copyright string. The example is located in the Samples\Multimedia\Dtrans\C++\Wipe\Wipedll folder.


<h3><A NAME="security"></A>DirectX Transform Security Mechanism</h3>
<P>DirectX Transform allows for a security mechanism for any transforms you write. For more information, see the <a href="copyright.htm">Copyright Information</a> article.

<h3><A NAME="optional_inputs"></A>Checking for Optional Inputs</h3>

<P>For optional inputs it is acceptable for a container to either not provide the input parameter completely, or to provide NULL in place of the input in the call to <b>Setup</b>. This implies that the transform needs to check if an optional input is NULL and deal with it appropriately. If a transform uses the helper function <b>GetInput</b>, both cases will be accounted for automatically, and the helper function will report that no input is present in both cases.

<H3><A NAME="relative_urls"></A>Supporting Relative URLs</h3>
<P>
Because transforms can be so easily integrated into Web pages, you might want your transform to support relative URLs if a URL is one of its properties. To do this, a transform must support the <i>IBindHost</i> interface.
It is an optional interface for transforms to support only if they are interested in obtaining a site-specific bind host. A container is responsible to query for this interface, and if available, to call <b>SetBindHost</b> with the proper parameter. DirectAnimation does this. For more information about this interface, see the Platform SDK.
<p>
For example, transforms that require a URL as a property can use the container's bind host to obtain a base URL and to take a relative URL as the custom property. This will help in content writing so that absolute URLs are not required. For example, both the <A HREF="../reference/effects/flashpix.htm">FlashPix</A> and <A HREF="../reference/effects/metaspec.htm">MetaStream</A> transforms support this interface.

<h3><A NAME="collisions"></A>Property Names and Name Space Collisions</h3>

<p>Because transforms are commonly hosted in Chromeffects, there is a possibility for name space collisions between transform custom property names and Chromeffects parameter names. To avoid such collisions, it is advised to preface property names with &quot;DXT&quot;, for example, DXTColor or DXTMeltRate.

<h3><A NAME="quick_setup"></A>Quick Setup</h3>
<P>There is no explicit support for this in the DirectX Transform architecture. Every transform is expected to use specific knowledge of its functionality in order to perform a set up efficiently.


<h2><a name="2d_topics" IDX_CONCEPT="2-D Image Transforms, Things You Need to Know About">Things You Need to Know About 2-D Image Transforms</a></h2>
<P>This section contains the following topics.
<ul>
<li><A HREF="#surfacepick">Surface Pick Correlation</A>
<li><A HREF="#supporting_IDXScaleOutput">Supporting IDXTScaleOutput</A>
</ul>

<h3><A NAME="surfacepick"></A>Surface Pick Correlation</h3>

<p>The following interface is intended for pick correlation.

<pre>
interface IDXSurfacePick : IUnknown
{
    HRESULT PointPick([in]const DXVEC *pInPoint,
        [out]long * plInputSurfaceIndex,
        [out]DXVEC * pOutPoint );
}
</pre>

<p>It provides for pick correlation between a given point and the inputs to an image transform. It returns the hit input and the point at which the hit happened in the local coordinates of that input.
<p>
This interface is essential for image transforms because they might composite their results to a surface provided by the container at which point the information required for the pick correlation to the input is usually lost. The correlation needs to occur before the final compositing takes place.
<p>
There are helper functions that aid in this pick correlation. See the <b>Wipe</b> example to see how they are used. This example is located in the Samples\Multimedia\Dtrans\C++\Wipe\Wipedll folder. Also, for single image input and single image output transforms, the base class does the pick correlation with no need for added code in the transform itself. The base class makes use of the <b>MapBoundsOut2In</b> of the transform, which would need to be implemented correctly for the base class to work correctly.

<p>
It is possible that an image transform either has no inputs or cannot map the pick event back to one of the inputs. In those cases, <a href="../reference/ifaces/idxsurfacepick.htm#pointpick">PointPick</a> will return DXT_S_HITOUTPUT if the pick point intersects the output surface. For example, this is the case for the gradient procedural surface.

<h3><A NAME="supporting_IDXScaleOutput"></A>Supporting IDXTScaleOutput</h3>
<p>This is an optional interface for zero input image transforms and/or <b>DXSurfaces</b> to consider supporting. Containers invoke the <a href="../reference/ifaces/idxtscaleoutput.htm#SetOutputSize">SetOutputSize</a> method on this interface to inform the transform of the desired size (width and height, in pixels) to render to. For example, this interface allows a very useful exchange of information between a container and a procedural surface. The DXETool application queries for this interface and invokes it upon window resize. Both the <A HREF="../reference/effects/gradient.htm">Gradient</A> and <A HREF="../reference/effects/flashpix.htm">FlashPix</A> <b>DXSurface</b> transforms support it.


<h2><a name="3d_topics" IDX_CONCEPT="3-D Image Transforms, Things You Need to Know About">Things You Need to Know About 3-D Image Transforms</a></h2>
<P>This section contains the following topics.
<ul>
<li><A HREF="#geometry">Geometry Convention for 3-D Effects</A>
<li><A HREF="#meshpick">Mesh Pick Correlation</A>
<li><A HREF="#using_meshbuilder">Using Direct3DRMMeshBuilder3</A>
<li><A HREF="#using_dxsurface">Using a DXSurface as a 3-D texture</A>
<li><A HREF="#frame_of_reference">Frames of Reference</A>
<li><A HREF="#generated_geometry">Extent of Synthetically Generated Geometry</A>
<li><A HREF="#mesh_coherency">Maintaining Coherency of Meshes</A>
</ul>

<h3><A NAME="geometry"></A>Geometry Convention for 3-D Effects</h3>
<P>Use consistent, right-handed conventions.

<UL>
<LI>The positive z-axis is pointing toward the user, positive y-axis is up and positive x-axis to the right (that is, a right-handed coordinate system).
<LI>The normal to a face (the front face) is based on a counterclockwise enumeration of vertices.
<LI>The positive angle of rotation around an axis is also based on a right-handed convention.
</UL>

<P>
The texture coordinates have an origin at the upper-left corner. Positive x goes right and positive y goes down. This is consistent with the Microsoft Direct3D&reg; Retained Mode convention and also with the Dynamic HTML coordinate system for Web pages, which makes it convenient to use an HTML-rendered page as a texture.
<p>
To obtain the above conventions, set the Direct3D Retained Mode right-handed global flag. For example, this will cause the <B>LoadFile</B> method (from an .x file that is left-hand based) to convert the ordering of vertices in faces and the <B>GenerateNormals</B> method to be based on a counterclockwise ordering of vertices. 
<p>
It is important to follow these conventions in order for the transform to be correctly hostable in DirectAnimation, Chromeffects, and <b>DXETool</b>. All meshes that are generated internally to the transform need to be based on these conventions. All C++ applications that use transforms (like <b>DXETool</b>) need to provide meshes and to interpret resulting meshes according to these conventions.

<h3><A NAME="meshpick"></A>Mesh Pick Correlation</h3>

<P>In the case of transforms that produce 3-D meshes, the container is expected to do the pick correlation based on the resulting <b>MeshBuilder</b> through Direct3D Retained Mode mechanisms. If the container needs to trace the pick event into the inputs (beyond the output mesh), by convention, the following needs to happen.

<ul>
    <li>The container needs to label the inputs. 
    <li>The transform needs to communicate the labels to the output mesh.
    <li>The container needs to interpret the labeling and deduce which input (or input fragment, in the case of a composite input mesh) is responsible for the pick.
</ul>

<P>The following are cases where labeling is necessary for clarity.
<ul>
    <li>One or more input meshes potentially with different submeshes, and the specific submesh that was picked needs to be identified. 
    <li>One or more textures in the input meshes and/or one or more surface inputs, and the texture that was picked needs to be identified.
</ul>
<P>In these cases, the container needs to call the <a href="../reference/ExtVisuals/ExternalUtil.htm#SetAppData">ExternalUtil::SetAppData</a> method to set a quantity called <i>AppData</i> on the submesh, texture, or surface. This <i>AppData</i> is used as the key for figuring out what was picked. For this to work, transforms need to communicate the <i>AppData</i> value to the elements of the output mesh.

<p>In most cases, this copying over of the <i>AppData</i> happens automatically, and the transform writer doesn't need to do anything special. <b>SetAppData</b> and <b>GetAppData</b> are supported on <b>DXSurfaces</b>, Direct3D Retained Mode meshes, and textures. Also, the <b>CreateD3DRMTexture</b> <b>DXSurface</b> method and the <b>AddMeshBuilder</b> Direct3D Retained Mode <B>MeshBuilder</B> method copy over the <i>AppData</i> value to their result by default. It is common for these methods to be used to construct the output mesh from the inputs. For example, this includes a transform with a single mesh input and a mesh output that maintains an identical structure in the output as in the input and tweaks only vertices for an effect. It uses <B>AddMeshBuilder</B> to construct the output mesh from the input and doesn't need to do anything special to copy the <i>AppData</i> value.
<p>
In other rare cases, the transform synthesizes parts of the output from the inputs; that is, the relation is not a straightforward, one-to-one situation like the previous one. For example, more than one input might contribute to a mesh or to a texture. In that case, it is the responsibility of the transform to introduce a policy by which it computes <i>AppData</i> for the output mesh or texture from the <i>AppData</i> of its ingredient inputs. For example, if two input surfaces are overlaid to produce a texture that is used in the output, it is the responsibility of the transform to assign <i>AppData</i> that corresponds to the composite texture. One possible policy for a transform that fades from surface A to surface B is to copy over to the output texture the <i>AppData</i> of surface A for a <I>Progress</I> setting of approximately 0 ([0, 0.25]), and the <i>AppData</i> of Surface B for a <I>Progress</I> setting of approximately 1 ([0.75, 1]), and no <i>AppData</i> otherwise. This is also a possible policy when the transform is a morph between two input meshes.
<p>
If the <i>AppData</i> value is NULL, this implies that no <i>AppData</i> was set on the picked entity, and, therefore, the pick event is not traceable to the inputs. In the previous example, this would be the case for a <I>Progress</I> parameter in the range [0.25, 0.75].
<p>
Containers (like DirectAnimation) need to do ray correlation with the output mesh, which results in a mesh, a texture, and a texture coordinate. The <i>AppData</i> can be obtained from the texture and the mesh, which (according to the previous convention) will point to the corresponding input. 

<h3><A NAME="using_meshbuilder"></A>Using Direct3DRMMeshBuilder3</h3>
<P>This is the data object for 3-D meshes and is part of Direct3D Retained Mode, not DirectX Transform. As a result, you need Direct3D Retained Mode version 6.0 to use 3-D transforms. A <B>MeshBuilder3</B> has some added richness, especially useful for transforms. It supports the <b>AddTriangles</b> method for efficiently adding a collection of triangles (including strips, fans, and combinations thereof, such as disjoint collections) with optional per-vertex information (like texture coordinates, normals, and colors).
<p>
Furthermore, a MeshBuilder might include sub-MeshBuilders in a tree fashion. This places a requirement on transforms to be able to inquire for and process such sub-Meshes. Sub-Meshes share a pool of vertices in the root mesh, but have their own face sets that point into vertices in the pool. Sub-Meshes enable the control of attributes such as color, visibility, texture, and material properties at the sub-Mesh level, and hence they provide added flexibility to the input of transforms in allowing such input to effectively be a composite geometry. 
<p>
Sub-meshes provide a way to apply transforms (like <A HREF="../reference/effects/explode.htm">Explode</A>) on composite objects (like a car), instead of needing to apply a transform repeatedly to the different parts of the car (door, wheels, and so on). Note that this is different from the case of transforming (exploding) a collection of two distinct objects (like a car and a truck), in which case two different instances of the transform would be required. Notice that a transform (explosion) typically is dependent on a reference point like the center of the object being transformed (exploded), and hence transforming (exploding) two objects separately is different from transforming (exploding) the collection of the two.
<p>You need to compute per-vertex normals initially and attach them to faces in a <b>MeshBuilder</b>. Later, and after vertices change, you can call <b>GenerateNormals</b> to update these normals. <b>GenerateNormals </b> doesn't create the normals from scratch.
<p>
It is not possible to use Direct3D Retained Mode Frame objects as inputs to transforms. This would introduce the complexity of parsing and interpreting general frames on every transform. Instead, <b>MeshBuilders</b> with sub-Meshes are used, which are significantly simpler to deal with, even though they support only a limited capacity of aggregation.
<p>
You have the option of computing per-vertex normals and attaching them to vertices in a <b>MeshBuilder</b>. Alternatively you can call <b>GenerateNormals</b> to have Retained Mode compute these normals for you by averaging the normals of the faces that share the particular vertex. After vertices change, you can either call <b>GenerateNormals</b> again to recompute these normals or transform the normals yourself. 

<p>The transform architecture doesn't provide for view-dependent procedural meshes because there is no way for the container to communicate the view to the transform. The way to do this is to implement a Direct3D Retained Mode <a href="../reference/ExtVisuals/ExtVisuals_intro.htm#IDirect3DRMExternalUtil">ExternalVisual</a> and obtain the view parameters from Direct3D Retained Mode directly.


<h3><A NAME="using_dxsurface"></A>Using a DXSurface as a 3-D texture</h3>

<P>Use the <a href="../reference/ifaces/idxsurfacefactory.htm#CreateD3DRMTexture">IDXSurfaceFactory::CreateD3DRMTexture</a> method on the interface to convert a <b>DXSurface</b> into a Direct3D Retained Mode texture.

<h3><A NAME="frame_of_reference"></A>Frames of Reference</h3>

<p>Usually 3-D transforms operate in relation to a context like a point, axis, or plane. The transform has a choice of extracting such context from the extents of the inputs or of exposing a custom interface that permits a container to specify such context. For example, an explosion usually emanates from a point; it is incorrect to assume the origin to be that point because the input object might be positioned off-center.

<h3><A NAME="generated_geometry"></A>Extent of Synthetically Generated Geometry</h3>

<p>Transforms that synthesize the 3-D output geometry internally usually take no 3-D meshes as inputs. You are advised to produce their geometry in the [-1,1] cubed extent. This is not a requirement, but is a useful normalizing factor across containers.

<h3><A NAME="mesh_coherency"></A>Maintaining Coherency of Meshes</h3>

<P>Certain meshes are originally or are pre-processed by a transform into a form where the same vertices are replicated across more than one face. This is done in order to have different textures for the different adjacent faces (hence different texture coordinates for the different instances of the vertex). Because it is common for transforms to operate by moving vertices along trajectories, it becomes important to move the different instances of the same vertex along the same trajectory, or else tearing will occur in the resulting output mesh. In some cases, tearing is a by-product of the nature of the effect, such as in the case of <B>Explode</B>.
<p>
A similar situation arises if the input mesh has vertices on edges of other faces. Because transforms generally do not preserve linearity, this will result in tearing, as well. This can only be avoided by insuring that there are no vertices on edges of other faces.




<!-- CONTENTS_END -->
<!-- START_PAGE_FOOTER -->


<H6><HR size=1></H6>
<P><A CLASS="line" HREF="#pagetop"><IMG src="../art/arrowup1.gif" WIDTH="11" HEIGHT="11" ALIGN="MIDDLE" BORDER=0 ALT="Top of Page">&nbsp;Top of Page</A>
<BR><A CLASS="line" HREF="../../cpyright.htm">&#169; 1998 Microsoft Corporation. All rights reserved. Terms of Use.</A>
<!-- END_PAGE_FOOTER -->
</BLOCKQUOTE>
<!-- START POP-UP GLOSSARY -->
<SCRIPT LANGUAGE="JAVASCRIPT">if((g_isIE == true) && (g_iMaj > 3)) {window.self.document.writeln('<SCR' + 'IPT SRC="../tip2.js"></SCR' + 'IPT><IFRAME ID="G_L_S" NAME="SecretBuffer" STYLE="display: none" SRC=""></IFRAME>')}</SCRIPT>
<!-- END POP-UP GLOSSARY -->

<!-- DACONTROL_START -->
    <DIV ID="HeadGraphAnim"></DIV>
    <SCRIPT LANGUAGE="JAVASCRIPT">if((g_isIE == true) && (g_iMaj > 3)) {window.self.document.writeln('<SCR' + 'IPT SRC="../anim.js"></SCR' + 'IPT>')}</SCRIPT>
<!-- DACONTROL_END -->
</BODY></HTML>
