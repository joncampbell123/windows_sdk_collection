<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">

<HTML>

<HEAD><TITLE>Example: The WipeDlg Application</TITLE>
<SCRIPT LANGUAGE="JavaScript"> var sRelPath = '../' </SCRIPT>

<META NAME="Description" CONTENT="Using a 2-D DirectX Transform">
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; CHARSET=iso8859-1">
<META NAME="MS.LOCALE" CONTENT="EN-US">
<META NAME="ROBOTS" CONTENT="all">



<!-- SNIFF_START -->


<SCRIPT LANGUAGE="JAVASCRIPT">

//<!--

var g_isIE = false, g_isNav = false, g_iMaj = 0, g_sPlat = "";

// -->


</SCRIPT>

<SCRIPT SRC="../ver.js"></SCRIPT>
<SCRIPT SRC="../gloss.js"></SCRIPT>





<SCRIPT DEFER SRC="../common.js"></SCRIPT>

<SCRIPT DEFER>

//<!--

function InitPage()

{

    if (g_isIE && g_iMaj >= 4)    

    {



        SetTOC();

    }

}

//-->


</SCRIPT>



<!-- STYLE_START -->


<SCRIPT LANGUAGE="JAVASCRIPT">

//<!--

   var sVR = '../'    // Set root for the style sheet

   var sCSS = '<LINK REL="stylesheet" HREF="' + sVR;



   if(g_isIE)

   {

       if (g_iMaj >= 4) // For MSIE 4.0 or later

       {

           sCSS += 'dxm_basicSDKIE4';

           if (g_sPlat == "Win") // Windows only for now

           {

               document.createStyleSheet(sVR + 'dxm_advSDKIE4.css');

           }

       }

       else // For MSIE 3.0 or earlier

       {

           sCSS += 'dxm_basicSDKIE3';

       }

   }

   else if (g_isNav) // For all Nav versions

   {

       sCSS += 'dxm_basicSDKNAV';

   }

   else

   {

       sCSS += 'dxm_basicSDKIE3'; // default to IE3 sheet

   }



   sCSS += (sCSS == '' ? '' : '.css" TYPE="text/css">');



   document.write(sCSS);

//-->


</SCRIPT>

<!-- STYLE_END -->




</HEAD>

<BODY onload="InitPage(); if (g_isIE && g_iMaj >= 4){HdgrphControl()}" BGCOLOR="#FFFFFF">

<A NAME="pagetop"></A>



<!-- HEADGRAPH_START -->


<TABLE CLASS="main" BORDER=0 CELLSPACING="0" CELLPADDING="0" WIDTH="*">

<TR>

<TD ROWSPAN="3" VALIGN="TOP" WIDTH="*">
<IMG SRC="../art/header1.gif" WIDTH="107" HEIGHT="110" BORDER=0 ALT="DirectX Transform Animated Header -- Microsoft DirectX Transform SDK"></TD>
<TD ROWSPAN="2" VALIGN="TOP" WIDTH="217"><IMG SRC="../art/hdrdtrns.gif" WIDTH="217" HEIGHT="110" BORDER=0 ALT="Microsoft DirectX Transform SDK"></TD>
<TD VALIGN="TOP" WIDTH="383">
<IMG SRC="../art/header3.gif" WIDTH="383" HEIGHT="95" BORDER=0 ALT="DirectX Transform Animated Header">
</TD>
<TD VALIGN="TOP" WIDTH="100%">
<IMG SRC="../art/spacer1.gif" WIDTH="100%" HEIGHT="94" BORDER=0 ALT="Microsoft DirectX Transform SDK">
</TD>

<TD VALIGN="TOP" WIDTH="100%">

<IMG SRC="../art/spacer1.gif" WIDTH="100%" HEIGHT="94" BORDER=0 ALT="Microsoft DirectX Transform SDK"></TD></TR>

<!-- HEADGRAPH_END -->


<!-- NAV_LINKS_START -->


<TR><TD VALIGN="TOP"><PRE><IMG ID="TOC_" SRC="../art/yelbtn.gif" WIDTH="11" HEIGHT="11" ALIGN="MIDDLE" BORDER=0 ALT="*"><A STYLE="color:black;font-weight:bold" ID="TOC" HREF="../contents.htm">Contents</A>  <IMG SRC="../art/yelbtn.gif" WIDTH="11" HEIGHT="11" ALIGN="MIDDLE" BORDER=0 ALT="*"><A STYLE="color:black;font-weight:bold" HREF="../index.htm">Index</A>  <IMG SRC="../art/yelbtn.gif" WIDTH="11" HEIGHT="11" ALIGN="MIDDLE" BORDER=0 ALT="*"><A STYLE="color:black;font-weight:bold" href="usingtransforms.htm">Topic Contents</A>

</PRE></TD></TR>

<TR><TD COLSPAN="2" VALIGN="TOP"><PRE><IMG SRC="../art/yelbtn.gif" WIDTH="11" HEIGHT="11" ALIGN="MIDDLE" BORDER=0 ALT="*"><B>Previous Topic:</B> <A STYLE="color:black" href="users_implement.htm">Using Transforms in C++</a>
<IMG SRC="../art/yelbtn.gif" WIDTH="11" HEIGHT="11" ALIGN="MIDDLE" BORDER=0 ALT="*"><B>Next Topic:</B> <A  STYLE="color:black" HREF="dxetool_users.htm">DXETool for Transform Users</A>

</PRE></TD></TR></TABLE>

<!-- NAV_LINKS_END -->






<BLOCKQUOTE CLASS="body">



<!-- CONTENTS_START -->




<H1><a name="WipeTransform">Example: The WipeDlg Application</a></H1>





<P>
Microsoft&reg; DirectX&reg; Transform provides you with powerful tools for manipulating two-dimensional (2-D) image data. With DirectX Transform, you can perform operations on a single image (such as a <A HREF="../reference/effects/dissolve.htm">Dissolve</A> or a <A HREF="../reference/effects/Ripple_meta.htm">Ripple</A> transform) or combine two images to form a single output image.



<P>
The WipeDlg sample application shows how to host the <A HREF="../reference/effects/wipe.htm">Wipe</A> transform in C++. The <B>Wipe</B> transform requires two input images (referred to in the code as &quot;Image A&quot; and &quot;Image B&quot;). The transform animates Image A, gradually turning it into Image B by sweeping a blended region of both images from left to right that gradually overlays Image B onto Image A. The following animation shows how this looks at different stages of the transform.

<center>
<IMG SRC="../art/wipe.gif" WIDTH="300" HEIGHT="50" BORDER=0 ALT="Wipe Transform Image">
</center>

<p>
The WipeDlg example code is located in the the DirectX Transform Software Development Kit (SDK) in the Dxmedia\Samples\Multimedia\Dtrans\C++\Wipe\WipeDlg folder. This folder contains all of the source code and resource files needed to build the WipeDlg.exe application, as well as a Microsoft Visual Studio&reg; project file. Most of the code discussed in this article is located in WipeDlg.cpp. To run the example, you may need to register the Wipe.dll. To do this, run the Regsvr32.exe program located in your C:\Windows\System folder, passing to it the path to Wipe.dll.

<p>
Run WipeDlg.exe (located in the Dxmedia\Samples\Multimedia\Dtrans\Bin\X86\ folder). When you start the application, you are prompted to load Image A and Image B. You can do this from the <B>File</B> menu. After the images are loaded, you can use the <B>Play</B> buttons to either animate Image B into Image A, or Image A into Image B. The <B>Properties</B> button enables you to change two properties of the <B>Wipe</B> transform: <I>GradientSize</I> and <I>Duration</I>.


The <I>GradientSize</I> controls the percentage of the total window size that comprises the transition region between the images, while the <I>Duration</I> controls the length of time (in seconds) the animation process takes. A small <I>GradientSize</I> produces a drawn-curtain kind of transition from Image A to Image B, and a large <I>GradientSize</I> causes a subtle fade from Image A to Image B. You can also adjust the trackbar control to look at one of the intermediate steps in the animation process and see areas where parts of both images are visible.

<p>The following sections examine the specific parts of the source code for the application that hosts this transform.


<ul>

<li><a href="#BasicMethods">The Basic Methods</a>

<li><a href="#InitializingTheTransform">Initializing the Transform</a>

<li><a href="#PerformingTheTransform">Performing the Transform</a>

<li><a href="#SweepingLeftAndRight">Sweeping Left and Right</a>

</ul>






<h2><a name="BasicMethods" IDX_CONCEPT="noindex">The Basic Methods</a></h2>

<p>As with all Microsoft Windows&reg; applications, the program execution begins in the <b>WinMain</b> function. This is a standard Windows function responsible for opening the dialog window and processing the dialog's message loop. Creation of the dialog happens with this call.

<pre>
   // Create the main window.
    hWnd = CreateDialog(hInst, MAKEINTRESOURCE(IDD_WipeDlg), NULL,
    (DLGPROC)MainWndProc);

    if(!hWnd || !g_pSurfFact)
        goto failure;
</pre>

<P>Notice that if the program is unable to create the window or unable to create an <A HREF="../reference/Ifaces/idxsurfacefactory.htm">IDXSurfaceFactory</A> interface needed for the transforms, the application quits (the following explains how the surfaces are created by <b>CreateDialog</b>). If Dxtrans.dll and Wipe.dll are properly registered by Windows, and you have sufficient memory, this call should succeed.
<p>
The program enters a standard message loop, which branches to the <b>MainWindowProc</b> function when a message is received. The function is passed a handle to the dialog message and the <b>switch(uMsg)</b> statement determines which function of WipeDlg.cpp to call. The <b>HandleInitDialog</b> function is executed when the window is created. <b>HandleSize</b> is called when a user resizes a window, and <b>HandleTrackBar</b> is called when the trackbar control value changes. The <b>HandleCommand</b> function is another <b>switch</b> which handles image file loading, playing the transform, and changing transform properties.
<p>
The important function to examine is <b>HandleDrawItem</b>, which draws a frame of transformed image output to the screen. Those details are examined in the <a href ="#PerformingTheTransform">Performing the Transform</a> section. Next, this article examines how to initialize the transform, and the <A CLASS="Glossary" HREF="javascript:Glossary(sRelPath + 'gloss/gloss_D.htm#gloss_dxsurface')">DXSurface</A> objects needed by the transform.




<h2><a name="InitializingTheTransform" IDX_CONCEPT="noindex">Initializing the Transform</a></h2>





<p>When the message loop calls the <b>CreateDialog</b> function, it automatically calls the <b>MainWndProc</b> function, as well, with the message <b>WM_INITDIALOG</b>. This function, in turn, calls <b>HandleInitDialog</b>, which is shown in the following:

<pre>
/////////////////////////////////////////////////////////////////
BOOL HandleInitDialog(HWND hWnd, HWND hwndFocus, LPARAM lParam)
/////////////////////////////////////////////////////////////////
{
    HRESULT     hr  = S_OK;

    // Store the dialog handle.
    g_hDlg  = hWnd;

    // Initialize the Progress trackbar control.
    SendDlgItemMessage( hWnd, IDS_PCTCOMP, TBM_SETRANGE, TRUE,
    MAKELONGcontained( 0, 100 ) );
    SendDlgItemMessage( hWnd, IDS_PCTCOMP, TBM_SETTICFREQ, 20, 0 );

</pre>

 <P>The function begins executing by storing the dialog handle to a global variable (defined in Globals.cpp) and initializing the <B>Progress</B> trackbar control to zero.

<pre>
    CoInitialize(NULL);

    // Create the Transform Factory.
    hr = CoCreateInstance( CLSID_DXTransformFactory, NULL,
    CLSCTX_INPROC, IID_IDXTransformFactory,
    (void **)&amp;g_pTransFact );
</pre>

<P>The previous two statements use Component Object Model (COM) methods to create a <A HREF="../reference/Ifaces/idxtransformfactory.htm">DXTransformFactory</A> object (Transform Factory). The first statement is a standard method that initializes the COM library. The second statement creates the <B>IDXTransformFactory</B> interface by using its class identifier (CLSID) and interface identifier (IID), receiving a pointer to the requested interface and an HRESULT that indicates whether the creation was successful. For more details on the use of these COM methods, you should consult one of the standard texts on COM or the <i>COM Reference</i> in the Platform SDK.

<p>Now you can use the Transform Factory to &quot;manufacture&quot; transforms. These transforms operate on objects called <B>DXSurfaces</B>, which store all the image data. <B>DXSurfaces</B> are created with the <A HREF="../reference/Ifaces/idxsurfacefactory.htm">IDXSurfaceFactory</A> interface, which is exposed when the Transform Factory is created. 

<p>To use the <B>DXSurfaceFactory</B> object (Surface Factory), you must use the Transform Factory to get a pointer to the Surface Factory it exposed, as shown in the following:

<pre>
hr = g_pTransFact-&gt;QueryService( SID_SDXSurfaceFactory,
IID_IDXSurfaceFactory, (void **)&amp;g_pSurfFact );
</pre>

<p>The <B>QueryService</B> method is a standard COM interface used to get a pointer to a service of an interface. You pass the <B>QueryService</B> method a service ID, indicating to the Transform Factory to use the Surface Factory query service. You also pass <B>QueryService</B> an interface ID to get a pointer to a Surface Factory interface. It returns an HRESULT value, indicating whether the interface exists. If it returns a value of <b>S_OK</b>, it also returns a pointer you can use to access the Surface Factory's  methods and to create <B>DXSurfaces</B>. It isn't necessary to create the surfaces until the program loads the image files, but the Surface Factory will be ready to manufacture them when that happens.

<p>The following uses the Transform Factory to create an instance of a <B>Wipe</B> transform.

<pre>
hr = g_pTransFact-&gt;CreateTransform( NULL, 0, NULL, 0, NULL, NULL,
CLSID_DXTWipe, IID_IDXTransform, (void **)&amp;g_pWipeTrans );
</pre>

<P>At this stage there are no input or output surfaces for the transform, so the first four parameters are either NULL or zero. The  next NULL indicates that there is no COM property bag (a stored parameter set) for this interface. The fourth NULL indicates that no transform errors need to be logged. The first
parameter passed to the Transform Factory is the CLSID of a transform, which in this case indicates to the Factory that a <B>Wipe</B> transform needs to be manufactured. Each transform has its own CLSID. The second parameter tells the Transform Factory that you want a pointer to an <B>IDXTransform</B> interface. If successful, that pointer is stored in <i>g_pWipeTrans</i>,
and after the input and output surfaces are identified, you can start using this transform on <B>DXSurfaces</B>.

<p>
As a final step, you obtain a pointer to an <a href="../reference/ifaces/idxeffect.htm">IDXEffect</a>  interface.

<pre>
hr = g_pWipeTrans-&gt;QueryInterface( IID_IDXEffect, (
void **)&amp;g_pEffect );
</pre>
<P>Because all COM interfaces inherit from the <b>IUnknown</b> interface, they all have a <b>QueryInterface</b> method. This method is used to determine whether the requested interface is supported by its object, and if so, to get a pointer to the interface. To use <b>QueryInterface</b>, you should pass it the <I>IID_IDXEffect</I> parameter. If the <B>Wipe</B> transform supports this interface, it returns an S_OK value and a pointer to the location of the <B>IDXEffect</B> interface. This will enable you to set the properties of the transform that are discussed in the <a href="#PerformingTheTransform">Performing the Transform</a> section of this article.

<p>
After the dialog initialization routine is complete, control of the program is returned to the message loop. One of the possible messages the loop can receive is a <b>WM_COMMAND</b>, indicating that the user has selected one of the dialog commands. When it gets one of these messages, program control goes to <b>HandleCommand</b>. This function determines which dialog control was selected and calls the appropriate message handler. However, no image output can occur until the images have been loaded into memory. This is handled by the following block of code, which is located in Commdlg.cpp.

<pre>
        case IDM_IMAGEA:
        case IDM_IMAGEB:
            IDXSurface  **ppSurface     = NULL;
            TCHAR       szError[256]    = _T("");

            if (id == IDM_IMAGEA)
            {
                ppSurface = &amp;g_pInSurfA;
                _tcscpy(szError, _T("Couldn't read Image A\n"));
            }
            else
            {
                ppSurface = &amp;g_pInSurfB;
                _tcscpy(szError, _T("Couldn't read Image B\n"));
            }

            InitializeFileOpenDlg( g_hDlg );
            if (PopFileOpenDlg (g_hDlg, szFileName, szTitleName))
            {
                if (!ReadImageFile (ppSurface, szFileName))
                    MessageBox( g_hDlg, szError, _T("Load Error"),
                    MB_ICONERROR );
            }

            // If we have both surfaces, force send a resize
            // to force Setup and Repaint.
            HandleSize( g_hDlg, 0, 0, 0 );
            break;
    }

    return;
}
</pre>

<P>First, the function initializes a <B>DXSurface</B> pointer and file name string. The <B>DXSurface</B> pointer refers to either Image A or Image B, depending on which image is being loaded. The routine then opens a dialog box so the user can select an image for loading. When the routine has a file name for the image, it calls the <b>ReadImageFile</b> function located in Commdlg.cpp.

<pre>
BOOL ReadImageFile (IDXSurface **lplpDXSurf, PTSTR pstrFileName)
{
    WCHAR   pwcsBuffer[256] ;
    HRESULT hr;
    
#ifndef UNICODE
    mbstowcs( pwcsBuffer, pstrFileName, strlen(pstrFileName) ); 
#endif

    // Load Input surfaces.
    hr = g_pSurfFact-&gt;LoadImage( pwcsBuffer, NULL, NULL,
    &amp;DDPF_PMARGB32, IID_IDXSurface, (void**)lplpDXSurf );

    if (FAILED(hr))
        MessageBox(g_hDlg, _T("Couldn't load image!"), _T
        ("Error Loading"), MB_ICONERROR );

    return SUCCEEDED( hr );
}
</pre>
<P>This routine uses the Surface Factory to create a <B>DXSurface</B> with the <b>LoadImage</b> method. The first parameter is the file name of the image to load. The next two parameters are used only if the source is a Microsoft DirectDraw&reg; image, which is not the case in this example. The <a href="pixelformats.htm">pixel format</a> to use for this <B>DXSurface</B> is specified by the fourth parameter.






In this example, the Surface Factory is set to store the image in a 32-bit, alpha-premultiplied PMARGB32  format. You can use any of 12 formats, and the Surface Factory will convert the image format to the one specified. The fifth parameter specifies that the Surface Factory should return a pointer to an <B>IDXSurface</B> interface, and the last parameter is the location where the pointer should be stored.


<p>
The last step of the image loading process involves defining the input and output surfaces for the <B>Wipe</B> transform.  This is initiated by a routine in the <b>HandleSize</b> function.

<pre>
    // Create Output surface.
    SAFE_RELEASE(g_pOutSurf);
    CDXDBnds bnds;
    bnds.SetXYSize(DCWidth, DCHeight);
    hr = g_pSurfFact-&gt;CreateSurface(NULL, NULL, &amp;DDPF_PMARGB32,
    &amp;bnds, 0, NULL, IID_IDXSurface, (void**)&amp;g_pOutSurf );
                                        
    if (g_pInSurfA &amp;&amp; g_pInSurfB)
    {
          if( SUCCEEDED( hr ) )
        {
            IUnknown* In[2];
            IUnknown* Out[1];
            In[0] = g_pInSurfA;
            In[1] = g_pInSurfB;
            Out[0]= g_pOutSurf;
            hr = g_pWipeTrans-&gt;Setup( In, 2, Out, 1, 0 );
        }
    }
</pre>
<P>If Image A and Image B have been loaded, the routine creates an output surface based on the size of the dialog window. The routine then initializes the arrays of input and output surface pointers to be used by the transform. For the <B>Wipe</B> transform, there are two inputs and one output. Finally, the <a href="../reference/ifaces/idxtransform.htm#Setup">Setup</a> method is called with the number of inputs and outputs, and zero for an unused parameter. After this routine has run, the <B>Wipe</B> transform knows where to get its image input and where to store its output.







<h2><a name="PerformingTheTransform" IDX_CONCEPT="noindex">Performing the Transform</a></h2>




<P>Each transform that supports the <a href="../reference/ifaces/idxeffect.htm">IDXEffect</a> interface has two important member variables that are used to produce an effect: <i>Progress</i> and <i>Duration</i>. The <i>Progress</i> variable is a number from zero through one that specifies how much of the transform has been completed. In the case of the <B>Wipe</B> transform, setting <i>Progress</i> to zero shows only Image A, while setting it to 1 shows only Image B. Setting it to 0.5 shows some of Image B on the left, some of Image A on the right, and a blurry mixture of both images in the middle. This effect of setting the <i>Progress</i> value is specific to the <B>Wipe</B> transform. Changing this value on a different transform will have a different effect on the output. The <i>Duration</i> variable stores the length of time (in seconds) it should take for the transform to occur.

<p>
Each transform can support a custom interface that gives the transform properties that are specific to the kind of effect it is producing. For the <B>Wipe</B> transform, one custom property is the <i>GradientSize</i>.
It specifies the width of the transition region between Image A and Image B as a fraction of the total window width. Setting a <i>GradientSize</i> of 0.01 produces a sharp transition region that sweeps across the screen, as if Image A were being peeled away to show Image B. Setting this value to 2.0 produces a gradient wider than the window, with Image A gradually fading to become Image B. Another property specific to transform type is the <B>WipeStyle</B>, which tells the gradient region to sweep left to right, or top to bottom. These properties can be set directly in code or changed through a dialog box created by the transform. The <B>WipeDlg</B> function uses the latter option in its <b>HandleProperties</b> function.

<p>
The <a href="../reference/effects/effects.htm">Transform Reference</a> section provides information about the custom properties of each transform. You don't have to set these properties, though. Each transform is created with reasonable default values for each property.

<p>
The following section shows how the transform is used in C++. A transform is started when the user clicks either of the <b>Play</b> buttons or adjusts the <B>Progress</B> trackbar control in the dialog box. In the following example, let's assume the user adjusts the trackbar control to somewhere in the middle. The message handler in <b>MainWndProc</b> receives a WM_HSCROLL message and calls the <b>HandleTrackBar</b> function.
<pre>
/////////////////////////////////////////////////////////////////
void HandleTrackBar( HWND hwnd, HWND hctl, UINT code, int pos)
/////////////////////////////////////////////////////////////////
{
    int     nPosition   = pos;
    TCHAR   szString[256];

    if ( (code == SB_THUMBPOSITION) &amp;&amp; !CheckImages() )
        return;

    nPosition   = SendMessage( hctl, TBM_GETPOS, 0, 0 );
    _stprintf(szString, _T("Progress: %u%%"), nPosition);
    SetDlgItemText( hwnd, IDT_PCTCOMP, szString);

    g_pEffect-&gt;put_Progress( (float)(nPosition/100.0) );

    HandleDrawItem( NULL, NULL );

    return;
}
</pre>
<P>The first statement checks that the two images have been loaded, and if not, returns from the function. Otherwise, the statement uses the <b>SendMessage</b> function to get the current trackbar control position and writes the value as text to the dialog window. The next call uses the transform <B>IDXEffect</B> interface created earlier to set the progress of the transform. Because the <i>Progress</i> member variable is a value from zero to one, and <I>Progress</I> ranges from zero to 100, it is converted and passed to the <b>put_Progress</b> method.

<p>
The program must now redraw the screen based on the new value for the <i>Progress</i> member variable. <B>WipeDlg</B> has a separate function for doing this, called <b>HandleDrawItem</b>. This is an important function, which is explained in steps after the following sample code.
<pre>
/////////////////////////////////////////////////////////////////
void HandleDrawItem( HWND hwnd, const DRAWITEMSTRUCT *lpDrawItem )
/////////////////////////////////////////////////////////////////
//
// Gets a Display Context from the owner draw button
// on the dialog, then executes a frame of the transform
// and blits the result over the owner draw button.
// 
// The arguments are ignored.
{
    HDC                 hdc         = NULL;
    HRESULT             hr          = S_OK;
    HDC                 hdcSurf     = NULL;
    IDirectDrawSurface  *pDDSurf    = NULL;
    HWND                hOwnerDraw  = NULL;
    DWORD               DCWidth, DCHeight;
    RECT                rect;

    // Get the handle and size of the owner draw window.
    hOwnerDraw  = GetDlgItem( g_hDlg, IDB_OWNERDRAW );
    GetClientRect( hOwnerDraw, &amp;rect );
    DCWidth     = rect.right;
    DCHeight    = rect.bottom;

    // Get the Display Context as a place to blit.
    hdc = GetDC(hOwnerDraw);

    // Erase the output surface with a color.
    DXFillSurface( g_pOutSurf, 0xFFC0C0FF, false );
</pre>
<P>The function starts by defining some variables, including handles to the device context for image output and a <A CLASS="Glossary" HREF="javascript:Glossary(sRelPath + 'gloss/gloss_D.htm#gloss_ddsurf')">DirectDrawSurface</a> to store the transformed result. It is followed by functions






 that get a handle to the dialog box image window and the window's size. This allows the function to draw an image of the correct size. The set up for the transform continues as the <b>GetDC</b> function returns the output device context and fills the output <B>DXSurface</B> with a default color.

<p>
With both input surfaces defined, the output surface initialized, and the <i>Progress</i> value set, the transform is ready to execute, as shown in the following code.
<pre>
    // Execute if we have our inputs.
    if (g_pInSurfA &amp;&amp; g_pInSurfB)
    {
        // Execute the transform.
        DXVEC Placement = { DXBT_DISCRETE, 0 };

        hr = g_pWipeTrans-&gt;Execute( NULL, NULL, &amp;Placement );
    }
</pre>

<P>You must specify a position for the transformed image on the output surface, as well as the variable type used to store the position for each transform. Passing a DXBT_DISCRETE from the <a href="../reference/enums/dxbndtype_enum.htm">DXBNDTYPE</a> enumeration  specifies LONG variables for the position. The zero specifies that you want no special position offset for the output image.

<p>
The important method call is <b>Execute</b> because it takes the two input images and combines them to fill the output surface. The first parameter passed to the method is used for multithreaded transforms and is usually set to NULL.
The second parameter specifies the portion of the output image to be blitted to the output surface. To show all of the output, this is set to NULL. The last parameter is  the output image position. If the transform is successful, it returns <B>S_OK</B>, and the program continues.

<pre>
    if( SUCCEEDED( hr ) )
    {
        // Get the DirectDrawSurface from the output DXTransform
        // surface.
        hr = g_pOutSurf-&gt;GetDirectDrawSurface(
        IID_IDirectDrawSurface, (void**)&amp;pDDSurf );
        if( SUCCEEDED( hr ) )
        {
            // Get the DC from the DirectDraw surface.
            hr = pDDSurf-&gt;GetDC( &amp;hdcSurf );
        }
    }

    if( SUCCEEDED( hr ) )                                            
    {
        // Blit the output surface to the DC on the screen.
        BOOL bStat = BitBlt( hdc, 0, 0, DCWidth, DCHeight,
        hdcSurf, 0, 0, SRCCOPY );
        hr = pDDSurf-&gt;ReleaseDC( hdcSurf );
    }

    // Clean up and get out of here.
    ReleaseDC( hOwnerDraw, hdc );
    SAFE_RELEASE( pDDSurf );

    return;
}
</pre>

<P>The remainder of the function takes care of rendering the output image to the screen, which uses standard DirectDraw methods. To do this, you need a pointer to a <B>DirectDrawSurface</B> that represents the transformed image. All <B>DXSurface</B> objects have the <b>GetDirectDrawSurface</b> method, which does just this. The first parameter of the method specifies a pointer to a <b>DirectDrawSurface</b>, and the second parameter is a reference to the returned pointer. From there, it's a matter of getting a device context for the <b>DirectDrawSurface</b> and blitting the result to the window. For more information on how that is done, consult a DirectDraw reference.<!--JB, 4/30/98: Need a nicer way to say this.-->







<h2><a name="SweepingLeftAndRight" IDX_CONCEPT="noindex">Sweeping Left and Right</a></h2>




<P>The previous section showed how to draw one frame of a transform, based on the value of the <i>Progress</i> member variable. Sweeping the transform left to right is just a loop over <i>Progress</i>, calling <b>HandleDrawItem</b> to update the screen for each iteration. The new feature shown in the following code is the <i>Duration</i> member variable which determines the length of time for the transform to complete.

<pre>
/////////////////////////////////////////////////////////////////
void HandlePlayForward( void )
/////////////////////////////////////////////////////////////////
{
    float Duration, Progress = 0;
    DWORD msStartTime = timeGetTime();
    ULONG ulFrames = 0;

    if (CheckImages())
    {
        // This duration can be set with the property page for
        // the effect. It defaults to .50.
        g_pEffect-&gt;get_Duration( &amp;Duration );

        do
        {
            // Set Progress.
            g_pEffect-&gt;put_Progress( Progress );

            // Cause repaint.
            HandleDrawItem( NULL, NULL );

            // Next
            Progress = (float)(( (timeGetTime() - msStartTime) /
            1000. ) / Duration);
            ++ulFrames;
        }
        while( Progress &lt;= 1. );

        // Update the dialog with the frame rate.
        TCHAR szFrames[20];
        _stprintf( szFrames, _T("Frames/Sec = %.2f"), (
        double)ulFrames / Duration );
        SetDlgItemText( g_hDlg, IDT_FRAMES_PER_SEC, szFrames );
    }

    return;
}
</pre>

<P>The function starts by recording the start time of the transform with the Windows <b>timeGetTime</b> function and by initializing the <i>Progress</i> member variable to zero. The transform duration is then obtained by using the <b>get_Duration</b> method of the <b>IDXEffect</b> interface. The function enters the <B>do</B> loop by updating the most recent value for the transform's <i>Progress</i> member variable with the <b>put_Progress</b> method. <b>HandleDrawItem</b> updates the screen, and then <i>Progress</i> is recalculated based on the elapsed time. When the elapsed time is greater than the <i>Duration</i>, the loop ends. When the transform completes, the frame rate is calculated and displayed, showing how quickly your computer rendered the images.

<P>
To sweep the transform in the other direction, the <b>HandlePlayBackward</b> function is used. It is much the same as <b>HandlePlayForward</b>, but with the loop over <i>Progress</i> moving down from one to zero instead of up from zero to one.

<p>
Much of the previous code dealt with standard function calls in a Windows application. However, the code for performing a sophisticated transform took only a few lines. Setting things up required calls to methods in the <b>IDXTransformFactory</b>, the <b>IDXSurfaceFactory</b>, <b>IDXTransform</b>, and <b>IDXEffect</b> interfaces. Performing the transform required setting the <i>Progress</i> value and calling <b>Execute</b>. DirectX Transform took care of all the details for combining the images.







<!-- CONTENTS_END -->


<!-- START_PAGE_FOOTER -->




<H5><HR size=1></H5>

<P><A CLASS="line" HREF="#pagetop"><IMG src="../art/arrowup1.gif" WIDTH="11" HEIGHT="11" ALIGN="MIDDLE" BORDER=0 ALT="Top of Page">&nbsp;Top of Page</A>

<BR><A CLASS="line" HREF="../../cpyright.htm">&#169; 1998 Microsoft Corporation. All rights reserved. Terms of Use.</A>

<!-- END_PAGE_FOOTER -->


</BLOCKQUOTE>




<!-- START POP-UP GLOSSARY -->

<SCRIPT LANGUAGE="JAVASCRIPT">if((g_isIE == true) && (g_iMaj > 3)) {window.self.document.writeln('<SCR' + 'IPT SRC="../tip2.js"></SCR' + 'IPT><IFRAME ID="G_L_S" NAME="SecretBuffer" STYLE="display: none" SRC=""></IFRAME>')}</SCRIPT>
<!-- END POP-UP GLOSSARY -->


<!-- DACONTROL_START -->

    <DIV ID="HeadGraphAnim"></DIV>
    <SCRIPT LANGUAGE="JAVASCRIPT">if((g_isIE == true) && (g_iMaj > 3)) {window.self.document.writeln('<SCR' + 'IPT SRC="../anim.js"></SCR' + 'IPT>')}</SCRIPT>
<!-- DACONTROL_END -->

</BODY></HTML>

