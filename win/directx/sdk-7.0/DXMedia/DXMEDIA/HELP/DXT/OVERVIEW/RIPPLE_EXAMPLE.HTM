<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<HTML>
<HEAD><TITLE>Example: The Ripple Transform</TITLE>
<SCRIPT LANGUAGE="JavaScript"> var sRelPath = '../' </SCRIPT>


<META NAME="Description" CONTENT="Example: The Ripple Transform">
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; CHARSET=iso8859-1">
<META NAME="MS.LOCALE" CONTENT="EN-US">
<META NAME="ROBOTS" CONTENT="all">

<!-- SNIFF_START -->


<SCRIPT LANGUAGE="JAVASCRIPT">

//<!--

var g_isIE = false, g_isNav = false, g_iMaj = 0, g_sPlat = "";

// -->


</SCRIPT>

<SCRIPT SRC="../ver.js"></SCRIPT>
<SCRIPT SRC="../gloss.js"></SCRIPT>





<SCRIPT DEFER SRC="../common.js"></SCRIPT>

<SCRIPT DEFER>

//<!--

function InitPage()

{

    if (g_isIE && g_iMaj >= 4)    

    {



        SetTOC();

    }

}

//-->


</SCRIPT>



<!-- STYLE_START -->


<SCRIPT LANGUAGE="JAVASCRIPT">

//<!--

   var sVR = '../'    // Set root for the style sheet

   var sCSS = '<LINK REL="stylesheet" HREF="' + sVR;



   if(g_isIE)

   {

       if (g_iMaj >= 4) // For MSIE 4.0 or later

       {

           sCSS += 'dxm_basicSDKIE4';

           if (g_sPlat == "Win") // Windows only for now

           {

               document.createStyleSheet(sVR + 'dxm_advSDKIE4.css');

           }

       }

       else // For MSIE 3.0 or earlier

       {

           sCSS += 'dxm_basicSDKIE3';

       }

   }

   else if (g_isNav) // For all Nav versions

   {

       sCSS += 'dxm_basicSDKNAV';

   }

   else

   {

       sCSS += 'dxm_basicSDKIE3'; // default to IE3 sheet

   }



   sCSS += (sCSS == '' ? '' : '.css" TYPE="text/css">');



   document.write(sCSS);

//-->


</SCRIPT>

<!-- STYLE_END -->




</HEAD>

<BODY onload="InitPage(); if (g_isIE && g_iMaj >= 4){HdgrphControl()}" BGCOLOR="#FFFFFF">
<A NAME="pagetop"></A><A NAME="understanding_dxsurfaces"></A>



<!-- HEADGRAPH_START -->



<!-- TOOLBAR_START -->

<!-- TOOLBAR_END -->


<!-- HEADGRAPH_START -->

<TABLE CLASS="main" BORDER=0 CELLSPACING="0" CELLPADDING="0" WIDTH="*">
<TR>
<TD ROWSPAN="3" VALIGN="TOP" WIDTH="*">
<IMG SRC="../art/header1.gif" WIDTH="107" HEIGHT="110" BORDER=0 ALT="DirectX Transform Animated Header -- Microsoft DirectX Transform SDK"></TD>
<TD ROWSPAN="2" VALIGN="TOP" WIDTH="217"><IMG SRC="../art/hdrdtrns.gif" WIDTH="217" HEIGHT="110" BORDER=0 ALT="Microsoft DirectX Transform SDK"></TD>
<TD VALIGN="TOP" WIDTH="383">
<IMG SRC="../art/header3.gif" WIDTH="383" HEIGHT="95" BORDER=0 ALT="DirectX Transform Animated Header">
</TD>
<TD VALIGN="TOP" WIDTH="100%">
<IMG SRC="../art/spacer1.gif" WIDTH="100%" HEIGHT="94" BORDER=0 ALT="Microsoft DirectX Transform SDK">
</TD>
</TR>
<!-- HEADGRAPH_END -->

<!-- NAV_LINKS_START -->

<TR><TD VALIGN="TOP"><PRE><IMG ID="TOC_" SRC="../art/yelbtn.gif" WIDTH="11" HEIGHT="11" ALIGN="MIDDLE" BORDER=0 ALT="*"><A STYLE="color:black;font-weight:bold" ID="TOC" HREF="../contents.htm">Contents</A>  <IMG SRC="../art/yelbtn.gif" WIDTH="11" HEIGHT="11" ALIGN="MIDDLE" BORDER=0 ALT="*"><A STYLE="color:black;font-weight:bold" HREF="../index.htm">Index</A>  <IMG SRC="../art/yelbtn.gif" WIDTH="11" HEIGHT="11" ALIGN="MIDDLE" BORDER=0 ALT="*"><A STYLE="color:black;font-weight:bold" HREF="writingtransforms.htm">Topic Contents</A>
</PRE></TD></TR>

<TR><TD COLSPAN="2" VALIGN="TOP"><PRE><IMG SRC="../art/yelbtn.gif" WIDTH="11" HEIGHT="11" ALIGN="MIDDLE" BORDER=0 ALT="*"><B>Previous Topic:</B> <A STYLE="color:black" HREF="writing_2dtransforms.htm">Example: The Wipe Transform</A>
<IMG SRC="../art/yelbtn.gif" WIDTH="11" HEIGHT="11" ALIGN="MIDDLE" BORDER=0 ALT="*"><B>Next Topic:</B> <A  STYLE="color:black" HREF="dxetool_writers.htm">DXETool for Transform Writers</A>
</PRE></TD></TR></TABLE>

<!-- NAV_LINKS_END -->




<BLOCKQUOTE class="body">

<!-- CONTENTS_START -->


<H1>Example: The Ripple Transform</H1>

<P>This article discusses the <A HREF="../reference/effects/ripple.htm">Ripple</A> transform as an example of how to write a three-dimensional (3-D) transform. The Microsoft&reg; Visual Studio&reg; project and source code can be found in the C:\Samples\Multimedia\Dtrans\C++\Ripple folder of the Microsoft DirectX&reg; Media Software Development Kit (SDK). 

<p>
Before reading this article, you should run the DXETool application and view the <B>Ripple</B> transform effect. It is located in the C:\DXMedia\bin directory of the SDK. Select the &quot;Ripple Sample&quot; transform and load an image from the <B>File</B> menu. If you right-click and hold the mouse button on the image and move the mouse, you can change the position of the camera on the z-axis, which changes the size of the object on the screen. You can change the orientation of the 3-D object by clicking on the object while moving the mouse. You can play the transform by selecting the right double-arrow button next to the <B>Progress</B> slider. This effect is best viewed with the surface turned slightly sideways, so that the displacements of the 3-D surfaces are easier to see.

<p>As the animation proceeds over time, you should see a flat surface that quickly begins to distort and produce waves. The wave amplitude is a maximum at 25 percent <i>Progress</i>, after which the waves begin to gradually stop. This way of dividing the animation over <i>Progress</i> produces the effect of a stone being dropped in a still pond, producing large waves at the start and slowly dissipating over time.
<p>
This article examines the <B>Ripple</B> transform in the following sections.
<ul>
    <li><a href="#MakingWaves">Making Waves</a>
    <li><a href="#CustomProperties">Custom Properties</a>
    <li><a href="#CodeOverview">Code Overview</a>
    <li><a href="#OnSetup">The <b>OnSetup</b> Method</a>
    <li><a href="#OnExecute">The <b>OnExecute</b> Method</a>
</ul>

<h2><a name="MakingWaves" IDX_CONCEPT="noindex">Making Waves</a></h2>
<P>When you produce a disturbance in a pond, you can see that displacements of the surface are different at different locations on the surface, and they change over time to produce a smooth, rolling effect. In addition, the amplitude of the waves gets smaller the farther away the wave is from the initial splash.
<p>
Waves on surfaces are represented in code as a series of z-axis displacements of a two-dimensional (2-D) plane formed by the x-axis and y-axis. The <B>Ripple</B> example code uses the following algorithm to calculate wave amplitudes.



<BLOCKQUOTE>
<PRE>z(r, Progress) = A(Progress)*[1 -  r/Max]^2 *
Sin[ 2*pi(r/Wavelength + (1 - Progress)) ]
</PRE>
</BLOCKQUOTE>



<p>
For the <B>Ripple</B> transform, this function






controls the z-position of the vertices of a 3-D mesh. The amplitude is a value that depends on the <i>Progress</i> variable. <I>Progress</I> starts and ends at zero, and achieves its maximum value at  <i>Progress</i> = 0.25. The <i>r</i> variable is the distance of a given vertex from the location of the splash. The <i>Wavelength</i> parameter determines the size of the wave across the surface, and the <i>Max</i> parameter determines how many waves will extend across the surface.

<p>
The displacements previously calculated are applied to a grid of mesh vertices that forms the rectangle of the input image. You'll see how these vertices are created in the <b>OnSetup</b> method and how they are displaced in the <b>OnExecute</b> method.

<h2><a name="CustomProperties" IDX_CONCEPT="noindex">Custom Properties</a></h2>

<P>The <B>Ripple</B> transform custom properties affect the appearance of the waves on the surface. These can be set through the <b>put_PropertyName</b> method, where <I>PropertyName</I> can be any of the listed custom properties for the transform. Similarly, <b>get_PropertyName</b> enables you to retrieve current settings. 
<p>
The following are the <a href="../reference/effects/ripple.htm">Ripple</a> transform custom properties.
<ul>
    <li><I>XOrigin</I>: X-coordinate of the center of the ripples. 
    <li><I>YOrigin</I>: Y-coordinate of the center of the ripples. 
    <li><I>Wavelength</I>: Distance between peaks (or valleys) of the ripples. 
    <li><I>Amplitude</I>: Maximum height of any ripple from a zero baseline.
    <li><I>NumberOfWaves</I>: Number of waves from the center to the outermost wave. This enables you to isolate the wave to a smaller region of the surface. 
    <li><I>MinSteps</I>: Minimum number of steps along each axis to use for constructing the vertices.
    <li><I>MaxSteps</I>: Maximum number of steps along each axis to use for constructing the vertices. The difference between this number and <I>MinSteps</I> is multiplied by the <b>m_fQuality</b> data member and added to <i>MinSteps</i>. The result is the number of vertices along each axis. 
</ul>
<P>In addition, the <b>SetQuality</b> method accesses the <b>m_fQuality</b> data member. This data member is inherited as a protected member of the <A HREF="../reference/CDXBaseNTo1/CDXBaseNTo1_intro.htm">CDXBaseNTo1</A> class and defaults to the value of 0.5 when your transform is created.

<p>For more information about these custom properties, see the <a href="../reference/effects/effects.htm">Transform Reference</a>.

<h2><a name="CodeOverview" IDX_CONCEPT="noindex">Code Overview</a></h2>
<p>The code that does the work for the <B>Ripple</B> transform is located in the CRipple.cpp and CRipple.h files. Open the Ripple.dsp file and take a look at CRipple.cpp.

<p>
The constructor for the <B>CRipple</B> object is located at the beginning of the file. It handles initialization of all the custom properties with default values. These values can be changed by the user with the <B>put_</B><I>Property</I> and <B>get_</B><I>Property</I> methods for each property. You can override the <b>DetermineBnds</b> method from <b>CDXBaseNTo1</b>, so that transform users can determine the volume that the output mesh will occupy.





<p>
Throughout the code you will see repeated calls to the <A HREF="../reference/CDXBaseNTo1/CDXBaseNTo1_helpers.htm#InputSurface">CDXBaseNTo1::InputSurface</A> and <A HREF="../reference/CDXBaseNTo1/CDXBaseNTo1_helpers.htm#OutputMeshBuilder">CDXBaseNTo1::OutputMeshBuilder</a> helper functions. These are helper functions inherited from <b>CDXBaseNTo1</b> that enable you to retrieve pointers to the transform inputs and outputs.

<p>
The bulk of the calculation and vertex manipulation is done with the <b>OnSetup</b> and <b>OnExecute</b> methods and their helper functions.





<h2><a name="OnSetup" IDX_CONCEPT="noindex">The <b>OnSetup</b> Method</a></h2>
<P>The <b>OnSetup</b> method is called by the <A HREF="../reference/Ifaces/idxtransform.htm">IDXTransform</A> interface when a user calls its <a href="../reference/ifaces/idxtransform.htm#setup">Setup</a> method on your transform.

<P>The following code first calls the <B>InitializeBitmap</B> internal helper function, which converts the input <A CLASS="Glossary" HREF="javascript:Glossary(sRelPath + 'gloss/gloss_D.htm#gloss_dxsurface')">DXSurface</A> into a <B>D3DRMTexture3</B> object.

<BLOCKQUOTE>
<PRE>HRESULT CRipple::InitializeBitmap(void)
{
    m_cpInputTexture = NULL;

    _ASSERT(InputSurface(0));
    return m_cpSurfFact-&gt;CreateD3DRMTexture(InputSurface(0), 
        m_cpDirectDraw,m_cpDirect3DRM, 
        IID_IDirect3DRMTexture3,(void**)&amp;m_cpInputTexture);
}
</PRE>
</BLOCKQUOTE>
<P>The transform inherits a pointer to an <a href="../reference/ifaces/idxsurfacefactory.htm">IDXSurfaceFactory</a> interface
from the <B>CDXBaseNTo1</B> base class. The <a href="../reference/ifaces/idxsurfacefactory.htm#CreateD3DRMTexture">IDXSurfaceFactory::CreateD3DRMTexture</a> method performs the conversion and stores the pointer as a data member for later use.

<p>Next, a quick calculation determines the number of vertices and polygons in the mesh, based on the <i>MinSteps</i>, <i>MaxSteps</i>, and <b>m_fQuality</b>. This produces a square mesh of vertices, with two triangular polygons per square.

<BLOCKQUOTE>
<PRE>
m_Steps = m_MinSteps + (long)((m_MaxSteps - m_MinSteps) *
  m_fQuality);
m_cVertices = (m_Steps + 1) * (m_Steps + 1);
    
// Number of polygons
int cPolys = m_Steps * m_Steps * 2;
</PRE>
</BLOCKQUOTE>



<p>
The remaining code is responsible for preparing the rectangular mesh that will be reshaped into the series of waves. Many of the methods of the <b>IDirect3DRMMeshBuilder3</b> interface are required to do this. The <B>Reset</B> internal helper function
creates the vertex and calculates the distance of each vertex from the origin, as shown in the following code.

<BLOCKQUOTE>
<PRE>HRESULT CRipple::Reset()
{
    // Allocate the vertices lookup table.
    delete[] m_prgvert;
    m_prgvert = new D3DRMVERTEX[m_cVertices];
    if (NULL == m_prgvert)
    {
        return E_OUTOFMEMORY;
    }

    delete[] m_pflDistanceTable;
    m_pflDistanceTable = new float[m_cVertices];
    if (!m_pflDistanceTable) {
        return E_OUTOFMEMORY;
    }
    HRESULT hr;

    CDXDBnds bndsBounds;

    if(FAILED(hr = bndsBounds.SetToSurfaceBounds(
      InputSurface(0)))) return hr;

    if(bndsBounds.Width() == 0 || bndsBounds.Height() == 0)
    {
        m_flHeight = TARGET_HEIGHT;
        m_flWidth = TARGET_WIDTH;
    }
    else
    {
        double dHeightToWidthRatio = sqrt(
          (double)bndsBounds.Height()/
          (double)bndsBounds.Width());

        m_flHeight =
          (float)(TARGET_HEIGHT * dHeightToWidthRatio);
        m_flWidth =
          (float)(TARGET_WIDTH / dHeightToWidthRatio);
    }

    // Generate the vertices.
    D3DRMVERTEX* pvert = m_prgvert;
    float *pDist = m_pflDistanceTable;
    for (int y = 0; y &lt;= m_Steps; y++)
    {
        for (int x = 0; x &lt;= m_Steps; x++)
        {
            pvert-&gt;position.x =
              (-m_flWidth  / 2.0f) + ((m_flWidth  * (float)x) /
              (float)m_Steps);
            pvert-&lt;position.y =
              (-m_flHeight / 2.0f) + ((m_flHeight * (float)y) /
              (float)m_Steps);
            float flXDelta = (pvert-&gt;position.x - m_XOrigin);
            float flYDelta = (pvert-&gt;position.y - m_YOrigin);
            *pDist = (float)sqrt
              ((flXDelta * flXDelta) + (flYDelta * flYDelta));
            pvert-&gt;position.z = 0.0f;
            pvert-&gt;normal.x   = 0.0f;
            pvert-&gt;normal.x   = 0.0f;
            pvert-&gt;normal.z   = 1.0f;
            pvert-&gt;tu    = (float)x / (float)m_Steps;
            pvert-&gt;tv    = 1.0f - ((float)y / (float)m_Steps);
            pvert-&gt;color = D3DRGB(255, 0, 0);
            pvert++;
            pDist++;
        }
    }
    return S_OK;   
}
</PRE>
</BLOCKQUOTE>

<P>After allocating the vertex and distance arrays and setting the volume boundaries, the routine enters a double loop over all the vertices, setting the x-position and y-position for each. The <i>pvert</i> variable is a <B>D3DRMVERTEX</B> structure that holds the vertex position, texture coordinates, normal vectors, and color. These are calculated relative to the global constants <b>gc_flWidth</b> and <b>gc_flHeight</b>, which define the 3-D volume used for the mesh. The distance of each vertex from the <b>m_XOrigin</b> and <b>m_YOrigin</b> are also calculated. These two data members are custom properties that are accessed with the corresponding <b>put_</b><I>Property</I> and <b>get_</b><I>Property</I> methods.

<p>When the <b>Reset</b> helper function returns, the created vertices and normals are added to the mesh.
<BLOCKQUOTE>
<PRE>
    // Just need one normal. Initially, everything is facing
    // the same direction.
    // Direct3D Retained Mode will compute its own face normals
    // as needed later on.
    OutputMeshBuilder()-&gt;AddNormal(0.0f,0.0f,1.0f);

    // Add all the vertices and normals. We assume the indices
    // of the vertices increase monotonically from zero.
    for (long i = 0; i &lt; m_cVertices; i++)
    {
        int iVertex =
          OutputMeshBuilder()-&gt;AddVertex(
          m_prgvert[i].position.x,
          m_prgvert[i].position.y,
          m_prgvert[i].position.z);
          
    _ASSERT(iVertex == i);
        hr = OutputMeshBuilder()-&gt;SetTextureCoordinates(
          iVertex, m_prgvert[i].tu, m_prgvert[i].tv);
          
        if (FAILED(hr))
        {
            return hr;
        }
        int iNormal =
          OutputMeshBuilder()-&gt;AddNormal(
          m_prgvert[i].normal.x,
          m_prgvert[i].normal.y,
          m_prgvert[i].normal.z);
          
        _ASSERT(iNormal == i);
    }
    .
    .
    .
</PRE>
</BLOCKQUOTE>
<P>The routine continues by




using these vertex definitions to create two polygons for each square of the mesh, looping over all the squares. When that is done, the input surface texture is associated with the mesh by the <b>IDirect3DRMMeshBuilder3::SetTexture</b> method.

<p>
Finally, the <A HREF="../reference/CDXBaseNTo1/CDXBaseNTo1_helpers.htm#ClearDirty">CDXBaseNTo1::ClearDirty</A> function sets a value that indicates that the transform is ready to produce output. It is an accessor function inherited from <B>CDXBaseNTo1</B>, which tracks whether any of the transform
set-up variables have changed. Note that every <b>put_</b><I>Property</I> call includes a call to <b>SetDirty</b>, so that the transform can be notified whether it needs to perform a set up before execution.

<h2><a name="OnExecute" IDX_CONCEPT="noindex">The <b>OnExecute</b> Method</a></h2>
<P>This is the part of the transform code that uses the wave equation to calculate the z-axis displacements of the vertices. This method is called implicitly when a transform user calls the <a href="../reference/ifaces/idxtransform.htm#Execute">IDXTransform::Execute</a> method.

<p>
The code starts by checking whether any of the inputs have changed since the last call to <b>Execute</b>. If a custom property has changed, the <b>OnSetup</b> method is called again. If only the input image has changed, a full set up is not required. However, the 3-D texture needs to change, which is done with another call to <b>SetTexture</b>. 

<p>
The <b>GetCurrentAmplitude</b> internal helper function uses the <i>Progress</i> property to determine the maximum amplitude of the waves.
<BLOCKQUOTE>
<PRE>float CRipple::GetCurrentAmplitude(void)
{
    if (m_Progress == 0.0f || m_Progress == 1.0f) {
    return 0.0f;
    }
    if (m_Progress &lt;= 0.25f) {
    return m_Amplitude * (1.0f - ((0.25f - m_Progress) * 4.0f));
    } 

    return m_Amplitude *
    (1.0f - ((m_Progress - 0.25f) / 3.0f * 4.0f));
}
</PRE>
</BLOCKQUOTE>
<P>This amplitude is designed to have a maximum at a <I>Progress</I> of 0.25.

<p>
Finally, the code calculates the new z-axis value and normal vector for each vertex based on the <i>Progress</i> value, its position, and its distance from the origin. This new vertex value is changed in the output mesh with the Direct3D Retained Mode <b>IDirect3DRMMeshBuilder3::SetVertex</b> and <b>IDirect3DRMMeshBuilder3::SetNormal</b> methods.

<BLOCKQUOTE>
<PRE>
// Apply the wave to the vertices.
float flMaxDistance = (float)m_NumWaves * m_Wavelength;
D3DRMVERTEX* pvert = m_prgvert;
float * pDistance = m_pflDistanceTable;
for (y = 0; y &lt;= m_Steps; y++)
{
    for (x = 0; x &lt;= m_Steps; x++)
    {
        float flDistance = *pDistance;
        if (flDistance &lt; flMaxDistance &amp;&amp; flCurAmplitude &gt; 0.0f)
        {
            float flTmp = (1.0f - (flDistance / flMaxDistance));
            float flAmp = flCurAmplitude * flTmp * flTmp;
            float flAngle = (1.0f - m_Progress + (flDistance /
              m_Wavelength)) * M_2PI;
            pvert-&gt;position.z = flAmp * (float)sin(flAngle);

             if ((y == 0) || (x == 0))
            {
                pvert-&gt;normal.x = 0.0f;
                pvert-&gt;normal.y = 0.0f;
                pvert-&gt;normal.z = 1.0f;
            } else {
                // CW around current point.                                                                    
                pvert-&gt;normal = ComputeNormal( pvert-&gt;position,
                  (pvert - 1)-&gt;position,
                  (pvert - m_Steps)-&gt;position);
                }
       } else {
            pvert-&gt;position.z = 0.0;
            pvert-&gt;normal.x = 0.0f;
            pvert-&gt;normal.y = 0.0f;
            pvert-&gt;normal.z = 1.0f;
        }
        pvert++;
        pDistance++;
    }
}
pvert = m_prgvert;
for (int i = 0; i &lt; m_cVertices; i++)
{
    hr = OutputMeshBuilder()-&gt;SetVertex(i,
      pvert-&gt;position.x,
      pvert-&gt;position.y,
      pvert-&gt;position.z);
    if (FAILED(hr))
    {
        ::DebugBreak();
        return hr;
    }
    hr = OutputMeshBuilder()-&gt;SetNormal(i,
      pvert-&gt;normal.x,
      pvert-&gt;normal.y,
      pvert-&gt;normal.z);

    if (FAILED(hr))
    {
        ::DebugBreak();
        return hr;
    }
    pvert++;
}

return S_OK;
}
</PRE>
</BLOCKQUOTE>
<P>When the loop is done, the modifications to the output mesh are complete, and the mesh is ready to be displayed by the calling routine.





<!-- CONTENTS_END -->


<!-- START_PAGE_FOOTER -->




<H5><HR size=1></H5>

<P><A CLASS="line" HREF="#pagetop"><IMG src="../art/arrowup1.gif" WIDTH="11" HEIGHT="11" ALIGN="MIDDLE" BORDER=0 ALT="Top of Page">&nbsp;Top of Page</A>

<BR><A CLASS="line" HREF="../../cpyright.htm">&#169; 1998 Microsoft Corporation. All rights reserved. Terms of Use.</A>

<!-- END_PAGE_FOOTER -->


</BLOCKQUOTE>




<!-- START POP-UP GLOSSARY -->

<SCRIPT LANGUAGE="JAVASCRIPT">if((g_isIE == true) && (g_iMaj > 3)) {window.self.document.writeln('<SCR' + 'IPT SRC="../tip2.js"></SCR' + 'IPT><IFRAME ID="G_L_S" NAME="SecretBuffer" STYLE="display: none" SRC=""></IFRAME>')}</SCRIPT>
<!-- END POP-UP GLOSSARY -->


<!-- DACONTROL_START -->

    <DIV ID="HeadGraphAnim"></DIV>
    <SCRIPT LANGUAGE="JAVASCRIPT">if((g_isIE == true) && (g_iMaj > 3)) {window.self.document.writeln('<SCR' + 'IPT SRC="../anim.js"></SCR' + 'IPT>')}</SCRIPT>
<!-- DACONTROL_END -->

</BODY></HTML>

