<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">

<HTML>

<HEAD><TITLE>Example: The Wipe Transform</TITLE>
<SCRIPT LANGUAGE="JavaScript"> var sRelPath = '../' </SCRIPT>

<META NAME="Description" CONTENT="Article_Title">
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; CHARSET=iso8859-1">
<META NAME="MS.LOCALE" CONTENT="EN-US">
<META NAME="ROBOTS" CONTENT="all">



<!-- SNIFF_START -->


<SCRIPT LANGUAGE="JAVASCRIPT">

//<!--

var g_isIE = false, g_isNav = false, g_iMaj = 0, g_sPlat = "";

// -->


</SCRIPT>

<SCRIPT SRC="../ver.js"></SCRIPT>
<SCRIPT SRC="../gloss.js"></SCRIPT>





<SCRIPT DEFER SRC="../common.js"></SCRIPT>

<SCRIPT DEFER>

//<!--

function InitPage()

{

    if (g_isIE && g_iMaj >= 4)    

    {



        SetTOC();

    }

}

//-->


</SCRIPT>



<!-- STYLE_START -->


<SCRIPT LANGUAGE="JAVASCRIPT">

//<!--

   var sVR = '../'    // Set root for the style sheet

   var sCSS = '<LINK REL="stylesheet" HREF="' + sVR;



   if(g_isIE)

   {

       if (g_iMaj >= 4) // For MSIE 4.0 or later

       {

           sCSS += 'dxm_basicSDKIE4';

           if (g_sPlat == "Win") // Windows only for now

           {

               document.createStyleSheet(sVR + 'dxm_advSDKIE4.css');

           }

       }

       else // For MSIE 3.0 or earlier

       {

           sCSS += 'dxm_basicSDKIE3';

       }

   }

   else if (g_isNav) // For all Nav versions

   {

       sCSS += 'dxm_basicSDKNAV';

   }

   else

   {

       sCSS += 'dxm_basicSDKIE3'; // default to IE3 sheet

   }



   sCSS += (sCSS == '' ? '' : '.css" TYPE="text/css">');



   document.write(sCSS);

//-->


</SCRIPT>

<!-- STYLE_END -->




</HEAD>

<BODY onload="InitPage(); if (g_isIE && g_iMaj >= 4){HdgrphControl()}" BGCOLOR="#FFFFFF">

<A NAME="pagetop"></A>



<!-- HEADGRAPH_START -->


<TABLE CLASS="main" BORDER=0 CELLSPACING="0" CELLPADDING="0" WIDTH="*">

<TR>

<TD ROWSPAN="3" VALIGN="TOP" WIDTH="*">
<IMG SRC="../art/header1.gif" WIDTH="107" HEIGHT="110" BORDER=0 ALT="DirectX Transform Animated Header -- Microsoft DirectX Transform SDK"></TD>
<TD ROWSPAN="2" VALIGN="TOP" WIDTH="217"><IMG SRC="../art/hdrdtrns.gif" WIDTH="217" HEIGHT="110" BORDER=0 ALT="Microsoft DirectX Transform SDK"></TD>
<TD VALIGN="TOP" WIDTH="383">
<IMG SRC="../art/header3.gif" WIDTH="383" HEIGHT="95" BORDER=0 ALT="DirectX Transform Animated Header">
</TD>
<TD VALIGN="TOP" WIDTH="100%">
<IMG SRC="../art/spacer1.gif" WIDTH="100%" HEIGHT="94" BORDER=0 ALT="Microsoft DirectX Transform SDK">
</TD>

<TD VALIGN="TOP" WIDTH="100%">

<IMG SRC="../art/spacer1.gif" WIDTH="100%" HEIGHT="94" BORDER=0 ALT="Microsoft DirectX Transform SDK"></TD></TR>

<!-- HEADGRAPH_END -->


<!-- NAV_LINKS_START -->


<TR><TD VALIGN="TOP"><PRE><IMG ID="TOC_" SRC="../art/yelbtn.gif" WIDTH="11" HEIGHT="11" ALIGN="MIDDLE" BORDER=0 ALT="*"><A STYLE="color:black;font-weight:bold" ID="TOC" HREF="../contents.htm">Contents</A>  <IMG SRC="../art/yelbtn.gif" WIDTH="11" HEIGHT="11" ALIGN="MIDDLE" BORDER=0 ALT="*"><A STYLE="color:black;font-weight:bold" HREF="../index.htm">Index</A>  <IMG SRC="../art/yelbtn.gif" WIDTH="11" HEIGHT="11" ALIGN="MIDDLE" BORDER=0 ALT="*"><A STYLE="color:black;font-weight:bold" href="writingtransforms.htm">Topic Contents</A>

</PRE></TD></TR>

<TR><TD COLSPAN="2" VALIGN="TOP"><PRE><IMG SRC="../art/yelbtn.gif" WIDTH="11" HEIGHT="11" ALIGN="MIDDLE" BORDER=0 ALT="*"><B>Previous Topic:</B> <A STYLE="color:black" href="baseclass_basics.htm">How to Use the CDXBaseNTo1 Base Class</a>
<IMG SRC="../art/yelbtn.gif" WIDTH="11" HEIGHT="11" ALIGN="MIDDLE" BORDER=0 ALT="*"><B>Next Topic:</B> <A  STYLE="color:black" HREF="ripple_example.htm">Example: The Ripple Transform</A>

</PRE></TD></TR></TABLE>

<!-- NAV_LINKS_END -->






<BLOCKQUOTE CLASS="body">



<!-- CONTENTS_START -->




<H1><a name="writing_2dtransforms">Example: The Wipe Transform</a></H1>


<P>This article walks you through the Wipe transform sample code. This transform uses custom helper functions and elements common to all dynamic-link library (.dll) files that use Microsoft&reg; DirectX&reg; Transform routines.

<P>This article assumes you are familiar with Component Object Model (COM) and that you have run the WipeDlg.exe so that you are familiar with the appearance of the transform.

<p>
The transforms for WipeDlg.exe are contained in Wipe.dll. The Microsoft Visual Studio&reg; project for building this .dll file is located in the Dxmedia\Samples\Multimedia\Dtrans\C++\Wipe\Wipedll folder. To see how Wipe.dll combines the two images to form the output, open the Wipe.dsp project file and look at the DxtWipe.cpp source file. The program follows three steps to produce the transform.

<P>This article contains the following sections.
<ul>
    <li><a href="writing_2Dtransforms.htm#IdentifyingTheRegions">Identifying the Regions</a>
    <li><a href="writing_2Dtransforms.htm#BuildingTheGradient">Building the Gradient</a>
    <li><a href="writing_2Dtransforms.htm#CombiningTheImages">Combining the Images</a>
    <li><a href="writing_2Dtransforms.htm#Summary">Summary</a>
</ul>

<P>The <A HREF="using_2Dtransforms.htm">Using 2-D Transforms</A> article walks you through WipeDlg.exe, which uses a transform to gradually change one image into another. For WipeDlg.exe, WipeDlg.cpp takes care of loading and displaying the images, and DirectX Transform takes care of the detailed combination of the images. See the <A HREF="../reference/effects/effects.htm">Transform Reference</A> for information about other transforms included with this Software Development Kit (SDK) that you can add to your applications.
<p>
The DirectX Transform architecture enables you to develop your own ideas for transitions and effects and implement them in code in two ways. You can load the images as part of an application into <A CLASS="Glossary" HREF="javascript:Glossary(sRelPath + 'gloss/gloss_D.htm#gloss_dxsurface')">DXSurface</A> objects and manipulate them sample-by-sample to form a new image using the <A HREF="../reference/Ifaces/idxargbreadptr.htm">IDXARGBReadPtr</A> and <A HREF="../reference/Ifaces/idxargbreadwriteptr.htm">IDXARGBReadWritePtr</A> interfaces. Or you can place the algorithm that produces the effect into a separate transform that applications will be able to invoke using COM methods. The latter way is preferred because it makes the transform separate from the application and allows it to be easily reused and distributed.

<h2><a name="IdentifyingTheRegions">Identifying the Regions</a></h2>

<P>The Wipe transform divides the viewing area of the source surfaces into three areas.

<IMG align=right SRC="../art/writing_fig1.gif" WIDTH=181 HEIGHT=137 ALT="[Img B | gradient | Img A]" BORDER="0">

<ol>
    <li>A rectangular area that is from only<br>
	 Image A.
    <li>A rectangular area that is from only<br>
	 Image B.
    <li>A rectangular gradient area that is a mixture of both Image A and Image B.
</ol>

<p>The previous illustration shows a typical Wipe transform. Because the default transform sweeps from left to right, the boundary between the Image A area and the gradient is called the <I>leading edge</I>. Similarly, the boundary between Image B and the gradient is called the <I>trailing edge</I>. The positions of these two boundaries relative to the picture frame






determine how the samples in a given row will be combined to form a row in the output image. For samples from the left edge of the image to the trailing edge, there is no mixing; all samples are from Image B. From the leading edge to the right edge of the image, all the samples are from Image A. In the region from the trailing edge to the leading edge, samples from the two images are mixed to produce a smooth transition between the two.

<p>The following code shows two variables that determine these positions, which are set by the calling application. The <i>Progress</i> variable is a number from 0.0 to 1.0, indicating how much of the transition has completed. The <i>m_GradPercentSize</i> variable specifies what percentage of the total image width to use as the gradient region. Note that this percentage can be greater than 100 percent, making the gradient width larger than the entire image width. This also means that the leading and trailing edges are not necessarily inside the image boundaries.

<p><b>_ComputeStartPoints</b> is a helper function in DxtWipe.cpp that calculates the location of the leading and trailing edges, which are used to locate the <i>AStart</i> and <i>GradStart</i> positions. In addition, it calculates <i>AWid</i> and <i>BWid</i>, which are used later to get the correct number of samples from each image.

<pre>
void CDXTWipe::_ComputeStartPoints(const CDXDBnds &amp; bnds,
    ULONG &amp; AWid, ULONG &amp; AStart, ULONG &amp; BWid, ULONG &amp; BUnpackWid,
    ULONG &amp; GradStart, ULONG &amp; GradWid, ULONG &amp; GradWgtStart)
{
    AWid = 0, AStart = 0, BWid = 0, BUnpackWid = 0;
    GradStart = 0, GradWid = 0, GradWgtStart = 0;
    ULONG BndsWid = bnds.Width();
    ULONG ulRange     = m_InputSize.cx + m_GradientSize;
    long LeadEdgePos  = (long)(ulRange * GetEffectProgress());
    long TrailEdgePos = LeadEdgePos - m_GradientSize;

    if( LeadEdgePos &gt;= bnds.Left() )
    {
        if( LeadEdgePos &lt;= bnds.Right() )
        {
            if( TrailEdgePos &lt; bnds.Left() )
            {
                // Leading in-between, trailing out
                GradWid =
                m_GradientSize - ( bnds.Left() - TrailEdgePos );
                GradWgtStart = bnds.Left() - TrailEdgePos;
            }
            else
            {
                // Leading and Trailing in between
                GradWid = m_GradientSize;
                BWid = TrailEdgePos - bnds.Left();
            }
            GradStart = m_GradientSize - GradWid;
            AWid = BndsWid - GradWid - BWid;
        }
        else
        {
            if( TrailEdgePos &lt; bnds.Left() )
            {
                // Leading is past right, trailing is before left
                GradWid      = BndsWid;
                GradWgtStart = bnds.Left() - TrailEdgePos;
            }
            else if( TrailEdgePos &lt; bnds.Right() )
            {
                // Leading is past right, trailing is in between
                GradWid = bnds.Right() - TrailEdgePos;
                BWid    = BndsWid - GradWid;
            }
            else
            {
                // All B
                BWid = BndsWid;
            }
        }
        GradStart  = BWid;
        BUnpackWid = BWid + GradWid;
        AStart     = GradStart + GradWid;
    }
    else
    {
        // All A
        AWid = BndsWid;
    }
}

</pre>

<P>As shown in the previous code, after all the variables are initialized, the routine locates the leading and trailing edges. Notice that the leading edge position is the product of the image width and the <i>Progress</i>. After initialization, each possible combination of edge locations is tested, with the width and positions of the gradient, the A region, and the B region set accordingly. In cases where the trailing edge is located to the left of the image boundary, the <i>GradWgtStart</i> variable records how much of the gradient region lies outside the image. Notice also that <i>ulRange</i> is equal to the sum of the full image width and the gradient regions. This means that the trailing edge of the gradient is at the right boundary of the image when <i>Progress</i> is equal to one, and only Image B is visible.

<h2><a name="BuildingTheGradient">Building the Gradient</a></h2>

<P>When the <B>Setup</B> method is called for this transform by the application, the transform interface calls the <b>OnSetup</b> function.

<pre>
HRESULT CDXTWipe::OnSetup( DWORD dwFlags )
{
    // Compute the effect step resolution and weights.
    HRESULT hr;
    CDXDBnds InBounds(InputSurface(0), hr);
    if (SUCCEEDED(hr))
    {
        InBounds.GetXYSize(m_InputSize);
        _UpdateStepRes();
        hr = _UpdateGradWeights();
    }
    return hr;
</pre>

<P>The function in the previous code starts when a <A HREF="../reference/CDXBnds/CDXBnds_intro.htm">CDXBnds</A> object is created and initialized with the bounds of one of the input surfaces. Inside the .dll code, the input and output surface pointers are obtained with the <b>InputSurface</b> and <b>OutputSurface</b> methods of the <A HREF="../reference/CDXBaseNTo1/CDXBaseNTo1_intro.htm">CDXBaseNTo1</A> class. Because the input index of zero corresponds to Image A, this stores the bounds of Image A in the <B>InBounds</B> object. The <b>m_InputSize</b> data member of the <B>Wipe</B> transform object is initialized with this width, and two other functions are called. <b>_UpdateStepRes</b> calculates <i>m_GradientSize</i> based on the custom property variable <i>m_GradPercentSize</i>, shown in the following:


<pre>
m_GradientSize   = (long)(m_InputSize.cx * m_GradPercentSize);
</pre>

<p>The following code shows <b>_UpdateGradWeights</b>, which creates an array of gradient weights that step smoothly from 255 to zero. The size of the array is equal to the width of the gradient region. Elements of this array are used later as an <A CLASS="Glossary" HREF="javascript:Glossary(sRelPath + 'gloss/gloss_A.htm#gloss_alpha_channel')">alpha channel</A> to mix different amounts of Image A and Image B samples.

<pre>
HRESULT CDXTWipe::_UpdateGradWeights( void )
{
    HRESULT hr = S_OK;

    delete m_pGradientWeights;
    m_pGradientWeights = new ULONG[m_GradientSize];

    if( !m_pGradientWeights )
    {
        hr = E_OUTOFMEMORY;
    }
    else
    {
        float fWeight = 1.0, fInc = 1.f / m_GradientSize;
        for(long i = 0; i &lt; m_GradientSize; ++i, fWeight -= fInc )
        {
            m_pGradientWeights[i] = (ULONG)(fWeight * 255.);
        }
    }

    return hr;
</pre>

<h2><a name="CombiningTheImages">Combining the Images</a></h2>

<P>When the application calls the <A HREF="../reference/Ifaces/idxtransform.htm#execute">IDXTransform::Execute</A> method, the <b>WorkProc</b> function of DxtWipe.cpp is executed and the two images are combined row-by-row into a single output image. The <i>WI</i> variable is a pointer to a <A HREF="../reference/CDXTWorkInfoNTo1/CDXTWorkInfoNTo1.htm">CDXTWorkInfoNTo1</A> object




 passed to the function that contains the bounds of output surface and an HRESULT that indicates to the calling routine whether the transform was successful. The <i>pbContinue</i> parameter is used for multithreading, causing the .dll to exit if its thread is stopped.
<pre>
HRESULT CDXTWipe::WorkProc(
const CDXTWorkInfoNTo1&amp; WI, BOOL* pbContinue )
{
    HRESULT hr = S_OK;

    // Get input sample access pointer for the requested region.
    // Note: Lock may fail due to a lost surface.
    CComPtr&lt;IDXARGBReadPtr&gt; pInA;
    hr = InputSurface( 0 )-&gt;LockSurface(
    &amp;WI.DoBnds, m_ulLockTimeOut, DXLOCKF_READ,
    IID_IDXARGBReadPtr, (void**)&amp;pInA, NULL );
    if( FAILED( hr ) ) return hr;

    CComPtr&lt;IDXARGBReadPtr&gt; pInB;
    hr = InputSurface( 1 )-&gt;LockSurface(
    &amp;WI.DoBnds, m_ulLockTimeOut, DXLOCKF_READ,
    IID_IDXARGBReadPtr, (void**)&amp;pInB, NULL );
    if( FAILED( hr ) ) return hr;

    // Put a write lock only on the region we are updating so
    // multiple threads don't conflict.
    // Note: Lock may fail due to a lost surface.
    CComPtr&lt;IDXARGBReadWritePtr&gt; pOut;
    hr = OutputSurface()-&gt;LockSurface(
    &amp;WI.OutputBnds, m_ulLockTimeOut, DXLOCKF_READWRITE,
    IID_IDXARGBReadWritePtr, (void**)&amp;pOut, NULL );
    if( FAILED( hr ) ) return hr;
</pre>

<P>The preceding code begins by declaring COM pointer variables to DirectX Transform read and read/write interfaces. The input and output surfaces for the transform are not referenced directly, but with the <b>InputSurface</b> and <b>OutputSurface</b> member functions of the <B>CDXBaseNTo1</B> class. Multiple surface inputs are usually stored in arrays and indexed as previously shown. The two input surfaces are locked with the <a href="../reference/ifaces/idxsurface.htm#locksurface">IDXSurface::LockSurface</a> method. Because the lock is made with the <I>DXLOCKF_READ</I> and <I>IID_IDXARGBReadPtr</I> parameters, the method returns read pointers to the two input surfaces. Then the output surface is locked for writing by specifying the <I>DXLOCKF_READWRITE</I> and <I>IID_IDXARGBReadWritePtr</I> parameters.

<p>The following code continues the set up for the image combination.
<pre>
    // Allocate a working buffer
    ULONG DoBndsWid = WI.DoBnds.Width();
    DXPMSAMPLE* pRowBuff = DXPMSAMPLE_Alloca( DoBndsWid );

    // Allocate output buffer if needed
    DXPMSAMPLE *pOutBuff = NULL;
    if( OutputSampleFormat() != DXPF_PMARGB32 )
    {
        pOutBuff = DXPMSAMPLE_Alloca( DoBndsWid );
    }

    // Compute the width of each region.
    ULONG ulDoNumRows = WI.DoBnds.Height();

    ULONG AWid, AStart, BWid, BUnpackWid, GradStart, GradWid,
	GradWgtStart;
    _ComputeStartPoints(WI.DoBnds, AWid, AStart, BWid, BUnpackWid,
    GradStart, GradWid, GradWgtStart);

    // Allocate working buffers for the gradient area.
    DXPMSAMPLE *pGradBuff = DXPMSAMPLE_Alloca( GradWid );

    //
    // Set up the dither structure.
    //
    DXDITHERDESC dxdd;
    if (DoDither())
    {
        dxdd.x = WI.OutputBnds.Left();
        dxdd.y = WI.OutputBnds.Top();
        dxdd.pSamples = pRowBuff;
        dxdd.cSamples = DoBndsWid;
        dxdd.DestSurfaceFmt = OutputSampleFormat();
    }
</pre>

<P>To combine the samples from the two input images, the code requires a working buffer that can hold an entire row of image data. The <I>pRowBuff</I> array serves this purpose and is allocated with the <b>DXPMSAMPLE_Alloca</b> helper function. In cases where the transform uses the <b>OverArrayAndMove</b> method to do a composite onto the destination surface, the code needs to allocate a scratch buffer for the operation. This is needed only if the output surface's pixel format is not <A CLASS="Glossary" HREF="javascript:Glossary(sRelPath + 'gloss/gloss_P.htm#gloss_pmargb32')">PMARGB32</A>, so that is checked before allocation.

<p>Next, the leading and trailing edge calculations are performed by <b>_ComputeStartPoints</b>, using the bounds of the output surface. The function returns all the parameters that are needed to unpack the image data, including the gradient width. Combining the data in the gradient region also requires a working buffer, which is allocated after the function call. Finally, if dithered output is required, a structure is initialized to enable it to be produced.

<p>The code then enters the main loop where it reads image data from each of the regions into arrays and combines samples in the gradient region, as shown in the following code.

<pre>
// === Main loop =================================================
for(ULONG OutY = 0; *pbContinue &amp;&amp; (OutY &lt; ulDoNumRows); ++OutY)
{
    // Get leading solid B samples
    if( BUnpackWid )
    {
        pInB-&gt;MoveToRow( OutY );
        pInB-&gt;UnpackPremult( pRowBuff, BUnpackWid, FALSE );
    }
</pre>
If there is an Image B region that shows in the output, the routine moves to the current row in <i>pInB</i> and reads the samples into the working buffer. This is done with the <b>IDXARGBReadPtr::UnpackPremult</b> method, which extracts a number of samples in the native pixel format and converts them to <B>PMARGB32</B> format, if needed. This saves the step of multiplying each color component by alpha before combining the samples. Notice also that because <i>BUnpackWid</i> = <i>BWid</i> + <i>GradWid</i>, the routine is unpacking samples all the way up to the leading edge. The reason for this is shown in the following:


<pre>    
        // Compute gradient transition area
        if( GradWid )
        {
            pInA-&gt;MoveToXY( BWid, OutY );
            pInA-&gt;UnpackPremult( pGradBuff, GradWid, FALSE );

            for( ULONG i = 0; i &lt; GradWid; ++i )
            {
                ULONG Wgt = m_pGradientWeights[GradWgtStart+i];
                pRowBuff[BWid+i] =
                DXScaleSample( pGradBuff[i], Wgt ^ 0xFF ) + 
                DXScaleSample( pRowBuff[BWid+i], Wgt ); 
            }
        }
</pre>

<P>If there is a gradient region, <b>MoveToXY</b> jumps back to the trailing edge position on the same row on Image A and reads in enough samples into the gradient buffer to fill the gradient region. In the loop over the gradient row that follows, the samples are combined based on the value of the gradient weight. Each sample is scaled by the helper function <b>DXScaleSample</b>, which takes a sample color and a weight from zero to 255 and returns the scaled color. Samples from Image B are scaled by <i>Wgt</i>, and samples from Image A are scaled by 1-<i>Wgt</i>, and the sum of the two represents the output.

<pre>       // Get trailing solid A samples
        if( AWid )
        {
            pInA-&gt;MoveToXY( AStart, OutY );
            pInA-&gt;UnpackPremult( pRowBuff + AStart, AWid, FALSE );
        }
</pre>

<P>If there is any region of Image A showing, it is read into <i>pRowBuff</i>, completing this row of the output image. All that remains is to write the completed row to the output surface.

<pre>        // Get the output row
        pOut-&gt;MoveToRow( OutY );
        if (DoDither())
        {
            DXDitherArray(&amp;dxdd);
            dxdd.y++;
        }
        if (DoOver())
        {
            pOut-&gt;OverArrayAndMove(pOutBuff, pRowBuff, DoBndsWid);
        }
        else
        {
            pOut-&gt;PackPremultAndMove(pRowBuff, DoBndsWid);
        }
    } // End for
    return hr;
}
</pre>


<P>First, the write pointer is moved to the correct row of the output surface. If the transform has specified that the output should be dithered, that is done by the <b>DXDitherArray</b> helper function.

<p>The method used to write the output row on the destination surface depends on whether the output row should be blended onto the surface. If so, the <a href="../reference/ifaces/idxargbreadwriteptr.htm#OverArrayAndMove">OverArrayAndMove</a> method is used. This is the method that requires a scratch buffer to hold the blended output of <i>pRowBuff</i> and the destination surface, which was allocated earlier as <i>pOutBuff</i>. If the <i>pRowBuff</i> should replace the corresponding row on the destination surface, the <a href="../reference/ifaces/idxargbreadwriteptr.htm#PackPremultAndMove">PackPremultAndMove</a> method performs the correct operation.

<p>The loop is executed for each row of the two images, until the output surface is filled with the combined image. 

<h2><a name="summary" IDX_CONCEPT="noindex">Summary</a></h2>
<P>This particular image transform used a number of custom helper functions to produce an image effect. There are a number of elements to this routine, however, that are common to all .dll files that use DirectX Transform routines.

<ul>
    <li>The <b>WorkProc</b> function that takes a <A HREF="../reference/CDXTWorkInfoNTo1/CDXTWorkInfoNTo1.htm">CDXTWorkInfoNTo1</A> object and a Boolean as arguments.
    <li>The input and output surfaces are accessed with the <b>InputSurface</b> and <b>OutputSurface</b> helper functions.
    <li>The routine uses <b>LockSurface</b> to get pointers for reading from and writing to each surface.
    <li>The routine uses the methods of the <a href="../reference/ifaces/idxargbreadptr.htm">IDXARGBReadPtr</a> interface to read samples from the input surfaces into local memory.
    <li>The routine uses the methods of the <a href="../reference/ifaces/idxargbreadwriteptr.htm">IDXARGBReadWritePtr</a> interface to write samples to the output surface.
</ul>

<!-- CONTENTS_END -->


<!-- START_PAGE_FOOTER -->




<H5><HR size=1></H5>

<P><A CLASS="line" HREF="#pagetop"><IMG src="../art/arrowup1.gif" WIDTH="11" HEIGHT="11" ALIGN="MIDDLE" BORDER=0 ALT="Top of Page">&nbsp;Top of Page</A>

<BR><A CLASS="line" HREF="../../cpyright.htm">&#169; 1998 Microsoft Corporation. All rights reserved. Terms of Use.</A>

<!-- END_PAGE_FOOTER -->


</BLOCKQUOTE>




<!-- START POP-UP GLOSSARY -->

<SCRIPT LANGUAGE="JAVASCRIPT">if((g_isIE == true) && (g_iMaj > 3)) {window.self.document.writeln('<SCR' + 'IPT SRC="../tip2.js"></SCR' + 'IPT><IFRAME ID="G_L_S" NAME="SecretBuffer" STYLE="display: none" SRC=""></IFRAME>')}</SCRIPT>
<!-- END POP-UP GLOSSARY -->


<!-- DACONTROL_START -->

    <DIV ID="HeadGraphAnim"></DIV>
    <SCRIPT LANGUAGE="JAVASCRIPT">if((g_isIE == true) && (g_iMaj > 3)) {window.self.document.writeln('<SCR' + 'IPT SRC="../anim.js"></SCR' + 'IPT>')}</SCRIPT>
<!-- DACONTROL_END -->

</BODY></HTML>

