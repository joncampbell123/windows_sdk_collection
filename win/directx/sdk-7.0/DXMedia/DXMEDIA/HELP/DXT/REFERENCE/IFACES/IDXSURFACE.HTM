<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<HTML>
<HEAD><TITLE>IDXSurface Interface</TITLE>
<SCRIPT LANGUAGE="JavaScript"> var sRelPath = '../../' </SCRIPT>


<META NAME="Description" CONTENT="IDXSurface">
<META NAME="Description" CONTENT="IDXSurface::GetAppData">
<META NAME="Description" CONTENT="IDXSurface::GetBounds">
<META NAME="Description" CONTENT="IDXSurface::GetColorKey">
<META NAME="Description" CONTENT="IDXSurface::GetDirectDrawSurface">
<META NAME="Description" CONTENT="IDXSurface::GetPixelFormat">
<META NAME="Description" CONTENT="IDXSurface::GetStatusFlags">
<META NAME="Description" CONTENT="IDXSurface::LockSurface">
<META NAME="Description" CONTENT="IDXSurface::LockSurfaceDC">
<META NAME="Description" CONTENT="IDXSurface::SetAppData">
<META NAME="Description" CONTENT="IDXSurface::SetColorKey">
<META NAME="Description" CONTENT="IDXSurface::SetStatusFlags">
<META NAME="Description" CONTENT="GetAppData (IDXSurface)">
<META NAME="Description" CONTENT="GetBounds (IDXSurface)">
<META NAME="Description" CONTENT="GetColorKey (IDXSurface)">
<META NAME="Description" CONTENT="GetDirectDrawSurface (IDXSurface)">
<META NAME="Description" CONTENT="GetPixelFormat (IDXSurface)">
<META NAME="Description" CONTENT="GetStatusFlags (IDXSurface)">
<META NAME="Description" CONTENT="LockSurface (IDXSurface)">
<META NAME="Description" CONTENT="LockSurfaceDC (IDXSurface)">
<META NAME="Description" CONTENT="SetAppData (IDXSurface)">
<META NAME="Description" CONTENT="SetColorKey (IDXSurface)">
<META NAME="Description" CONTENT="SetStatusFlags (IDXSurface)">
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; CHARSET=iso8859-1">
<META NAME="MS.LOCALE" CONTENT="EN-US">
<META NAME="ROBOTS" CONTENT="all">

<!-- SNIFF_START -->

<SCRIPT LANGUAGE="JAVASCRIPT">
//<!--
var g_isIE = false, g_isNav = false, g_iMaj = 0, g_sPlat = "";
// -->

</SCRIPT>
<SCRIPT SRC="../../ver.js"></SCRIPT>
<SCRIPT SRC="../../gloss.js"></SCRIPT>
<!-- SNIFF_END -->


<SCRIPT DEFER SRC="../../common.js"></SCRIPT>
<SCRIPT DEFER>
//<!--
function InitPage()
{
	if (g_isIE && g_iMaj >= 4)	
	{

		SetTOC();
	}
}
//-->

</SCRIPT>

<!-- STYLE_START -->

<SCRIPT LANGUAGE="JAVASCRIPT">
//<!--
   var sVR = '../../'	// Set root for the style sheet
   var sCSS = '<LINK REL="stylesheet" HREF="' + sVR;

   if(g_isIE)
   {
	   if (g_iMaj >= 4) // For MSIE 4.0 or later
	   {
		   sCSS += 'dxm_basicSDKIE4';
		   if (g_sPlat == "Win") // Windows only for now
		   {
			   document.createStyleSheet(sVR + 'dxm_advSDKIE4.css');
		   }
	   }
	   else // For MSIE 3.0 or earlier
	   {
		   sCSS += 'dxm_basicSDKIE3';
	   }
   }
   else if (g_isNav) // For all Nav versions
   {
	   sCSS += 'dxm_basicSDKNAV';
   }
   else
   {
	   sCSS += 'dxm_basicSDKIE3'; // default to IE3 sheet
   }

   sCSS += (sCSS == '' ? '' : '.css" TYPE="text/css">');

   document.write(sCSS);
//-->

</SCRIPT>
<!-- STYLE_END -->


</HEAD>


<BODY onload="InitPage(); if (g_isIE && g_iMaj >= 4){HdgrphControl()}" BGCOLOR="#FFFFFF">
<A NAME="pagetop"></A><A NAME="IDXSurface"></A>
<!--TOOLBAR_START-->

<!--TOOLBAR_EXEMPT-->

<!--TOOLBAR_END-->

<!-- HEADGRAPH_START -->

<TABLE CLASS="main" BORDER=0 CELLSPACING="0" CELLPADDING="0" WIDTH="*">
<TR>
<TD ROWSPAN="3" VALIGN="TOP" WIDTH="*">
<IMG SRC="../../art/header1.gif" WIDTH="107" HEIGHT="110" BORDER=0 ALT="DirectX Transform Animated Header -- Microsoft DirectX Transform SDK"></TD>
<TD ROWSPAN="2" VALIGN="TOP" WIDTH="217"><IMG SRC="../../art/hdrdtrns.gif" WIDTH="217" HEIGHT="110" BORDER=0 ALT="Microsoft DirectX Transform SDK"></TD>
<TD VALIGN="TOP" WIDTH="383">
<IMG SRC="../../art/header3.gif" WIDTH="383" HEIGHT="95" BORDER=0 ALT="DirectX Transform Animated Header">
</TD>
<TD VALIGN="TOP" WIDTH="100%">
<IMG SRC="../../art/spacer1.gif" WIDTH="100%" HEIGHT="94" BORDER=0 ALT="Microsoft DirectX Transform SDK">
</TD>
</TR>
<!-- HEADGRAPH_END -->

<!-- NAV_LINKS_START -->

<TR><TD VALIGN="TOP"><PRE><IMG ID="TOC_" SRC="../../art/yelbtn.gif" WIDTH="11" HEIGHT="11" ALIGN="MIDDLE" BORDER=0 ALT="*"><A STYLE="color:black;font-weight:bold" ID="TOC" HREF="../../contents.htm">Contents</A>  <IMG SRC="../../art/yelbtn.gif" WIDTH="11" HEIGHT="11" ALIGN="MIDDLE" BORDER=0 ALT="*"><A STYLE="color:black;font-weight:bold" HREF="../../index.htm">Index</A>  <IMG SRC="../../art/yelbtn.gif" WIDTH="11" HEIGHT="11" ALIGN="MIDDLE" BORDER=0 ALT="*"><A STYLE="color:black;font-weight:bold" HREF="interface_intro.htm">Topic Contents</A>
</PRE></TD></TR>

<TR><TD COLSPAN="2" VALIGN="TOP"><PRE><IMG SRC="../../art/yelbtn.gif" WIDTH="11" HEIGHT="11" ALIGN="MIDDLE" BORDER=0 ALT="*"><B>Previous Topic:</B> <A STYLE="color:black" HREF="idxrawsurface.htm">IDXRawSurface Interface</A>
<IMG SRC="../../art/yelbtn.gif" WIDTH="11" HEIGHT="11" ALIGN="MIDDLE" BORDER=0 ALT="*"><B>Next Topic:</B> <A  STYLE="color:black" HREF="IDXSurfaceFactory.htm">IDXSurfaceFactory Interface</A>
</PRE></TD></TR></TABLE>

<!-- NAV_LINKS_END -->


<BLOCKQUOTE class="body">

<!-- CONTENTS_START -->


<H1>IDXSurface Interface</H1>

<p>The IDXSurface interface is used by <A CLASS="Glossary" HREF="javascript:Glossary(sRelPath + 'gloss/gloss_d.htm#gloss_dxtransform')">DXTransform</A> objects to access images. The interface is supported by objects that wrap traditional bitmap memory arrays, as well as objects that produce images procedurally. <A CLASS="Glossary" HREF="javascript:Glossary(sRelPath + 'gloss/gloss_d.htm#gloss_dxsurface')">DXSurface</A> objects are created through the <a href="idxsurfacefactory.htm">IDXSurfaceFactory</a> interface. Other objects such as procedural surfaces can implement the <b>IDXSurface</b> interface to act as image objects.


<p>The basic bitmap object is exposed by <B>DXSurface</B> objects.


 These <B>DXSurface</B>s wrap <A CLASS="Glossary" HREF="javascript:Glossary(sRelPath + 'gloss/gloss_d.htm#gloss_ddsurf')">DirectDrawSurface</A> objects or can be used to perform operations directly on memory buffers.

<p>This interface provides methods for determining information about surfaces, such as the native pixel format and bounds. The <B>IDXSurface</B> interface is also used to <a href="idxsurface.htm#locksurface">lock</a> the surface to provide access to the samples or to a handle to a <A CLASS="Glossary" HREF="javascript:Glossary(sRelPath + 'gloss/gloss_d.htm#gloss_devicecontext')">device context</A>.

<p>Implement this interface when you are creating a custom surface. You must reimplement this interface to support new pixel formats that are introduced. If you want to introduce a new pixel format, you need to implement the <B>DXSurface</B> object with the support for the new pixel format. For a list of currently supported pixel formats, see <a href="../../overview/pixelformats.htm">Supported Pixel Formats</a>. 


<p>This interface inherits from the <A HREF="idxbaseobject.htm">IDXBaseObject</A> interface. 


<P>Other objects can implement <b>IDXSurface</b> to act as image objects. These objects are typically referred to as <A CLASS="Glossary" HREF="javascript:Glossary(sRelPath + 'gloss/gloss_P.htm#gloss_proceduralsurface')">procedural surface</A> objects, because they produce data on request. Two examples of procedural surfaces are gradient fills and Surface Modifiers.


<P CLASS="ref">IDXSurface Methods</P>
<BLOCKQUOTE>
<TABLE CLASS="ref">
<TR><TD><A HREF="IDXSurface.htm#GetAppData">GetAppData</A></TD>
	<TD>Retrieves an application-specific <B>DWORD</B> of data.
	
 
</TD></TR>
<TR><TD><A HREF="IDXSurface.htm#GetBounds">GetBounds</A></TD>
	<TD>Retrieves the boundary structure containing the surface's bounding volume.
	
 
</TD></TR>
<TR><TD><A HREF="IDXSurface.htm#GetColorKey">GetColorKey</A></TD>
	<TD>Retrieves the surface's <A CLASS="Glossary" HREF="javascript:Glossary(sRelPath + 'gloss/gloss_C.htm#gloss_colorkey')">color key</A> value.
</TD></TR>
<TR><TD><A HREF="IDXSurface.htm#GetDirectDrawSurface">GetDirectDrawSurface</A></TD>
	<TD>Retrieves an interface on the underlying <B>DirectDrawSurface</B> object
if the <B>DXSurface</B> object is aggregated onto a <B>DirectDrawSurface</B>.
</TD></TR>
<TR><TD><A HREF="IDXSurface.htm#GetPixelFormat">GetPixelFormat</A></TD>
	<TD>Retrieves the pixel format of the surface.
</TD></TR>
<TR><TD><A HREF="IDXSurface.htm#GetStatusFlags">GetStatusFlags</A></TD>
	<TD>Retrieves the surface status flags, indicating whether the surface changes often.
</TD></TR>
<TR><TD><A HREF="IDXSurface.htm#LockSurface">LockSurface</A></TD>
	<TD>Locks a region of the surface and returns a pointer through which you can access samples on <B>DXSurface</B>s.
</TD></TR>
<TR><TD><A HREF="IDXSurface.htm#LockSurfaceDC">LockSurfaceDC</A></TD>
	<TD>Locks a region of the surface and returns an <a href="idxdclock.htm">IDXDCLock</a> interface.
</TD></TR>
<TR><TD><A HREF="IDXSurface.htm#SetAppData">SetAppData</A></TD>
	<TD>Sets the surface's application-specified <B>DWORD</B> of data.
</TD></TR>
<TR><TD><A HREF="IDXSurface.htm#SetColorKey">SetColorKey</A></TD>
	<TD>Sets the surface's color key value.
</TD></TR>
<TR><TD><A HREF="IDXSurface.htm#SetStatusFlags">SetStatusFlags</A></TD>
	<TD>Sets the status flags of the <B>DXSurface</B> object.
</TD></TR>
</TABLE>
</BLOCKQUOTE>

<!-- =================================================================== -->

<H1><A NAME="GetAppData">IDXSurface::GetAppData</A><HR size=1></H1>
<p>Retrieves an application-specific <B>DWORD</B> of data.

<P CLASS="ref">Syntax</P>
<BLOCKQUOTE>
<PRE>HRESULT GetAppData(
	DWORD *pdwAppData
);
</PRE>
</BLOCKQUOTE>

<P CLASS="ref">Parameters</P>
<BLOCKQUOTE>
<DL><DT><I>pdwAppData</I> 
 </DT><DD>[out] Pointer to a <B>DWORD</B> of data that was previously set with the <A HREF="#SetAppData">SetAppData</A> method. If no call has been made to <B>SetAppData</B>, the value returned will be zero.
</DD></DL>
</BLOCKQUOTE>


<P CLASS="ref">Return Value</P>
<BLOCKQUOTE>
<P>Returns S_OK for success or E_POINTER to indicate a NULL pointer argument; these are the only valid return values. The call will not fail if a valid pointer is given.
</BLOCKQUOTE>

<!-- =================================================================== -->

<H1><A NAME="GetBounds">IDXSurface::GetBounds</A><HR size=1></H1>
<p>Retrieves the boundary structure containing the surface's bounding volume. 
<P CLASS="ref">Syntax</P>
<BLOCKQUOTE>
<PRE>HRESULT GetBounds(
	DXBNDS *pBounds
);
</PRE>
</BLOCKQUOTE>

<P CLASS="ref">Parameters</P>
<BLOCKQUOTE>
<DL><DT><I>pBounds</I> 
 </DT><DD>[out] Pointer to the <A HREF="../structs/DXBNDS_struct.htm">DXBNDS</A> boundary structure containing the surface's bounding volume. 
</DD></DL>
</BLOCKQUOTE>

<P CLASS="ref">Return Value</P>
<BLOCKQUOTE>
<P>Returns an <A HREF="../errorandsuccess.htm">HRESULT</A> value that depends on the implementation of the interface. 
</BLOCKQUOTE>


<P CLASS="ref">See Also</P>
<BLOCKQUOTE>
<P><A HREF="idxsurfacemodifier.htm#SetBounds">IDXSurfaceModifier::SetBounds</A>
</BLOCKQUOTE>

<!-- =================================================================== -->

<H1><A NAME="GetColorKey">IDXSurface::GetColorKey</A><HR size=1></H1>
<p>Retrieves the surface's color key value.

<P CLASS="ref">Syntax</P>
<BLOCKQUOTE>
<PRE>HRESULT GetColorKey(
	DXSAMPLE *pColorKey
);
</PRE>
</BLOCKQUOTE>

<P CLASS="ref">Parameters</P>
<BLOCKQUOTE>
<DL><DT><I>pColorKey</I> 
 </DT><DD>[out] Pointer to the <A HREF="../structs/DXSAMPLE_struct.htm">DXSAMPLE</A> structure that indicates the color to be treated as transparent.
</DD></DL>
</BLOCKQUOTE>

<P CLASS="ref">Return Value</P>
<BLOCKQUOTE>
<P>Returns an <A HREF="../errorandsuccess.htm">HRESULT</A> value that depends on the implementation of the interface. 
</BLOCKQUOTE>

<P CLASS="ref">Remarks</P>
<BLOCKQUOTE>
<P>Some surface implementations will not allow color keys, so the method can return E_NOTIMPL.
</BLOCKQUOTE>

<P CLASS="ref">See Also</P>
<BLOCKQUOTE>
<P><A HREF="idxsurface.htm#SetColorKey">IDXSurface::SetColorKey</A>
</BLOCKQUOTE>




<H1><A NAME="GetDirectDrawSurface">IDXSurface::GetDirectDrawSurface</A><HR size=1></H1>
<p>Retrieves an interface on the underlying <B>DirectDrawSurface</B> object if the <B>DXSurface</B> object is aggregated onto a <B>DirectDrawSurface</B>.

<P CLASS="ref">Syntax</P>
<BLOCKQUOTE>
<PRE>HRESULT GetDirectDrawSurface(
	REFIID riid,
	void **ppSurface
);
</PRE>
</BLOCKQUOTE>

<P CLASS="ref">Parameters</P>
<BLOCKQUOTE>
<DL><DT><I>riid</I> 
 </DT><DD>[in] Value indicating the type of interface to return. This can be any interface ID defined by DirectDraw, such as IID_IDirectDrawSurface, IID_IDirectDrawSurface2, or IID_IDirectDrawSurface3, as exposed by the underlying DirectDraw driver. 
</DD></DL>
<DL><DT><I>ppSurface</I> 
 </DT><DD>[out] Address of a pointer to the surface.
 

</DD></DL>
</BLOCKQUOTE>

<P CLASS="ref">Return Value</P>
<BLOCKQUOTE>
<P>Returns an <A HREF="../errorandsuccess.htm">HRESULT</A> value that depends on the implementation of the interface. 
</BLOCKQUOTE>

<P CLASS="ref">Remarks</P>
<BLOCKQUOTE>
<p>Some surfaces, such as procedural surfaces, will not have an underlying <B>DirectDrawSurface</B>. The caller should be prepared for a return code of E_NOTIMPL.


</BLOCKQUOTE>


<H1><A NAME="GetPixelFormat">IDXSurface::GetPixelFormat</A><HR size=1></H1>
<p>Retrieves the pixel format of the surface.

<P CLASS="ref">Syntax</P>
<BLOCKQUOTE>
<PRE>HRESULT GetPixelFormat(
	GUID *pFormatID,
	DXSAMPLEFORMATENUM *pSampleFormatEnum
); 
</PRE>
</BLOCKQUOTE>

<P CLASS="ref">Parameters</P>
<BLOCKQUOTE>
<DL><DT><I>pFormatID</I> 
 </DT><DD>[out] Pointer to the pixel format's globally unique identifier (GUID).
</DD></DL>
<DL><DT><I>pSampleFormatEnum</I> 
 </DT><DD>[out] Pointer to one of the DirectX Transform-supported pixel formats from the <A HREF="..\enums\DXSAMPLEFORMATENUM_enum.htm">DXSAMPLEFORMATENUM</A> enumeration.
</DD></DL>
</BLOCKQUOTE>

<P CLASS="ref">Return Value</P>
<BLOCKQUOTE>
<P>Returns an <A HREF="../errorandsuccess.htm">HRESULT</A> value that depends on the implementation of the interface. 
</BLOCKQUOTE>

<P CLASS="ref">Remarks</P>
<BLOCKQUOTE>
<P>Either pointer can be NULL if the caller does not want the information. Implementers must check for NULL pointers for the call to succeed.


</BLOCKQUOTE>

<P CLASS="ref">See Also</P>
<BLOCKQUOTE>
<P><A HREF="..\enums\DXSAMPLEFORMATENUM_enum.htm">DXSAMPLEFORMATENUM</A>, <a href="../../overview/pixelformats.htm">Supported Pixel Formats</a>
</BLOCKQUOTE>

<!-- ======================================================================== -->


<H1><A NAME="GetStatusFlags">IDXSurface::GetStatusFlags</A><HR size=1></H1>
<p>Retrieves status flags for the surface.

<P CLASS="ref">Syntax</P>
<BLOCKQUOTE>
<PRE>HRESULT GetStatusFlags(
	DWORD *pdwStatusFlags
);
</PRE>
</BLOCKQUOTE>

<P CLASS="ref">Parameters</P>
<BLOCKQUOTE>
<DL>
<DT><I>pdwStatusFlags</I> 
 </DT><DD>[out] Pointer to the location to store the surface status flags.
 

</DD></DL>
</BLOCKQUOTE>

<P CLASS="ref">Return Value</P>
<BLOCKQUOTE>
<P>Returns an <A HREF="../errorandsuccess.htm">HRESULT</A> value that depends on the implementation of the interface. 
</BLOCKQUOTE>

<P CLASS="ref">Remarks</P>
<BLOCKQUOTE>
<P>This method returns the DXSURF_TRANSIENT flag if the data in the surface changes often. If it does, the user should generally not cache information about the surface.


Run information will never be generated for transient surfaces.

<p>If the DXSURF_READONLY flag is set, then the surface cannot be locked with a <B>READWRITE</B> lock.


</BLOCKQUOTE>

<P CLASS="ref">See Also</P>
<BLOCKQUOTE>
<P><A HREF="idxsurface.htm#SetStatusFlags">IDXSurface::SetStatusFlags</A>, <A HREF="..\enums\DXSURFSTATUS_enum.htm">DXSURFSTATUS</A>
</BLOCKQUOTE>

<!-- =================================================================== -->


<H1><A NAME="LockSurface">IDXSurface::LockSurface</A><HR size=1></H1>
<p>Locks a region of the surface and returns a pointer through which you can access samples on <B>DXSurface</B>s.

<P CLASS="ref">Syntax</P>
<BLOCKQUOTE>
<PRE>HRESULT LockSurface(
	const DXBNDS *pBounds,
	ULONG ulTimeOut,
	DWORD dwFlags,
	REFIID riid,
	void **ppPointer,
	ULONG *pulGenerationId
);
</PRE>
</BLOCKQUOTE>

<P CLASS="ref">Parameters</P>
<BLOCKQUOTE>
<DL><DT><I>pBounds</I> 
 </DT><DD>[in] Pointer to the region to lock, as specified by the <A HREF="../structs/DXBNDS_struct.htm">DXBNDS</A> structure; specifying NULL locks the whole surface.
</DD>
<DT><I>ulTimeOut</I> 
 </DT><DD>[in] Time, in milliseconds, that the caller will wait for the lock to be obtained. If the lock attempt fails, E_ABORT is returned. If INFINITE is specified, the method will not return until the lock is acquired.
</DD><DT><I>dwFlags</I> 
 </DT><DD>[in] <B>DWORD</B> value indicating the lock type, specified by the <A HREF="../enums/DXLOCKSURF_enum.htm">DXLOCKSURF</A> enumeration. Specify DXLOCKF_READ (or 0) for read-only access, or DXLOCKF_READWRITE for read/write access to the surface.
</DD>
<DT><I>riid</I> 
 </DT><DD>[in] Interface to return for accessing the samples of the surface. The format for passing this parameter for C programs is <b>&amp;IID_</b> , and for C++ it is <b>IID_</b> .
</DD>
<DT><I>ppPointer</I> 
 </DT><DD>[out] Address of a pointer to the returned interface.
</DD>
<DT><I>pulGenerationId</I> 
 </DT><DD>[out] Pointer to the generation ID associated with the surface.
</DD></DL>
</BLOCKQUOTE>

<P CLASS="ref">Return Value</P>
<BLOCKQUOTE>
<P>Returns an <A HREF="../errorandsuccess.htm">HRESULT</A> value that depends on the implementation of the interface. 
</BLOCKQUOTE>

<P CLASS="ref">Remarks</P>
<BLOCKQUOTE>
<p>Use this method before executing a transform, to lock down a surface and obtain a pointer to a read or read/write interface.


 Typically, this method will return the <A HREF="idxsurfacemodifier.htm">IDXSurfaceModifier</A>, <A HREF="idxargbreadptr.htm">IDXARGBReadPtr</A>, or <A HREF="idxargbreadwriteptr.htm">IDXARGBReadWritePtr</A> interface. These interfaces enable transforms to access the surface samples and to alter the image.

<p>The z and t dimensions


 of the <A HREF="../structs/DXBNDS_struct.htm">DXBNDS</A> structure will usually range from 0 to 1 for two-dimensional surfaces. If the surface is procedural, the z and t dimensions might not be used, depending on the implementation of the interface.

<p>The <I>pulGenerationId</I> parameter is optional. If it is used, it will return the generation ID of the surface when the lock was obtained.

<p>Any number of threads can use <b>LockSurface</b> to obtain read pointers to the same surface or a region within that surface. When requesting a read/write pointer, however, the method checks to see whether the requested bounds overlap any regions that are currently read/write locked. If there is no overlap, the method locks the specified region of the surface and returns the read/write pointer. If the regions do overlap, the method waits <i>ulTimeOut</i> milliseconds for the conflicting region(s) to be released. If the region(s) not are released before the timeout, an E_ABORT <A HREF="../errorandsuccess.htm">HRESULT</a> is returned.

<p>This scheme


 allows multiple threads to modify different regions of the same surface. These processes need to be very careful that they stay within the bounds specified for operations on those regions. To make surface access as fast as possible, the code does not check that you are writing only inside your locked region. Should you write beyond your stated bounds, you might overwrite image data in other regions of the surface or corrupt your application memory.

<p>When requesting a pointer to a region away from the origin, the method returns a pointer to that region and translates the origin to the upper-left corner of the region. All region access should be done relative to the new origin. For example, assume you lock a region from (150,200) to (250,300). All access to that region with the returned pointer should happen within the region (0,0) and (100,100).

<p>The <i>dwFlags</i> parameter is used to specify what type of access is desired (read or read/write), and to provide information to the surface about what type of data access is likely to take place. Two flags, DXLOCKF_WANTRUNINFO and DXLOCKF_EXISTINGINFOONLY, control the generation of run information that is provided through the <a href="idxargbreadptr.htm#MoveAndGetRunInfo">IDXARGBReadPtr::MoveAndGetRunInfo</a> method. If you plan to use run information, you must specify DXLOCKF_WANTRUNINFO when locking the surface, to force the surface to generate run information. The process of generating run information is relatively expensive, but for static surfaces, it only needs to be done once and can significantly improve the performance of some algorithms that access a surface repeatedly. If combined with DXLOCKF_EXISTINGINFOONLY, the run information will not be generated if it does not yet exist.


 Even if you use neither of these flags, the <B>MoveAndGetRunInfo</B> method will return valid information, but you can get a run of type "unknown" that is then the full width of the locked region.


 Run information is never generated for transient surfaces.

<p>If you plan to access samples that are not alpha-premultiplied, you might want to set the flag DXLOCKF_NONPREMULT to give the surface a hint about the type of data access it can expect. This can be especially useful for procedural surfaces.


 In any case, you can access either sample type regardless of whether you set this flag.

<p>The surface is unlocked by calling the <a href="../iunknown.htm#release">IUnknown::Release</a> method on the returned interface. 
</BLOCKQUOTE>

<P CLASS="ref">See Also</P>
<BLOCKQUOTE>
<p><A HREF="../enums/DXLOCKSURF_enum.htm">DXLOCKSURF</A>
</BLOCKQUOTE>

<!-- =================================================================== -->


<H1><A NAME="LockSurfaceDC">IDXSurface::LockSurfaceDC</A><HR size=1></H1>
<p>Locks a region of the surface and returns an <A HREF="idxdclock.htm">IDXDCLock</A> interface.

<P CLASS="ref">Syntax</P>
<BLOCKQUOTE>
<PRE>HRESULT LockSurfaceDC(
	const DXBNDS *pBounds,
	ULONG ulTimeOut,
	DWORD dwFlags,
	IDXDCLock **ppDCLock
);
</PRE>
</BLOCKQUOTE>

<P CLASS="ref">Parameters</P>
<BLOCKQUOTE>
<DL><DT><I>pBounds</I> 
 </DT><DD>[in] Pointer to the region to lock, as specified by the <A HREF="../structs/DXBNDS_struct.htm">DXBNDS</A> structure. If NULL, the entire surface will be locked. 
</DD>
<DT><I>ulTimeOut</I> 
 </DT><DD>[in] Time, in milliseconds, to wait for the lock to be obtained. You can use INFINITE for this parameter. If the lock fails because of a time-out, the call will return E_ABORT. 
</DD><DT><I>dwFlags</I> 
 </DT><DD>[in] <B>DWORD</B> value indicating the lock type. Specify DXLOCKF_READ for read-only access or DXLOCKF_READWRITE for read/write access to the surface.
</DD>
<DT><I>ppDCLock</I> 
 </DT><DD>[out] Address of a pointer to the <B>IDXDCLock</B> interface.
</DD></DL>
</BLOCKQUOTE>

<P CLASS="ref">Return Value</P>
<BLOCKQUOTE>
<P>Returns an <A HREF="../errorandsuccess.htm">HRESULT</A> value that depends on the implementation of the interface. 
</BLOCKQUOTE>

<P CLASS="ref">Remarks</P>
<BLOCKQUOTE>
<P>This method is similar to the <a href="#locksurface">LockSurface</a> but is used to gain access to the surface's handle to a device context (HDC) so that Microsoft&reg; Win32&reg; Graphics Device Interface (GDI) operations can be performed on the data. Many surfaces, such as procedural surfaces, will not have an associated HDC, so this call might return E_NOTIMPL. In this case, if an HDC is required, you might want to use the <a href="idxsurfacefactory.htm#copysurfacetonewformat">IDXSurfaceFactory::CopySurfaceToNewFormat</a> method to obtain a <B>DXSurface</B> that supports an HDC.

<p>The locking semantics are similar to <b>LockSurface</b>, and subregions of the surface can be locked for reading or writing. One important difference is that all HDC locks are not relative to the locked region. In addition, the HDC will reference the entire surface, regardless of the bounds locked.

<p>The returned interface supports only a single method: <A HREF="idxdclock.htm#getdc">IDXDCLock::GetDC</A>, which returns an HDC. The HDC returned is valid for the entire time that a reference is held on the <b>IDXDCLock</b> object. When the object is released by means of <a href="../iunknown.htm#release">IUnknown::Release</a>, then the HDC will be released and the caller should not use it again.
</BLOCKQUOTE>


<!-- =================================================================== -->

<H1><A NAME="SetAppData">IDXSurface::SetAppData</A><HR size=1></H1>
<p>Sets the surface's application-specified <B>DWORD</B> of data.

<P CLASS="ref">Syntax</P>
<BLOCKQUOTE>
<PRE>HRESULT SetAppData(
	DWORD dwAppData
);
</PRE>
</BLOCKQUOTE>

<P CLASS="ref">Parameters</P>
<BLOCKQUOTE>
<DL><DT><I>dwAppData</I> 
 </DT><DD>[in] Any <B>DWORD</B> value to be used by the application to store information specific to the surface.
</DD></DL>
</BLOCKQUOTE>

<P CLASS="ref">Return Value</P>
<BLOCKQUOTE>
<P>Returns S_OK.
</BLOCKQUOTE>

<P CLASS="ref">Remarks</P>
<BLOCKQUOTE>
<P>This method enables an application to "tag" a surface with a unique <B>DWORD</B> of data. Hosts of 3-D transforms might want to tag input surfaces to transforms so that they can identify which textures were hit when doing 3-D hit testing.


 The <a href="idxsurfacefactory.htm#CreateD3DRMTexture">IDXSurfaceFactory::CreateD3DRMTexture</a> method will copy the application data to the texture from the <B>DXSurface</B> when it creates the texture. Applications can use this data in any appropriate way.


<p>All surface implementations must support <B>SetAppData</B> and <B>GetAppData</B>.

</BLOCKQUOTE>

<!-- =================================================================== -->

<H1><A NAME="SetColorKey">IDXSurface::SetColorKey</A><HR size=1></H1>
<p>Sets the surface's <A CLASS="Glossary" HREF="javascript:Glossary(sRelPath + 'gloss/gloss_C.htm#gloss_colorkey')">color key</A> value.

<P CLASS="ref">Syntax</P>
<BLOCKQUOTE>
<PRE>HRESULT SetColorKey(
	DXSAMPLE ColorKey
);
</PRE>
</BLOCKQUOTE>

<P CLASS="ref">Parameters</P>
<BLOCKQUOTE>
<DL><DT><I>ColorKey</I>
 </DT><DD>[in] A color in <A HREF="../structs/DXSAMPLE_struct.htm">DXSAMPLE</A> format indicating the color to be treated as transparent.
</DD></DL>
</BLOCKQUOTE>

<P CLASS="ref">Return Value</P>
<BLOCKQUOTE>
<P>Returns an <A HREF="../errorandsuccess.htm">HRESULT</A> value that depends on the implementation of the interface. 
<P>Many surfaces do not support color keys, so this call could return an <B>HRESULT</B> of E_NOTIMPL.
</BLOCKQUOTE>

<P CLASS="ref">Remarks</P>
<BLOCKQUOTE>
<p>The specified color must have an alpha value of 255 (0xFF). The other color components must specify the color as a 24-bit RGB value. The surface implementation can convert this to a different color representation internally, if necessary.
</BLOCKQUOTE>

<P CLASS="ref">See Also</P>
<BLOCKQUOTE>
<P><A HREF="idxsurface.htm#GetColorKey">IDXSurface::GetColorKey</A>
</BLOCKQUOTE>



<H1><A NAME="SetStatusFlags">IDXSurface::SetStatusFlags</A><HR size=1></H1>
<p>Sets the status flags of the <B>DXSurface</B> object.

<P CLASS="ref">Syntax</P>
<BLOCKQUOTE>
<PRE>HRESULT SetStatusFlags(
	DWORD dwStatusFlags
);
</PRE>
</BLOCKQUOTE>

<P CLASS="ref">Parameters</P>
<BLOCKQUOTE>
<DL><DT><I>dwStatusFlags</I> 
 </DT><DD>[in] Value indicating whether the data in this surface changes often, so you should not cache information about the surface. Specify a value of DXSURF_TRANSIENT if the data in the surface changes often. To prevent write access to a surface, set the DXSURF_READONLY flag. 







</DD></DL>
</BLOCKQUOTE>

<P CLASS="ref">Return Value</P>
<BLOCKQUOTE>
<P>Returns an <A HREF="../errorandsuccess.htm">HRESULT</A> value that depends on the implementation of the interface. 
</BLOCKQUOTE>


<P CLASS="ref">See Also</P>
<BLOCKQUOTE>
<P><A HREF="idxsurface.htm#GetStatusFlags">IDXSurface::GetStatusFlags</A>, <A HREF="..\enums\DXSURFSTATUS_enum.htm">DXSURFSTATUS</A>
</BLOCKQUOTE>

<!-- CONTENTS_END -->

<!-- START_PAGE_FOOTER -->


<H6><HR size=1></H6>
<P><A CLASS="line" HREF="#pagetop"><IMG src="../../art/arrowup1.gif" WIDTH="11" HEIGHT="11" ALIGN="MIDDLE" BORDER=0 ALT="Top of Page">&nbsp;Top of Page</A>
<BR><A CLASS="line" HREF="../../../cpyright.htm">&#169; 1998 Microsoft Corporation. All rights reserved. Terms of Use.</A>
<!-- END_PAGE_FOOTER -->

</BLOCKQUOTE>

<!-- START POP-UP GLOSSARY -->

<SCRIPT LANGUAGE="JAVASCRIPT">if((g_isIE == true) && (g_iMaj > 3)) {window.self.document.writeln('<SCR' + 'IPT SRC="../../tip2.js"></SCR' + 'IPT><IFRAME ID="G_L_S" NAME="SecretBuffer" STYLE="display: none" SRC=""></IFRAME>')}</SCRIPT>
<!-- END POP-UP GLOSSARY -->


<!-- DACONTROL_START -->

	<DIV ID="HeadGraphAnim"></DIV>
	<SCRIPT LANGUAGE="JAVASCRIPT">if((g_isIE == true) && (g_iMaj > 3)) {window.self.document.writeln('<SCR' + 'IPT SRC="../../anim.js"></SCR' + 'IPT>')}</SCRIPT>
<!-- DACONTROL_END -->

</BODY>
</HTML>