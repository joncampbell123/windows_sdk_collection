<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<HTML>
<HEAD><TITLE>IDXARGBReadWritePtr Interface</TITLE>
<SCRIPT LANGUAGE="JavaScript"> var sRelPath = '../../' </SCRIPT>



<META NAME="Description" CONTENT="IDXARGBReadPtr">
<META NAME="Description" CONTENT="IDXARGBReadWritePtr::CopyAndMoveBoth">
<META NAME="Description" CONTENT="IDXARGBReadWritePtr::CopyRect">
<META NAME="Description" CONTENT="IDXARGBReadWritePtr::FillAndMove">
<META NAME="Description" CONTENT="IDXARGBReadWritePtr::FillRect">
<META NAME="Description" CONTENT="IDXARGBReadWritePtr::OverArrayAndMove">
<META NAME="Description" CONTENT="IDXARGBReadWritePtr::OverSample">
<META NAME="Description" CONTENT="IDXARGBReadWritePtr::PackAndMove">
<META NAME="Description" CONTENT="IDXARGBReadWritePtr::PackPremultAndMove">
<META NAME="Description" CONTENT="IDXARGBReadWritePtr::PackRect">
<META NAME="Description" CONTENT="CopyAndMoveBoth (IDXARGBReadPtr)">
<META NAME="Description" CONTENT="CopyRect (IDXARGBReadPtr)">
<META NAME="Description" CONTENT="FillAndMove (IDXARGBReadPtr)">
<META NAME="Description" CONTENT="FillRect (IDXARGBReadPtr)">
<META NAME="Description" CONTENT="OverArrayAndMove (IDXARGBReadPtr)">
<META NAME="Description" CONTENT="OverSample (IDXARGBReadPtr)">
<META NAME="Description" CONTENT="PackAndMove (IDXARGBReadPtr)">
<META NAME="Description" CONTENT="PackPremultAndMove (IDXARGBReadPtr)">
<META NAME="Description" CONTENT="PackRect (IDXARGBReadPtr)">
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; CHARSET=iso8859-1">
<META NAME="MS.LOCALE" CONTENT="EN-US">
<META NAME="ROBOTS" CONTENT="all">

<!-- SNIFF_START -->

<SCRIPT LANGUAGE="JAVASCRIPT">
//<!--
var g_isIE = false, g_isNav = false, g_iMaj = 0, g_sPlat = "";
// -->

</SCRIPT>
<SCRIPT SRC="../../ver.js"></SCRIPT>
<SCRIPT SRC="../../gloss.js"></SCRIPT>
<!-- SNIFF_END -->


<SCRIPT DEFER SRC="../../common.js"></SCRIPT>
<SCRIPT DEFER>
//<!--
function InitPage()
{
	if (g_isIE && g_iMaj >= 4)	
	{

		SetTOC();
	}
}
//-->

</SCRIPT>

<!-- STYLE_START -->

<SCRIPT LANGUAGE="JAVASCRIPT">
//<!--
   var sVR = '../../'	// Set root for the style sheet
   var sCSS = '<LINK REL="stylesheet" HREF="' + sVR;

   if(g_isIE)
   {
	   if (g_iMaj >= 4) // For MSIE 4.0 or later
	   {
		   sCSS += 'dxm_basicSDKIE4';
		   if (g_sPlat == "Win") // Windows only for now
		   {
			   document.createStyleSheet(sVR + 'dxm_advSDKIE4.css');
		   }
	   }
	   else // For MSIE 3.0 or earlier
	   {
		   sCSS += 'dxm_basicSDKIE3';
	   }
   }
   else if (g_isNav) // For all Nav versions
   {
	   sCSS += 'dxm_basicSDKNAV';
   }
   else
   {
	   sCSS += 'dxm_basicSDKIE3'; // default to IE3 sheet
   }

   sCSS += (sCSS == '' ? '' : '.css" TYPE="text/css">');

   document.write(sCSS);
//-->

</SCRIPT>
<!-- STYLE_END -->


</HEAD>


<BODY onload="InitPage(); if (g_isIE && g_iMaj >= 4){HdgrphControl()}" BGCOLOR="#FFFFFF">
<A NAME="pagetop"></A><A NAME="IDXARGBReadWritePtr"></A>
<!--TOOLBAR_START-->

<!--TOOLBAR_EXEMPT-->

<!--TOOLBAR_END-->


<!-- HEADGRAPH_START -->

<TABLE CLASS="main" BORDER=0 CELLSPACING="0" CELLPADDING="0" WIDTH="*">
<TR>
<TD ROWSPAN="3" VALIGN="TOP" WIDTH="*">
<IMG SRC="../../art/header1.gif" WIDTH="107" HEIGHT="110" BORDER=0 ALT="DirectX Transform Animated Header -- Microsoft DirectX Transform SDK"></TD>
<TD ROWSPAN="2" VALIGN="TOP" WIDTH="217"><IMG SRC="../../art/hdrdtrns.gif" WIDTH="217" HEIGHT="110" BORDER=0 ALT="Microsoft DirectX Transform SDK"></TD>
<TD VALIGN="TOP" WIDTH="383">
<IMG SRC="../../art/header3.gif" WIDTH="383" HEIGHT="95" BORDER=0 ALT="DirectX Transform Animated Header">
</TD>
<TD VALIGN="TOP" WIDTH="100%">
<IMG SRC="../../art/spacer1.gif" WIDTH="100%" HEIGHT="94" BORDER=0 ALT="Microsoft DirectX Transform SDK">
</TD>
</TR>
<!-- HEADGRAPH_END -->

<!-- NAV_LINKS_START -->

<TR><TD VALIGN="TOP"><PRE><IMG ID="TOC_" SRC="../../art/yelbtn.gif" WIDTH="11" HEIGHT="11" ALIGN="MIDDLE" BORDER=0 ALT="*"><A STYLE="color:black;font-weight:bold" ID="TOC" HREF="../../contents.htm">Contents</A>  <IMG SRC="../../art/yelbtn.gif" WIDTH="11" HEIGHT="11" ALIGN="MIDDLE" BORDER=0 ALT="*"><A STYLE="color:black;font-weight:bold" HREF="../../index.htm">Index</A>  <IMG SRC="../../art/yelbtn.gif" WIDTH="11" HEIGHT="11" ALIGN="MIDDLE" BORDER=0 ALT="*"><A STYLE="color:black;font-weight:bold" HREF="interface_intro.htm">Topic Contents</A>
</PRE></TD></TR>

<TR><TD COLSPAN="2" VALIGN="TOP"><PRE><IMG SRC="../../art/yelbtn.gif" WIDTH="11" HEIGHT="11" ALIGN="MIDDLE" BORDER=0 ALT="*"><B>Previous Topic:</B> <A STYLE="color:black" HREF="IDXARGBReadPtr.htm">IDXARGBReadPtr Interface</A>
<IMG SRC="../../art/yelbtn.gif" WIDTH="11" HEIGHT="11" ALIGN="MIDDLE" BORDER=0 ALT="*"><B>Next Topic:</B> <A  STYLE="color:black" HREF="IDXARGBSurfaceInit.htm">IDXARGBSurfaceInit Interface</A>
</PRE></TD></TR></TABLE>

<!-- NAV_LINKS_END -->





<BLOCKQUOTE class="body">


<!-- CONTENTS_START -->


<H1>IDXARGBReadWritePtr Interface</H1>
<p>DirectX Transform objects use the <B>IDXARGBReadWritePtr</B> interface to gain read/write access to samples contained in a <A CLASS="Glossary" HREF="javascript:Glossary(sRelPath + 'gloss/gloss_D.htm#gloss_dxsurface')">DXSurface</A> object. This interface contains methods that select
various locations within a <B>DXSurface</B> and  <A HREF="idxargbreadwriteptr.htm#PackandMove">pack</A> <A CLASS="Glossary" HREF="javascript:Glossary(sRelPath + 'gloss/gloss_A.htm#gloss_argb32')">ARGB32</A> or <A CLASS="Glossary" HREF="javascript:Glossary(sRelPath + 'gloss/gloss_P.htm#gloss_pmargb32')">PMARGB32</A> transformed samples into the native, underlying format of the output surface. A pointer to this interface is returned when you use the <A HREF="idxsurface.htm#locksurface">IDXSurface::LockSurface</A> method with the DXLOCKF_READWRITE flag set.

<p>
This interface inherits from <A HREF="idxargbreadptr.htm">IDXARGBReadPtr</A> Interface.


<p>For more information on using this interface, see the <A HREF="../../overview/about_dxtrans.htm#dxtrans_and_dxsurf">Applying Transforms through DXSurfaces</A> article.

<P>If you create a custom <B>DXSurface</B>, you need to implement this interface on your object,  which is used to access samples within your custom surface. 

<p><b>WARNING:</b>  In order to achieve fast performance on these methods, no parameter validation is done before execution.  Passing invalid parameters to any of these methods may cause the .dll to crash.


<P CLASS="ref">IDXARGBWriteReadPtr Methods</P>
<BLOCKQUOTE>
<TABLE CLASS="ref">
<TR><TD><A HREF="IDXARGBReadWritePtr.htm#CopyAndMoveBoth">CopyAndMoveBoth</A></TD>
	<TD>Copies the specified number of samples from the current position of the source surface to the current position of the output surface.
</TD></TR>
<TR><TD><A HREF="IDXARGBReadWritePtr.htm#CopyRect">CopyRect</A></TD>
	<TD>Copies the specified number of samples from the specified rectangle in the source surface to the current position on the output surface.
</TD></TR>
<TR><TD><A HREF="IDXARGBReadWritePtr.htm#FillAndMove">FillAndMove</A></TD>
	<TD>Fills the output surface with the specified sample value starting at the current position and advances the current position.
</TD></TR>
<TR><TD><A HREF="IDXARGBReadWritePtr.htm#FillRect">FillRect</A></TD>
	<TD>Fills the specified rectangle with the specified sample value, optionally doing an &quot;over&quot; operation.
</TD></TR>
<TR><TD><A HREF="IDXARGBReadWritePtr.htm#OverArrayAndMove">OverArrayAndMove</A></TD>
	<TD><A CLASS="Glossary" HREF="javascript:Glossary(sRelPath + 'gloss/gloss_A.htm#gloss_alphablending')">Alpha blends</a> an array of samples over the output surface and moves the pointer a specified number of samples. 
</TD></TR>
<TR><TD><A HREF="IDXARGBReadWritePtr.htm#OverSample">OverSample</A></TD>
	<TD><A CLASS="Glossary" HREF="javascript:Glossary(sRelPath + 'gloss/gloss_A.htm#gloss_alphablending')">Alpha blends</a> the specified sample value over the sample at the specified position.
</TD></TR>
<TR><TD><A HREF="IDXARGBReadWritePtr.htm#PackAndMove">PackAndMove</A></TD>
	<TD>Places a buffer of ARGB32 samples into the output surfaces and moves the sample pointer.
</TD></TR>
<TR><TD><A HREF="IDXARGBReadWritePtr.htm#PackPremultAndMove">PackPremultAndMove</A></TD>
	<TD>Places a buffer of PMARGB32 samples into the output surfaces and moves the sample pointer.
</TD></TR>
<TR><TD><A HREF="IDXARGBReadWritePtr.htm#PackRect">PackRect</A></TD>
	<TD>Accepts a buffer of either PMARGB32 or ARGB32 samples and writes them to a subsection of the output surface defined by a DXPACKEDRECTDESC structure.
</TD></TR>
</TABLE>
</BLOCKQUOTE>


<H1><A NAME="CopyAndMoveBoth">IDXARGBReadWritePtr::CopyAndMoveBoth</A><HR size=1></H1>
<p>Copies the specified number of samples from the current position of the source surface to the current position of the output surface. 

<P CLASS="ref">Syntax</P>
<BLOCKQUOTE>
<PRE>void CopyAndMoveBoth(
	DXBASESAMPLE *pScratchBuffer,
	IDXARGBReadPtr *pSrc,
	ULONG cSamples,
	BOOL bIsOpaque
);
</PRE>
</BLOCKQUOTE>

<P CLASS="ref">Parameters</P>
<BLOCKQUOTE>
<DL>
<DT><I>pScratchBuffer</I> 
 </DT><DD>[in] Pointer to a buffer that may be used by the method. The initial contents of the buffer are ignored, and when the call returns the buffer contents are undefined. The buffer must be at least [<i>cSamples</i> * sizeof(DXBASESAMPLE)] bytes in size. If the surface pixel format is either <A CLASS="Glossary" HREF="javascript:Glossary(sRelPath + 'gloss/gloss_A.htm#gloss_argb32')">ARGB32</A> or <A CLASS="Glossary" HREF="javascript:Glossary(sRelPath + 'gloss/gloss_P.htm#gloss_pmargb32')">PMARGB32</A>, this buffer is not required and <i>pScratchBuffer</i> can be NULL. 
</DD>
<DT><I>pSrc</I> 
 </DT><DD>[in] Source surface read pointer to copy from.
</DD>
<DT><I>cSamples</I> 
 </DT><DD>[in] Number of samples to copy.
</DD>
<DT><I>bIsOpaque</I> 
 </DT><DD>[in] Value specifying whether the samples are opaque or transparent. If TRUE, the caller guarantees that all of the samples being copied have an <A CLASS="Glossary" HREF="javascript:Glossary(sRelPath + 'gloss/gloss_A.htm#gloss_alpha_channel')">alpha channel</A> value of 255. In some cases this can enable faster code performance. If you are not sure that all samples are opaque, specify FALSE. 

</DD>
</DL>
</BLOCKQUOTE>

<P CLASS="ref">Return Value</P>
<BLOCKQUOTE>
<P>No return value.
</BLOCKQUOTE>

<P CLASS="ref">Remarks</P>
<BLOCKQUOTE>
<P>After a call to this method, the positions of both the source and destination surfaces are advanced by <I>cSamples</I>.
</BLOCKQUOTE>

<P CLASS="ref">See Also</P>
<BLOCKQUOTE>
<P><A HREF="idxargbreadwriteptr.htm#CopyRect">IDXARGBReadWritePtr::CopyRect</A>,
<A HREF="../structs/DXBASESAMPLE_struct.htm">DXBASESAMPLE</A>
</BLOCKQUOTE>




<H1><A NAME="CopyRect">IDXARGBReadWritePtr::CopyRect</A><HR size=1></H1>
<p>Copies the specified number of samples from the specified rectangle in the source surface to the current position on the output surface.
<P CLASS="ref">Syntax</P>
<BLOCKQUOTE>
<PRE>void CopyRect(
    DXBASESAMPLE *pScratchBuffer,
	const RECT *pDestRect,
	IDXARGBReadPtr *pSrc,
	const POINT *pSrcOrigin,
	BOOL bIsOpaque
);
</PRE>
</BLOCKQUOTE>

<P CLASS="ref">Parameters</P>
<BLOCKQUOTE>
<DL><DT><I>pScratchBuffer</I>
 </DT><DD>[in] Pointer to a buffer that may be used by the method. The initial contents of the buffer are ignored, and when the call returns the buffer contents are undefined. The buffer must be at least [ (<i>pDestRect.right - pDestRect.left</i>) * sizeof(DXBASESAMPLE) ] bytes in size.  If the surface pixel format is either <A CLASS="Glossary" HREF="javascript:Glossary(sRelPath + 'gloss/gloss_A.htm#gloss_argb32')">ARGB32</A> or <A CLASS="Glossary" HREF="javascript:Glossary(sRelPath + 'gloss/gloss_P.htm#gloss_pmargb32')">PMARGB32</A>, this buffer is not required and <i>pScratchBuffer</i> can be NULL. 
</DD><DT><I>pDestRect</I> 
 </DT><DD>[in] Region, relative to the locked region in the output surface, to copy to. If this parameter is NULL, the entire locked region is used.
</DD>
<DT><I>pSrc</I> 
 </DT><DD>[in] Source surface read pointer to copy from.
</DD>
<DT><I>pSrcOrigin</I> 
 </DT><DD>[in] Point at which the copy starts, relative to the locked source region. If this parameter is NULL, the point (0,0) relative to the locked source region is used.
</DD>
<DT><I>bIsOpaque</I> 
 </DT><DD>[in] Value specifying whether the samples are opaque or transparent. If TRUE, the caller is guaranteeing that all of the samples being copied have an <A CLASS="Glossary" HREF="javascript:Glossary(sRelPath + 'gloss/gloss_A.htm#gloss_alpha_channel')">alpha channel</A> value of 255. In some cases this can allow  faster code performance.  If you are not sure that all samples are opaque, specify FALSE.
</DD>
</DL>
</BLOCKQUOTE>

<P CLASS="ref">Return Value</P>
<BLOCKQUOTE>
<P>No return value.
</BLOCKQUOTE>

<P CLASS="ref">Remarks</P>
<BLOCKQUOTE>
<P>After this call has been made, the current positions of both pointer objects are undefined.






You will need to call <b>MoveToRow</b>, <b>MoveAndGetRunInfo</b>, or <b>MoveToXY</b> to re-establish the pointer location before calling any of the following methods: <b>Unpack</b>, <b>UnpackPremult</b>, <b>CopyAndMoveBoth</b>, <b>FillAndMove</b>, <b>PackAndMove</b>, <b>PackPremultAndMove</b>, or <b>OverArrayAndMove</b>.

</BLOCKQUOTE>

<P CLASS="ref">See Also</P>
<BLOCKQUOTE>
<P><A HREF="idxargbreadwriteptr.htm#CopyAndMoveBoth">IDXARGBReadWritePtr::CopyAndMoveBoth</A>
</BLOCKQUOTE>




<H1><A NAME="FillAndMove">IDXARGBReadWritePtr::FillAndMove</A><HR size=1></H1>
<p>Fills the output surface with the specified sample value, starting at the current position and advancing the current position.

<P CLASS="ref">Syntax</P>
<BLOCKQUOTE>
<PRE>void FillAndMove(
	DXBASESAMPLE *pScratchBuffer,
	DXPMSAMPLE SampVal,
	ULONG cSamples,
	BOOL bDoOver
);
</PRE>
</BLOCKQUOTE>

<P CLASS="ref">Parameters</P>
<BLOCKQUOTE>
<DL>
<DT><I>pScratchBuffer</I> 
 </DT><DD>[in] Pointer to a buffer that may be used by the method. The initial contents of the buffer are ignored, and when the call returns the buffer contents are undefined. The buffer must be at least [ <i>cSamples</i>*sizeof(DXBASESAMPLE) ] bytes in size. If the surface pixel format is either <A CLASS="Glossary" HREF="javascript:Glossary(sRelPath + 'gloss/gloss_A.htm#gloss_argb32')">ARGB32</A> or <A CLASS="Glossary" HREF="javascript:Glossary(sRelPath + 'gloss/gloss_P.htm#gloss_pmargb32')">PMARGB32</A>, this buffer is not required and <i>pScratchBuffer </i>can be NULL.
</DD>
<DT><I>SampVal</I> 
 </DT><DD>[in] Alpha-premultiplied color to use for the fill.
</DD>
<DT><I>cSamples</I> 
 </DT><DD>[in] Number of samples to fill.
</DD>
<DT><I>bDoOver</I> 
 </DT><DD>[in] Value indicating whether to fill over existing data or to replace existing data.




If TRUE, the samples are alpha-blended over the current data. If FALSE, the samples replace the current data.
</DD>
</DL>
</BLOCKQUOTE>

<P CLASS="ref">Return Value</P>
<BLOCKQUOTE>
<P>No return values
</BLOCKQUOTE>

<P CLASS="ref">Remarks</P>
<BLOCKQUOTE>
<P>This method moves the current position of the pointer object forward along the x-axis by <i>cSamples</i>.
</BLOCKQUOTE>

<P CLASS="ref">See Also</P>
<BLOCKQUOTE>
<P><A HREF="idxargbreadwriteptr.htm#FillRect">IDXARGBReadWritePtr::FillRect</A>
</BLOCKQUOTE>


<H1><A NAME="FillRect">IDXARGBReadWritePtr::FillRect</A><HR size=1></H1>
<p>Fills the specified rectangle with the specified sample value, optionally doing an &quot;over&quot; operation.





<P CLASS="ref">Syntax</P>
<BLOCKQUOTE>
<PRE>void FillRect(
	const RECT *pRect,
	DXPMSAMPLE SampVal,
	BOOL bDoOver
);
</PRE>
</BLOCKQUOTE>

<P CLASS="ref">Parameters</P>
<BLOCKQUOTE>
<DL><DT><I>pRect</I> 
 </DT><DD>[in] Pointer to the rectangle to fill. If NULL, the whole surface is filled.
</DD>
<DT><I>SampVal</I> 
 </DT><DD>[in] Alpha-premultiplied color to use for the fill.
</DD>
<DT><I>bDoOver</I>
  </DT><DD>[in] Value indicating whether to fill over existing data or to replace existing data.




If TRUE, the samples are alpha-blended over the current data. If FALSE, the samples replace the current data.
</DL>
</BLOCKQUOTE>

<P CLASS="ref">Return Value</P>
<BLOCKQUOTE>
<P>No return value.
</BLOCKQUOTE>

<P CLASS="ref">Remarks</P>
<BLOCKQUOTE>
<P>




After this call has been made, the current position of the pointer object is undefined.  Call <A HREF="idxargbreadptr.htm#MoveToRow">MoveToRow</a>, <A HREF="idxargbreadptr.htm#MoveAndGetRunInfo">MoveAndGetRunInfo</a>, or <A HREF="idxargbreadptr.htm#MoveToXY">MoveToXY</a> to re-establish the pointer location before calling any method that uses the current pointer location.

</BLOCKQUOTE>

<P CLASS="ref">See Also</P>
<BLOCKQUOTE>
<P><A HREF="IDXARGBReadWriteptr.htm#FillAndMove">IDXARGBReadWrite::FillAndMove</A>, 
<A HREF="idxargbreadptr.htm#MoveToRow">IDXARGBReadPtr::MoveToRow</A>,
<A HREF="idxargbreadptr.htm#MoveToXY">IDXARGBReadPtr::MoveToXY</A>,
<A HREF="idxargbreadptr.htm#MoveAndGetRunInfo">IDXARGBReadPtr::MoveAndGetRunInfo</A>,
</BLOCKQUOTE>



<H1><A NAME="OverArrayAndMove">IDXARGBReadWritePtr::OverArrayAndMove</A><HR size=1></H1>
<p><A CLASS="Glossary" HREF="javascript:Glossary(sRelPath + 'gloss/gloss_A.htm#gloss_alphablending')">Alpha blends</a> an array of samples over the output surface and moves the pointer a specified number of samples. 
<P CLASS="ref">Syntax</P>
<BLOCKQUOTE>
<PRE>void OverArrayAndMove(
	DXBASESAMPLE *pScratchBuffer, 
	const DXPMSAMPLE *pSrc,
	ULONG cSamples
);
</PRE>
</BLOCKQUOTE>

<P CLASS="ref">Parameters</P>
<BLOCKQUOTE>
<DL><DT><I>pScratchBuffer</I> 
 </DT><DD>[in] Pointer to a buffer that may be used by the method. The initial contents of the buffer are ignored, and when the call returns the buffer contents are undefined. The buffer must be at least [ <i>cSamples</i>*sizeof(DXBASESAMPLE) ] bytes in size. If the surface pixel format is either <A CLASS="Glossary" HREF="javascript:Glossary(sRelPath + 'gloss/gloss_A.htm#gloss_argb32')">ARGB32</A> or <A CLASS="Glossary" HREF="javascript:Glossary(sRelPath + 'gloss/gloss_P.htm#gloss_pmargb32')">PMARGB32</A>this buffer is not required and <i>pScratchBuffer </i>can be NULL
</DD>
<DT><I>pSrc</I> 
 </DT><DD>[in] Pointer to an array of <A HREF="../structs/DXPMSAMPLE_struct.htm">DXPMSAMPLE</A> structures that describe the source samples.
</DD>
<DT><I>cSamples</I>
  </DT><DD>[in] Number of samples in the arrays.
</DD></DL>
</BLOCKQUOTE>

<P CLASS="ref">Return Value</P>
<BLOCKQUOTE>
<P>No return value.
</BLOCKQUOTE>
<P CLASS="ref">Remarks</P>
<BLOCKQUOTE>
<P>After a call to this method, the positions of both the source and destination surfaces are advanced by <I>cSamples</I>.
<p>
If you know that the majority of the source samples are translucent, and you are going to blend more than 16 samples, it can be more efficient to do the following: unpack the destination samples, call the <a href="../helpers/composite_helpers.htm#DXOverArrayMMX">DXOverArrayMMX</a> helper function,




 and then pack the resulting buffer. For PMARGB32 <b>DXSurfaces</b>, the unpack/pack step would not be necessary.
</BLOCKQUOTE>



<H1><A NAME="OverSample">IDXARGBReadWritePtr::OverSample</A><HR size=1></H1>
<p><A CLASS="Glossary" HREF="javascript:Glossary(sRelPath + 'gloss/gloss_A.htm#gloss_alphablending')">Alpha blends</a> the specified sample value over the sample at the specified position.

<P CLASS="ref">Syntax</P>
<BLOCKQUOTE>
<PRE>void OverSample(
	const DXOVERSAMPLEDESC * pOverDesc
);
</PRE>
</BLOCKQUOTE>

<P CLASS="ref">Parameters</P>
<BLOCKQUOTE>
<DL><DT><I>pOverDesc</I> 
 </DT><DD>[in] Pointer to a <a href="../structs/DXOVERSAMPLEDESC_struct.htm">DXOVERSAMPLEDESC</a> structure holding the position and color of the specified sample on the destination surface.
</DD></DL>
</BLOCKQUOTE>

<P CLASS="ref">Return Value</P>
<BLOCKQUOTE>
<P>No return value.
</BLOCKQUOTE>

<P CLASS="ref">Remarks</P>
<BLOCKQUOTE>
<P>This method does not modify the current position of the pointer object.
<p>
<b>DXSurface</b> implementations are optimized for opaque colors (alpha = 255). In these cases, this operation is identical to a sample replacement




and no blending is done.


</BLOCKQUOTE>






<H1><A NAME="PackAndMove">IDXARGBReadWritePtr::PackAndMove</A><HR size=1></H1>
<p>Places a buffer of ARGB32 samples into the output surface and moves the sample pointer.


<P CLASS="ref">Syntax</P>
<BLOCKQUOTE>
<PRE>void PackAndMove(
	const DXSAMPLE *pSamples,
	ULONG cSamples
); 
</PRE>
</BLOCKQUOTE>

<P CLASS="ref">Parameters</P>
<BLOCKQUOTE>
<DL><DT><I>pSamples</I> 
 </DT><DD>[in] Pointer to the sample values to pack into the destination surface. If the surface pixel format is ARGB32, the pointer can be NULL, in which case no data copy is performed, but the current pointer location is still updated. 
</DD></DL>
<DL><DT><I>cSamples</I> 
 </DT><DD>[in] Number of samples to convert.
</DD></DL>
</BLOCKQUOTE>

<P CLASS="ref">Return Value</P>
<BLOCKQUOTE>
<P>No return value. 
</BLOCKQUOTE>

<P CLASS="ref">Remarks</P>
<BLOCKQUOTE>
<P>This method will advance the current horizontal position of the pointer to the samples by <I>cSamples</I> amount. If the pixel format of the underlying surface is not ARGB32, this method will convert the samples into the underlying native pixel format. 
</BLOCKQUOTE>

<P CLASS="ref">See Also</P>
<BLOCKQUOTE>
<P><A HREF="idxargbreadwriteptr.htm#PackPremultAndMove">IDXARGBReadWritePtr::PackPremultAndMove</A>, <A HREF="idxargbreadwriteptr.htm#PackRect">IDXARGBReadWritePtr::PackRect</A>
</BLOCKQUOTE>




<H1><A NAME="PackPremultAndMove">IDXARGBReadWritePtr::PackPremultAndMove</A><HR size=1></H1>
<p>Places a buffer of ARGB32 samples into the output surfaces and moves the sample pointer.

<P CLASS="ref">Syntax</P>
<BLOCKQUOTE>
<PRE>void PackPremultAndMove(
	const DXPMSAMPLE *pSamples,
	ULONG cSamples
);
</PRE>
</BLOCKQUOTE>

<P CLASS="ref">Parameters</P>
<BLOCKQUOTE>
<DL><DT><I>pSamples</I> 
 </DT><DD>[in] Pointer to the sample values to pack into the destination surface. If the surface pixel format is PMARGB32, the pointer can be NULL, in which case no data copy is performed, but the current pointer location is still updated. 
</DD>
<DT><I>cSamples</I> 
 </DT><DD>[in] Number of samples to convert.
</DD>
</DL>
</BLOCKQUOTE>

<P CLASS="ref">Return Value</P>
<BLOCKQUOTE>
<P>No return value.
</BLOCKQUOTE>

<P CLASS="ref">Remarks</P>
<BLOCKQUOTE>
<P>This method will advance the current horizontal position of the pointer to the samples by <I>cSamples</I> amount. If the pixel format of the underlying surface is not PMARGB32, this method will convert the samples into the underlying native pixel format. 
</BLOCKQUOTE>

<P CLASS="ref">See Also</P>
<BLOCKQUOTE>
<P><A HREF="idxargbreadwriteptr.htm#PackAndMove">IDXARGBReadWritePtr::PackAndMove</A>, <A HREF="idxargbreadwriteptr.htm#PackRect">IDXARGBReadWritePtr::PackRect</A>
</BLOCKQUOTE>




<H1><A NAME="PackRect">IDXARGBReadWritePtr::PackRect</A><HR size=1></H1>
<p>Accepts a buffer of either PMARGB32 or ARGB32 samples and writes them to a subsection of the output surface defined by a <A HREF="../structs/DXPACKEDRECTDESC_struct.htm">DXPACKEDRECTDESC</A> structure.

<P CLASS="ref">Syntax</P>
<BLOCKQUOTE>
<PRE>void PackRect(
	const DXPACKEDRECTDESC *pRectDesc
);
</PRE>
</BLOCKQUOTE>

<P CLASS="ref">Parameters</P>
<BLOCKQUOTE>
<DL><DT><I>pRectDesc</I> 
 </DT><DD>[in] Pointer to a DXPACKEDRECTDESC structure containing sample information to write to the output surface.
</DD></DL>
</BLOCKQUOTE>


<P CLASS="ref">Return Value</P>
<BLOCKQUOTE>
<P>No return value.
</BLOCKQUOTE>

<P CLASS="ref">Remarks</P>
<BLOCKQUOTE>
<P>This method can be used to pack single columns or rectangular regions of a surface from a buffer of contiguous samples. It can pack them row by row into equally spaced, discontiguous regions by setting <i>lRowPadding</i> to non-zero.
<p>
The size of the buffer required is [ (<i>Width</i>+<i>lRowPadding</i>) * (<i>Height</i> - 1)) + <i>Width </i>]. If <i>lRowPadding</i> is zero, this is equivalent to <i>Width</i>*<i>Height</i>.
<p>
The packing begins with the sample at the upper-left corner of the rectangle and packs samples from the buffer into the surface until reaching the end of the row. It then adds <i>lRowPadding</i> samples to the buffer pointer and packs the next row.
<p>After this call has been made, the current position of the pointer object is undefined. Call <A HREF="idxargbreadptr.htm#MoveToRow">MoveToRow</a>, <A HREF="idxargbreadptr.htm#MoveAndGetRunInfo">MoveAndGetRunInfo</a>, or <A HREF="idxargbreadptr.htm#MoveToXY">MoveToXY</a> to re-establish the pointer location before calling any method that uses the current pointer location.


</BLOCKQUOTE>

<P CLASS="ref">See Also</P>
<BLOCKQUOTE>
<P><A HREF="idxargbreadwriteptr.htm#PackAndMove">IDXARGBReadWritePtr::PackAndMove</A>, <A HREF="idxargbreadwriteptr.htm#PackPremultAndMove">IDXARGBReadWritePtr::PackPremultAndMove</A>,
<A HREF="../structs/DXPACKEDRECTDESC_struct.htm">DXPACKEDRECTDESC</A>,
<A HREF="idxargbreadptr.htm#MoveToRow">IDXARGBReadPtr::MoveToRow</A>,
<A HREF="idxargbreadptr.htm#MoveToXY">IDXARGBReadPtr::MoveToXY</A>,
<A HREF="idxargbreadptr.htm#MoveAndGetRunInfo">IDXARGBReadPtr::MoveAndGetRunInfo</A>,
</BLOCKQUOTE>






<!-- CONTENTS_END -->

<!-- START_PAGE_FOOTER -->


<H6><HR size=1></H6>
<P><A CLASS="line" HREF="#pagetop"><IMG src="../../art/arrowup1.gif" WIDTH="11" HEIGHT="11" ALIGN="MIDDLE" BORDER=0 ALT="Top of Page">&nbsp;Top of Page</A>
<BR><A CLASS="line" HREF="../../../cpyright.htm">&#169; 1998 Microsoft Corporation. All rights reserved. Terms of Use.</A>
<!-- END_PAGE_FOOTER -->

</BLOCKQUOTE>

<!-- START POP-UP GLOSSARY -->

<SCRIPT LANGUAGE="JAVASCRIPT">if((g_isIE == true) && (g_iMaj > 3)) {window.self.document.writeln('<SCR' + 'IPT SRC="../../tip2.js"></SCR' + 'IPT><IFRAME ID="G_L_S" NAME="SecretBuffer" STYLE="display: none" SRC=""></IFRAME>')}</SCRIPT>
<!-- END POP-UP GLOSSARY -->


<!-- DACONTROL_START -->

	<DIV ID="HeadGraphAnim"></DIV>
	<SCRIPT LANGUAGE="JAVASCRIPT">if((g_isIE == true) && (g_iMaj > 3)) {window.self.document.writeln('<SCR' + 'IPT SRC="../../anim.js"></SCR' + 'IPT>')}</SCRIPT>
<!-- DACONTROL_END -->

</BODY></HTML>