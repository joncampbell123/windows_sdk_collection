<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<HTML>
<HEAD><TITLE>IDXARGBReadPtr Interface</TITLE>
<SCRIPT LANGUAGE="JavaScript"> var sRelPath = '../../' </SCRIPT>

<META NAME="Description" CONTENT="IDXARGBReadPtr">
<META NAME="Description" CONTENT="IDXARGBReadPtr::GetNativeType">
<META NAME="Description" CONTENT="IDXARGBReadPtr::GetSurface">
<META NAME="Description" CONTENT="IDXARGBReadPtr::Move">
<META NAME="Description" CONTENT="IDXARGBReadPtr::MoveAndGetRunInfo">
<META NAME="Description" CONTENT="IDXARGBReadPtr::MoveToRow">
<META NAME="Description" CONTENT="IDXARGBReadPtr::MoveToXY">
<META NAME="Description" CONTENT="IDXARGBReadPtr::Unpack">
<META NAME="Description" CONTENT="IDXARGBReadPtr::UnpackPremult">
<META NAME="Description" CONTENT="IDXARGBReadPtr::UnpackRect">
<META NAME="Description" CONTENT="GetNativeType (IDXARGBReadPtr)">
<META NAME="Description" CONTENT="GetSurface (IDXARGBReadPtr)">
<META NAME="Description" CONTENT="Move (IDXARGBReadPtr)">
<META NAME="Description" CONTENT="MoveAndGetRunInfo (IDXARGBReadPtr)">
<META NAME="Description" CONTENT="MoveToRow (IDXARGBReadPtr)">
<META NAME="Description" CONTENT="MoveToXY (IDXARGBReadPtr)">
<META NAME="Description" CONTENT="Unpack (IDXARGBReadPtr)">
<META NAME="Description" CONTENT="UnpackPremult (IDXARGBReadPtr)">
<META NAME="Description" CONTENT="UnpackRect (IDXARGBReadPtr)">
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; CHARSET=iso8859-1">
<META NAME="MS.LOCALE" CONTENT="EN-US">
<META NAME="ROBOTS" CONTENT="all">

<!-- SNIFF_START -->

<SCRIPT LANGUAGE="JAVASCRIPT">
//<!--
var g_isIE = false, g_isNav = false, g_iMaj = 0, g_sPlat = "";
// -->

</SCRIPT>
<SCRIPT SRC="../../ver.js"></SCRIPT>
<SCRIPT SRC="../../gloss.js"></SCRIPT>
<!-- SNIFF_END -->


<SCRIPT DEFER SRC="../../common.js"></SCRIPT>
<SCRIPT DEFER>
//<!--
function InitPage()
{
	if (g_isIE && g_iMaj >= 4)	
	{

		SetTOC();
	}
}
//-->

</SCRIPT>

<!-- STYLE_START -->

<SCRIPT LANGUAGE="JAVASCRIPT">
//<!--
   var sVR = '../../'	// Set root for the style sheet
   var sCSS = '<LINK REL="stylesheet" HREF="' + sVR;

   if(g_isIE)
   {
	   if (g_iMaj >= 4) // For MSIE 4.0 or later
	   {
		   sCSS += 'dxm_basicSDKIE4';
		   if (g_sPlat == "Win") // Windows only for now
		   {
			   document.createStyleSheet(sVR + 'dxm_advSDKIE4.css');
		   }
	   }
	   else // For MSIE 3.0 or earlier
	   {
		   sCSS += 'dxm_basicSDKIE3';
	   }
   }
   else if (g_isNav) // For all Nav versions
   {
	   sCSS += 'dxm_basicSDKNAV';
   }
   else
   {
	   sCSS += 'dxm_basicSDKIE3'; // default to IE3 sheet
   }

   sCSS += (sCSS == '' ? '' : '.css" TYPE="text/css">');

   document.write(sCSS);
//-->

</SCRIPT>
<!-- STYLE_END -->


</HEAD>


<BODY onload="InitPage(); if (g_isIE && g_iMaj >= 4){HdgrphControl()}" BGCOLOR="#FFFFFF">
<A NAME="pagetop"></A><A NAME="IDXARGBReadPtr"></A>
<!--TOOLBAR_START-->

<!--TOOLBAR_EXEMPT-->

<!--TOOLBAR_END-->


<!-- HEADGRAPH_START -->

<TABLE CLASS="main" BORDER=0 CELLSPACING="0" CELLPADDING="0" WIDTH="*">
<TR>
<TD ROWSPAN="3" VALIGN="TOP" WIDTH="*">
<IMG SRC="../../art/header1.gif" WIDTH="107" HEIGHT="110" BORDER=0 ALT="DirectX Transform Animated Header -- Microsoft DirectX Transform SDK"></TD>
<TD ROWSPAN="2" VALIGN="TOP" WIDTH="217"><IMG SRC="../../art/hdrdtrns.gif" WIDTH="217" HEIGHT="110" BORDER=0 ALT="Microsoft DirectX Transform SDK"></TD>
<TD VALIGN="TOP" WIDTH="383">
<IMG SRC="../../art/header3.gif" WIDTH="383" HEIGHT="95" BORDER=0 ALT="DirectX Transform Animated Header">
</TD>
<TD VALIGN="TOP" WIDTH="100%">
<IMG SRC="../../art/spacer1.gif" WIDTH="100%" HEIGHT="94" BORDER=0 ALT="Microsoft DirectX Transform SDK">
</TD>
</TR>
<!-- HEADGRAPH_END -->

<!-- NAV_LINKS_START -->

<TR><TD VALIGN="TOP"><PRE><IMG ID="TOC_" SRC="../../art/yelbtn.gif" WIDTH="11" HEIGHT="11" ALIGN="MIDDLE" BORDER=0 ALT="*"><A STYLE="color:black;font-weight:bold" ID="TOC" HREF="../../contents.htm">Contents</A>  <IMG SRC="../../art/yelbtn.gif" WIDTH="11" HEIGHT="11" ALIGN="MIDDLE" BORDER=0 ALT="*"><A STYLE="color:black;font-weight:bold" HREF="../../index.htm">Index</A>  <IMG SRC="../../art/yelbtn.gif" WIDTH="11" HEIGHT="11" ALIGN="MIDDLE" BORDER=0 ALT="*"><A STYLE="color:black;font-weight:bold" HREF="interface_intro.htm">Topic Contents</A>
</PRE></TD></TR>

<TR><TD COLSPAN="2" VALIGN="TOP"><PRE><IMG SRC="../../art/yelbtn.gif" WIDTH="11" HEIGHT="11" ALIGN="MIDDLE" BORDER=0 ALT="*"><B>Previous Topic:</B> <A  STYLE="color:black" HREF="iface_summary.htm">Summary of Interfaces</A>
<IMG SRC="../../art/yelbtn.gif" WIDTH="11" HEIGHT="11" ALIGN="MIDDLE" BORDER=0 ALT="*"><B>Next Topic:</B> <A STYLE="color:black" HREF="IDXARGBReadWritePtr.htm">IDXARGBReadWritePtr Interface</A>
</PRE></TD></TR></TABLE>

<!-- NAV_LINKS_END -->


<BLOCKQUOTE class="body">

<!-- CONTENTS_START -->


<H1>IDXARGBReadPtr Interface</H1>

<P>Microsoft&reg; DirectX&reg; Transform objects use the <B>IDXARGBReadPtr</B> interface to gain read-only access to <A CLASS="Glossary" HREF="javascript:Glossary(sRelPath + 'gloss/gloss_S.htm#gloss_sample')">samples</a> contained in a <A CLASS="Glossary" HREF="javascript:Glossary(sRelPath + 'gloss/gloss_D.htm#gloss_dxsurface')">DXSurface</A> object.

<p>This interface contains methods to move a sample pointer to various locations within a <B>DXSurface</B> and to unpack samples into a common pixel format (either <A CLASS="Glossary" HREF="javascript:Glossary(sRelPath + 'gloss/gloss_A.htm#gloss_argb32')">ARGB32</A> or <A CLASS="Glossary" HREF="javascript:Glossary(sRelPath + 'gloss/gloss_P.htm#gloss_pmargb32')">PMARGB32</A>). Unpacking the samples into a common format means transforms that modify data from <B>DXSurfaces</B> only need to be able to handle these two formats. If the underlying samples in the <B>DXSurface</B> are already ARGB32 or PMARGB32, you can obtain a pointer directly to them by specifying NULL for the working buffer arguments, avoiding a copy.



You can determine the format of the underlying samples by using the <A HREF="idxargbreadptr.htm#getnativetype">GetNativeType</A> method.

<p>Use the <A HREF="idxsurface.htm#locksurface">IDXSurface::LockSurface</A> method to retrieve a pointer to this interface. For more information on using this interface see the <a href="../../overview/dxt_objects.htm">Architecture</a> overview article. 

<p>
If you create a custom <b>DXSurface</b>, you need to implement this interface on your <b>DXSurface</b> object which is used to access samples within your custom surface. DirectX Transform objects will use this interface to gain access to samples contained in your custom <b>DXSurface</b>.



<p>The coordinates used in all operations for <B>IDXARGBReadPtr</B> and <A HREF="idxargbreadwriteptr.htm">IDXARGBReadWritePtr</A> interfaces are relative to the locked region of the <b>DXSurface</b>.  This means, for example, that if you lock a region from (10, 10) to (100, 100) and then call <code class="text">pPtr-&gt;MoveToXY(10, 10)</code>, the sample pointer will be positioned at the pixel at 20,20 on the surface.

<p><b>WARNING:</b> To achieve fast performance on these methods, no parameter validation occurs before execution. Passing invalid parameters can cause the dynamic-link library (DLL) to crash.

<p>For more information on using this interface, see the <A HREF="../../overview/about_dxtrans.htm#dxtrans_and_dxsurf">About Transforms and DXSurfaces</A> overview article.

<P CLASS="ref">IDXARGBReadPtr Methods</P>
<BLOCKQUOTE>
<TABLE CLASS="ref">
<TR><TD><A HREF="IDXARGBReadPtr.htm#GetNativeType">GetNativeType</A></TD>
	<TD>Retrieves the native underlying pixel format of a <B>DXSurface</B>.
</TD></TR>
<TR><TD><A HREF="IDXARGBReadPtr.htm#GetSurface">GetSurface</A></TD>
	<TD>Returns a pointer to the parent <b>DXSurface</b>.
</TD></TR>
<TR><TD><A HREF="IDXARGBReadPtr.htm#Move">Move</A></TD>
	<TD>Moves the sample pointer along the x-axis relative to its current position.
</TD></TR>
<TR><TD><A HREF="IDXARGBReadPtr.htm#MoveAndGetRunInfo">MoveAndGetRunInfo</A></TD>
	<TD>Moves the sample pointer to a specified row and retrieves a pointer to the run information associated with the specified row.
</TD></TR>
<TR><TD><A HREF="IDXARGBReadPtr.htm#MoveToRow">MoveToRow</A></TD>
	<TD>Moves the sample pointer to an absolute row along the y-axis and resets the x-axis position to zero. 

</TD></TR>
<TR><TD><A HREF="IDXARGBReadPtr.htm#MoveToXY">MoveToXY</A></TD>
	<TD>Moves the sample pointer to an absolute position.
</TD></TR>
<TR><TD><A HREF="IDXARGBReadPtr.htm#Unpack">Unpack</A></TD>
	<TD>Unpacks the specified number of samples into the supplied buffer in ARGB32 pixel format.
</TD></TR>
<TR><TD><A HREF="IDXARGBReadPtr.htm#UnpackPremult">UnpackPremult</A></TD>
	<TD>Unpacks the specified number of samples into the supplied buffer in alpha-premultiplied PMARGB32 pixel format.
</TD></TR>
<TR><TD><A HREF="IDXARGBReadPtr.htm#UnpackRect">UnpackRect</A></TD>
	<TD>Unpacks a subsection of source samples defined by a rectangle structure and advances the horizontal position of the read pointer.
</TD></TR>
</TABLE>
</BLOCKQUOTE>




<H1><A NAME="GetNativeType">IDXARGBReadPtr::GetNativeType</A><HR size=1></H1>
<p>Retrieves the native underlying pixel format of a <B>DXSurface</B>.

<P CLASS="ref">Syntax</P>
<BLOCKQUOTE>
<PRE>DXSAMPLEFORMATENUM GetNativeType(
	DXNATIVETYPEINFO *pInfo
);
</PRE>
</BLOCKQUOTE>

<P CLASS="ref">Parameters</P>
<BLOCKQUOTE>
<DL><DT><I>pInfo</I>
 </DT><DD>[out] Pointer to a <A HREF="../structs/DXNATIVETYPEINFO_struct.htm">DXNATIVETYPEINFO</A> structure that the method will fill with native type information about the surface. This structure contains the color key, surface pitch, pointers to the samples at the current location, and origin of the surface. This pointer can be NULL, in which case only the <A HREF="../enums/dxsampleformatenum_enum.htm">DXSAMPLEFORMATENUM</A> enumeration will be returned. 
</DD></DL>
</BLOCKQUOTE>

<P CLASS="ref">Return Value</P>
<BLOCKQUOTE>
<P>Returns a <B>DXSAMPLEFORMATENUM</B> enumerated type, indicating the format of the pixels contained in the surface.

</BLOCKQUOTE>

<P CLASS="ref">Remarks</P>
<BLOCKQUOTE>
<P>This method can be used to directly access the data in the surface. If the calling routine supports the pixel format of the surface, it can use the information in this structure to retrieve or modify data directly in the surface memory. Note that some surfaces, such as <A CLASS="Glossary" HREF="javascript:Glossary(sRelPath + 'gloss/gloss_p.htm#gloss_proceduralsurface')">procedural surfaces</A>, don't have a backing array of samples, and therefore will always set the entire <B>DXNATIVETYPEINFO</B> structure to zero. 
</BLOCKQUOTE>



<H1><A NAME="GetSurface">IDXARGBReadPtr::GetSurface</A><HR size=1></H1>
<p>Returns a pointer to the parent <b>DXSurface</b>.

<P CLASS="ref">Syntax</P>
<BLOCKQUOTE>
<PRE>HRESULT GetSurface(
	REFIID riid,
	void **ppSurface
); 
</PRE>
</BLOCKQUOTE>

<P CLASS="ref">Parameters</P>
<BLOCKQUOTE>
<DL><DT><I>riid</I> 
 </DT><DD>[in] Interface to retrieve from the read pointer (typically IID_IDXSurface).
</DD></DL>
<DL><DT><I>ppSurface</I> 
 </DT><DD>[out] Address of a pointer to the requested interface.
</DD></DL>
</BLOCKQUOTE>

<P CLASS="ref">Return Value</P>
<BLOCKQUOTE>
<P>Returns an <A HREF="../errorandsuccess.htm">HRESULT</A> value that depends on the implementation of the interface. 
</BLOCKQUOTE>

<P CLASS="ref">Remarks </P>
<BLOCKQUOTE>
<P>This method is used to get a pointer to the parent surface associated with the specified <b>IDXARGBReadPtr</b> interface. It provides a link between the <b>IDXSurface::LockSurface</b> interface, which exposes the <b>IDXARGBReadPtr</b> and <a href="idxargbreadwriteptr.htm">IDXARGBReadWritePtr</a> interfaces, and the <b>DXSurface</b> object, which exposes the <a href="idxsurface.htm">IDXSurface</a> interface.
</BLOCKQUOTE>



<H1><A NAME="Move">IDXARGBReadPtr::Move</A><HR size=1></H1>
<p>Moves the sample pointer along the x-axis relative to its current position.

<P CLASS="ref">Syntax</P>
<BLOCKQUOTE>
<PRE>void Move(
	long cSamples
);
</PRE>
</BLOCKQUOTE>

<P CLASS="ref">Parameters</P>
<BLOCKQUOTE>
<DL><DT><I>cSamples</I> 
 </DT><DD>[in] Number of samples to move the position along the x-axis.
</DD></DL>
</BLOCKQUOTE>

<P CLASS="ref">Return Value</P>
<BLOCKQUOTE>
<P>No return value.
</BLOCKQUOTE>

<P CLASS="ref">Remarks</P>
<BLOCKQUOTE>
<P>Specifying a negative value will move the sample pointer backward. Specifying a value larger than the row width may or may not move you to the next row, depending on whether  the surface occupies a contiguous block of memory.
</BLOCKQUOTE>

<P CLASS="ref">See Also</P>
<BLOCKQUOTE>
<P><A HREF="idxargbreadptr.htm#movetorow">IDXARGBReadPtr::MoveToRow</A>, <A HREF="idxargbreadptr.htm#movetoXY">IDXARGBReadPtr::MoveToXY</A>, <A HREF="idxargbreadptr.htm#MoveAndGetRunInfo">IDXARGBReadPtr::MoveAndGetRunInfo</A>
</BLOCKQUOTE>




<H1><A NAME="MoveAndGetRunInfo">IDXARGBReadPtr::MoveAndGetRunInfo</A><HR size=1></H1>
<p>Moves the sample pointer to a specified row and retrieves a pointer to the run information associated with that row.

<P CLASS="ref">Syntax</P>
<BLOCKQUOTE>
<PRE>ULONG MoveAndGetRunInfo(
	ULONG Row,
	DXRUNINFO **ppInfo
);
</PRE>
</BLOCKQUOTE>

<P CLASS="ref">Parameters</P>
<BLOCKQUOTE>
<DL><DT><I>Row</I> 
 </DT><DD>[in] Row to place the sample pointer. The run information will be for this row of samples.
</DD></DL>
<DL><DT><I>ppInfo</I> 
 </DT><DD>[out] Address of a pointer to a <A HREF="../structs/DXRUNINFO_struct.htm">DXRUNINFO</A> structure to store the run information.
</DD></DL>
</BLOCKQUOTE>

<P CLASS="ref">Return Value</P>
<BLOCKQUOTE>
<P>Returns a value indicating the number of <B>DXRUNINFO</B> structures that contain run information.
</BLOCKQUOTE>

<P CLASS="ref">Remarks</P>
<BLOCKQUOTE>
<P>When locking the surface, specify DXLOCKF_WANTRUNINFO to ensure that run information is generated.

<p>The count returned specifies the number of <A HREF="../structs/DXRUNINFO_struct.htm">DXRUNINFO</A> structures returned by the call. Each <B>DXRUNINFO</B> structure contains a count of pixels and a type. The sum of all of the counts will equal the width of the locked region. Typically, users of this feature will get the run information and then read the source pixels, performing different operations for each run type. This is useful for skipping clear pixels, copying opaque pixels, and blending translucent or unknown pixels.

<p>The returned data is only valid for as long as the sample pointer is on the specified row. After the sample pointer has been moved to a different row by using the <A HREF="#movetoxy">MoveToXY</A>, <A HREF="#movetorow">MoveToRow</A>, or <B>MoveAndGetRunInfo</B> method, the pointer returned by this method should not be used because the underlying surface could reuse a temporary buffer to construct new run information.

<p>All surface implementations are required to support this method. The simplest implementations will only return a count of one <B>DXRUNINFO</B> structure. That structure will be of type DXRUNTYPE_UNKNOWN with a count equal to the width of the locked region. This method will work even if the caller did not specify DXLOCKF_WANTRUNINFO when the surface was locked.

<p>If a <B>DXSurface</B> object is marked as transient (its surface status flags specify DXSURF_TRANSIENT), then the surface will not create detailed run information and will always return a single DXRUNTYPE_UNKNOWN run with a count equal to the width of the entire row.

<p>Run information describes a series of identical pixels. Pixel information stored in a run can improve the efficiency of transform operations.

<p>Pixel runs are described by the <a href="../structs/DXRUNINFO_struct.htm">DXRUNINFO</a> structure, and include a <B>Count</B> of the identical samples and the <B>Type</B>. The run type can be one of the following elements of the <a href="../enums/DXRUNTYPE_enum.htm">DXRUNTYPE</a> enumeration.
<table>
<tr><td>DXRUNTYPE_CLEAR</td>  <td>Run is zero alpha (clear).</td></tr>
<tr><td>DXRUNTYPE_OPAQUE</td> <td>Run is full alpha (255) and fully opaque.</td></tr>
<tr><td>DXRUNTYPE_TRANS</td> <td>Run is nonzero alpha and partially transparent.</td></tr>
<tr><td>DXRUNTYPE_UNKNOWN</td> <td>Run type is unknown.</td></tr>  
</table>

<p>DXRUNTYPE_CLEAR and DXRUNTYPE_OPAQUE are always completely contiguous runs of clear or opaque pixels.  In the case of a copy operation, the caller would skip the clear pixels and copy the opaque pixels.

<p>DXRUNTYPE_TRANS can contain pixels that are translucent. These runs can benefit from the use of MMX instructions since most pixels will need to be blended if doing an over operation. Use <A HREF="../helpers/composite_helpers.htm#DXOverArrayMMX">DXOverArrayMMX</A> if doing an over operation with a translucent run.

<p>DXRUNTYPE_UNKNOWN means that the pixels for the specified run could be of any type, clear, translucent, or opaque. The caller should examine each pixel's alpha to determine what operation to perform. Typically, if doing an over operation, it is faster to use <A HREF="../helpers/composite_helpers.htm#DXOverArray">DXOverArray</A> instead of the MMX version because clear and opaque pixels are special-cased in this function.
</BLOCKQUOTE>




<H1><A NAME="MoveToRow">IDXARGBReadPtr::MoveToRow</A><HR size=1></H1>
<p>Moves the sample pointer to an absolute row along the y-axis and resets the x-axis position to zero. 

<P CLASS="ref">Syntax</P>
<BLOCKQUOTE>
<PRE>void MoveToRow(
	ULONG y
);
</PRE>
</BLOCKQUOTE>

<P CLASS="ref">Parameters</P>
<BLOCKQUOTE>
<DL><DT><I>y</I> 
 </DT><DD>[in] Row to move to along the y-axis.
</DD></DL>
</BLOCKQUOTE>

<P CLASS="ref">Return Value</P>
<BLOCKQUOTE>
<P>No return value.
</BLOCKQUOTE>

<P CLASS="ref">See Also</P>
<BLOCKQUOTE>
<P><A HREF="idxargbreadptr.htm#move">IDXARGBReadPtr::Move</A>, <A HREF="idxargbreadptr.htm#movetoXY">IDXARGBReadPtr::MoveToXY</A>
</BLOCKQUOTE>




<H1><A NAME="MoveToXY">IDXARGBReadPtr::MoveToXY</A><HR size=1></H1>
<p>Moves the sample pointer to an absolute position.

<P CLASS="ref">Syntax</P>
<BLOCKQUOTE>
<PRE>void MoveToXY(
	ULONG x,
	ULONG y
);
</PRE>
</BLOCKQUOTE>

<P CLASS="ref">Parameters</P>
<BLOCKQUOTE>
<DL><DT><I>x</I> 
 </DT><DD>[in] Position along the x-axis.
</DD>
<DT><I>y</I> 
 </DT><DD>[in] Position along the y-axis.
</DD></DL>
</BLOCKQUOTE>

<P CLASS="ref">Return Value</P>
<BLOCKQUOTE>
<P>No return value.
</BLOCKQUOTE>

<P CLASS="ref">See Also</P>
<BLOCKQUOTE>
<P><A HREF="idxargbreadptr.htm#move">IDXARGBReadPtr::Move</A>,
<A HREF="idxargbreadptr.htm#movetoRow">IDXARGBReadPtr::MoveToRow</A>
</BLOCKQUOTE>




<H1><A NAME="Unpack">IDXARGBReadPtr::Unpack</A><HR size=1></H1>
<p>Unpacks the specified number of samples into the supplied buffer in ARGB32 pixel format.

<P CLASS="ref">Syntax</P>
<BLOCKQUOTE>
<PRE>DXSAMPLE *Unpack(
	DXSAMPLE *pSamples,
	ULONG cSamples,
	BOOL bMove
);
</PRE>
</BLOCKQUOTE>

<P CLASS="ref">Parameters</P>
<BLOCKQUOTE>
<DL><DT><I>pSamples</I> 
 </DT><DD>[in] Pointer to a buffer to store the samples. If the surface's native type is ARGB32, then this pointer can be NULL. Otherwise, it must point to a buffer large enough to hold the samples.
</DD>
<DT><I>cSamples</I> 
 </DT><DD>[in] Number of samples to get.
</DD>
<DT><I>bMove</I>
  </DT><DD>[in] Value indicating whether to advance the read pointer. Specify TRUE to advance the current horizontal position. Specify FALSE to leave the pointer set to the current location.
</DL>
</BLOCKQUOTE>

<P CLASS="ref">Return Value</P>
<BLOCKQUOTE>
<P>Returns a pointer to a buffer containing the unpacked, converted samples. If <i>pSamples</i> was non-NULL, the return value will always be equal to <i>pSamples</i>. If <i>pSamples</i> was NULL, then the returned pointer points directly to the ARGB samples in the surface memory.
</BLOCKQUOTE>

<P CLASS="ref">Remarks</P>
<BLOCKQUOTE>
<P>This method converts the pixel format of the underlying surface into <A CLASS="Glossary" HREF="javascript:Glossary(sRelPath + 'gloss/gloss_A.htm#gloss_argb32')">ARGB32</A> format in the process of extracting the surface samples into a buffer. If the underlying data is in an alpha-premultiplied format, the method will convert the data to <b>ARGB32</b> as it is being copied.

<p>If the caller supplies a pointer to a buffer in the <i>pSamples</i> parameter, the samples will be stored in that location, and this method will return a pointer to the user's buffer. If the underlying samples are already <b>ARGB32</b>, the user can obtain a pointer directly to the samples, avoiding a copy by specifying NULL for the <i>pSamples</i> parameter.



 In this case, the returned pointer will point directly at the surface memory. 

<p>This method uses the <B>DXSAMPLE</B> structure to store color information about the samples.

<p><B>WARNING:</B> You should never use the returned pointer to modify a read-only surface. A good coding practice for read-locked surfaces is to assign the returned pointer to a constant <A HREF="../structs/DXSAMPLE_struct.htm">DXSAMPLE</A> pointer.


</BLOCKQUOTE>

<P CLASS="ref">See Also</P>
<BLOCKQUOTE>
<P><A HREF="idxargbreadptr.htm#unpackpremult">UnpackPremult</A>, <A HREF="idxargbreadptr.htm#UnpackRect">UnpackRect</A>
</BLOCKQUOTE>



<H1><A NAME="UnpackPremult">IDXARGBReadPtr::UnpackPremult</A><HR size=1></H1>
<p>Unpacks the specified number of samples into the supplied buffer in alpha-premultiplied PMARGB32 pixel format.

<P CLASS="ref">Syntax</P>
<BLOCKQUOTE>
<PRE>DXPMSAMPLE *UnpackPremult(
	DXPMSAMPLE *pSamples,
	ULONG cSamples,
	BOOL bMove
);
</PRE>
</BLOCKQUOTE>

<P CLASS="ref">Parameters</P>
<BLOCKQUOTE>
<DL><DT><I>pSamples</I> 
 </DT><DD>[in] Pointer to buffer you must supply to store the samples. If the surface's native type is PMARGB32 (alpha-premultiplied), this pointer can be NULL. Otherwise it must point to a buffer large enough to hold the samples. 
</DD>
<DT><I>cSamples</I> 
 </DT><DD>[in] Number of samples to get.
</DD>
<DT><I>bMove</I>
  </DT><DD>[in] Value specifying whether to advance the current horizontal position of the read pointer. Specify TRUE to advance or FALSE to leave the pointer set to the current location.
</DD></DL>
</BLOCKQUOTE>

<P CLASS="ref">Return Value</P>
<BLOCKQUOTE>
<P>Returns a pointer to a buffer containing the unpacked, converted sample data. If <i>pSamples</i> was non-NULL then this will always be equal to <i>pSamples</i>. If <i>pSamples</i> was NULL, then the returned pointer points directly at the samples in the surface memory.
</BLOCKQUOTE>

<P CLASS="ref">Remarks</P>
<BLOCKQUOTE>
<P>This method converts the pixel format of the underlying surface samples into PMARGB32 format before copying them into the buffer that you must supply. If the underlying data is not in alpha-premultiplied format, the samples are converted as they are being copied.

<p>If you supply a buffer in the <I>pSamples</I> parameter, the samples will be stored in that location, and this method will return a pointer to your buffer.

<p>This method uses the <A HREF="../structs/DXSAMPLE_struct.htm">DXPMSAMPLE</A> structure to store color information about the samples.

<p><B>WARNING:</B> You should never use the returned pointer to modify a read-only surface. A good coding practice for read-locked surfaces is to assign the returned pointer to a constant <A HREF="../structs/DXSAMPLE_struct.htm">DXSAMPLE</A> pointer.


</BLOCKQUOTE>

<P CLASS="ref">See Also</P>
<BLOCKQUOTE>
<P><A HREF="idxargbreadptr.htm#unpack">Unpack</A>, <A HREF="idxargbreadptr.htm#UnpackRect">UnpackRect</A>
</BLOCKQUOTE>




<H1><A NAME="UnpackRect">IDXARGBReadPtr::UnpackRect</A><HR size=1></H1>
<p>Unpacks a subsection of source samples defined by a rectangle structure and advances the horizontal position of the read pointer.

<P CLASS="ref">Syntax</P>
<BLOCKQUOTE>
<PRE>void UnpackRect(
	const DXPACKEDRECTDESC * pRectDesc
);
</PRE>
</BLOCKQUOTE>

<P CLASS="ref">Parameters</P>
<BLOCKQUOTE>
<DL><DT><I>pRectDesc</I> 
 </DT><DD>[in] Pointer to a <A HREF="../structs/DXPACKEDRECTDESC_struct.htm">DXPACKEDRECTDESC</a> structure to be used in unpacking the rectangular region of samples.
</DD></DL>
</BLOCKQUOTE>

<P CLASS="ref">Return Value</P>
<BLOCKQUOTE>
<P>No return value.
</BLOCKQUOTE>

<P CLASS="ref">Remarks</P>
<BLOCKQUOTE>
<P>This method can be used to unpack single columns or rectangular regions of a surface into contiguous samples. It also can unpack them row-by-row into equally spaced, noncontiguous regions by setting the <b>lRowPadding</b> member of <B>DXPACKEDRECTDESC</B> to a nonzero value.

<p>The size of the buffer required is ((<i>Width</i> + <b>lRowPadding</b>) * (<i>Height</i> - 1)) + <i>Width</i>. If <b>lRowPadding</b> is zero, then this is equivalent to <i>Width</i>*<i>Height</i>.

<p><b>UnpackRect</b> starts with the sample at the upper-left corner of the rectangle and unpacks samples into the buffer until reaching the end of the row. It then adds <b>lRowPadding</b> samples to the buffer pointer and unpacks the next row.

<p>After this call has been made, the current position of the pointer object is undefined. You will need to call <A HREF="#movetorow">MoveToRow</A>, <A HREF="#MoveAndGetRunInfo">MoveAndGetRunInfo</A>, or <A HREF="#MoveToXY">MoveToXY</A> to re-establish the pointer location before calling <A HREF="#Unpack">Unpack</A> or <A HREF="#UnpackPremult">UnpackPremult</A>.
</BLOCKQUOTE>



<!-- CONTENTS_END -->

<!-- START_PAGE_FOOTER -->


<H6><HR size=1></H6>
<P><A CLASS="line" HREF="#pagetop"><IMG src="../../art/arrowup1.gif" WIDTH="11" HEIGHT="11" ALIGN="MIDDLE" BORDER=0 ALT="Top of Page">&nbsp;Top of Page</A>
<BR><A CLASS="line" HREF="../../../cpyright.htm">&#169; 1998 Microsoft Corporation. All rights reserved. Terms of Use.</A>
<!-- END_PAGE_FOOTER -->

</BLOCKQUOTE>
<!-- START POP-UP GLOSSARY -->

<SCRIPT LANGUAGE="JAVASCRIPT">if((g_isIE == true) && (g_iMaj > 3)) {window.self.document.writeln('<SCR' + 'IPT SRC="../../tip2.js"></SCR' + 'IPT><IFRAME ID="G_L_S" NAME="SecretBuffer" STYLE="display: none" SRC=""></IFRAME>')}</SCRIPT>
<!-- END POP-UP GLOSSARY -->


<!-- DACONTROL_START -->

	<DIV ID="HeadGraphAnim"></DIV>
	<SCRIPT LANGUAGE="JAVASCRIPT">if((g_isIE == true) && (g_iMaj > 3)) {window.self.document.writeln('<SCR' + 'IPT SRC="../../anim.js"></SCR' + 'IPT>')}</SCRIPT>
<!-- DACONTROL_END -->

</BODY></HTML>
