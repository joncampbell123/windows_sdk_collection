<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<HTML>
<HEAD><TITLE>Source and Target Rectangles in Video Renderers</TITLE>
<STYLE>
<!--
.tctop {color: blue}
.cpslug {color: blue; text-decoration: none}
-->
</STYLE>
<SCRIPT LANGUAGE="JAVASCRIPT">
//<!--
function ShowButtons() {
    if (window.top.frames.length!=0 && window.top.frames[0].ShowButtons!=null)
	window.top.frames[0].ShowButtons('/dssd0090.htm','/dssd0000.htm','/dssd0068.htm','/index.htm','/dssd0091.htm');
}
ShowButtons();
//-->
</SCRIPT>
</HEAD>
<BODY onLoad="ShowButtons()" TOPMARGIN=10 BGPROPERTIES="FIXED" BGCOLOR="#FFFFFF" LINK="#000000" VLINK="#808080" ALINK="#000000">
<FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">
<H2><A NAME="Rectangles">Source and Target Rectangles in Video Renderers</A></H2>
<BR CLEAR=ALL>
<P>There are three sizes found in the <A HREF="dssd0300.htm#structs_0001060501001d00" TARGET="TEXT">VIDEOINFO</A>, <A HREF="dssd0300.htm#structs_0001060501001e00" TARGET="TEXT">VIDEOINFOHEADER</A>, and <A HREF="dssd0300.htm#structs_0001060501001f00" TARGET="TEXT">VIDEOINFOHEADER2</A> format structures of video mediatypes. This article explains what they are and how they work.

<p>First, there is a size in the <B>bmiHeader</B> member of these structures. The <B>bmiHeader</B> member is a <A HREF="dssd0080.htm#avispec_0001050502020500" TARGET="TEXT">BITMAPINFOHEADER</A> structure with its own width and height members <B>bmiHeader.biWidth</B> and <B> bmiHeader.biHeight</B>.
<p>Secondly, there is a rectangle in the <B>rcSource</B> member of these structures, and lastly there is a rectangle in the <B>rcTarget</B> member of these structures.


<p>Assume you have two filters, A and B, and that these filters are connected to each other (A on the left, or upstream, and B on the right, or downstream) with a certain video mediatype.
<p>The buffers that pass between filters A and B have the size (<B>bmiHeader.biWidth</B>, <B>bmiHeader.biHeight</B>). Filter A should take a portion of its input video determined by <B>rcSource</B> and stretch that video to fill the <B>rcTarget</B> portion of the buffer.  The portion of the input video to use is based on how <B>rcSource</B> compares to the (<B>biWidth</B>, <B>biHeight</B>) size of the media type that filters A and B originally connected with. If <B>rcSource</B> is empty, filter A uses its entire input video. If <B>rcTarget</B> is empty, filter A fills the entire output buffer.
<p>For example, assume filter A is receiving video data that is 160x120 pixels. Assume also that filter A is connected to filter B with the following mediatype:
<dl>
<dd>(biWidth, biHeight):  320,240</dd>
<dd>rcSource: (0, 0, 0, 0)</dd>
<dd>rcTarget: (0, 0, 0, 0)</dd>
</dl>

<p>This means that filter A will stretch the video it receives by 2 in both x and y, and fill a 320x240 output buffer.


<p> As another example, assume filter A is receiving 160x120 video data, and that it is connected to filter B with the following mediatype:
<dl>
<dd>(biWidth, biHeight):  320,240</dd>
<dd>rcSource: (0, 0, 160, 240)</dd>
<dd>rcTarget: (0, 0, 0, 0)</dd>
</dl>
<p>The <B>rcSource</B> member is relative to the connected buffer size of 320,240. Since the specified <B>rcSource</B> (0, 0, 160, 240) is the left half of the buffer, filter A will take the left half of its input video, or the (0, 0, 80, 120) portion, and stretch the video to a size of (320,240) (by 4 in the x direction, and by 2 in the y direction) and filling the 320x240 output buffer.

<p>Now assume that filter A calls <A HREF="dssd0199.htm#Lib_0001060209050600" TARGET="TEXT">GetBuffer</A>, and the media sample returned has a media type attached to it, signifying that filter B wants filter A to provide a different size or kind of video than it has previously been providing. Assume the new media type is:
<dl>
<dd>(biWidth, biHeight): 640,480</dd>
<dd>rcSource: (0, 0, 160, 120)</dd>
<dd>rcTarget: (0, 0, 80, 60)</dd>
</dl>

<p>This means that the media sample has a buffer that is 640x480 in size. The <B>rcSource</B> member is relative to the original connected media type (320,240) not to the new media type of (640,480), so <B>rcSource</B> specifies that the top left corner (25%) of the input video is to be used. This portion of the input video is placed in the top left (80,60) pixels of the 640x480 output buffer, as specified by <B>rcTarget</B> of (0, 0, 80, 60).  Since filter A is receiving 160x120 video, the top left corner of the input video is an (80,60) piece, the same size of the output bitmap, and no stretching is required.

<p>Filter A will place no data in the other pixels of the output buffer, and will leave those bits untouched. The <B>rcSource</B> member is bounded by the <B>biWidth</B> and <B>biHeight</B> of the original connected media type between filters A and B, and <B>rcTarget</B> is bounded by the new <B>biWidth</B> and <B>biHeight</B> of the media sample.  In the example above <B>rcSource</B> could not go outside the boundaries of (0,0,320,240) and <B>rcTarget</B> could not go outside the boundaries of (0,0,640,480).




<P><P><FONT FACE="MS SANS SERIF" SIZE="1" COLOR="BLACK">
<A CLASS=cpslug HREF="copyrite.htm" TARGET="TEXT">&#169; 1998 Microsoft Corporation. All rights reserved. Terms of Use.</A>
</FONT>
<BR CLEAR=ALL><P>
</FONT><P>
</BODY></HTML>
