<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<HTML>
<HEAD><TITLE>Direct3D Retained Mode Tutorial</TITLE>
<STYLE>
<!--
.tctop {color: blue}
.cpslug {color: blue; text-decoration: none}
-->
</STYLE>
<SCRIPT LANGUAGE="JAVASCRIPT">
//<!--
function ShowButtons() {
    if (window.top.frames.length!=0 && window.top.frames[0].ShowButtons!=null)
	window.top.frames[0].ShowButtons('/rm0004.htm','/rm0000.htm','/rm0000.htm','/index.htm','/rm0006.htm');
}
ShowButtons();
//-->
</SCRIPT>
</HEAD>
<BODY onLoad="ShowButtons()" TOPMARGIN=10 BGPROPERTIES="FIXED" BGCOLOR="#FFFFFF" LINK="#000000" VLINK="#808080" ALINK="#000000">
<FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">
<H2><A NAME="dx5_Direct3d_Retained_Mode_Tutorial_d3drm"></A><A NAME="rmtutor_0001010501000000">Direct3D Retained Mode Tutorial</A></H2>
<BR CLEAR=ALL>
<P>To create a Microsoft&#174; Windows&#174;-based, Direct3D&#174; Retained Mode application, you set up the features of two different environments: the devices, viewports, and color capabilities of the Windows environment, and the models, textures, lights, and positions of the virtual environment. This section is a tutorial that contains all the code for a simple Retained Mode application. The following illustration is a single frame from the running animation:

<P><IMG SRC="art/helscren.gif" WIDTH="300" HEIGHT="300" ALT="Single-frame animation">


<P>The tutorial is divided into the following sections:
<UL><LI><A CLASS=tctop HREF="rm0005.htm#rmtutor_0001010501010000" TARGET="TEXT">Making the Helworld Sample</A>
<LI><A CLASS=tctop HREF="rm0005.htm#rmtutor_0001010501020000" TARGET="TEXT">Definitions and Global Variables</A>
<LI><A CLASS=tctop HREF="rm0005.htm#rmtutor_0001010501030000" TARGET="TEXT">Windows Setup and Initialization</A>
<LI><A CLASS=tctop HREF="rm0005.htm#rmtutor_0001010501040000" TARGET="TEXT">Enumerating Device Drivers</A>
<LI><A CLASS=tctop HREF="rm0005.htm#rmtutor_0001010501050000" TARGET="TEXT">Setting up the 3-D Environment</A>
<LI><A CLASS=tctop HREF="rm0005.htm#rmtutor_0001010501060000" TARGET="TEXT">The Rendering Loop</A>
<LI><A CLASS=tctop HREF="rm0005.htm#rmtutor_0001010501070000" TARGET="TEXT">Creating the Scene</A>
<LI><A CLASS=tctop HREF="rm0005.htm#rmtutor_0001010501080000" TARGET="TEXT">Cleaning Up</A>
</UL>
<H3><A NAME="rmtutor_0001010501010000">Making the Helworld Sample</A></H3>
<P>This tutorial includes all the code for a working Direct3D Retained Mode application. You can copy the code from this tutorial into a single .c file and then compile and run it if the following conditions are met:
<UL><LI>You have the Direct3D header files (D3d.h, D3drm.h, and so on) in your include path.
<LI>You link with the Winmm.lib, D3drm.lib, and Ddraw.lib static libraries.
<LI>Your compiler can find the Sphere3.x file in the media directory of the Microsoft&#174; DirectX&#174; Software Development Kit.
<LI>You supply a bitmap called Tutor.bmp. 
<P>Note that this bitmap must have pixel dimensions that are a power of 2; for example, a 16&#215;16 pixel bitmap, a 128&#215;1024 pixel bitmap, a 512&#215;256 pixel bitmap, and so on.
</UL>
<P>Most of the code responsible for 3-D effects in this sample has been broken out into discrete functions so that you can modify parts of the system incrementally in your own experiments. You should look at the samples in the SDK for implementations of more complicated features of Direct3D.


<P>The following topics describe some of the concerns that apply to the overall development of a simple Direct3D Retained Mode application. 
<UL><LI><A CLASS=tctop HREF="rm0005.htm#rmtutor_0001010501010100" TARGET="TEXT">Limitations of the Sample</A>
<LI><A CLASS=tctop HREF="rm0005.htm#rmtutor_0001010501010200" TARGET="TEXT">DirectDraw Windowed Mode</A>
</UL>
<H4><A NAME="rmtutor_0001010501010100">Limitations of the Sample</A></H4>
<P>This tutorial contains the Helworld.c example code, which creates a sphere, applies a texture to it, and rotates it in a window. This is the only C source file required to build this application. The only other files you need are Sphere3.x, a mesh file that ships in the Media directory of the DirectX SDK; and Tutor.bmp, a bitmap you supply. (Note that you must have the Direct3D header files in your include path and link to the Winmm.lib, D3drm.lib, and Ddraw.lib static libraries.) 

<P>This tutorial is a simplified version of the Globe sample that is part of the DirectX SDK. The Globe sample, like all the Direct3D Retained Mode samples in the SDK, requires the inclusion of a file named Rmmain.cpp and a number of header files. In Helworld.c, the relevant parts of Rmmain.cpp have been converted to C from C++ and integrated into the source code.
 
<P>The code shown in this tutorial should not be mistaken for production code. The only possible user interactions with the program are starting it, stopping it, and minimizing the window while it is running. Most of the error checking has been removed for clarity. The purpose of this example is analogous to the purpose of the beginning program that prints "Hello, world!" on the screen: to produce output with as little confusion as possible.

<H4><A NAME="rmtutor_0001010501010200">DirectDraw Windowed Mode</A></H4>
<P>Nearly all Direct3D applications will use DirectDraw&#174; to display their graphics on the screen. These applications will either use DirectDraw full-screen (exclusive) mode or DirectDraw windowed mode. The code in this documentation uses windowed mode. Although the full-screen mode offers some benefits in performance and convenience, it is much easier to debug code written in windowed mode. Most developers will write their code in windowed mode and port it to full-screen mode late in the development cycle, when most of the bugs have been worked out.





<H3><A NAME="rmtutor_0001010501020000">Definitions and Global Variables</A></H3>
<P>Below are the first lines of the Helworld.c example. Helworld.c is the only C source file required to build this application. 


<P>Notice that INITGUID must be defined prior to all other includes and defines. This is a crucial point that is sometimes missed by developers who are new to DirectX.

<PRE><FONT FACE="Courier" SIZE="2">/////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 1996 Microsoft Corporation. All Rights Reserved.
//
//  File: Helworld.c
//
//  Simplified Direct3D Retained Mode example, based on 
//  the "Globe" SDK sample.
//
/////////////////////////////////////////////////////////////////////

#define INITGUID           // Must precede other defines and includes

#include &lt;windows.h&gt;
#include &lt;malloc.h&gt;        // Required by memset call
#include &lt;d3drmwin.h&gt;

#define MAX_DRIVERS 5           // Maximum D3D drivers expected  

// Global variables

LPDIRECT3DRM lpD3DRM;           // Direct3DRM object 
LPDIRECTDRAWCLIPPER lpDDClipper;// DirectDrawClipper object 

struct _myglobs {
    LPDIRECT3DRMDEVICE dev;     // Direct3DRM device 
    LPDIRECT3DRMVIEWPORT view;  // Direct3DRM viewport through which 
                                // the scene is viewed
    LPDIRECT3DRMFRAME scene;    // Master frame in which others are 
                                // placed 
    LPDIRECT3DRMFRAME camera;   // Frame describing the user's POV 

    GUID DriverGUID[MAX_DRIVERS];     // GUIDs of available D3D drivers 
    char DriverName[MAX_DRIVERS][50]; // Names of available D3D drivers 
    int  NumDrivers;                  // Number of available D3D drivers 
    int  CurrDriver;                  // Number of D3D driver currently
                                      // being used 

    BOOL bQuit;                 // Program is about to terminate 
    BOOL bInitialized;          // All D3DRM objects are initialized 
    BOOL bMinimized;            // Window is minimized 

    int BPP;                    // Bit depth of the current display mode

} myglobs;

// Function prototypes.
 
static BOOL InitApp(HINSTANCE, int);
long FAR PASCAL WindowProc(HWND, UINT, WPARAM, LPARAM);
static BOOL EnumDrivers(HWND win);
static HRESULT WINAPI enumDeviceFunc(LPGUID lpGuid, 
    LPSTR lpDeviceDescription, LPSTR lpDeviceName, 
    LPD3DDEVICEDESC lpHWDesc, LPD3DDEVICEDESC lpHELDesc, 
    LPVOID lpContext);
static DWORD BPPToDDBD(int bpp);
static BOOL CreateDevAndView(LPDIRECTDRAWCLIPPER lpDDClipper, 
    int driver, int width, int height);
static BOOL SetRenderState(void);
static BOOL RenderLoop(void);
static BOOL MyScene(LPDIRECT3DRMDEVICE dev, LPDIRECT3DRMVIEWPORT view, 
    LPDIRECT3DRMFRAME scene, LPDIRECT3DRMFRAME camera);
void MakeMyFrames(LPDIRECT3DRMFRAME lpScene, LPDIRECT3DRMFRAME lpCamera,
    LPDIRECT3DRMFRAME * lplpLightFrame1, 
    LPDIRECT3DRMFRAME * lplpWorld_frame);
void MakeMyLights(LPDIRECT3DRMFRAME lpScene, LPDIRECT3DRMFRAME lpCamera, 
    LPDIRECT3DRMFRAME lpLightFrame1, 
    LPDIRECT3DRMLIGHT * lplpLight1, LPDIRECT3DRMLIGHT * lplpLight2);
void SetMyPositions(LPDIRECT3DRMFRAME lpScene, 
    LPDIRECT3DRMFRAME lpCamera, LPDIRECT3DRMFRAME lpLightFrame1, 
    LPDIRECT3DRMFRAME lpWorld_frame);
void MakeMyMesh(LPDIRECT3DRMMESHBUILDER * lplpSphere3_builder);
void MakeMyWrap(LPDIRECT3DRMMESHBUILDER sphere3_builder, 
                LPDIRECT3DRMWRAP * lpWrap);
void AddMyTexture(LPDIRECT3DRMMESHBUILDER lpSphere3_builder, 
                  LPDIRECT3DRMTEXTURE * lplpTex);
static void CleanUp(void);
</FONT></PRE>
<H3><A NAME="rmtutor_0001010501030000">Windows Setup and Initialization</A></H3>
<P>This section describes the standard setup and initialization functions in a Windows program, as implemented in the Helworld.c sample code.
<UL><LI><A CLASS=tctop HREF="rm0005.htm#rmtutor_0001010501030100" TARGET="TEXT">The WinMain Function</A>
<LI><A CLASS=tctop HREF="rm0005.htm#rmtutor_0001010501030200" TARGET="TEXT">The InitApp Function</A>
<LI><A CLASS=tctop HREF="rm0005.htm#rmtutor_0001010501030300" TARGET="TEXT">The Main Window Procedure</A>
</UL>
<H4><A NAME="rmtutor_0001010501030100">The WinMain Function</A></H4>
<P>The WinMain function in Helworld.c has only a few lines of code that are unique to an application that uses DirectDraw and Direct3D Retained Mode. The InitApp and CleanUp functions are standard parts of a Windows program, although in the case of Helworld, they perform some unique tasks. The most important call in WinMain, from the perspective of Direct3D, is the call to the RenderLoop function. RenderLoop is responsible for drawing each new frame of the animation. For more information about the RenderLoop function, see <A CLASS=tctop HREF="rm0005.htm#rmtutor_0001010501060000" TARGET="TEXT">The Rendering Loop</A>.

<PRE><FONT FACE="Courier" SIZE="2">/////////////////////////////////////////////////////////////////////
// 
// WinMain
// Initializes the application and enters a message loop.
// The message loop renders the scene until a quit message is received.
//
/////////////////////////////////////////////////////////////////////
 
int PASCAL
WinMain (HINSTANCE this_inst, HINSTANCE prev_inst, LPSTR cmdline, 
    int cmdshow)
{
    MSG     msg;
    HACCEL  accel = NULL;
    int     failcount = 0;  // Number of times RenderLoop has failed 

    prev_inst;
    cmdline;

    // Create the window and initialize all objects needed to begin 
    // rendering.
     
    if (!InitApp(this_inst, cmdshow))
        return 1;

    while (!myglobs.bQuit) {
        
        // Monitor the message queue until there are no pressing
        // messages.
         
        while (PeekMessage(&amp;msg, NULL, 0, 0, PM_REMOVE)) {
            if (!TranslateAccelerator(msg.hwnd, accel, &amp;msg)) {
                TranslateMessage(&amp;msg);
                DispatchMessage(&amp;msg);
            }
        }
        
        // If the app is not minimized, not about to quit, and D3DRM has
        // been initialized, begin rendering.
         
        if (!myglobs.bMinimized &amp;&amp; !myglobs.bQuit &amp;&amp; 
             myglobs.bInitialized) {

            // Attempt to render a frame. If rendering fails more than 
            // twice, abort execution.
                 
            if (!RenderLoop())
                ++failcount;
            if (failcount &gt; 2) {
                CleanUp();
                break;
            }
        }
    }
    return msg.wParam;
}
</FONT></PRE>
<H4><A NAME="rmtutor_0001010501030200">The InitApp Function</A></H4>
<P>The initialization function in Helworld.c creates the window class and main application window, just as in most Windows-based applications. After this, however, it does some work that is unique to applications using DirectDraw and Direct3D.


<P>Next, InitApp retrieves the current display's bits per pixel. This information is used to help set the rendering quality for the application. For more information, see <A CLASS=tctop HREF="rm0005.htm#rmtutor_0001010501050200" TARGET="TEXT">Setting the Render State</A>.

<P>InitApp then uses the locally defined EnumDrivers function to determine which Direct3D drivers are available and to choose one. For more information about enumerating drivers, see <A CLASS=tctop HREF="rm0005.htm#rmtutor_0001010501040000" TARGET="TEXT">Enumerating Device Drivers</A>.

<P>Next, the code uses the <A HREF="rm0007.htm#rmfuncs_0001010601000500" TARGET="TEXT">Direct3DRMCreate</A> function to create an <A CLASS=tctop HREF="rm0010.htm#rmid3drm_0001010604000000" TARGET="TEXT">IDirect3DRM</A> interface. It uses this interface in the calls to <A HREF="rm0010.htm#rmid3drm_0001010604000900" TARGET="TEXT">IDirect3DRM::CreateFrame</A> and <A HREF="rm0017.htm#rmframe_000101060b002b00" TARGET="TEXT">IDirect3DRMFrame::SetPosition</A> that create the scene and camera frames, and position the camera in the scene. 

<P>A DirectDrawClipper object makes it simple to manage the clipping planes that control which parts are visible of a 3-D scene. Helworld.c uses the <A HREF="rm0038.htm#external_0001010620000018" TARGET="TEXT">DirectDrawCreateClipper</A> function to create an <A CLASS=tctop HREF="rm0038.htm#external_000101062000001c" TARGET="TEXT">IDirectDrawClipper</A> interface, and then uses the <A HREF="rm0038.htm#external_000101062000001d" TARGET="TEXT">IDirectDrawClipper::SetHWnd</A> method to set the window handle that obtains the clipping information. 

<P>Now the InitApp function uses the locally defined CreateDevAndView function to create the Direct3D device and viewport. For more information about this function, see <A CLASS=tctop HREF="rm0005.htm#rmtutor_0001010501050100" TARGET="TEXT">Creating the Device and Viewport</A>.

<P>When the entire supporting structure of a Direct3D application has been put into place, the details of the 3-D scene can be constructed. The MyScene function does this. For more information about MyScene, see <A CLASS=tctop HREF="rm0005.htm#rmtutor_0001010501050100" TARGET="TEXT">Creating the Device and Viewport</A>.

<P>Finally, just as in a standard initialization function, InitApp shows and updates the window.


<PRE><FONT FACE="Courier" SIZE="2">/////////////////////////////////////////////////////////////////////
// 
// InitApp
// Creates window and initializes all objects necessary to begin 
// rendering.
//
/////////////////////////////////////////////////////////////////////
 
static BOOL
InitApp(HINSTANCE this_inst, int cmdshow)
{
    HWND win;
    HDC hdc;
    WNDCLASS wc;
    RECT rc;

    // Set up and register the window class.
     
    wc.style = CS_HREDRAW | CS_VREDRAW;
    wc.lpfnWndProc = WindowProc;
    wc.cbClsExtra = 0;
    wc.cbWndExtra = sizeof(DWORD);
    wc.hInstance = this_inst;
    wc.hIcon = LoadIcon(this_inst, "AppIcon");
    wc.hCursor = LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground = (HBRUSH)GetStockObject(BLACK_BRUSH);
    wc.lpszMenuName = NULL;        
    wc.lpszClassName = "D3DRM Example";
    if (!RegisterClass(&amp;wc))
        return FALSE;
    
    // Initialize the global variables.
     
    memset(&amp;myglobs, 0, sizeof(myglobs));

    // Create the window.
     
    win =
        CreateWindow
        (   "D3DRM Example",            // Class 
            "Hello World (Direct3DRM)", // Title bar 
            WS_VISIBLE | WS_OVERLAPPED | WS_CAPTION | WS_SYSMENU |
                 WS_MINIMIZEBOX | WS_MAXIMIZEBOX,
            CW_USEDEFAULT,              // Init. x pos 
            CW_USEDEFAULT,              // Init. y pos 
            300,                        // Init. x size 
            300,                        // Init. y size 
            NULL,                       // Parent window 
            NULL,                       // Menu handle 
            this_inst,                  // Program handle 
            NULL                        // Create parms 
        );
    if (!win)
        return FALSE;
   
    // Record the current display bits-per-pixel.
     
    hdc = GetDC(win);
    myglobs.BPP = GetDeviceCaps(hdc, BITSPIXEL);
    ReleaseDC(win, hdc);
   
    // Enumerate the D3D drivers and select one.
     
    if (!EnumDrivers(win))
        return FALSE;
   
    // Create the D3DRM object and the D3DRM window object.
     
    lpD3DRM = NULL;
    Direct3DRMCreate(&amp;lpD3DRM);
    
    // Create the master scene frame and camera frame.
     
    lpD3DRM-&gt;lpVtbl-&gt;CreateFrame(lpD3DRM, NULL, &amp;myglobs.scene);
    lpD3DRM-&gt;lpVtbl-&gt;CreateFrame(lpD3DRM, myglobs.scene, 
        &amp;myglobs.camera);
    myglobs.camera-&gt;lpVtbl-&gt;SetPosition(myglobs.camera, myglobs.scene, 
        D3DVAL(0.0), D3DVAL(0.0), D3DVAL(0.0));

    // Create a DirectDrawClipper object and associate the 
    // window with it.
     
    DirectDrawCreateClipper(0, &amp;lpDDClipper, NULL);
    lpDDClipper-&gt;lpVtbl-&gt;SetHWnd(lpDDClipper, 0, win);
    
    // Create the D3DRM device by using the selected D3D driver.
     
    GetClientRect(win, &amp;rc);
    if (!CreateDevAndView(lpDDClipper, myglobs.CurrDriver, rc.right, 
            rc.bottom)) {
        return FALSE;
    }
    
    // Create the scene to be rendered.
     
    if (!MyScene(myglobs.dev, myglobs.view, myglobs.scene, 
            myglobs.camera))
        return FALSE;
    
    myglobs.bInitialized = TRUE;  // Initialization completed
    
    // Display the window.
     
    ShowWindow(win, cmdshow);
    UpdateWindow(win);

    return TRUE;
}
</FONT></PRE>
<H4><A NAME="rmtutor_0001010501030300">The Main Window Procedure</A></H4>
<P>The Helworld.c sample has a very simple main window procedure&#151;after all, the application allows practically no user interaction. 

<P>When the window procedure receives a WM_DESTROY message, it uses the CleanUp function, just as you would expect.

<P>When it receives a WM_ACTIVATE message, it retrieves an <A CLASS=tctop HREF="rm0032.htm#rmwindev_000101061a000000" TARGET="TEXT">IDirect3DRMWinDevice</A> interface and uses the <A HREF="rm0032.htm#rmwindev_000101061a000100" TARGET="TEXT">IDirect3DRMWinDevice::HandleActivate</A> method to ensure that the colors are correct in the active rendering window. Similarly, the function reacts to a WM_PAINT message by using the <A HREF="rm0032.htm#rmwindev_000101061a000200" TARGET="TEXT">IDirect3DRMWinDevice::HandlePaint</A> method.




<PRE><FONT FACE="Courier" SIZE="2">/////////////////////////////////////////////////////////////////////
//
// WindowProc
// Main window message handler.
//
/////////////////////////////////////////////////////////////////////
 
LONG FAR PASCAL WindowProc(HWND win, UINT msg, 
    WPARAM wparam, LPARAM lparam)
{
    RECT r;
    PAINTSTRUCT ps;
    LPDIRECT3DRMWINDEVICE lpD3DRMWinDev;

    switch (msg)    {
        
    case WM_DESTROY:
        CleanUp();
        break;

    case WM_ACTIVATE:
        {
       
        // Create a Windows-specific Direct3D Retained Mode window device to handle this
        // message.
         
        LPDIRECT3DRMWINDEVICE lpD3DRMWinDev;
        if (!myglobs.dev)
            break;
        myglobs.dev-&gt;lpVtbl-&gt;QueryInterface(myglobs.dev, 
            &amp;IID_IDirect3DRMWinDevice, (void **) &amp;lpD3DRMWinDev);
        lpD3DRMWinDev-&gt;lpVtbl-&gt;HandleActivate(lpD3DRMWinDev, 
            (WORD) wparam);
        lpD3DRMWinDev-&gt;lpVtbl-&gt;Release(lpD3DRMWinDev);
        }
        break;

    case WM_PAINT:
        if (!myglobs.bInitialized || !myglobs.dev)
            return DefWindowProc(win, msg, wparam, lparam);
       
        // Create a Windows-specific Direct3D Retained Mode window device to handle this
        // message.
         
        if (GetUpdateRect(win, &amp;r, FALSE)) {
            BeginPaint(win, &amp;ps);
            myglobs.dev-&gt;lpVtbl-&gt;QueryInterface(myglobs.dev, 
                &amp;IID_IDirect3DRMWinDevice, (void **) &amp;lpD3DRMWinDev);
            lpD3DRMWinDev->lpVtbl->HandlePaint(lpD3DRMWinDev, ps.hdc);
            lpD3DRMWinDev-&gt;lpVtbl-&gt;Release(lpD3DRMWinDev);
            EndPaint(win, &amp;ps);
        }
        break;
    default:
        return DefWindowProc(win, msg, wparam, lparam);
    }
    return 0L;
}
</FONT></PRE>
<H3><A NAME="rmtutor_0001010501040000">Enumerating Device Drivers</A></H3>
<P>Applications that use Direct3D always enumerate the available drivers and choose the one that best matches their needs. The following sections each describe one of the functions that perform this task:

<UL><LI><A CLASS=tctop HREF="rm0005.htm#rmtutor_0001010501040100" TARGET="TEXT">The EnumDrivers Function</A>
 <LI><A CLASS=tctop HREF="rm0005.htm#rmtutor_0001010501040200" TARGET="TEXT">The enumDeviceFunc Callback Function</A>
 <LI><A CLASS=tctop HREF="rm0005.htm#rmtutor_0001010501040300" TARGET="TEXT">The BPPToDDBD Helper Function</A>
</UL>
<H4><A NAME="rmtutor_0001010501040100">The EnumDrivers Function</A></H4>
<P>The EnumDrivers function is used by the InitApp function just before InitApp creates the application's scene and camera.

<P>The <A CLASS=tctop HREF="rm0038.htm#external_0001010620000019" TARGET="TEXT">IDirect3D</A> Component Object Model (COM) interface is really an interface to a DirectDraw object, so the first thing this enumeration function does is use the <A HREF="rm0038.htm#external_0001010620000017" TARGET="TEXT">DirectDrawCreate</A> function to create a DirectDrawObject. Then EnumDrivers uses the <A HREF="rm0038.htm#external_0001010620000021" TARGET="TEXT">QueryInterface</A> method to create an <B>IDirect3D</B> interface. Notice that the C implementation of <B>QueryInterface</B> requires that you pass the address of the interface identifier as the second parameter, not simply the constant itself (like in the C++ implementation). 

<P>The enumeration is handled by the <A HREF="rm0038.htm#external_000101062000001a" TARGET="TEXT">IDirect3D::EnumDevices</A> method, which depends on the locally defined enumDeviceFunc callback function. For more information about this callback function, see <A CLASS=tctop HREF="rm0005.htm#rmtutor_0001010501040200" TARGET="TEXT">The enumDeviceFunc Callback Function</A>.

<P>Notice that <B>IDirect3D::EnumDevices</B> is a Direct3D method, not a Direct3DRM method; there is no enumeration method in the Retained Mode API. This is a good example of the natural use of both Retained Mode and Immediate Mode methods in a single application. 

<PRE><FONT FACE="Courier" SIZE="2">/////////////////////////////////////////////////////////////////////
//
// EnumDrivers
// Enumerate the available D3D drivers and choose one.
//
/////////////////////////////////////////////////////////////////////
 
static BOOL
EnumDrivers(HWND win)
{
    LPDIRECTDRAW lpDD;
    LPDIRECT3D lpD3D;
    HRESULT rval;

    // Create a DirectDraw object and query for the Direct3D interface 
    // to use to enumerate the drivers.
     
    DirectDrawCreate(NULL, &amp;lpDD, NULL);
    rval = lpDD-&gt;lpVtbl-&gt;QueryInterface(lpDD, &amp;IID_IDirect3D, 
        (void**) &amp;lpD3D);
    if (rval != DD_OK) {
        lpDD-&gt;lpVtbl-&gt;Release(lpDD);
        return FALSE;
    }
    
    // Enumerate the drivers, setting CurrDriver to -1 to initialize the
    // driver selection code in enumDeviceFunc.
     
    myglobs.CurrDriver = -1;
    lpD3D-&gt;lpVtbl-&gt;EnumDevices(lpD3D, enumDeviceFunc, 
        &amp;myglobs.CurrDriver);
    
    // Ensure at least one valid driver was found.
     
    if (myglobs.NumDrivers == 0) {
        return FALSE;
    }
    lpD3D-&gt;lpVtbl-&gt;Release(lpD3D);
    lpDD-&gt;lpVtbl-&gt;Release(lpDD);
    
    return TRUE;
}
</FONT></PRE>
<H4><A NAME="rmtutor_0001010501040200">The enumDeviceFunc Callback Function</A></H4>
<P>The enumDeviceFunc callback function is of the <A HREF="rm0038.htm#external_0001010620000006" TARGET="TEXT">D3DENUMDEVICESCALLBACK</A> type, as defined in the D3dcaps.h header file. The system uses this function with identifiers and names for each Direct3D driver in the system, as well as the hardware and emulated capabilities of the driver.

<P>The callback function uses the <B>dcmColorModel</B> member of the <A HREF="rm0038.htm#external_0001010620000005" TARGET="TEXT">D3DDEVICEDESC</A> structure to determine whether to examine the hardware or emulated driver description. If the member has been filled by the hardware description, the function consults the hardware description.

<P>Next, the callback function determines whether the driver being enumerated can render in the current bit depth. If not, the function returns D3DENUMRET_OK to skip the rest of the process for this driver and continue the enumeration with the next driver. The callback function uses the locally defined BPPToDDBD function to compare the reported bit depth against the bits-per-pixel retrieved by the call to the <B>GetDeviceCaps</B> function in the InitApp function. (BPPToDDBD stands for bits-per-pixel to DirectDraw bit-depth.) For the code for this function, see <A CLASS=tctop HREF="rm0005.htm#rmtutor_0001010501040300" TARGET="TEXT">The BPPToDDBD Helper Function</A>.

<P>If the driver being enumerated passes a few simple tests, other parts of <B>D3DDEVICEDESC</B> are examined. The callback function will choose hardware over software emulation, and RGB lighting capabilities over monochromatic lighting capabilities.

<PRE><FONT FACE="Courier" SIZE="2">/////////////////////////////////////////////////////////////////////
//
// enumDeviceFunc
// Callback function that records each usable D3D driver's name 
// and GUID. Chooses a driver and sets *lpContext to this driver.
//
/////////////////////////////////////////////////////////////////////
 
static HRESULT
WINAPI enumDeviceFunc(LPGUID lpGuid, LPSTR lpDeviceDescription, 
    LPSTR lpDeviceName, LPD3DDEVICEDESC lpHWDesc, 
    LPD3DDEVICEDESC lpHELDesc, LPVOID lpContext)
{
    static BOOL hardware = FALSE; // Current start driver is hardware 
    static BOOL mono = FALSE;     // Current start driver is mono light 
    LPD3DDEVICEDESC lpDesc;
    int *lpStartDriver = (int *)lpContext;
   
    // Decide which device description should be consulted.
     
    lpDesc = lpHWDesc-&gt;dcmColorModel ? lpHWDesc : lpHELDesc;
    
    // If this driver cannot render in the current display bit-depth, 
    // skip it and continue with the enumeration.
     
    if (!(lpDesc-&gt;dwDeviceRenderBitDepth &amp; BPPToDDBD(myglobs.BPP)))
        return D3DENUMRET_OK;
    
    // Record this driver's name and GUID.
     
    memcpy(&amp;myglobs.DriverGUID[myglobs.NumDrivers], lpGuid, 
        sizeof(GUID));
    lstrcpy(&amp;myglobs.DriverName[myglobs.NumDrivers][0], lpDeviceName);
   
    // Choose hardware over software, RGB lights over mono lights.
     
    if (*lpStartDriver == -1) {
        
        // This is the first valid driver.
         
        *lpStartDriver = myglobs.NumDrivers;
        hardware = lpDesc == lpHWDesc ? TRUE : FALSE;
        mono = lpDesc-&gt;dcmColorModel &amp; D3DCOLOR_MONO ? TRUE : FALSE;
    } else if (lpDesc == lpHWDesc &amp;&amp; !hardware) {
        
        // This driver is hardware and the start driver is not.
         
        *lpStartDriver = myglobs.NumDrivers;
        hardware = lpDesc == lpHWDesc ? TRUE : FALSE;
        mono = lpDesc-&gt;dcmColorModel &amp; D3DCOLOR_MONO ? TRUE : FALSE;
    } else if ((lpDesc == lpHWDesc &amp;&amp; hardware ) || 
               (lpDesc == lpHELDesc &amp;&amp; !hardware)) {
        if (lpDesc-&gt;dcmColorModel == D3DCOLOR_MONO &amp;&amp; !mono) {
            
            // This driver and the start driver are the same type, and 
            // this driver is mono whereas the start driver is not.
             
            *lpStartDriver = myglobs.NumDrivers;
            hardware = lpDesc == lpHWDesc ? TRUE : FALSE;
            mono = lpDesc-&gt;dcmColorModel &amp; D3DCOLOR_MONO ? TRUE : FALSE;
        }
    }
    myglobs.NumDrivers++;
    if (myglobs.NumDrivers == MAX_DRIVERS)
        return (D3DENUMRET_CANCEL);
    return (D3DENUMRET_OK);
}
</FONT></PRE>
<H4><A NAME="rmtutor_0001010501040300">The BPPToDDBD Helper Function</A></H4>
<P>The enumDeviceFunc callback function uses the BPPToDDBD helper function to convert the stored bits-per-pixel the current device supports to a form that can be compared against the bit depth for the driver being enumerated. For more information about enumDeviceFunc, see <A CLASS=tctop HREF="rm0005.htm#rmtutor_0001010501040200" TARGET="TEXT">The enumDeviceFunc Callback Function</A>.

<PRE><FONT FACE="Courier" SIZE="2">/////////////////////////////////////////////////////////////////////
//
// BPPToDDBD
// Converts bits-per-pixel to a DirectDraw bit-depth flag.
//
/////////////////////////////////////////////////////////////////////

static DWORD
BPPToDDBD(int bpp)
{
    switch(bpp) {
        case 1:
            return DDBD_1;
        case 2:
            return DDBD_2;
        case 4:
            return DDBD_4;
        case 8:
            return DDBD_8;
        case 16:
            return DDBD_16;
        case 24:
            return DDBD_24;
        case 32:
            return DDBD_32;
        default:
            return 0;
    }
}
</FONT></PRE>
<H3><A NAME="rmtutor_0001010501050000">Setting up the 3-D Environment</A></H3>
<P>This section describes the code in Helworld.c that establishes the 3-D environment. The following sections describe the two functions that perform this task:

<UL><LI><A CLASS=tctop HREF="rm0005.htm#rmtutor_0001010501050100" TARGET="TEXT">Creating the Device and Viewport</A>
 <LI><A CLASS=tctop HREF="rm0005.htm#rmtutor_0001010501050200" TARGET="TEXT">Setting the Render State</A>
</UL>
<P>These functions do not populate the 3-D environment with objects, frames, and lights. That is done by the MyScene function and the functions it uses. For information about filling up the 3-D environment, see <A CLASS=tctop HREF="rm0005.htm#rmtutor_0001010501070000" TARGET="TEXT">Creating the Scene</A>.

<H4><A NAME="rmtutor_0001010501050100">Creating the Device and Viewport</A></H4>
<P>The Direct3D device and viewport are created as part of the application's initialization. After creating a DirectDrawClipper object, the InitApp function uses CreateDevAndView, passing as parameters the DirectDrawClipper object, the driver that was chosen, and the dimensions of the client rectangle. 

<P>The CreateDevAndView function uses the <A HREF="rm0010.htm#rmid3drm_0001010604000500" TARGET="TEXT">IDirect3DRM::CreateDeviceFromClipper</A> method to create a Direct3DRM device, using the driver that was selected by

 the enumeration process. It uses this <A CLASS=tctop HREF="rm0014.htm#rmdevice_0001010608000000" TARGET="TEXT">IDirect3DRMDevice</A> interface to retrieve the device's width and height, by using <A HREF="rm0014.htm#rmdevice_0001010608000d00" TARGET="TEXT">IDirect3DRMDevice::GetWidth</A> and <A HREF="rm0014.htm#rmdevice_0001010608000700" TARGET="TEXT">IDirect3DRMDevice::GetHeight</A> methods. After it has retrieved this information, it uses the <A HREF="rm0010.htm#rmid3drm_0001010604001400" TARGET="TEXT">IDirect3DRM::CreateViewport</A> method to retrieve the <A CLASS=tctop HREF="rm0031.htm#rmviewpt_0001010619000000" TARGET="TEXT">IDirect3DRMViewport</A> interface.

<P>When CreateDevAndView has used the <A HREF="rm0031.htm#rmviewpt_0001010619001500" TARGET="TEXT">IDirect3DRMViewport::SetBack</A> method to set the back clipping plane of the viewport, it uses the locally defined SetRenderState function. SetRenderState is described in the next section, <A CLASS=tctop HREF="rm0005.htm#rmtutor_0001010501050200" TARGET="TEXT">Setting the Render State</A>. 

<PRE><FONT FACE="Courier" SIZE="2">/////////////////////////////////////////////////////////////////////
//
// CreateDevAndView
// Create the D3DRM device and viewport with the given D3D driver and 
// with the specified size.
// 
/////////////////////////////////////////////////////////////////////
 
static BOOL
CreateDevAndView(LPDIRECTDRAWCLIPPER lpDDClipper, int driver, 
    int width, int height)
{
    HRESULT rval;

    // Create the D3DRM device from this window by using the specified 
    // D3D driver.
     
    lpD3DRM-&gt;lpVtbl-&gt;CreateDeviceFromClipper(lpD3DRM, lpDDClipper, 
        &amp;myglobs.DriverGUID[driver], width, height, &amp;myglobs.dev);
    
    // Create the D3DRM viewport by using the camera frame. Set the 
    // background depth to a large number. The width and height
    // might have been slightly adjusted, so get them from the device.
     
    width = myglobs.dev-&gt;lpVtbl-&gt;GetWidth(myglobs.dev);
    height = myglobs.dev-&gt;lpVtbl-&gt;GetHeight(myglobs.dev);
    rval = lpD3DRM-&gt;lpVtbl-&gt;CreateViewport(lpD3DRM, myglobs.dev, 
        myglobs.camera, 0, 0, width, height, &amp;myglobs.view);
    if (rval != D3DRM_OK) {
        myglobs.dev-&gt;lpVtbl-&gt;Release(myglobs.dev);
        return FALSE;
    }
    rval = myglobs.view-&gt;lpVtbl-&gt;SetBack(myglobs.view, D3DVAL(5000.0));
    if (rval != D3DRM_OK) {
        myglobs.dev-&gt;lpVtbl-&gt;Release(myglobs.dev);
        myglobs.view-&gt;lpVtbl-&gt;Release(myglobs.view);
        return FALSE;
    }
    
    // Set the render quality, fill mode, lighting state,
    // and color shade info.
     
    if (!SetRenderState())
        return FALSE;
    return TRUE;
}
</FONT></PRE>
<H4><A NAME="rmtutor_0001010501050200">Setting the Render State</A></H4>
<P>Direct3D is a <I>state machine</I>; applications set up the state of the lighting, rendering, and transformation modules and then pass data through them. This architecture is integral to Immediate Mode, but it is partially hidden by the Retained Mode API. The SetRenderState function is a simple way to set the rendering state for a Retained Mode application.

<P>First, SetRenderState uses the <A HREF="rm0014.htm#rmdevice_0001010608001400" TARGET="TEXT">IDirect3DRMDevice::SetQuality</A> method, specifying that the lights are on, that the fill mode is solid, and that Gouraud shading should be used. At this point, applications that need to change the dithering mode or texture quality can use the <A HREF="rm0014.htm#rmdevice_0001010608001300" TARGET="TEXT">IDirect3DRMDevice::SetDither</A> or <A HREF="rm0014.htm#rmdevice_0001010608001600" TARGET="TEXT">IDirect3DRMDevice::SetTextureQuality</A> methods.


<PRE><FONT FACE="Courier" SIZE="2">/////////////////////////////////////////////////////////////////////
//
// SetRenderState
// Set the render quality and shade information.
//
/////////////////////////////////////////////////////////////////////
 
BOOL
SetRenderState(void)
{
    HRESULT rval;
    
    // Set the render quality (light toggle, fill mode, shade mode).
     
    rval = myglobs.dev-&gt;lpVtbl-&gt;SetQuality(myglobs.dev, 
        D3DRMLIGHT_ON | D3DRMFILL_SOLID | D3DRMSHADE_GOURAUD);
    if (rval != D3DRM_OK) {
        return FALSE;
    }
    
    // If you want to change the dithering mode, use SetDither here.

    // If you want a texture quality other than D3DRMTEXTURE_NEAREST
    // (the default value), use SetTextureQuality here.
        
   return TRUE;
}
</FONT></PRE>
<H3><A NAME="rmtutor_0001010501060000">The Rendering Loop</A></H3>
<P>The WinMain function uses the RenderLoop function to draw each new frame of the animation. The RenderLoop function performs a few simple tasks: 

<UL><LI>Uses the <A HREF="rm0017.htm#rmframe_000101060b002600" TARGET="TEXT">IDirect3DRMFrame::Move</A> method to apply the rotations and velocities for all frames in the hierarchy. 

<LI>Uses the <A HREF="rm0031.htm#rmviewpt_0001010619000100" TARGET="TEXT">IDirect3DRMViewport::Clear</A> method to clear the current viewport, setting it to the current background color. 

<LI>Uses the <A HREF="rm0031.htm#rmviewpt_0001010619001400" TARGET="TEXT">IDirect3DRMViewport::Render</A> method to render the current scene into the current viewport. 

<LI>Uses the <A HREF="rm0014.htm#rmdevice_0001010608001700" TARGET="TEXT">IDirect3DRMDevice::Update</A> method to copy the rendered image to the display. 
</UL>
<PRE><FONT FACE="Courier" SIZE="2">/////////////////////////////////////////////////////////////////////
//
// RenderLoop
// Clear the viewport, render the next frame, and update the window.
//
/////////////////////////////////////////////////////////////////////
 
static BOOL
RenderLoop()
{
    HRESULT rval;
   
    // Tick the scene.
     
    rval = myglobs.scene-&gt;lpVtbl-&gt;Move(myglobs.scene, D3DVAL(1.0));
    if (rval != D3DRM_OK) {
        return FALSE;
    }
    
    // Clear the viewport.
     
    rval = myglobs.view-&gt;lpVtbl-&gt;Clear(myglobs.view);
    if (rval != D3DRM_OK) {
        return FALSE;
    }
   
    // Render the scene to the viewport.
     
    rval = myglobs.view-&gt;lpVtbl-&gt;Render(myglobs.view, myglobs.scene);
    if (rval != D3DRM_OK) {
        return FALSE;
    }
    
    // Update the window.
     
    rval = myglobs.dev-&gt;lpVtbl-&gt;Update(myglobs.dev);
    if (rval != D3DRM_OK) {
        return FALSE;
    }
    return TRUE;
}
</FONT></PRE>
<H3><A NAME="rmtutor_0001010501070000">Creating the Scene</A></H3>
<P>After setting up the 3-D environment&#151;choosing a device driver, creating the 3-D device and viewport, setting the rendering state, and so on&#151;Helworld.c uses a series of functions to populate this 3-D environment with objects, frames, and lights:

<UL><LI><A CLASS=tctop HREF="rm0005.htm#rmtutor_0001010501070100" TARGET="TEXT">The MyScene Function</A>
 <LI><A CLASS=tctop HREF="rm0005.htm#rmtutor_0001010501070200" TARGET="TEXT">The MakeMyFrames Function</A>
 <LI><A CLASS=tctop HREF="rm0005.htm#rmtutor_0001010501070300" TARGET="TEXT">The MakeMyLights Function</A>
 <LI><A CLASS=tctop HREF="rm0005.htm#rmtutor_0001010501070400" TARGET="TEXT">The SetMyPositions Function</A>
 <LI><A CLASS=tctop HREF="rm0005.htm#rmtutor_0001010501070500" TARGET="TEXT">The MakeMyMesh Function</A>
 <LI><A CLASS=tctop HREF="rm0005.htm#rmtutor_0001010501070600" TARGET="TEXT">The MakeMyWrap Function</A>
 <LI><A CLASS=tctop HREF="rm0005.htm#rmtutor_0001010501070700" TARGET="TEXT">The AddMyTexture Function</A>
</UL>
<H4><A NAME="rmtutor_0001010501070100">The MyScene Function</A></H4>
<P>The MyScene function in Helworld.c corresponds to the BuildScene function that is implemented in all the Direct3D samples in the DirectX SDK. This is where all the work occurs that displays unique objects with unique textures and lighting effects.

<P>The MyScene function uses a series of locally defined functions that set up the separate features of the scene that is being created. These functions are:

<UL><LI><A CLASS=tctop HREF="rm0005.htm#rmtutor_0001010501070200" TARGET="TEXT">MakeMyFrames</A>
<LI><A CLASS=tctop HREF="rm0005.htm#rmtutor_0001010501070300" TARGET="TEXT">MakeMyLights</A>
<LI><A CLASS=tctop HREF="rm0005.htm#rmtutor_0001010501070400" TARGET="TEXT">SetMyPositions</A>
<LI><A CLASS=tctop HREF="rm0005.htm#rmtutor_0001010501070500" TARGET="TEXT">MakeMyMesh</A>
<LI><A CLASS=tctop HREF="rm0005.htm#rmtutor_0001010501070600" TARGET="TEXT">MakeMyWrap</A>
<LI><A CLASS=tctop HREF="rm0005.htm#rmtutor_0001010501070700" TARGET="TEXT">AddMyTexture</A>
</UL>
<P>When these functions have set up the visual object, MyScene uses the <A HREF="rm0017.htm#rmframe_000101060b000800" TARGET="TEXT">IDirect3DRMFrame::AddVisual</A> method to add the object to the environment's world frame. After adding the visual object, MyScene no longer needs the interfaces it has created, so it uses the <A HREF="rm0038.htm#external_0001010620000020" TARGET="TEXT">Release</A> method repeatedly to release them all.

<PRE><FONT FACE="Courier" SIZE="2">/////////////////////////////////////////////////////////////////////
//
// MyScene
// Uses the functions that create the frames, lights, mesh, and
// texture. Releases all interfaces on completion.
//
/////////////////////////////////////////////////////////////////////

BOOL
MyScene(LPDIRECT3DRMDEVICE dev, LPDIRECT3DRMVIEWPORT view,
    LPDIRECT3DRMFRAME lpScene, LPDIRECT3DRMFRAME lpCamera)
{
    LPDIRECT3DRMFRAME lpLightframe1 = NULL;
    LPDIRECT3DRMFRAME lpWorld_frame = NULL;
    LPDIRECT3DRMLIGHT lpLight1      = NULL;
    LPDIRECT3DRMLIGHT lpLight2      = NULL;
    LPDIRECT3DRMTEXTURE lpTex       = NULL;
    LPDIRECT3DRMWRAP lpWrap         = NULL;
    LPDIRECT3DRMMESHBUILDER lpSphere3_builder = NULL;

    MakeMyFrames(lpScene, lpCamera, &amp;lpLightframe1, &amp;lpWorld_frame);
    MakeMyLights(lpScene, lpCamera, lpLightframe1, &amp;lpLight1,
        &amp;lpLight2);
    SetMyPositions(lpScene, lpCamera, lpLightframe1, lpWorld_frame);
    MakeMyMesh(&amp;lpSphere3_builder);
    MakeMyWrap(lpSphere3_builder, &amp;lpWrap);
    AddMyTexture(lpSphere3_builder, &amp;lpTex);

    // If you need to create a material (for example, to create
    // a shiny surface), use CreateMaterial and SetMaterial here.

    // Now that the visual object has been created, add it
    // to the world frame.

    lpWorld_frame-&gt;lpVtbl-&gt;AddVisual(lpWorld_frame, 
        (LPDIRECT3DRMVISUAL) lpSphere3_builder);

    lpLightframe1-&gt;lpVtbl-&gt;Release(lpLightframe1);
    lpWorld_frame-&gt;lpVtbl-&gt;Release(lpWorld_frame);
    lpSphere3_builder-&gt;lpVtbl-&gt;Release(lpSphere3_builder);
    lpLight1-&gt;lpVtbl-&gt;Release(lpLight1);
    lpLight2-&gt;lpVtbl-&gt;Release(lpLight2);
    lpTex-&gt;lpVtbl-&gt;Release(lpTex);
    lpWrap-&gt;lpVtbl-&gt;Release(lpWrap);

    return TRUE;
}
</FONT></PRE>
<H4><A NAME="rmtutor_0001010501070200">The MakeMyFrames Function</A></H4>
<P>The MyScene function uses the MakeMyFrames function to create the frames for the directional light and the world frame used in Helworld.c. MakeMyFrames does this work by using the <A HREF="rm0010.htm#rmid3drm_0001010604000900" TARGET="TEXT">IDirect3DRM::CreateFrame</A> method.

<PRE><FONT FACE="Courier" SIZE="2">/////////////////////////////////////////////////////////////////////
//
// MakeMyFrames
// Create frames used in the scene.
//
/////////////////////////////////////////////////////////////////////

void MakeMyFrames(LPDIRECT3DRMFRAME lpScene, LPDIRECT3DRMFRAME lpCamera,
    LPDIRECT3DRMFRAME * lplpLightFrame1,
    LPDIRECT3DRMFRAME * lplpWorld_frame)
{
    lpD3DRM-&gt;lpVtbl-&gt;CreateFrame(lpD3DRM, lpScene, lplpLightFrame1);
    lpD3DRM-&gt;lpVtbl-&gt;CreateFrame(lpD3DRM, lpScene, lplpWorld_frame);
}
</FONT></PRE>
<H4><A NAME="rmtutor_0001010501070300">The MakeMyLights Function</A></H4>
<P>The MyScene function uses the MakeMyLights function to create the <A HREF="rm0049.htm#3Dgloss_0001010805000002" TARGET="TEXT">directional</A> and <A HREF="rm0046.htm#3Dgloss_0001010802000001" TARGET="TEXT">ambient</A> lights used in Helworld.c. MakeMyLights uses the <A HREF="rm0010.htm#rmid3drm_0001010604000b00" TARGET="TEXT">IDirect3DRM::CreateLightRGB</A> and <A HREF="rm0017.htm#rmframe_000101060b000200" TARGET="TEXT">IDirect3DRMFrame::AddLight</A> methods to create a bright directional light and add it to a light frame, and to create a dim ambient light and add it to the entire scene. (Ambient lights are always associated with an entire scene.)

<PRE><FONT FACE="Courier" SIZE="2">/////////////////////////////////////////////////////////////////////
//
// MakeMyLights
// Create lights used in the scene.
//
/////////////////////////////////////////////////////////////////////

void MakeMyLights(LPDIRECT3DRMFRAME lpScene, LPDIRECT3DRMFRAME lpCamera, 
    LPDIRECT3DRMFRAME lpLightFrame1, 
    LPDIRECT3DRMLIGHT * lplpLight1, LPDIRECT3DRMLIGHT * lplpLight2)
{
    lpD3DRM-&gt;lpVtbl-&gt;CreateLightRGB(lpD3DRM, D3DRMLIGHT_DIRECTIONAL, 
        D3DVAL(0.9), D3DVAL(0.9), D3DVAL(0.9), lplpLight1);
                          
    lpLightFrame1-&gt;lpVtbl-&gt;AddLight(lpLightFrame1, *lplpLight1);

    lpD3DRM-&gt;lpVtbl-&gt;CreateLightRGB(lpD3DRM, D3DRMLIGHT_AMBIENT, 
        D3DVAL(0.1), D3DVAL(0.1), D3DVAL(0.1), lplpLight2);
    
    lpScene-&gt;lpVtbl-&gt;AddLight(lpScene, *lplpLight2);
}
</FONT></PRE>
<H4><A NAME="rmtutor_0001010501070400">The SetMyPositions Function</A></H4>
<P>The MyScene function uses the SetMyPositions function to set the positions and orientations of the frames used in Helworld.c. SetMyPositions does this work by using the <A HREF="rm0017.htm#rmframe_000101060b002b00" TARGET="TEXT">IDirect3DRMFrame::SetPosition</A> and <A HREF="rm0017.htm#rmframe_000101060b002a00" TARGET="TEXT">IDirect3DRMFrame::SetOrientation</A> methods. The <A HREF="rm0017.htm#rmframe_000101060b002c00" TARGET="TEXT">IDirect3DRMFrame::SetRotation</A> method imparts a spin to the frame to which the sphere will be added.

<PRE><FONT FACE="Courier" SIZE="2">/////////////////////////////////////////////////////////////////////
//
// SetMyPositions
// Set the positions and orientations of the light, camera, and 
// world frames. Establish a rotation for the globe.
//
/////////////////////////////////////////////////////////////////////

void SetMyPositions(LPDIRECT3DRMFRAME lpScene, 
    LPDIRECT3DRMFRAME lpCamera, LPDIRECT3DRMFRAME lpLightFrame1, 
    LPDIRECT3DRMFRAME lpWorld_frame)
{

    lpLightFrame1-&gt;lpVtbl-&gt;SetPosition(lpLightFrame1, lpScene, 
        D3DVAL(2), D3DVAL(0.0), D3DVAL(22));

    lpCamera-&gt;lpVtbl-&gt;SetPosition(lpCamera, lpScene, 
        D3DVAL(0.0), D3DVAL(0.0), D3DVAL(0.0));
    lpCamera-&gt;lpVtbl-&gt;SetOrientation(lpCamera, lpScene, 
        D3DVAL(0.0), D3DVAL(0.0), D3DVAL(1), 
        D3DVAL(0.0), D3DVAL(1), D3DVAL(0.0));
                                        
    lpWorld_frame-&gt;lpVtbl-&gt;SetPosition(lpWorld_frame, lpScene, 
        D3DVAL(0.0), D3DVAL(0.0), D3DVAL(15));
    lpWorld_frame-&gt;lpVtbl-&gt;SetOrientation(lpWorld_frame, lpScene, 
        D3DVAL(0.0), D3DVAL(0.0), D3DVAL(1),
        D3DVAL(0.0), D3DVAL(1), D3DVAL(0.0));
                                
    lpWorld_frame-&gt;lpVtbl-&gt;SetRotation(lpWorld_frame, lpScene, 
        D3DVAL(0.0), D3DVAL(0.1), D3DVAL(0.0), D3DVAL(0.05));
}
</FONT></PRE>
<H4><A NAME="rmtutor_0001010501070500">The MakeMyMesh Function</A></H4>
<P>The MyScene function uses the MakeMyMesh function to load and set the spherical mesh used in Helworld.c. MakeMyMesh uses the <A HREF="rm0010.htm#rmid3drm_0001010604000e00" TARGET="TEXT">IDirect3DRM::CreateMeshBuilder</A> method to create an <A CLASS=tctop HREF="rm0023.htm#rmmshbld_0001010611000000" TARGET="TEXT">IDirect3DRMMeshBuilder</A> interface. Then it uses the <A HREF="rm0023.htm#rmmshbld_0001010611001500" TARGET="TEXT">IDirect3DRMMeshBuilder::Load</A>, <A HREF="rm0023.htm#rmmshbld_0001010611001800" TARGET="TEXT">IDirect3DRMMeshBuilder::Scale</A>, and <A HREF="rm0023.htm#rmmshbld_0001010611001a00" TARGET="TEXT">IDirect3DRMMeshBuilder::SetColorRGB</A> methods to prepare the mesh represented by the Sphere3.x file. (The Sphere3.x file is included in the DirectX SDK, as part of the media provided for use with the sample code.)

<PRE><FONT FACE="Courier" SIZE="2">/////////////////////////////////////////////////////////////////////
//
// MakeMyMesh
// Create MeshBuilder object, load, scale, and color the mesh.
//
/////////////////////////////////////////////////////////////////////

void MakeMyMesh(LPDIRECT3DRMMESHBUILDER * lplpSphere3_builder)
{
    lpD3DRM-&gt;lpVtbl-&gt;CreateMeshBuilder(lpD3DRM, lplpSphere3_builder);

    (*lplpSphere3_builder)-&gt;lpVtbl-&gt;Load(*lplpSphere3_builder, 
        "sphere3.x", NULL, D3DRMLOAD_FROMFILE, NULL, NULL);

    (*lplpSphere3_builder)-&gt;lpVtbl-&gt;Scale(*lplpSphere3_builder,
        D3DVAL(2), D3DVAL(2), D3DVAL(2));
      
    // Set sphere to white to avoid unexpected texture-blending results.

    (*lplpSphere3_builder)-&gt;lpVtbl-&gt;SetColorRGB(*lplpSphere3_builder, 
        D3DVAL(1), D3DVAL(1), D3DVAL(1));
}
</FONT></PRE>
<H4><A NAME="rmtutor_0001010501070600">The MakeMyWrap Function</A></H4>
<P>The MyScene function uses the MakeMyWrap function to create and apply texture coordinates to the sphere loaded by the MakeMyMesh function. MakeMyWrap uses the <A HREF="rm0023.htm#rmmshbld_0001010611000b00" TARGET="TEXT">IDirect3DRMMeshBuilder::GetBox</A> method to retrieve the bounding box that contains the sphere and uses the dimensions of that bounding box in a call to the <A HREF="rm0010.htm#rmid3drm_0001010604001500" TARGET="TEXT">IDirect3DRM::CreateWrap</A> method, which creates a cylindrical texture wrap and retrieves the <A CLASS=tctop HREF="rm0033.htm#rmwrap_000101061b000000" TARGET="TEXT">IDirect3DRMWrap</A> interface. A call to the <A HREF="rm0033.htm#rmwrap_000101061b000100" TARGET="TEXT">IDirect3DRMWrap::Apply</A> method applies the texture coordinates to the sphere.

<PRE><FONT FACE="Courier" SIZE="2">/////////////////////////////////////////////////////////////////////
//
// MakeMyWrap
// Creates and applies wrap for texture.
//
/////////////////////////////////////////////////////////////////////

void MakeMyWrap(LPDIRECT3DRMMESHBUILDER sphere3_builder, 
                LPDIRECT3DRMWRAP * lpWrap)
{
    D3DVALUE miny, maxy, height;
    D3DRMBOX box;

    sphere3_builder-&gt;lpVtbl-&gt;GetBox(sphere3_builder, &amp;box);

    maxy = box.max.y;
    miny = box.min.y;
    height = maxy - miny;

    lpD3DRM-&gt;lpVtbl-&gt;CreateWrap
        (lpD3DRM, D3DRMWRAP_CYLINDER, NULL,
        D3DVAL(0.0), D3DVAL(0.0), D3DVAL(0.0),
        D3DVAL(0.0), D3DVAL(1.0), D3DVAL(0.0),
        D3DVAL(0.0), D3DVAL(0.0), D3DVAL(1.0),
        D3DVAL(0.0), D3DDivide(miny, height),
        D3DVAL(1.0), D3DDivide(D3DVAL(1.0), height),
        lpWrap);

    (*lpWrap)-&gt;lpVtbl-&gt;Apply(*lpWrap, (LPDIRECT3DRMOBJECT)
        sphere3_builder);

}
</FONT></PRE>
<H4><A NAME="rmtutor_0001010501070700">The AddMyTexture Function</A></H4>
<P>The MyScene function uses the AddMyTexture function to load a texture and associate it with the sphere. AddMyTexture uses the <A HREF="rm0010.htm#rmid3drm_0001010604001b00" TARGET="TEXT">IDirect3DRM::LoadTexture</A> method to load a bitmap called Tutor.bmp, and then it uses the <A HREF="rm0023.htm#rmmshbld_0001010611002000" TARGET="TEXT">IDirect3DRMMeshBuilder::SetTexture</A> method to associate the bitmap with the sphere. 

<P><IMG SRC="art/hello.gif" WIDTH="256" HEIGHT="256" ALT="Bitmap used as a texture on the sphere">

<PRE><FONT FACE="Courier" SIZE="2">/////////////////////////////////////////////////////////////////////
//
// AddMyTexture
// Creates and applies wrap for texture.
//
/////////////////////////////////////////////////////////////////////

void AddMyTexture(LPDIRECT3DRMMESHBUILDER lpSphere3_builder, 
    LPDIRECT3DRMTEXTURE * lplpTex)
{
    lpD3DRM-&gt;lpVtbl-&gt;LoadTexture(lpD3DRM, "tutor.bmp", lplpTex);

    // If you need a color depth other than the default (16), 
    // use IDirect3DRMTexture::SetShades here.

    lpSphere3_builder-&gt;lpVtbl-&gt;SetTexture(lpSphere3_builder, *lplpTex);

}
</FONT></PRE>
<H3><A NAME="rmtutor_0001010501080000">Cleaning Up</A></H3>
<P>Helworld.c uses the CleanUp function when it receives a WM_DESTROY message or after several consecutive unsuccessful attempts to use the RenderLoop function. 



<PRE><FONT FACE="Courier" SIZE="2">/////////////////////////////////////////////////////////////////////
//
// CleanUp
// Release all D3DRM objects and set the bQuit flag.
//
/////////////////////////////////////////////////////////////////////

void
CleanUp(void)
{
    myglobs.bInitialized = FALSE;
    myglobs.scene-&gt;lpVtbl-&gt;Release(myglobs.scene);
    myglobs.camera-&gt;lpVtbl-&gt;Release(myglobs.camera);
    myglobs.view-&gt;lpVtbl-&gt;Release(myglobs.view);
    myglobs.dev-&gt;lpVtbl-&gt;Release(myglobs.dev);
    lpD3DRM-&gt;lpVtbl-&gt;Release(lpD3DRM);
    lpDDClipper-&gt;lpVtbl-&gt;Release(lpDDClipper);

    myglobs.bQuit = TRUE;
}
</FONT></PRE>
<P><P><FONT FACE="MS SANS SERIF" SIZE="1" COLOR="BLACK">
<A CLASS=cpslug HREF="copyrite.htm" TARGET="TEXT">&#169; 1998 Microsoft Corporation. All rights reserved. Terms of use.</A>
</FONT>
<BR CLEAR=ALL><P>
</FONT><P>
</BODY></HTML>
