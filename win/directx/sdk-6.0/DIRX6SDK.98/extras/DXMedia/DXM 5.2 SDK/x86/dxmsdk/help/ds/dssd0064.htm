<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<HTML>
<HEAD><TITLE>Creating a Capture Application</TITLE>
<STYLE>
<!--
.tctop {color: blue}
.cpslug {color: blue; text-decoration: none}
-->
</STYLE>
<SCRIPT LANGUAGE="JAVASCRIPT">
//<!--
function ShowButtons() {
    if (window.top.frames.length!=0 && window.top.frames[0].ShowButtons!=null)
	window.top.frames[0].ShowButtons('/dssd0063.htm','/dssd0000.htm','/dssd0048.htm','/index.htm','/filter_categories.htm');
}
ShowButtons();
//-->
</SCRIPT>
</HEAD>
<BODY onLoad="ShowButtons()" TOPMARGIN=10 BGPROPERTIES="FIXED" BGCOLOR="#FFFFFF" LINK="#000000" VLINK="#808080" ALINK="#000000">
<FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">
<H2><A NAME="capapp_0001040401000000">Creating a Capture Application</A></H2>
<BR CLEAR=ALL>
<P>Microsoft&#174; DirectShow&#153; provides the capability to capture and preview both video and audio data from an application, when combined with the appropriate capture hardware. The data source might include a VCR, camera, TV tuner, microphone, or other source. An application can display the captured data immediately (preview) or save it to a file for later viewing either inside or outside of the application. 

<P>DirectShow takes advantage of new capture drivers that are written as DirectShow filters, and also uses existing Video for Windows-style drivers.

<P><B>Note</B>  This article relies heavily on the <A CLASS=TCTOP HREF="dssd0370.htm#samples_0001070208010000" TARGET="TEXT">AMCap Sample (DirectShow Capture Application)</A> sample application. See the AMCap sample code (Amcap.cpp) in the Samples\DS\Capture directory of the DirectShow SDK for complete sample code, because this article does not present <A CLASS=TCTOP HREF="dssd0370.htm#samples_0001070208010000" TARGET="TEXT">AMCap Sample (DirectShow Capture Application)</A> in its entirety. 
<P>The <A CLASS=TCTOP HREF="dssd0370.htm#samples_0001070208010000" TARGET="TEXT">AMCap Sample (DirectShow Capture Application)</A> sample application performs video and audio capture, similar to the VidCap sample from Video for Windows&#174;. It uses the <A HREF="dssd0126.htm#If_0001060121000000" TARGET="TEXT">ICaptureGraphBuilder</A> interface to handle the majority of the capture work. In your own capture application, you'll use the same methods and interfaces that AMCap uses. This article focuses on AMCap's use of <B>ICaptureGraphBuilder</B> to perform video and audio capture and presents relevant code excerpts from AMCap. 

<P>This article assumes you are familiar with the DirectShow filter graph architecture and the general layout of a capture filter graph. See <A CLASS=TCTOP HREF="dssd0033.htm" TARGET="TEXT">Filter Graph Manager and Filter Graphs</A> and <A CLASS=TCTOP HREF="dssd0037.htm" TARGET="TEXT">About Capture Filter Graphs</A> for more information.

<P><B>Contents of this article:</B>
<UL><LI><A CLASS=TCTOP HREF="dssd0064.htm#capapp_0001040401010000" TARGET="TEXT">Introduction to ICaptureGraphBuilder</A>
<LI><A CLASS=TCTOP HREF="dssd0064.htm#capapp_0001040401020000" TARGET="TEXT">Device Enumeration and Capture Interfaces</A> 
<LI><A CLASS=TCTOP HREF="dssd0064.htm#capapp_0001040401030000" TARGET="TEXT">Building the Capture and Preview Filter Graph</A>
<LI><A CLASS=TCTOP HREF="dssd0064.htm#capapp_0001040401040000" TARGET="TEXT">Controlling the Capture Filter Graph</A>
<LI><A CLASS=TCTOP HREF="dssd0064.htm#capapp_0001040401050000" TARGET="TEXT">Obtaining Capture Statistics</A>
<LI><A CLASS=TCTOP HREF="dssd0064.htm#capapp_0001040401060000" TARGET="TEXT">Saving the Captured File</A>
<LI><A CLASS=TCTOP HREF="dssd0064.htm#capapp_0001040401070000" TARGET="TEXT">Displaying Property Pages</A>
<LI><A CLASS=TCTOP HREF="dssd0064.htm#Additional_Notes" TARGET="TEXT">Additional Notes</A>
</UL>
<A NAME="capapp_0001040401010000"></A><P><B>Introduction to ICaptureGraphBuilder</B>
<P>The <A HREF="dssd0126.htm#If_0001060121000000" TARGET="TEXT">ICaptureGraphBuilder</A> interface provides a filter graph builder object that applications use to handle some of the more tedious tasks involved in building a capture filter graph, which frees the application to focus on capture. You access the graph builder object by calling methods on <B>ICaptureGraphBuilder</B>. The variety of methods satisfies the basic requirements for capture and preview functionality. 

<P>The <A HREF="dssd0126.htm#If_0001060121030400" TARGET="TEXT">FindInterface</A> method searches for a particular capture-related interface in the filter graph. The method handles the complexities of filter graph traversal for you, which enables you to access the functionality of a particular interface without having to enumerate pins and filters in the filter graph looking for the interface. The <A HREF="dssd0126.htm#If_0001060121030600" TARGET="TEXT">RenderStream</A> method connects source filters to rendering filters, optionally adding other needed intermediate filters. The 
<A HREF="dssd0126.htm#If_0001060121030200" TARGET="TEXT">ControlStream</A> method independently control sections of the graph for frame-accurate start and stop. 

<P>Additional methods deal with allocating space for the capture file (<A HREF="dssd0126.htm#If_0001060121030100" TARGET="TEXT">AllocCapFile</A>), specifying a name for it and building up the <I>file writer</I> section of the graph, which consists of the multiplexer and file writer filters (<A HREF="dssd0126.htm#If_0001060121030800" TARGET="TEXT">SetOutputFileName</A>), and saving the captured data to another file (<A HREF="dssd0126.htm#If_0001060121030300" TARGET="TEXT">CopyCaptureFile</A>). Finally, <A HREF="dssd0126.htm#If_0001060121030700" TARGET="TEXT">SetFiltergraph</A> and <A HREF="dssd0126.htm#If_0001060121030500" TARGET="TEXT">GetFiltergraph</A> enable the application to provide a filter graph for the graph builder to use or retrieve the filter graph already in use.

<A NAME="capapp_0001040401020000"></A><P><B>Device Enumeration and Capture Interfaces</B>
<P>AMCap's InitCapFilters function enumerates the capture devices on the system by using the <A HREF="dssd0129.htm#If_0001060124030100" TARGET="TEXT">ICreateDevEnum::CreateClassEnumerator</A> method. After enumerating a capture device and instantiating a DirectShow filter to use that device, the sample calls the <A HREF="dssd0126.htm#If_0001060121030400" TARGET="TEXT">ICaptureGraphBuilder::FindInterface</A> method several times to obtain interface pointers for the <A HREF="dssd0104.htm#If_000106010b000000" TARGET="TEXT">IAMDroppedFrames</A>, <A HREF="dssd0119.htm#If_000106011a000000" TARGET="TEXT">IAMVideoCompression</A>, <A HREF="dssd0110.htm#If_0001060111000000" TARGET="TEXT">IAMStreamConfig</A>, and <A HREF="dssd0117.htm#If_0001060118000000" TARGET="TEXT">IAMVfwCaptureDialogs</A> capture-related interfaces. The AMCap code saves all of these interface pointers for later use in the gcap global structure and uses gcap structure members throughout the code. 

<P><B>Note:</B>  <A HREF="dssd0117.htm#If_0001060118000000" TARGET="TEXT">IAMVfwCaptureDialogs</A> is designed for you to use only with the Microsoft-supplied video capture filter and only when using a former Video for Windows device.<P>For your convenience, the declaration of the gcap structure follows:

<PRE><FONT FACE="Courier" SIZE="2">
struct _capstuff {
    char szCaptureFile[_MAX_PATH];
    WORD wCapFileSize;  // size in Meg
    ICaptureGraphBuilder *pBuilder;
    IVideoWindow *pVW;
    IMediaEventEx *pME;
    IAMDroppedFrames *pDF;
    IAMVideoCompression *pVC;
    IAMVfwCaptureDialogs *pDlg;
    IAMStreamConfig *pASC;      // for audio cap
    IAMStreamConfig *pVSC;      // for video cap
    IBaseFilter *pRender;
    IBaseFilter *pVCap, *pACap;
    IGraphBuilder *pFg;
    IFileSinkFilter *pSink;
    IConfigAviMux *pConfigAviMux;
    int  iMasterStream;
    BOOL fCaptureGraphBuilt;
    BOOL fPreviewGraphBuilt;
    BOOL fCapturing;
    BOOL fPreviewing;
    BOOL fCapAudio;
    int  iVideoDevice;
    int  iAudioDevice;
    double FrameRate;
    BOOL fWantPreview;
    long lCapStartTime;
    long lCapStopTime;
    char achFriendlyName[120];
    BOOL fUseTimeLimit;
    DWORD dwTimeLimit;
} gcap;
</FONT></PRE>
<P>AMCap's InitCapFilters function stores several interface pointers in the gcap structure. Be sure to properly release all interface pointers when they are no longer needed as shown in the following example.

<PRE><FONT FACE="Courier" SIZE="2">
    if (gcap.pBuilder)
      gcap.pBuilder-&gt;Release();
    gcap.pBuilder = NULL;
    if (gcap.pSink)
      gcap.pSink-&gt;Release();
    gcap.pSink = NULL;
    if (gcap.pConfigAviMux)
      gcap.pConfigAviMux-&gt;Release();
    gcap.pConfigAviMux = NULL;
    if (gcap.pRender)
      gcap.pRender-&gt;Release();
    gcap.pRender = NULL;
    if (gcap.pVW)
      gcap.pVW-&gt;Release();
    gcap.pVW = NULL;
    if (gcap.pME)
      gcap.pME-&gt;Release();
    gcap.pME = NULL;
    if (gcap.pFg)
      gcap.pFg-&gt;Release();
    gcap.pFg = NULL;
</FONT></PRE>
<P>See <A CLASS=TCTOP HREF="dssd0059.htm" TARGET="TEXT">Enumerate and Access Hardware Devices in DirectShow Applications</A> for more information about device enumeration.

<A NAME="capapp_0001040401030000"></A><P><B>Building the Capture and Preview Filter Graph</B>
<P>AMCap includes a BuildCaptureGraph function that builds up a capture graph with both capture and preview components. Most applications will perform the same tasks sequentially as described in the following topics contained in this section.

<UL><LI><A CLASS=TCTOP HREF="dssd0064.htm#capapp_0001040401030100" TARGET="TEXT">Set the Capture File Name</A>
<LI><A CLASS=TCTOP HREF="dssd0064.htm#capapp_0001040401030200" TARGET="TEXT">Create a Graph Builder Object</A>
<LI><A CLASS=TCTOP HREF="dssd0064.htm#capapp_0001040401030300" TARGET="TEXT">Set the Output File Name</A>
<LI><A CLASS=TCTOP HREF="dssd0064.htm#capapp_0001040401030400" TARGET="TEXT">Retrieve the Current Filter Graph</A>
<LI><A CLASS=TCTOP HREF="dssd0064.htm#capapp_0001040401030500" TARGET="TEXT">Add the Capture Filters to the Filter Graph</A>
<LI><A CLASS=TCTOP HREF="dssd0064.htm#capapp_0001040401030600" TARGET="TEXT">Render the Capture Pins</A>
<LI><A CLASS=TCTOP HREF="dssd0064.htm#capapp_0001040401030700" TARGET="TEXT">Render the Video Preview Pin</A>
<LI><A CLASS=TCTOP HREF="dssd0064.htm#capapp_0001040401030800" TARGET="TEXT">Configure the Video Preview Window</A>
</UL>
<P>These tasks are explained in greater detail later in this section.

<P>AMCap also includes a BuildPreviewGraph function that is essentially a version of BuildCaptureGraph that deals only with preview. Another difference between BuildCaptureGraph and BuildPreviewGraph is that the latter uses <A HREF="dssd0126.htm#If_0001060121030700" TARGET="TEXT">ICaptureGraphBuilder::SetFiltergraph</A> to provide a filter graph object (<A HREF="dssd0153.htm#If_000106013c000000" TARGET="TEXT">IGraphBuilder</A> interface) for the capture graph builder object (<A HREF="dssd0126.htm#If_0001060121000000" TARGET="TEXT">ICaptureGraphBuilder</A> interface) to use. You probably won't need to call <A HREF="dssd0126.htm#If_0001060121030700" TARGET="TEXT">SetFiltergraph</A> as the graph builder object creates a filter graph to use by default. Use this method only if you have already created your own filter graph and want the graph builder to use your filter graph. If you call this method after the graph builder has created a filter graph, this method will fail.

 BuildPreviewGraph calls <A HREF="dssd0406.htm#external_00010a010900000c" TARGET="TEXT">CoCreateInstance</A> to create a new filter graph object, if necessary, as shown in the following example.


<PRE><FONT FACE="Courier" SIZE="2">
hr = CoCreateInstance(CLSID_FilterGraph, NULL, CLSCTX_INPROC,
                      IID_IGraphBuilder, (LPVOID *)&amp;gcap.pFg);


hr = gcap.pBuilder-&gt;SetFiltergraph(gcap.pFg);
    if (hr != NOERROR) {
      ErrMsg("Cannot give graph to builder");
      goto SetupPreviewFail;
    }
</FONT></PRE>
<P>The details of each important task performed by BuildCaptureGraph follow. 

<A NAME="capapp_0001040401030100"></A><P><B>Set the Capture File Name</B>
<P>AMCap's SetCaptureFile function displays the common Open File dialog box to enable the user to select a capture file. If the specified file is a new file, it calls the application-defined AllocCaptureFile function that prompts the user to allocate space for the capture file. This "preallocation" of file space is important, because it reserves a large block of space on disk. This speeds up the capture operation when it occurs, because the file space doesn't have to be allocated while capture takes place (it has been preallocated). The <A HREF="dssd0126.htm#If_0001060121030100" TARGET="TEXT">ICaptureGraphBuilder::AllocCapFile</A> method performs the actual file allocation. <A HREF="dssd0144.htm#If_0001060133030200" TARGET="TEXT">IFileSinkFilter::SetFileName</A> instructs the file writer filter to use the file name that the user chose. The code assumes you've called <A HREF="dssd0126.htm#If_0001060121030800" TARGET="TEXT">ICaptureGraphBuilder::SetOutputFileName</A> to add the file writer to the filter graph. See <A CLASS=TCTOP HREF="dssd0064.htm#capapp_0001040401030300" TARGET="TEXT">Set the Output File Name</A> for more information.

<P>The AMCap-defined SetCaptureFile and AllocCaptureFile functions follow:

<PRE><FONT FACE="Courier" SIZE="2">
/*
 * Put up a dialog to allow the user to select a capture file.
 */
BOOL SetCaptureFile(HWND hWnd)
{
    if (OpenFileDialog(hWnd, gcap.szCaptureFile, _MAX_PATH)) {
        OFSTRUCT os;

      // We have a capture file name.

        /*
         * If this is a new file, then invite the user to
         * allocate some space.
         */
        if (OpenFile(gcap.szCaptureFile, &amp;os, OF_EXIST) == HFILE_ERROR) {

          // Bring up dialog, and set new file size.
          BOOL f = AllocCaptureFile(hWnd);
          if (!f)
            return FALSE;
        }
    } else {
      return FALSE;
    }

    SetAppCaption();      // Need a new app caption.

    // Tell the file writer to use the new file name.
    if (gcap.pSink) {
        WCHAR wach[_MAX_PATH];
        MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, gcap.szCaptureFile, -1,
                            wach, _MAX_PATH);
        gcap.pSink-&gt;SetFileName(wach, NULL);
    }

    return TRUE;
}

// Preallocate the capture file.
// 
BOOL AllocCaptureFile(HWND hWnd)
{
// We'll get into an infinite loop in the dlg proc setting a value.
    if (gcap.szCaptureFile[0] == 0)
      return FALSE;

    /*
     * Show the allocate file space dialog to encourage
     * the user to pre-allocate space.
     */
    if (DoDialog(hWnd, IDD_AllocCapFileSpace, AllocCapFileProc, 0)) {

      // Ensure repaint after dismissing dialog before
      // possibly lengthy operation.
      UpdateWindow(ghwndApp);

      // User has hit OK. Alloc requested capture file space.
      BOOL f = MakeBuilder();
      if (!f)
        return FALSE;
      WCHAR wach[_MAX_PATH];
      MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, gcap.szCaptureFile, -1,
                          wach, _MAX_PATH);
      if (gcap.pBuilder-&gt;AllocCapFile(wach,
                                gcap.wCapFileSize * 1024L * 1024L) != NOERROR) {
        MessageBoxA(ghwndApp, "Error",
                    "Failed to pre-allocate capture file space",
                    MB_OK | MB_ICONEXCLAMATION);
        return FALSE;
        }
    return TRUE;
    } else {
        return FALSE;
        }
}
</FONT></PRE>
<A NAME="capapp_0001040401030200"></A><P><B>Create a Graph Builder Object</B>
<P>AMCap's MakeBuilder function creates a capture graph builder object and obtains an <A HREF="dssd0126.htm#If_0001060121000000" TARGET="TEXT">ICaptureGraphBuilder</A> interface pointer by calling <A HREF="dssd0406.htm#external_00010a010900000c" TARGET="TEXT">CoCreateInstance</A>. If you already have a capture graph builder object, you can call <A HREF="dssd0183.htm#If_000106015a030200" TARGET="TEXT">QueryInterface</A> to obtain an interface pointer. AMCap stores the object pointer in the pBuilder member of the global gcap structure. 

<PRE><FONT FACE="Courier" SIZE="2">
// Make a graph builder object we can use for capture graph building.
//
BOOL MakeBuilder()
{
    // We have one already.
    if (gcap.pBuilder)
      return TRUE;

    HRESULT hr = CoCreateInstance((REFCLSID)CLSID_CaptureGraphBuilder,
                    NULL, CLSCTX_INPROC, (REFIID)IID_ICaptureGraphBuilder,
                    (void **)&amp;gcap.pBuilder);
    return (hr == NOERROR) ? TRUE : FALSE;
}
</FONT></PRE>
<A NAME="capapp_0001040401030300"></A><P><B>Set the Output File Name</B>
<P>AMCap creates the rendering section of the filter graph, consisting of the <A CLASS=TCTOP HREF="dssd0320.htm#filteref_0001070109000000" TARGET="TEXT">AVI MUX</A> (multiplexer) and the <A CLASS=TCTOP HREF="dssd0334.htm#filteref_0001070117000000" TARGET="TEXT">File Writer</A>. It also provides the filter graph with the previously specified file name to which to save the captured data. See <A CLASS=TCTOP HREF="dssd0037.htm" TARGET="TEXT">About Capture Filter Graphs</A> for more information about capture filter graph in general. 

<P><A HREF="dssd0126.htm#If_0001060121030800" TARGET="TEXT">ICaptureGraphBuilder::SetOutputFileName</A> signals to add the multiplexer and file writer to the filter graph, connects them, and sets the file name. The following example illustrates a call to <A HREF="dssd0126.htm#If_0001060121030800" TARGET="TEXT">SetOutputFileName</A>.

<PRE><FONT FACE="Courier" SIZE="2">
//
// We need a rendering section that will write the capture file out in AVI
// file format.
//

    WCHAR wach[_MAX_PATH];
    MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, gcap.szCaptureFile, -1, wach,
                        _MAX_PATH);
    GUID guid = MEDIASUBTYPE_Avi;
    hr = gcap.pBuilder-&gt;SetOutputFileName(&amp;guid, wach, &amp;gcap.pRender,
                                          &amp;gcap.pSink);
    if (hr != NOERROR) {
      ErrMsg("Error %x: Cannot set output file", hr);
      goto SetupCaptureFail;
    }
</FONT></PRE>
<P>In the above code fragment the value of the first parameter, <I>pType</I>, in the call to <A HREF="dssd0126.htm#If_0001060121030800" TARGET="TEXT">SetOutputFileName</A> is MEDIASUBTYPE_Avi, indicating that the capture graph builder object will insert an AVI multiplexer filter. Consequently, the file writer that is connected to the multiplexer will write the data to the capture file in AVI file format. 

<P>The second parameter, <I>lpwstrFile</I>, specifies the file name. The last two parameters contain pointers to the multiplexer filter and the file writer filter, respectively, and are initialized for you by the capture graph builder object upon return from <A HREF="dssd0126.htm#If_0001060121030800" TARGET="TEXT">SetOutputFileName</A>. AMCap stores these pointers in the pRender and pSink members of its gcap structure. Internally, the capture graph builder object creates a filter graph object which exposes the <A HREF="dssd0153.htm#If_000106013c000000" TARGET="TEXT">IGraphBuilder</A> interface and inserts these two filters into that filter graph. It tells the file writer to use the specified file when writing to disk. 

<P>Alternatively, if you want filters besides the multiplexer and file writer in the rendering section of your filter graph, call <A HREF="dssd0147.htm#If_0001060136030100" TARGET="TEXT">IFilterGraph::AddFilter</A> to explicitly add the necessary filters. You might need to remember the pointer to the <A HREF="dssd0123.htm#If_000106011e000000" TARGET="TEXT">IBaseFilter</A> interface of the first filter in your custom rendering chain so you can use it in calls such as <A HREF="dssd0126.htm#If_0001060121030600" TARGET="TEXT">RenderStream</A>.

<A NAME="capapp_0001040401030400"></A><P><B>Retrieve the Current Filter Graph</B>
<P>Because the capture graph builder object created a filter graph in response to 
<A HREF="dssd0126.htm#If_0001060121030800" TARGET="TEXT">SetOutputFileName</A> and you must put the necessary filters in the same filter graph, call the <A HREF="dssd0126.htm#If_0001060121030500" TARGET="TEXT">ICaptureGraphBuilder::GetFiltergraph</A> method to retrieve the newly created filter graph. The pointer to the filter graph's <A HREF="dssd0153.htm#If_000106013c000000" TARGET="TEXT">IGraphBuilder</A> interface is returned in the function's parameter.

<PRE><FONT FACE="Courier" SIZE="2">
//
// The graph builder created a filter graph to do that.  Find out what it is,
// and put the video capture filter in the graph too.
//

    hr = gcap.pBuilder-&gt;GetFiltergraph(&amp;gcap.pFg);
    if (hr != NOERROR) {
      ErrMsg("Error %x: Cannot get filtergraph", hr);
      goto SetupCaptureFail;
    }
</FONT></PRE>
<A NAME="capapp_0001040401030500"></A><P><B>Add the Capture Filters to the Filter Graph</B>
<P>Call <A HREF="dssd0147.htm#If_0001060136030100" TARGET="TEXT">IFilterGraph::AddFilter</A> to add the capture filters to the filter graph as shown in the following example. 

<PRE><FONT FACE="Courier" SIZE="2">
    hr = gcap.pFg-&gt;AddFilter(gcap.pVCap, NULL);
    if (hr != NOERROR) {
      ErrMsg("Error %x: Cannot add vidcap to filtergraph", hr);
      goto SetupPreviewFail;
    }

    hr = gcap.pFg-&gt;AddFilter(gcap.pACap, NULL);
      if (hr != NOERROR) {
          ErrMsg("Error %x: Cannot add audcap to filtergraph", hr);
          goto SetupCaptureFail;
      }
</FONT></PRE>
<A NAME="capapp_0001040401030600"></A><P><B>Render the Capture Pins</B>
<P>The <A HREF="dssd0126.htm#If_0001060121030600" TARGET="TEXT">ICaptureGraphBuilder::RenderStream</A> method connects the source filter's pin to the rendering filter. It connects intermediate filters if necessary. The pin category is optional, but typically specifies either a capture pin (<A HREF="dssd0305.htm#propset_0001060704000004" TARGET="TEXT">PIN_CATEGORY_CAPTURE</A>) or a preview pin (<A HREF="dssd0305.htm#propset_0001060704000008" TARGET="TEXT">PIN_CATEGORY_PREVIEW</A>). The following example connects the capture pin on the video capture filter (represented by the gcap.pVCap variable) to the renderer (represented by gcap.pRender).
 
<PRE><FONT FACE="Courier" SIZE="2">
//
// Render the video capture and preview pins - we may not have preview, so
// don't worry if it doesn't work.
//

    hr = gcap.pBuilder-&gt;RenderStream(&amp;PIN_CATEGORY_CAPTURE, gcap.pVCap,
                                     NULL, gcap.pRender);
    // Error checking.
</FONT></PRE>
<P>Call <A HREF="dssd0126.htm#If_0001060121030600" TARGET="TEXT">ICaptureGraphBuilder::RenderStream</A> again to connect the audio capture filter (represented by gcap.pACap) to the audio renderer as in the following example.

<PRE><FONT FACE="Courier" SIZE="2">
//
// Render the audio capture pin?
//

    if (gcap.fCapAudio) {
      hr = gcap.pBuilder-&gt;RenderStream(&amp;PIN_CATEGORY_CAPTURE, gcap.pACap, NULL, gcap.pRender);
    // Error checking.
</FONT></PRE>
<A NAME="capapp_0001040401030700"></A><P><B>Render the Video Preview Pin</B>
<P>Call <A HREF="dssd0126.htm#If_0001060121030600" TARGET="TEXT">ICaptureGraphBuilder::RenderStream</A> again to render the graph from the capture filter's preview pin to a video renderer as in the following example. 
<PRE><FONT FACE="Courier" SIZE="2">
    hr = gcap.pBuilder-&gt;RenderStream(&amp;PIN_CATEGORY_PREVIEW, gcap.pVCap,
                                     NULL, NULL);
</FONT></PRE>
<A NAME="capapp_0001040401030800"></A><P><B>Configure the Video Preview Window</B>
<P>By default, the video preview window will be a separate window from your application window. If you want to change the default behavior, call <A HREF="dssd0126.htm#If_0001060121030400" TARGET="TEXT">ICaptureGraphBuilder::FindInterface</A> to obtain a pointer to the <A HREF="dssd0185.htm#If_000106015c000000" TARGET="TEXT">IVideoWindow</A> interface. The first parameter, <I>pCategory</I> specifies the output pin category to search for a connected filter that supports the desired interface. The code fragment below uses <A HREF="dssd0305.htm#propset_0001060704000008" TARGET="TEXT">PIN_CATEGORY_PREVIEW</A> to indicate a search beginning with all preview pins, and continuing to any pins and filters that connect to the preview pins. If that fails, the code then tries to call <A HREF="dssd0126.htm#If_0001060121030400" TARGET="TEXT">FindInterface</A> again, with PIN_CATEGORY_CAPTURE, because some capture filters do not have a preview pin, only a capture pin, and the graph builder may have used a <A HREF="smarttee.htm">Smart Tee</A> filter to provide a preview, which means the IVideoWindow interface will be found connected to the capture pin. See the documentation on the <A HREF="smarttee.htm">Smart Tee</A> filter for more information.
<p>The second parameter, specified by the gcap.pVCap variable below, represents the video capture filter. The third (<I>riid</I>) is the identifier for the desired interface (IID_IVideoWindow), and the last will be filled upon return from this function to give you the <B>IVideoWindow</B> interface. After you have the <B>IVideoWindow</B> interface, you can call <B>IVideoWindow</B> methods such as 
<A HREF="dssd0185.htm#If_000106015c031f00" TARGET="TEXT">put_Owner</A>, <A HREF="dssd0185.htm#If_000106015c032400" TARGET="TEXT">put_WindowStyle</A>, or 
<A HREF="dssd0185.htm#If_000106015c032700" TARGET="TEXT">SetWindowPosition</A> to take ownership of the video preview window, make it a child of your application, or to position it as desired. 

<PRE><FONT FACE="Courier" SIZE="2">
// This will go through a possible decoder, find the video renderer it's
// connected to, and get the IVideoWindow interface on it.
   hr = gcap.pBuilder-&gt;FindInterface(&amp;PIN_CATEGORY_PREVIEW, gcap.pVCap,
            IID_IVideoWindow, (void **)&amp;gcap.pVW);
    if (hr != NOERROR) {
	   hr = gcap.pBuilder->FindInterface(&PIN_CATEGORY_CAPTURE, gcap.pVCap,
            IID_IVideoWindow, (void **)&gcap.pVW);
    }
    if (hr != NOERROR) {

      ErrMsg("This graph cannot preview");
    } else {
      RECT rc;
      gcap.pVW-&gt;put_Owner((long)ghwndApp);    // We own the window now.
      gcap.pVW-&gt;put_WindowStyle(WS_CHILD);    // You are now a child.
      // Give the preview window all our space but where the status bar is.
      GetClientRect(ghwndApp, &amp;rc);
      cyBorder = GetSystemMetrics(SM_CYBORDER);
      cy = statusGetHeight() + cyBorder;
      rc.bottom -= cy;
      gcap.pVW-&gt;SetWindowPosition(0, 0, rc.right, rc.bottom); // Be this big.
      gcap.pVW-&gt;put_Visible(OATRUE);
    }
</FONT></PRE>
<P>Now that you've built the entire capture filter graph, you can preview video, audio, or actually capture data.

<A NAME="capapp_0001040401040000"></A><P><B>Controlling the Capture Filter Graph</B>
<P>Because a capture filter graph constructed by the <A HREF="dssd0126.htm#If_0001060121000000" TARGET="TEXT">ICaptureGraphBuilder</A> interface is simply a specialized filter graph, controlling a capture filter graph is much like controlling any other kind of filter graph: you use the <A HREF="dssd0156.htm#If_000106013f000000" TARGET="TEXT">IMediaControl</A> interface's <A HREF="dssd0156.htm#If_000106013f030700" TARGET="TEXT">Run</A>, <A HREF="dssd0156.htm#If_000106013f030500" TARGET="TEXT">Pause</A>, and <A HREF="dssd0156.htm#If_000106013f030800" TARGET="TEXT">Stop</A> methods. You can use the <A HREF="dssd0204.htm#Lib_000106020e081100" TARGET="TEXT">CBaseFilter::Pause</A> method to cue things up, but remember that capture and recompression only happen when the graph is running. In addition, <B>ICaptureGraphBuilder</B> provides the <A HREF="dssd0126.htm#If_0001060121030200" TARGET="TEXT">ControlStream</A> method to control the start and stop times of the capture filter graph's streams. Internally, <B>ControlStream</B> calls the <A HREF="dssd0111.htm#If_0001060112030200" TARGET="TEXT">IAMStreamControl::StartAt</A> and <A HREF="dssd0111.htm#If_0001060112030300" TARGET="TEXT">IAMStreamControl::StopAt</A> methods to start and stop the capture and preview portions of the filter graph for frame-accurate control.

<P><B>Note:</B>  This method might not work on every capture filter because not every capture filter supports <A HREF="dssd0111.htm#If_0001060112000000" TARGET="TEXT">IAMStreamControl</A> on its pins.
<P>The <A HREF="dssd0126.htm#If_0001060121030200" TARGET="TEXT">ICaptureGraphBuilder::ControlStream</A> method's first parameter (<I>pCategory</I>) is a pointer to a <A HREF="dssd0414.htm#gloss_00010b0108000001" TARGET="TEXT">GUID</A> that specifies the output pin category. This value is normally either <A HREF="dssd0305.htm#propset_0001060704000004" TARGET="TEXT">PIN_CATEGORY_CAPTURE</A> or <A HREF="dssd0305.htm#propset_0001060704000008" TARGET="TEXT">PIN_CATEGORY_PREVIEW</A>. See the <A CLASS=TCTOP HREF="dssd0305.htm#propset_0001060704000000" TARGET="TEXT">Pin Property Set</A> for a complete list of categories. Specify NULL to control all capture filters in the graph.

<P>The second parameter (<I>pFilter</I>) in <A HREF="dssd0126.htm#If_0001060121030200" TARGET="TEXT">ICaptureGraphBuilder::ControlStream</A> indicates which filter to control. Specify NULL to control the whole filter graph as AMCap does.

<P>To run only the preview portion of the capture filter graph, prevent capture by calling <A HREF="dssd0126.htm#If_0001060121030200" TARGET="TEXT">ICaptureGraphBuilder::ControlStream</A> with the capture pin category and the value MAX_TIME as the start time (third parameter, <I>pstart</I>). Call the method again with preview as the pin category, and a NULL start value to start preview immediately. The fourth parameter indicates the desired stop time (<I>pstop</I>, as with start time, NULL means immediately). MAX_TIME is defined in the DirectShow base classes as the maximum reference time, and in this case means to ignore or cancel the specified operation. 

<P>The last two parameters, <I>wStartCookie</I> and <I>wStopCookie</I> are start and stop cookies respectively. These cookies are arbitrary values set by the application so that it can differentiate between start and stop times and tell when specific actions have been completed. AMCap doesn't use a specific time in <A HREF="dssd0126.htm#If_0001060121030200" TARGET="TEXT">ICaptureGraphBuilder::ControlStream</A>, so it doesn't need any cookies. If you use a cookie, use <A HREF="dssd0157.htm#If_0001060140000000" TARGET="TEXT">IMediaEvent</A> to get event notifications. See <A HREF="dssd0111.htm#If_0001060112000000" TARGET="TEXT">IAMStreamControl</A> for more information.

<P>The following code fragment sets preview to start immediately, but ignores capture.
<PRE><FONT FACE="Courier" SIZE="2">
    // Let the preview section run, but not the capture section.
    // (There might not be a capture section.)
    REFERENCE_TIME start = MAX_TIME, stop = MAX_TIME;
    // Show us a preview first? but don't capture quite yet...
    hr = gcap.pBuilder-&gt;ControlStream(&amp;PIN_CATEGORY_PREVIEW, NULL,
                                      gcap.fWantPreview ? NULL : &amp;start,
                                      gcap.fWantPreview ? &amp;stop : NULL, 0, 0);
    if (SUCCEEDED(hr))
        hr = gcap.pBuilder-&gt;ControlStream(&amp;PIN_CATEGORY_CAPTURE, NULL, &amp;start,
                                          NULL, 0, 0);
</FONT></PRE>
<P>The same concept applies if you want only to capture and not preview. Set the capture start time to NULL to capture immediately and set the capture stop time to MAX_TIME. Set the preview start time to MAX_TIME, with an immediate (NULL) stop time.

<P>The following example tells the filter graph to start the preview stream now (the <I>pstart</I> (third) parameter is NULL). Specifying MAX_TIME for the stop time (<I>pstop</I>) means disregard the stop time.
<PRE><FONT FACE="Courier" SIZE="2">
    gcap.pBuilder-&gt;ControlStream(&amp;PIN_CATEGORY_PREVIEW, NULL, NULL, MAX_TIME, 0, 0); 
</FONT></PRE>
<P>Calling <A HREF="dssd0156.htm#If_000106013f030700" TARGET="TEXT">IMediaControl::Run</A> runs the graph.
<PRE><FONT FACE="Courier" SIZE="2">
// Run the graph.
    IMediaControl *pMC = NULL;
    HRESULT hr = gcap.pFg-&gt;QueryInterface(IID_IMediaControl, (void **)&amp;pMC);
    if (SUCCEEDED(hr)) {
      hr = pMC-&gt;Run();
      if (FAILED(hr)) {
          // Stop parts that ran.
          pMC-&gt;Stop();
      }
      pMC-&gt;Release();
    }
    if (FAILED(hr)) {
      ErrMsg("Error %x: Cannot run preview graph", hr);
      return FALSE;
</FONT></PRE>
<P>If the graph is already running, start capture immediately with another call to <A HREF="dssd0126.htm#If_0001060121030200" TARGET="TEXT">ICaptureGraphBuilder::ControlStream</A>. For example, the following call controls the whole filter graph (NULL <I>pFilter</I> (second) parameter), starts now (NULL <I>pstart</I> (third) parameter), and never stops (<I>pstop</I> (fourth) parameter initialized to MAX_TIME).

<PRE><FONT FACE="Courier" SIZE="2">
    REFERENCE_TIME stop = MAX_TIME;

    // NOW!
    gcap.pBuilder-&gt;ControlStream(&amp;PIN_CATEGORY_CAPTURE, NULL, NULL, &amp;stop, 0, 0);
</FONT></PRE>
<P>AMCap uses this approach to start capture in response to the user clicking a button.

<P>To stop the capture or preview operation, call <A HREF="dssd0156.htm#If_000106013f030800" TARGET="TEXT">IMediaControl::Stop</A>, much as you called <A HREF="dssd0156.htm#If_000106013f030700" TARGET="TEXT">IMediaControl::Run</A> to run the filter graph.
<PRE><FONT FACE="Courier" SIZE="2">
// Stop the graph.
    IMediaControl *pMC = NULL;
    HRESULT hr = gcap.pFg-&gt;QueryInterface(IID_IMediaControl, (void **)&amp;pMC);
    if (SUCCEEDED(hr)) {
      hr = pMC-&gt;Stop();
      pMC-&gt;Release();
    }
</FONT></PRE>
<A NAME="capapp_0001040401050000"></A><P><B>Obtaining Capture Statistics</B>
<P>AMCap calls methods on the <A HREF="dssd0104.htm#If_000106010b000000" TARGET="TEXT">IAMDroppedFrames</A> interface to obtain capture statistics. It determines the number of frames dropped (<A HREF="dssd0104.htm#If_000106010b030300" TARGET="TEXT">IAMDroppedFrames::GetNumDropped</A>) and captured (<A HREF="dssd0104.htm#If_000106010b030400" TARGET="TEXT">IAMDroppedFrames::GetNumNotDropped</A>), and uses the Win32 <A HREF="dssd0406.htm#external_00010a01090000e2" TARGET="TEXT">timeGetTime</A> function at the beginning and end of capture to determine the capture operation's duration. The <A HREF="dssd0104.htm#If_000106010b030100" TARGET="TEXT">IAMDroppedFrames::GetAverageFrameSize</A> method provides the average size of captured frames in bytes. Use the information from <B>IAMDroppedFrames::GetNumNotDropped</B>, <B>timeGetTime</B>, and <B>IAMDroppedFrames::GetAverageFrameSize</B> to obtain the total bytes captured and calculate the sustained frames per second for the capture operation.

<A NAME="capapp_0001040401060000"></A><P><B>Saving the Captured File</B>
<P>The original preallocated capture file temporarily holds capture data so you can capture as quickly as possible. When you want to save the data you captured to a more permanent location, call <A HREF="dssd0126.htm#If_0001060121030300" TARGET="TEXT">ICaptureGraphBuilder::CopyCaptureFile</A>. This method transfers the captured data out of the previously allocated capture file to another file you choose. The resulting new file size matches the size of the actual captured data rather than the preallocated file size, which is usually very large.

<P>The <A HREF="dssd0126.htm#If_0001060121030300" TARGET="TEXT">ICaptureGraphBuilder::CopyCaptureFile</A> method's first parameter, <I>lpwstrOld</I>, is the file you're copying from (typically the very large, preallocated file you always use for capture). The second parameter, <I>lpwstrNew</I>, is the file to which you want to save your captured data. Setting the third parameter, <I>fAllowEscAbort</I>, to TRUE indicates that the user is allowed to abort the copy operation by pressing <SMALL>ESC</SMALL>. The last parameter, <I>pCallback</I>, is optional and enables you to supply a progress indicator, if desired, by implementing the <A HREF="dssd0099.htm#If_0001060106000000" TARGET="TEXT">IAMCopyCaptureFileProgress</A> interface. The following example demonstrates a call to <A HREF="dssd0126.htm#If_0001060121030300" TARGET="TEXT">CopyCaptureFile</A>.

<PRE><FONT FACE="Courier" SIZE="2">
    hr = pBuilder-&gt;CopyCaptureFile(wachSrcFile, wachDstFile,TRUE,NULL);
</FONT></PRE>
<P>The SaveCaptureFile function defined by AMCap prompts the to enter a new file name in the Open File common dialog box, uses the Win32 <A HREF="dssd0406.htm#external_00010a01090000c2" TARGET="TEXT">MultiByteToWideChar</A> function to convert the file name to a wide string, and saves the captured data to the specified file using <A HREF="dssd0126.htm#If_0001060121030300" TARGET="TEXT">ICaptureGraphBuilder::CopyCaptureFile</A>.

<PRE><FONT FACE="Courier" SIZE="2">
/*
 * Put up a dialog to allow the user to save the contents of the capture file
 * elsewhere.
 */
BOOL SaveCaptureFile(HWND hWnd)
{
    HRESULT hr;
    char achDstFile[_MAX_PATH];
    WCHAR wachDstFile[_MAX_PATH];
    WCHAR wachSrcFile[_MAX_PATH];

    if (gcap.pBuilder == NULL)
      return FALSE;

    if (OpenFileDialog(hWnd, achDstFile, _MAX_PATH)) {

      // We have a capture file name.
      MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, gcap.szCaptureFile, -1,
                          wachSrcFile, _MAX_PATH);
      MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, achDstFile, -1,
                          wachDstFile, _MAX_PATH);
      statusUpdateStatus(ghwndStatus, "Saving capture file - please wait...");

      // We need our own graph builder because the main one might not exist.
      ICaptureGraphBuilder *pBuilder;
      hr = CoCreateInstance((REFCLSID)CLSID_CaptureGraphBuilder,
                            NULL, CLSCTX_INPROC, (REFIID)IID_ICaptureGraphBuilder,
                            (void **)&amp;pBuilder);
      if (hr == NOERROR) {
          // Allow the user to press ESC to abort... don't ask for progress.
          hr = pBuilder-&gt;CopyCaptureFile(wachSrcFile, wachDstFile,TRUE,NULL);
          pBuilder-&gt;Release();
      }
      if (hr == S_OK)
          statusUpdateStatus(ghwndStatus, "Capture file saved");
      else if (hr == S_FALSE)
          statusUpdateStatus(ghwndStatus, "Capture file save aborted");
      else
          statusUpdateStatus(ghwndStatus, "Capture file save ERROR");
      return (hr == NOERROR ? TRUE : FALSE); 

    } else {
return TRUE;    // They canceled or something.
    }
}
</FONT></PRE>
<P>See Amcap.cpp and Status.cpp from the AMCap sample for more details about capturing media files and obtaining capture statistics.
<A NAME="capapp_0001040401070000"></A><P><B>Displaying Property Pages</B>
<P>DirectShow provides a number of interfaces to customize the settings of a capture filter graph including: <B>IAMStreamConfig</B>, <B>IAMVideoCompression</B>, <B>IAMCrossbar</B>, <B>IAMTVTuner</B>, <B>IAMTVAudio</B>, <B>IAMAnalogVideoDecoder</B>, <B>IAMCameraControl</B>, <B>IAMVideoProcAmp</B>. Creating a property page is one way of allowing users to interact with these settings.

<P>To bring up the settings associated with an object on a property page, use an interface on the object to query for the ISpecifyPropertyPages interface. Use this interface to obtain a list of property page CLSIDs that this object supports. The CLSID list can be later passed to OleCreatePropertyFrame or OleCreatePropertyFrameIndirect to invoke a property sheet. This will supply your application with the custom property pages a filter has in addition to the standard pages.


<P>There are at least 9 objects that can have property pages in capture applications. Capture applications usually have 2 of these objects at least; the video capture filter and the audio capture filter (call them pVCap and pACap). These objects expose the <B>IBaseFilter</B> interface which can be used to query for the <B>ISpecifyPropertyPages</B> interface. You can obtain a pointer to the other 7 objects as follows:
<OL><LI>The video capture filter's capture pin. Get this by calling :
<PRE><FONT FACE="Courier" SIZE="2">FindInterface(&amp;PIN_CATEGORY_CAPTURE, pVCap, IID_IPin, &amp;pX);</FONT></PRE>
<LI>The video capture filter's preview pin. Get this by calling:
<PRE><FONT FACE="Courier" SIZE="2">FindInterface(&amp;PIN_CATEGORY_PREVIEW, pVCap, IID_IPin, &amp;pX);</FONT></PRE>
<LI>The audio capture filter's capture pin. Get this by calling:
<PRE><FONT FACE="Courier" SIZE="2">FindInterface(&amp;PIN_CATEGORY_CAPTURE, pACap, IID_IPin, &amp;pX);</FONT></PRE>
<LI>The crossbar connected to the video capture filter. Get this by calling:
<PRE><FONT FACE="Courier" SIZE="2">FindInterface(NULL, pVCap, IID_IAMCrossbar, &amp;pX);</FONT></PRE>
<LI>A possible second crossbar, that controls both audio and video.  This crossbar, if it exists, will be upstream of the crossbar found in #4.  Get this by calling:
<PRE><FONT FACE="Courier" SIZE="2">pX->QueryInterface(IID_IBaseFilter, (void **)&pBaseFilter);
FindInterface(&LOOK_UPSTREAM_ONLY, pBaseFilter, IID_IAMCrossbar, &pX2);
pBaseFilter->Release();
</FONT></PRE>
<p>where <I>pX</I> is the interface obtained by #4.
<LI>The TV Tuner connected to the video capture filter. Get this by calling:
<PRE><FONT FACE="Courier" SIZE="2">FindInterface(NULL, pVCap, IID_IAMTVTuner, &amp;pX);</FONT></PRE>
<LI>The TV Audio connected to the audio capture filter. Get this by calling:
<PRE><FONT FACE="Courier" SIZE="2">FindInterface(NULL, pACap, IID_IAMTVAudio, &amp;pX);</FONT></PRE>
</OL>
<P>If you do not wish to create your property page using the <B>ISpecifyPropertyPages</B> interface and the OleCreatePropertyFrame function, you can create your own custom property pages and use the results of your page to call the interfaces programmatically.
<BR CLEAR=ALL><P>

<h3><A NAME="Additional_Notes"></A>Additional Notes</h3>
<p>The following section provides some additional notes on using the <A HREF="dssd0126.htm#If_0001060121030600" TARGET="TEXT">ICaptureGraphBuilder::RenderStream</A> method. It details specific examples of how to customize a capture graph from your application.

<ol>
<li>The following example will render the preview pin of a video capture filter, connecting it to a default set of filters (usually a video renderer, possibly through a decompression filter), creating a graph that can be used to watch live video in a window (pCaptureFilter is the IBaseFilter interface of a video capture filter). Note that if the capture filter does not have a preview pin, this will still succeed and provide you with a preview by using a <A HREF="smarttee.htm" TARGET="TEXT">Smart Tee</A> filter. See the <A HREF="smarttee.htm" TARGET="TEXT">Smart Tee</A> documentation for more information. 


<pre><FONT FACE="Courier" SIZE="2">RenderStream(&PIN_CATEGORY_PREVIEW, pCaptureFilter, NULL, NULL);</FONT></pre>

<li>The following example will render the capture pin of a video capture filter to an AVI Mux filter, creating a graph that will create an AVI file out of live video data (<I>pCaptureFilter</I> is the <B>IBaseFilter</B> interface of a video capture filter and pAVIMuxFilter is the <B>IBaseFilter</B> interface of an AVI Mux filter created using the <A HREF="dssd0126.htm#If_0001060121030800" TARGET="TEXT">ICaptureGraphBuilder::SetOutputFileName</A> method). 


<pre><FONT FACE="Courier" SIZE="2">RenderStream(&PIN_CATEGORY_CAPTURE, pCaptureFilter, NULL, pAVIMuxFilter);</font></pre>

<li>The following example will create a graph that will recompress the video of an AVI file into Cinepak format, and leave the audio as is, and create a new AVI file (<I>pSourceFilter</I> is the <B>IBaseFilter</B> interface of a File Source Filter that is reading from an AVI file, pCinepakCompressor is the IBaseFilter interface of a Cinepak Video Compressor filter, and <I>pAVIMuxFilter</I> is the <B>IBaseFilter</B> interface of an AVI Mux filter created using the <A HREF="dssd0126.htm#If_0001060121030800" TARGET="TEXT">ICaptureGraphBuilder::SetOutputFileName</A> method).

<pre><FONT FACE="Courier" SIZE="2">RenderStream(NULL, pSourceFilter, pCinepakCompressor, pAVIMuxFilter);</font></pre>

<li>Finally, in the last example, the source filter can provide (through an AVI splitter) two outputs; a video stream and an output stream. 
<pre><FONT FACE="Courier" SIZE="2">RenderStream(NULL, pSourceFilter, NULL, pAVIMuxFilter);</font></pre>

<p><B>Note</B>  With the <B>RenderStream</B> method it is impossible to specify which stream you want, since the category is NULL in both cases. Because of this, it is important to connect the stream that is going through a compressor first, because only the video stream will successfully connect through the cinepak compressor, ensuring the right stream is chosen. After that, the only stream left unconnected is the audio stream, so the second call to <B>RenderStream</B> will correctly connect the audio stream to the AVI Mux. If you are dealing with AVI files or other files with more than 2 streams, this method will be unreliable for connecting up the stream you want, and you will want to build your graph step by step.
</ol>


<P><P><FONT FACE="MS SANS SERIF" SIZE="1" COLOR="BLACK">
<A CLASS=cpslug HREF="copyrite.htm" TARGET="TEXT">&#169; 1998 Microsoft Corporation. All rights reserved. Terms of Use.</A>
</FONT>
<BR CLEAR=ALL><P>
</FONT><P>
</BODY></HTML>
