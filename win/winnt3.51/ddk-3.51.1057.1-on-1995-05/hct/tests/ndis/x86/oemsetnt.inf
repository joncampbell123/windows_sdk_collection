***********************************************************************
;
; OEMSETNT.INF
;
;       NdisWan compliant miniport drivers' Test Protocol setup INF file
;
; Modification History:
;
;    01-26-95 Sanjay Anand  Created
;
; NOTE:  Please don't randomly change the order of the program or the
;        function calls (Shell commands).  A lot depends on the order
;        in which the functions are called.
;
;       Adapted primarily from oemnsvra.inf - the RAS setup INF file
;
;    03-08-95 Sanjay Anand
;        Changed the hardware netcard name generation to generate one
;        netcard per endpoint
;
;    04-27-95 Sanjay Anand
;        Removed references to tag files in the source media descriptions
;        since we cannot sync the names of files on the NT and DDK disks
;        that ship.
;-----------------------------------------------------------------------

[Identification]

    OptionType = NetService

[Options]
    TPD

[SystemVars]
    ; these need to be defined by us when the setup.exe is used to invoke
    ; the .inf file

    !STF_WINDOWSPATH    = "" ? $(!LIBHANDLE) GetWindowsNtDir
    !STF_WINDOWSSYSPATH = "" ? $(!LIBHANDLE) GetWindowsNtSysDir
    !STF_COMPUTERNAME   = "" ? $(!LIBHANDLE) GetMyComputerName
    !STF_USERNAME       = "" ? $(!LIBHANDLE) GetMyUserName
    !STF_FLOPPYLIST     = {} ? $(!LIBHANDLE) GetFloppyDriveLetters
    !STF_UNUSEDDRIVES   = {} ? $(!LIBHANDLE) GetUnusedDrives
    !STF_LANGUAGE       = "ENG"

    !NTN_SoftwareBase   = "Software"
    !NTN_ServiceBase    = "System\CurrentControlSet\Services"
    !NTN_ScUseRegistry  = "NO"

[GeneralConstants]

    !DebugOutputControl = 1


; Product Info

    Manufacturer    = "Microsoft"
    ProductMajorVersion    = "3"
    ProductMinorVersion    = "51"
    ProductVersion  = $(ProductMajorVersion)"."$(ProductMinorVersion)

; NDISWAN Software data

    !ProductNDISWANName	    = "NdisWan"

    !ProductNDISWANImagePath = "\SystemRoot\system32\drivers\ndiswan.sys"
    ProductNDISWANSvcType   = "kernel"
    ProductNDISWANType	    = "transport"

    !NetRuleNDISWANType	    = "ndisWanDrv ndisWanTransport"
    !NetRuleNDISWANClass     = {"ndisWanTransport basic"}
    NetRuleNDISWANUse	    = $(ProductNDISWANType)" yes yes"
    !NetRuleNDISWANBindForm  = """NdisWan"" yes no container"
    !ProductNDISWANDIALINOUTTPDName   = "NdisWanDialinoutTpd"
    !ProductNDISWANKeyName    = $(!NTN_SoftwareBase)"\"$(Manufacturer)"\"$(!ProductNDISWANName)"\CurrentVersion"
    ; the following variable is global because it is used in the
    ; UpdateNdisWanInfo routine during ras upgrade.
    !NetRuleNDISWANBindable  = +
	      {"ndisWanTransport ndisWanAdapterDialInOutTPD non non 100",+
               "ndistestTransport ndisWanAdapterDialInOutTPD non non 100"}
    !NetRuleHardwareNDISWANBindForm = " yes yes container"


 ; NDISTEST DRVR specific
 ;

    !ProductNDISTESTName	    = "Ndistest"

    !ProductNDISTESTImagePath = "\SystemRoot\system32\drivers\ndistest.sys"
    ProductNDISTESTSvcType   = "kernel"
    ProductNDISTESTType	    = "transport"

    !NetRuleNDISTESTType	    = "ndistest ndistestTransport"
    !NetRuleNDISTESTClass     = {"ndistestTransport basic"}
    NetRuleNDISTESTUse	    = $(ProductNDISTESTType)" yes yes"
    !NetRuleNDISTESTBindForm  = """Ndistest"" yes yes simple"
    !ProductNDISTESTDIALINOUTTPDName   = "NdisWanDialinoutTpd"

    ; the following variable is global because it is used in the
    ; UpdateNdisWanInfo routine during ras upgrade.
    !NetRuleNDISTESTBindable  = {}
          ;{"rasCapableTransport ndisWanAdapterDialInOutTP non non 100"} ;,+

    ; the software\ms\winnt\networkcards\netrules... keys vals
    ;
    !NetRuleHardwareDIALINOUTTPDType = "ndiswandialinoutTPD ndisWanAdapterDialInOutTPD"
    !NetRuleHardwareDIALINOUTTPDClass = {"ndisWanAdapterDialInOutTPD basic"}
    !NetRuleHardwareDIALINOUTTPDBlock = {"nbfTransport ndisWanAdapterDialInOutTPD",+
                                        "tcpipTransport ndisWanAdapterDialInOutTPD",+
                                        "netbtTransport ndisWanAdapterDialInOutTPD"}
    ; NdisTapi keys
    ;

    !ProductNDISTAPIName        = "NdisTapi"
    !ProductNDISTAPIImagePath   = "\SystemRoot\system32\drivers\ndistapi.sys"
    !NdisTapiKeyName         = $(!NTN_ServiceBase)"\"$(!ProductNDISTAPIName)

 ; INf file name ZZ
    ProductInfName     = $(STF_CONTEXTINFNAME) ;"OEMSETNT.INF"

 ; Registry Key

    ProductKeyBase  = $(!NTN_SoftwareBase)"\"$(Manufacturer)

    ProductKeyName          = $(!NTN_SoftwareBase)"\"$(Manufacturer)"\"$(ProductRASName)"\CurrentVersion"
    !NetworkCardKeyName      = $(!NTN_SoftwareBase)"\Microsoft\Windows NT\CurrentVersion\NetworkCards"
    RasTapiDevicesKeyName   = "HARDWARE\DEVICEMAP\Tapi Devices"
    NdisWanParamKeyName      = $(!NTN_ServiceBase)"\"$(!ProductNDISWANName)"\Parameters"

    !UtilityInf     = "UTILITY.INF"
    subroutninf    = "SUBROUTN.INF"
    CopySysFileInf = "TPDCPFL.INF"

    Exit_Code      = 0
    ShellCode      = 0
    from      = ""
    to        = ""
    ExitCodeOk     = 0
    ExitCodeCancel = 1
    ExitCodeFatal  = 2
    KeyNull         = ""
    !MAXIMUM_ALLOWED   = 33554432
    !SERVICE_NO_CHANGE = 4294967295
    RegistryErrorIndex = NO_ERROR
    ServerSize  = 820116
    ClientSize  = 634260
    AdminSize   = 513962
    HideComponent = 1

;---------------------------------------------------------------------------
; 1. Identify
;
; DESCRIPTION:   To verify that this INF deals with the same type of options
;                as we are choosing currently.
;
; INPUT:         None
;
; OUTPUT:        $($R0): STATUS: STATUS_SUCCESSFUL
;                $($R1): Option Type (COMPUTER ...)
;                $($R2): Diskette description
;---------------------------------------------------------------------------

[Identify]
    ;
    ;
    read-syms Identification

    set Status     = STATUS_SUCCESSFUL
    set Identifier = $(OptionType)
    set Media      = #("Source Media Descriptions", 1, 1)
    ; Debug-Output "OptionType "$(OptionType)

    Return $(Status) $(Identifier) $(Media)

;------------------------------------------------------------------------
; 2. ReturnOptions:
;
; DESCRIPTION:   To return the option list supported by this INF and the
;                localised text list representing the options.
;
;
; INPUT:         $($0):  Language used. ( ENG | FRN | ... )
;
; OUTPUT:        $($R0): STATUS: STATUS_SUCCESSFUL |
;                                STATUS_NOLANGUAGE
;                                STATUS_FAILED
;
;                $($R1): Option List
;                $($R2): Option Text List
;------------------------------------------------------------------------

[ReturnOptions]
    ;
    ;
    set Status        = STATUS_FAILED
    set OptionList     = {}
    set OptionTextList = {}

    ;
    ; Check if the language requested is supported
    ;
    set LanguageList = ^(LanguagesSupported, 1)
    Ifcontains(i) $($0) in $(LanguageList)
        goto returnoptions
    Else
        set Status = STATUS_NOLANGUAGE
        goto finish_ReturnOptions
    Endif

    ;
    ; form a list of all the options and another of the text representing
    ;

returnoptions = +
    set OptionList     = ^(Options, 1)
    set OptionTextList = ^(OptionsText$($0), 1)
    set Status         = STATUS_SUCCESSFUL

finish_ReturnOptions = +
    Return $(Status) $(OptionList) $(OptionTextList)


;***********************************************************************
;                    SETUP INVOCATION SECTION
;***********************************************************************
;------------------------------------------------------------------------
;
; Shell Commands:
;
;      This section is shelled to by main setup program
;
;------------------------------------------------------------------------

[Shell Commands]

    Debug-Output "STF_SRCDIR "$(!STF_SRCDIR)

    set Exit_Code = $(!STF_ERROR_GENERAL)
    LoadLibrary "x" $(!STF_SRCDIR)\setupdll.dll !LIBHANDLE

    Set !NCPA_HANDLE = ""
    LoadLibrary "y" $(!STF_CWDDIR)ncpa.cpl !NCPA_HANDLE

    ; Specify a null parent handle to center the dialog on the screen.
    set !STF_HWND = 0

    read-syms SystemVars
    detect    SystemVars

    Shell "" InstallOption $(!STF_LANGUAGE) "RAS" $(!STF_SRCDIR) "NO" "NO" "NO"
    FreeLibrary $(!LIBHANDLE)
    ifint $($ShellCode) != $( !SHELL_CODE_OK)
       exit
    endif
    set Exit_Code = $($R0)
    exit

;***********************************************************************
;                    SETUP (NTLANMAN) INVOCATION SECTION
;***********************************************************************
;------------------------------------------------------------------------
;
; InstallOption:
;
;      This section is shelled to by main installation processing.
;
;
; FUNCTION:  To copy files representing Option3s
;            To configure the installed option
;            To update the registry for the installed option
;
; INPUT:     $($0):  Language to use
;            $($1):  OptionID to install
;            $($2):  SourceDirectory
;            $($3):  AddCopy  (YES | NO)
;            $($4):  DoCopy   (YES | NO)
;            $($5):  DoConfig (YES | NO)
;
; OUTPUT:    $($R0): STATUS: STATUS_SUCCESSFUL |
;                            STATUS_NOLANGUAGE |
;                            STATUS_USERCANCEL |
;                            STATUS_FAILED
;
;------------------------------------------------------------------------

[InstallOption]

    ; extract parameters

    set Option      = $($1)
    set SourceDir   = $($2)
    set DoCopy      = $($4)

    Debug-Output "SrcDir "$(SourceDir)

    ;
    ; Check if the language requested is supported
    ;
    set LanguageList = ^(LanguagesSupported, 1)
    Ifcontains(i) $($0) NOT-IN $(LanguageList)
        Return STATUS_NOLANGUAGE
    endif

    set CommonStatus = STATUS_SUCCESSFUL

    set-subst LF = "\n"
    read-syms GeneralConstants

    read-syms DialogConstants$(!STF_LANGUAGE)
    read-syms FileConstants$(!STF_LANGUAGE)

    StartWait

    Debug-Output "Install mode is"$(!NTN_InstallMode)

    IfStr(i) $(!NTN_InstallMode)    ==    deinstall
        goto RemoveRas
    else-Ifstr(i) $(!NTN_InstallMode) == Update
        goto NotSupported
    else-Ifstr(i) $(!NTN_InstallMode) == configure
        goto NotSupported
    else-Ifstr(i) $(!NTN_InstallMode) == bind
        goto NotSupported
    else
        goto Install
    endif

Install =+
    ; Message to user to install the miniport first
    read-syms WarningMsg$(!STF_LANGUAGE)

    Shell $(subroutninf) SetupMessage, $(!STF_LANGUAGE), "WARNING", $(Text)
    ifint $($ShellCode) != $(!SHELL_CODE_OK)
    goto ShellCodeError
    endif
    ifstr(i) $($R1) == "OK"
       goto continue
    else-ifstr(i) $($R1) == "CANCEL"
       goto end
    else
       Debug-Msg "Error Error Bad DLGEVENT"
       goto end
    endif

    EndWait

continue =+

    ; Copy the files over
    ; need to determine the source directory to copy the rest of the files.

    Shell $(!UtilityInf), DoAskSource, $(!STF_CWDDIR), $(SourceDir) YES

    ;Debug-Output "Reached"

    Ifint $($ShellCode) != $(!SHELL_CODE_OK)
        goto ShellCodeError
    Else-Ifstr(i) $($R0) == STATUS_FAILED
        Shell $(!UtilityInf) RegistryErrorString "ASK_SOURCE_FAIL"
        ifint $($ShellCode) != $(!SHELL_CODE_OK)
            goto ShellCodeError
        endif
        set Error = $($R0)
        goto fatal
    Else-Ifstr(i) $($R0) == STATUS_USERCANCEL
         Goto end
    Endif

    Set !STF_SRCDIR = $($R1)
    Set SourceDir  = $($R1)

    ; Copy over the files
    install InstallFiles

    ifstr(i) $(STF_INSTALL_OUTCOME) != STF_SUCCESS
        goto filecopycancel
    endif

    StartWait
    read-syms FileCopyMesg$(!STF_LANGUAGE)

    ;set flist = {}
    ;Split-String #(Files-RemoveList, NDISWANSYS, 1) "\" list
    ;Debug-Output "list is "$(list)
    ;set flist = >($(flist), *(list1, 2)) ; how to specify last element ??
    ;Split-String #(Files-RemoveList, NDISTAPISYS, 1) "\" list
    ;set flist = >($(flist), *(list1, 2))

    set Text = $(Text1)+
              "1. "#(Files-RemoveList, NDISWANSYS, 1)$(LF)$(LF)+
              "2. "#(Files-RemoveList, NDISTAPISYS, 1)

    Debug-Output "Text is "$(Text)

    Shell $(subroutninf) PushBillBoard NETSTATUSDLG $(Text)

    Ifint $($ShellCode) != $(!SHELL_CODE_OK)
        Goto end
    Endif

    Shell $(CopySysFileInf), CopyFiles, $(SourceDir)

    EndWait

    read-syms StatusUpdatingRegistry$(!STF_LANGUAGE)
    shell $(subroutninf) PushBillBoard NETSTATUSDLG $(CreatingRas)

    ; add hardware and software components
    ; generate the bindings:
    ;    Ndistest -> NdisWanxx
    ;    NdisWan -> <Tapi>xx
    ;    Endpoints generation in NdisWan

    ; ADD NdisWan product and netrules keys
    ; {
    set ThisOption = NDISWAN
    set RasSpecificString = $(Product$(ThisOption)Name)

    Shell $(!UtilityInf), AddSoftwareComponent, $(Manufacturer), +
          $(!Product$(ThisOption)Name), $(!Product$(ThisOption)Name), +
          $(!Product$(ThisOption)DisplayName), +
          $(ProductInfName), $(!Product$(ThisOption)ImagePath),+
          "kernelautostart", "NDISWAN", {}, "" ;+
          ;$(RasMsgDll), $(EventTypeSupported)

    Debug-Output "Shellcode after addsoftwarecomponent ndiswan "$($ShellCode)

    ifint $($ShellCode) != $(!SHELL_CODE_OK)
        Debug-Output "AddSoftware bombed out"
        goto ShellCodeError
    endif

    set RegistryErrorIndex = $($R0)

    Ifstr(i) $(RegistryErrorIndex) != "NO_ERROR"
        EndWait
        CloseRegKey $($R1)
        CloseRegKey $($R2)
        CloseRegKey $($R3)
        CloseRegKey $($R4)
        CloseRegKey $($R5)
        goto fatalregistry
    endif
    ;
    ;   At this point:
    ;     $R1 contains the product version key handle;
    ;     $R2 contains the NetRules subkey handle;
    ;     $R3 contains the new Services key handle; and
    ;     $R4 contains the Parameters key
    ;     $R5 contains the Linkage key
    ;

    Set SoftProductKey    = $($R1)
    Set SoftNetRuleKey    = $($R2)
    CloseRegKey $($R3)
    CloseRegKey $($R4)
    CloseRegKey $($R5)

    ; Debug-Output $($R1)$($R2)$($R3)$($R4)$($R5)

    ; set product key information in the registry

    set NewValueList = +
        {{Infname ,$(NoTitle),$(!REG_VT_SZ),$(ProductInfName)},+
         {ServiceName,$(NoTitle),$(!REG_VT_SZ),+
          $(!Product$(ThisOption)Name)},+
         {SoftwareType,$(NoTitle),$(!REG_VT_SZ),+
          $(Product$(ThisOption)Type)},+
         {Title,$(NoTitle),$(!REG_VT_SZ),$(!Product$(ThisOption)Title)},+
         {Description,$(NoTitle),$(!REG_VT_SZ),+
          $(!Product$(ThisOption)Description)},+
         {PathName,$(NoTitle),$(!REG_VT_SZ),+
          $(!Product$(ThisOption)ImagePath)},+
         {MajorVersion,$(NoTitle),$(!REG_VT_DWORD),$(ProductMajorVersion)},+
         {MinorVersion,$(NoTitle),$(!REG_VT_DWORD),$(ProductMinorVersion)},+
         {BindControl,$(NoTitle),$(!REG_VT_DWORD),$(HideBindings)},+
         {InstallDate,$(NoTitle),$(!REG_VT_DWORD),*($(!CurrentDate),1)},+
         {Hidden,$(NoTitle),$(!REG_VT_DWORD),$(HideComponent)}}

    Shell  $(!UtilityInf), AddValueList, $(SoftProductKey), $(NewValueList)
    ifint $($ShellCode) != $(!SHELL_CODE_OK)
        Debug-Output "AddValueList bombed out"
        goto ShellCodeError
    endif

    set RegistryErrorIndex = $($R0)
    CloseRegKey $(SoftProductKey)

    Ifstr(i) $(RegistryErrorIndex) != "NO_ERROR"
        EndWait
        CloseRegKey $(SoftNetRuleKey)
        goto fatalregistry
    endif

    ; set netrules information in the registry

    set NewValueList = +
    {{class, $(NoTitle), $(!REG_VT_MULTI_SZ), $(!NetRule$(ThisOption)Class)},+
         {type,$(NoTitle),$(!REG_VT_SZ),$(!NetRule$(ThisOption)Type)},+
         {use,$(NoTitle),$(!REG_VT_SZ),$(NetRule$(ThisOption)Use)}, +
         {bindform,$(NoTitle),$(!REG_VT_SZ),+
          $(!NetRule$(ThisOption)BindForm)}, +
         {bindable,$(NoTitle),$(!REG_VT_MULTI_SZ),+
          $(!NetRule$(ThisOption)Bindable)}, +
         {InfOption,$(NoTitle),$(!REG_VT_SZ),$(ThisOption)}, +
         {Infname ,$(NoTitle),$(!REG_VT_SZ),$(ProductInfName)}}

    Shell  $(!UtilityInf), AddValueList, $(SoftNetRuleKey), $(NewValueList)
    ifint $($ShellCode) != $(!SHELL_CODE_OK)
        Debug-Output "AddValueList bombed out"
        goto ShellCodeError
    endif

    set RegistryErrorIndex = $($R0)

    CloseRegKey $(SoftNetRuleKey)

    Ifstr(i) $(RegistryErrorIndex) != "NO_ERROR"
        EndWait
        goto fatalregistry
    endif

    ; Add NDISWAN to the ServiceGroupOrder so that all NDIS components
    ; load before NdisWan driver.

    Shell "" AddNDISWANToServiceGroupOrder
    ifint $($ShellCode) != $(!SHELL_CODE_OK)
       Debug-Output "Cannot add NDISWAN to ServiceGroupOrder"
       goto ShellCodeError
    endif

DoNdisWanEnd = +
    ; }
    Debug-Output "NdisWan added as a service and software keys made"

    ; add NDISTEST product and netrules keys
    ; {
    set ThisOption = NDISTEST
    set RasSpecificString = $(Product$(ThisOption)Name)

    Shell $(!UtilityInf), AddSoftwareComponent, $(Manufacturer), +
          $(!Product$(ThisOption)Name), $(!Product$(ThisOption)Name), +
          $(!Product$(ThisOption)DisplayName), +
          $(ProductInfName), $(!Product$(ThisOption)ImagePath),+
          "kernelautostart", "NDISTEST", {}, ""
          ;$(RasMsgDll), $(EventTypeSupported)

    ifint $($ShellCode) != $(!SHELL_CODE_OK)
        Debug-Output "AddSoftware bombed out"
        goto ShellCodeError
    endif

    set RegistryErrorIndex = $($R0)

    Ifstr(i) $(RegistryErrorIndex) != "NO_ERROR"
        EndWait
        CloseRegKey $($R1)
        CloseRegKey $($R2)
        CloseRegKey $($R3)
        CloseRegKey $($R4)
        CloseRegKey $($R5)
        goto fatalregistry
    endif
    ;
    ;   At this point:
    ;     $R1 contains the product version key handle;
    ;     $R2 contains the NetRules subkey handle;
    ;     $R3 contains the new Services key handle; and
    ;     $R4 contains the Parameters key
    ;     $R5 contains the Linkage key
    ;

    Set SoftProductKey    = $($R1)
    Set SoftNetRuleKey    = $($R2)
    CloseRegKey $($R3)
    CloseRegKey $($R4)
    CloseRegKey $($R5)

    ; set product key information in the registry

    ; so the name is displayed in the bindings
    set HideComponent = 0

    set NewValueList = +
        {{Infname ,$(NoTitle),$(!REG_VT_SZ),$(ProductInfName)},+
         {ServiceName,$(NoTitle),$(!REG_VT_SZ),+
          $(!Product$(ThisOption)Name)},+
         {SoftwareType,$(NoTitle),$(!REG_VT_SZ),+
          $(Product$(ThisOption)Type)},+
         {Title,$(NoTitle),$(!REG_VT_SZ),$(!Product$(ThisOption)Title)},+
         {Description,$(NoTitle),$(!REG_VT_SZ),+
          $(!Product$(ThisOption)Description)},+
         {PathName,$(NoTitle),$(!REG_VT_SZ),+
          $(!Product$(ThisOption)ImagePath)},+
         {MajorVersion,$(NoTitle),$(!REG_VT_DWORD),$(ProductMajorVersion)},+
         {MinorVersion,$(NoTitle),$(!REG_VT_DWORD),$(ProductMinorVersion)},+
         {BindControl,$(NoTitle),$(!REG_VT_DWORD),$(HideBindings)},+
         {InstallDate,$(NoTitle),$(!REG_VT_DWORD),*($(!CurrentDate),1)},+
         {Hidden,$(NoTitle),$(!REG_VT_DWORD),$(HideComponent)}}

    Shell  $(!UtilityInf), AddValueList, $(SoftProductKey), $(NewValueList)
    ifint $($ShellCode) != $(!SHELL_CODE_OK)
        Debug-Output "AddValueList bombed out"
        goto ShellCodeError
    endif

    set RegistryErrorIndex = $($R0)
    CloseRegKey $(SoftProductKey)

    Ifstr(i) $(RegistryErrorIndex) != "NO_ERROR"
        EndWait
        CloseRegKey $(SoftNetRuleKey)
        goto fatalregistry
    endif

    ; set netrules information in the registry

    set NewValueList = +
    {{class, $(NoTitle), $(!REG_VT_MULTI_SZ), $(!NetRule$(ThisOption)Class)},+
         {type,$(NoTitle),$(!REG_VT_SZ),$(!NetRule$(ThisOption)Type)},+
         {use,$(NoTitle),$(!REG_VT_SZ),$(NetRule$(ThisOption)Use)}, +
         {bindform,$(NoTitle),$(!REG_VT_SZ),+
          $(!NetRule$(ThisOption)BindForm)}, +
         {bindable,$(NoTitle),$(!REG_VT_MULTI_SZ),+
          $(!NetRule$(ThisOption)Bindable)}, +
         {InfOption,$(NoTitle),$(!REG_VT_SZ),$(ThisOption)}, +
         {Infname ,$(NoTitle),$(!REG_VT_SZ),$(ProductInfName)}}

    Shell  $(!UtilityInf), AddValueList, $(SoftNetRuleKey), $(NewValueList)
    ifint $($ShellCode) != $(!SHELL_CODE_OK)
        Debug-Output "AddValueList bombed out"
        goto ShellCodeError
    endif

    set RegistryErrorIndex = $($R0)

    CloseRegKey $(SoftNetRuleKey)

    Ifstr(i) $(RegistryErrorIndex) != "NO_ERROR"
        EndWait
        goto fatalregistry
    endif

    ; Add NDISWAN to the ServiceGroupOrder so that all NDIS components
    ; load before NdisWan driver.

    ;Shell "" AddNDISWANToServiceGroupOrder
    ;ifint $($ShellCode) != $(!SHELL_CODE_OK)
    ;   Debug-Output "Cannot add NDISWAN to ServiceGroupOrder"
    ;   goto ShellCodeError
    ;endif

;DoNdistestEnd = +
    ; }
    Debug-Output "Ndistest software keys made"

    ; Install NdisTapi as a service and hook it to NdisWan
    ; {
    Shell "" InstallNdisTapiService
    ifint $($ShellCode) != $(!SHELL_CODE_OK)
         Debug-Output "Error shelling InstallNdisTapiService "
         goto ShellCodeError
    endif
    ifstr(i) $($R0) != STATUS_SUCCESSFUL
         set RegistryErrorIndex = $($R0)
         Debug-Output "Error installing NdisTapi Service"
         goto fatalregistry
    endif
    ; }

    ; GENERATE THE NdisWan\Params keys - bind NdisWan to the Tapi device
    ; {
    ; Read the Linkage value of the TAPI drivers to get the EndPoints info
    ; we need to make sure that if a TAPI driver has been removed, it is
    ; not added to the NDISWAN service dependency

    ; Read the product name from the devicemap
    ; Find the corresponding adapter from the Software\MS\WIN-NT\...\Network Cards key
    ; Put the adapter name in the Services..\NdisWan\Parameters\Bind key

    set ProviderList = {}
    set RasTapiDevicesKey = $(KeyNull)
    OpenRegKey $(!REG_H_LOCAL) "" $(RasTapiDevicesKeyName) $(!MAXIMUM_ALLOWED) RasTapiDevicesKey

    debug-output "Registry key "$(RasTapiDevicesKeyName)

    ifstr $(RasTapiDevicesKey) != $(KeyNull)
       set TapiProviderList = {}
       EnumRegKey $(RasTapiDevicesKey) TapiProviderList
       ForListDo $(TapiProviderList)
           set TapiAddress = {}
           set NumEndPoints = 0
           set ProviderName = *($($),1)

           Debug-Output "OEMNSVRA.INF: TAPI provider name = "$(ProviderName)
           OpenRegKey $(RasTapiDevicesKey) "" $(ProviderName) $(!MAXIMUM_ALLOWED) Provider
           ifstr $(Provider) != $(KeyNull)
               GetRegValue $(Provider), "Address" TapiAddress
               set AdapterNum = ""
               set EndPointCount = 0
               set tmpNdisWanParam = {}
               set tmpNdisWanEndPointsLst = {}
               set DeviceName = ""
               ForListDo *($(TapiAddress),4)
                   Split-String $($) "-" Address
                   set NewAdapterNum = *($(Address), 1)
                   ; if we come across a new adapter number
                   ifstr(i) $(AdapterNum) != $(NewAdapterNum)
                     ; and if we have accumulated some information
                     ifstr(i) $(AdapterNum) != ""
                        ; write it to temp list
                        set tmpNdisWanParam = >($(tmpNdisWanParam), $(DeviceName))
                        set tmpNdisWanEndPointsLst = >($(tmpNdisWanEndPointsLst), $(EndPointCount))
                        ; reset the end point count for the next adapter
                        set EndPointCount = 0
                     endif
                     ; save new adapter number
                     set AdapterNum = $(NewAdapterNum)
                     ; make new device name
                     set DeviceName = "\Device\"$(ProviderName)$(AdapterNum)
                   endif
                   ;increment endpoint count for the new device
                   set-add EndPointCount = $(EndPointCount), 1
               EndForListDo
               ; append the information for the last set of addresses to the
               ; tmp list
               ifstr $(DeviceName) != ""
                   set tmpNdisWanParam = >($(tmpNdisWanParam), $(DeviceName))
                   set tmpNdisWanEndPointsLst = >($(tmpNdisWanEndPointsLst), $(EndPointCount))
               endif
               CloseRegKey $(Provider)
           else
              Debug-Output "OEMNSVRA.INF: could not open HARDWARE\DEVICEMAP\TAPI DEVICES\"$(DriverName)" key."
           endif

           ; make the tapi-aware miniport dependent on NdisTapi
           ; driver so that the driver loads before the miniports.

           Shell "" AddServiceDependency $(ProviderName) "NdisTapi"

           debug-output "tmpNdisWanParam "$(tmpNdisWanParam)
           set NdisWanParam = {}
           set NdisWanEndPointsLst = {}
           debug-output "NdisWanParam "$(NdisWanParam)

           ForListDo $(tmpNdisWanParam)
            ;ifstr $($) != ""
                debug-output "In forlistdo $(tmpNdiswanParam) $($) "$($)
                set NdisWanParam = >($(NdisWanParam), $($))
                set NdisWanEndPointsLst = >($(NdisWanEndPointsLst), *($(tmpNdisWanEndPointsLst), $(#)))
            ;endif
           EndForListDo
           CloseRegKey $(ProviderKey)
       EndForListDo
       CloseRegKey $(RasTapiDevicesKey)
    else
        Debug-Output "OEMNSVRA.INF: could not open RAS\TAPI DEVICES key"
    endif

    ; and write this information as a parameter in the NdisWan section

    OpenRegKey $(!REG_H_LOCAL) "" $(NdisWanParamKeyName) $(!MAXIMUM_ALLOWED) NdisWanParamKey
    ifstr $(NdisWanParamKey) == $(KeyNull)
	Debug-Output "OEMNSVRA.INF: could not open NdisWanParamKey"
        set RegistryErrorIndex = UNABLE_ACCESS_CONFIGURE_SERVICE
        goto fatalregistry
    endif
    Debug-Output "Setting NdisWan param Bind to "$(NdisWanParam)
    set NewValueList = {{Bind, $(NoTitle), $(!REG_VT_MULTI_SZ), $(NdisWanParam)}}
    Shell $(!UtilityInf), AddValueList, $(NdisWanParamKey), $(NewValueList)
    ifint $($ShellCode) != $(!SHELL_CODE_OK)
	CloseRegKey $(NdisWanParamKey)
        goto ShellCodeError
    endif
    Debug-Output "Setting NdisWan param EndPoints to "$(NdisWanEndPointsLst)
    set NewValueList = {{EndPoints, $(NoTitle), $(!REG_VT_MULTI_SZ), $(NdisWanEndPointsLst)}}
    Shell $(!UtilityInf), AddValueList, $(NdisWanParamKey), $(NewValueList)
    ifint $($ShellCode) != $(!SHELL_CODE_OK)
	CloseRegKey $(NdisWanParamKey)
        goto ShellCodeError
    endif
    CloseRegKey $(NdisWanParamKey)
    ; }

    ; GENERATE Ndiswanxx adapters
    ; {
    ; Open the root of the services area and the root of the networkcards
    ; registry key and pass these keys to the AddHardwareComponent call.
    ; this should reduce the number of opens/closes made to the sam
    ; registry area and speed up the adapter creation.

    Shell "utility.inf" BaseServiceKey
    set RegistryErrorIndex = $($R0)
    Ifstr(i) $(RegistryErrorIndex) == NO_ERROR
        Debug-Output "OEMNSVRA.INF: Opened the services base key"
        set ServicesBaseKey = $($R1)
    else
        set ServicesBaseKey = $(KeyNull)
    endif

    OpenRegKey $(!REG_H_LOCAL) "" $(!NetworkCardKeyName) $(MAXIMUM_ALLOWED) KeyNetcards
    Ifstr(i) $(RegistryErrorIndex) == NO_ERROR
        Debug-Output "OEMNSVRA.INF: Opened the networkcardkey "
    endif
    ; start with 1
    set RasAdapterNumber = 1

    ;   Create the HARDWARE\Netcard region and its corresponding service

    ;
    ;generate two bindings for each endpoint
    ;
    set NumTotal = *($(NdisWanEndPointsLst), 1)
    Debug-Output "In the Add if loop. NumTotal = "$(NumTotal)
    set-add NumAddTotal = $(NumTotal), $(NumTotal)

    set ThisOption = NDISWAN
    set HideComponent = 1

    Debug-Output "In the Add if loop. NdisWanEndPointsLst = "$(NdisWanEndPointsLst)
    Debug-Output "In the Add if loop. NumAddTotal = "$(NumAddTotal)

AddNdisWanNetCard = +
    IfInt $(NumAddTotal) == 0
	     goto EndAddNdisWanNetCard
    else

        Debug-Output "In the Add if loop. NumAddTotal = "$(NumAddTotal)

        ; display the adapter number we are adding so that the user
        ; knows what is going on
        shell $(subroutninf) PushBillBoard NETSTATUSDLG +
                              $(WritingRasParamsAdd)" "$(NumAddTotal)

        set-sub NumAddTotal = $(NumAddTotal),1

        Shell $(!UtilityInf), AddHardwareComponent, +
        $(!Product$(ThisOption)Name),$(ProductInfName),+
        $(!Product$(ThisOption)KeyName), +
        $(ServicesBaseKey), $(KeyNetcards), $(RasAdapterNumber)

        ifint $($R4) != -1
           Set !NETCARD_LIST = >($(!NETCARD_LIST), +
                              {$(!Product$(ThisOption)Name),+
                              $(!NetworkCardKeyName)"\"$($R4)})
        ; save the adapter number for the next call to AddHardwareComponent
        set RasAdapterNumber = $($R4)
        endif

        ifint $($ShellCode) != $(!SHELL_CODE_OK)
        Debug-Output "Cannot add hardware component"
        goto ShellCodeError
        endif

        set RegistryErrorIndex = $($R0)

        Ifstr(i) $(RegistryErrorIndex) != NO_ERROR
        EndWait
        Debug-Output "Registry error: add hardware component"
        CloseRegKey $($R1)
        CloseRegKey $($R2)
        CloseRegKey $($R3)
        goto fatalregistry
        endif


        ;   At this point:
        ;     $R1  Registry key variable for HARDWARE\Netcard\(n)
        ;     $R2  Registry key variable for HARDWARE\Netcard\(n)\\NetRules
        ;     $R3  Registry key handle for <service>\Parameters key
        ;     $R4  Adapter number assigned to adapter
        ;     $R5  Service name generated by combining svc name with adapter
        ;          number
        set KeyNetcard    = $($R1)
        set KeyParameters = $($R3)
        set KeyAdapterRules = $($R2)
        set AdapterNumber = $($R4)

        set NetcardInfoList = +
        {{Manufacturer,$(NoTitle),$(!REG_VT_SZ),$(Manufacturer)},+
         {Title,$(NoTitle),$(!REG_VT_SZ),+
          "["$($R4)"] "$(!Product$(ThisOption)Title)},+
         {Description,$(NoTitle),$(!REG_VT_SZ),+
          $(!Product$(ThisOption)Description)},+
         {ServiceName,$(NoTitle),$(!REG_VT_SZ),$($R5)},+
         {InstallDate,$(NoTitle),$(!REG_VT_DWORD),*($(!CurrentDate),1)},+
         {Hidden,$(NoTitle),$(!REG_VT_DWORD),$(HideComponent)}}

        Shell $(!UtilityInf), GetBusTypeNum
        set BusTypeNum = $($R1)

        set NetcardInfoList = >($(NetcardInfoList), +
                         {ProductName,$(NoTitle),$(!REG_VT_SZ),+
                          $(!Product$(ThisOption)DIALINOUTTPDName)})
        set ServiceParamList = +
                 {{EnumExportPref,$(NoTitle),$(!REG_VT_DWORD),0},+
                 {BusType, $(NoTitle), $(!REG_VT_DWORD), $(BusTypeNum)}}
        set AdapterType = $(!NetRuleHardwareDIALINOUTTPDType)
        set AdapterClass = $(!NetRuleHardwareDIALINOUTTPDClass)
        set AdapterBlock = $(!NetRuleHardwareDIALINOUTTPDBlock)

        Shell  $(!UtilityInf), AddValueList, $(KeyNetcard), $(NetcardInfoList)
        ifint $($ShellCode) != $(!SHELL_CODE_OK)
        Debug-Output "ShellCode error"
        goto ShellCodeError
        endif

        CloseRegKey $(KeyNetcard)

        set TempProdName = """"$(!Product$(ThisOption)Name)$(AdapterNumber)""""
        set TempBindForm = $(TempProdName)$(!NetRuleHardware$(ThisOption)BindForm)
        set AdapterRulesList = +
        {{type,$(NoTitle),$(!REG_VT_SZ),+
          $(AdapterType)},+
         {bindform,$(NoTitle),$(!REG_VT_SZ),$(TempBindForm)},+
         {class,$(NoTitle),$(!REG_VT_MULTI_SZ),+
          $(AdapterClass)},+
         {block,$(NoTitle),$(!REG_VT_MULTI_SZ),+
          $(AdapterBlock)},+
         {InfOption,$(NoTitle),$(!REG_VT_SZ),$(ThisOption)},+
         {Infname ,$(NoTitle),$(!REG_VT_SZ),$(ProductInfName)}}

        Shell  $(!UtilityInf), AddValueList, $(KeyAdapterRules), $(AdapterRulesList)
        ifint $($ShellCode) != $(!SHELL_CODE_OK)
        Debug-Output "ShellCode error."
        goto ShellCodeError
        endif

        set RegistryErrorIndex = $($R0)

        Ifstr(i) $(RegistryErrorIndex) != NO_ERROR
        EndWait
        Debug-Output "Resgitry error: add value list."
        CloseRegKey $(KeyParameters)
        CloseRegKey $(KeyAdapterRules)
        goto fatalregistry
        endif

        CloseRegKey $(KeyAdapterRules)

        Shell  $(!UtilityInf), AddValueList, $(KeyParameters), $(ServiceParamList)
        ifint $($ShellCode) != $(!SHELL_CODE_OK)
        Debug-Output "ShellCode error."
        goto ShellCodeError
        endif

        CloseRegKey $(KeyParameters)

        goto AddNdisWanNetCard

    endif ; IfInt NumAddTotal == 0

    ; }

EndAddNdisWanNetCard = +
    Debug-Output "NdisWan added as a hardware component => netcardnames generated."


    goto end

ShellCodeError = +
    read-syms ShellCodeErrorMsg$(!STF_LANGUAGE)
    ui start "Error Message"
    goto setfailed

setfailed = +
    set CommonStatus = STATUS_FAILED
    ;
    ; If OEM_ABANDON_ON, we need to clean up the registry
    ;
    goto RemoveRas

filecopycancel =+
    set CommonStatus = STATUS_NO_EFFECT
    goto RemoveFiles

RemoveRas =+

    StartWait

    set REMOVE_SOFTWARE = {}

    set REMOVE_SOFTWARE = >($(REMOVE_SOFTWARE), $(!ProductNDISWANName))
    set REMOVE_SOFTWARE = >($(REMOVE_SOFTWARE), $(!ProductNDISTESTName))

    ; get the network card numbers corresponding to NdisWan and RasAsyMac
    ; from the registry

    Debug-Output "Remove list "$(REMOVE_SOFTWARE)

    OpenRegKey $(!REG_H_LOCAL) "" $(!NetworkCardKeyName) $(!MAXIMUM_ALLOWED) KeyNetcards
    ifstr $(KeyNetcards) == $(KeyNull)
         Debug-Output "OEMNSVRA.INF: could not open Netcards key"
         goto RemoveSoftware
    endif

    EnumRegKey $(KeyNetcards) NetcardsList

    Debug-Output "Netcards list "$(NetcardsList)

    ForListDo $(NetcardsList)
       set KeyName = *($($),1)
       OpenRegKey $(KeyNetcards) "" $(KeyName) $(!MAXIMUM_ALLOWED) Card
       ifstr $(Card) == $(KeyNull)
           Debug-Output "OEMNSVRA.INF: could not open netcard key"
           goto RemoveSoftware
       endif
       GetRegValue $(Card), "ProductName" ProductNameInfo
       set CardProductName = *($(ProductNameInfo), 4)
       ifstr(i) $(CardProductName) == $(!ProductNDISWANDIALINOUTTPDName)
             set !NETCARD_LIST = >($(!NETCARD_LIST), +
	                         {$(!ProductNDISWANName),+
                                 $(!NetworkCardKeyName)"\"$(KeyName)})
       endif
       CloseRegKey $(Card)
    EndForListDo

    CloseRegKey $(KeyNetcards)

    read-syms StatusUpdatingRegistry$(!STF_LANGUAGE)

    shell $(subroutninf) PushBillBoard NETSTATUSDLG $(Removingbindings)

    QueryListSize NumRemove $(!NETCARD_LIST)

    Debug-Output "NETCARD_LIST "$(!NETCARD_LIST)

    ForListDo  $(!NETCARD_LIST)
        ; display the adapter number we are adding so that the user
        ; knows what is going on
        shell $(subroutninf) PushBillBoard NETSTATUSDLG +
                              $(RemovingAdapters)" "$(NumRemove)
        Set BillboardVisible = 1
        debug-output "Removing hardware component: "$($)
        Shell $(!UtilityInf), RemoveHardwareComponent, $(Manufacturer),+
              *($($),1), *($($),2)
        set-sub NumRemove = $(NumRemove), 1
    EndForListDo

RemoveSoftware = +

    Shell "" RemoveNdisTapiService

    ; Remove any additional services we added for IP and IPX
    ; we do this before we remove the RAS software components because
    ; there are dependencies to take care of.

    Debug-Output "Remove Software List "$(REMOVE_SOFTWARE)

    ForListDo  $(REMOVE_SOFTWARE)
        Debug-Output "Removing software component: "$($)
        ifstr(i) $($) == RAS
             OpenRegKey $(!REG_H_LOCAL) "" $(ProductKeyBase) +
                        $(!MAXIMUM_ALLOWED) ProductKey
             Ifstr $(ProductKey) == $(KeyNull)
                Debug-Output "OEMNSVRA.INF: could not open Software product key"
                 goto RemoveFiles
             endif
             DeleteRegTree $(ProductKey) $(Product$($)Name)
             CloseRegKey $(ProductKey)
        else
            Shell $(!UtilityInf), RemoveSoftwareComponent, $(Manufacturer), $($)
        endif
    EndForListDo

RemoveFiles = +
        Install RemoveFiles
        goto end

fatalregistry = +
    Shell $(!UtilityInf) RegistryErrorString $(RegistryErrorIndex)
    ifint $($ShellCode) != $(!SHELL_CODE_OK)
       Debug-Output "fatalregistry: shell to find RegistryErrorString failed."
       goto ShellCodeError
    endif
    ifstr(i) $(RasSpecificString) != ""
        set Error = $($R0)" - service "$(RasSpecificString)"."
    else
        set Error = $($R0)
    endif
    read-syms AbortMessage$(!STF_LANGUAGE)
    set Error = $(Error)$(!LF)$(!LF)$(AbortText)
    goto fatal

fatal =    +
    Shell $(subroutninf) SetupMessage, $(!STF_LANGUAGE), "FATAL", $(Error)
    ifint $($ShellCode) != $(!SHELL_CODE_OK)
        Debug-Output "fatal: shell to SetupMessage failed."
    goto ShellCodeError
    endif
    goto setfailed

end = +

    Debug-Output "ending at last!!"
    goto term

term = +
    Debug-Output "OEMSETNT.INF:term: ; CommonStatus "$(CommonStatus)
    Return $(CommonStatus)


[InstallFiles]

    set STF_VITAL = ""
    Debug-Output  "In InstallFiles Copying Files"

    AddSectionFilesToCopyList Files-Common $(SourceDir) +
                 $(!STF_WINDOWSSYSPATH)
    AddSectionFilesToCopyList Files-Drivers $(SourceDir) +
                 $(!STF_WINDOWSSYSPATH)\drivers

    set !STF_NCPA_FLUSH_COPYLIST = TRUE  ; ZZ
    CopyFilesInCopyList
    Debug-Output  "Done Copying Files"

    exit

[RemoveFiles]

    ; we should actually use RemoveSectionFiles, but setup hasn't implemented
    ; it yet, so we remove file by file.

    set RemoveList = {}
    set RenameList = {}

    set RemoveList = >($(RemoveList), #(Files-RemoveList, HAPISUMEXE, 1))
    set RemoveList = >($(RemoveList), #(Files-RemoveList, HAPIEXE, 1))
    set RemoveList = >($(RemoveList), #(Files-RemoveList, WANCONNDLL, 1))
    set RemoveList = >($(RemoveList), #(Files-RemoveList, NDISTESTDLL, 1))
    set RemoveList = >($(RemoveList), #(Files-RemoveList, H_COREDLL, 1))

    ; HAPI stuff; scripts

    set RenameList = >($(RenameList), #(Files-RemoveList, NDISWANSYS, 1))
    set RenameList = >($(RenameList), #(Files-RemoveList, NDISTAPISYS, 1))
    set RenameList = >($(RenameList), #(Files-RemoveList, NDISTESTSYS, 1))

    ; delete the dll's and exe's
    ;
    ForListDo $(RemoveList)
        Debug-Output "Removing "$($)
        LibraryProcedure Status , $(!LIBHANDLE), DelFile $($)
        Debug-Output "Status is "$(Status)
    EndForListDo

    ; mark the sys's for deletion on next boot
    ;
    ForListDo $(RenameList)
        Split-String $($) "\" FilePath
        QueryListSize PathLen $(FilePath)
        Split-String *($(FilePath),$(PathLen)) "." FullFileName
        Set FileName = *($(FullFileName),1)
        Debug-Output "FileName is "$(FileName)
        LibraryProcedure STATUS, $(!LIBHANDLE),CheckFileExistance $(!STF_WINDOWSSYSPATH)"\DRIVERS\"$(FileName)".old"
        Debug-Output "CheckFile Status = "$(STATUS)
        ifstr(i) $(STATUS) == YES
            LibraryProcedure STATUS, $(!LIBHANDLE), DelFile $(!STF_WINDOWSSYSPATH)"\DRIVERS\"$(FileName)".old"
            Debug-Output "Delfile Status = "$(STATUS)
        endif
        Debug-Output "Renaming from "$($)
        Debug-Output "Renaming to "$(!STF_WINDOWSSYSPATH)"\DRIVERS\"$(FileName)".old"

        LibraryProcedure Status1 , $(!LIBHANDLE), RenFile $($), $(!STF_WINDOWSSYSPATH)"\DRIVERS\"$(FileName)".old"
        Debug-Output "Status is "$(Status1)

         ; Add the files to the delete list so that they get deleted at next boot

        AddFileToDeleteList $(!STF_WINDOWSSYSPATH)"\DRIVERS\"$(FileName)".old"

    EndForListDo

    exit

[InstallNdisTapiService]
; install the NdisTapi service if it is not already installed

    set Status = STATUS_SUCCESSFUL
    set KeyNull = ""

    Debug-Output "InstallNdisTapiService entry"

    OpenRegKey $(!REG_H_LOCAL) "" $(!NdisTapiKeyName) $(!MAXIMUM_ALLOWED) KeyService
    Ifstr(i) $(KeyService) == $(KeyNull)
        Shell "utility.inf", CreateService, $(!ProductNDISTAPIName), +
            $(!ProductNDISTAPIDisplayName), +
            $(!ProductNDISTAPIImagePath), +
            "kernelauto", "NDIS", {}, ""
        ifint $($ShellCode) != $(!SHELL_CODE_OK)
            Debug-Output "OEMNSVRA.INF: InstallNdisTapiService : ShellCode error"
            return STATUS_FAILED
        endif

        set RegistryErrorIndex = $($R0)
        set ParamKey = $($R2)
        CloseRegKey $($R1)
        CloseRegKey $($R3)

        Ifstr(i) $(RegistryErrorIndex) != NO_ERROR
            Debug-Output "OEMNSVRA.INF: InstallNdisTapiService: Registry error create service"
            return STATUS_FAILED
        endif

        ; 768 = 32 * NDIS_TAPI_EVENT

        SetRegValue $(ParamKey) {AsyncEventQueueSize, 0, $(!REG_VT_DWORD), 768}
        CloseRegKey $(ParamKey)

;        ; Add NdisTapiService to the DependOnService List of XXX service
;        Shell "" AddServiceDependency "TCPIP" $(!ProductRASARPName)
;        ifstr(i) $($R0) == STATUS_FAILED
;            Debug-Output "InstallNdisTapiService: error adding service dependency"
;        endif

    endif
    Ifstr(i) $(KeyService) != $(KeyNull)
        CloseRegKey $(KeyService)
    endif

    Debug-Output "InstallNdisTapiService exit"

    return $(Status)

[RemoveNdisTapiService]
    set Status = STATUS_SUCCESSFUL
    set KeyNull = ""
    Debug-Output "RemoveNdisTapiService entry"
    OpenRegKey $(!REG_H_LOCAL) "" $(!NdisTapiKeyName) $(!MAXIMUM_ALLOWED) KeyService
    Ifstr(i) $(KeyService) != $(KeyNull)
        Shell "utility.inf", RemoveService $(!ProductNDISTAPIName) "YES"
        ifint $($ShellCode) != $(!SHELL_CODE_OK)
            Debug-Output "OEMNSVRA.INF: RemoveNdisTapiService : ShellCode error"
            return STATUS_FAILED
        endif
        set RegistryErrorIndex = $($R0)
        Ifstr(i) $(RegistryErrorIndex) != NO_ERROR
            Debug-Output "OEMNSVRA.INF: RemoveNdisTapiService: Registry error: "
            return STATUS_FAILED
        endif
        CloseRegKey $(KeyService)
    endif
    Debug-Output "RemoveNdisTapiService exit"
    return $(Status)

[AddNDISWANToServiceGroupOrder]
    ; Add NDISWAN to the ServiceGroupOrder list between NDIS and TDI so
    ; that the NdisWan driver loads after the NDIS group components like
    ; AsyMac driver or the TAPI providers have loaded.

    set GroupOrderName = "SYSTEM\CurrentControlSet\Control\ServiceGroupOrder"

    OpenRegKey $(!REG_H_LOCAL) "" $(GroupOrderName) $(!MAXIMUM_ALLOWED) KeyGroup
    set OldList = {}
    Ifstr(i) $(KeyGroup) != $(KeyNull)
        GetRegValue  $(KeyGroup) "List" TmpList
        ifint $(RegLastError) == 0
            ForListDo *($(TmpList), 4)
                set OldList = >($(OldList), $($))
            EndForListDo
        endif
        Debug-Output "AddNDISWANToServiceGroupOrder current list "$(OldList)

        Ifcontains(i) "NDISWAN" not-in $(OldList)
            set NewGroupList = {}
            ForListDo $(OldList)
                set NewGroupList = >($(NewGroupList), $($))
                ifstr(i) $($) == "NDIS"
                    ; add NDISWAN just after NDIS in the group order
                    set NewGroupList = >($(NewGroupList), "NDISWAN" )
                endif
            EndForListDo
            Debug-Output "AddNDISWANToServiceGroupOrder new list "$(NewGroupList)
            SetRegValue $(KeyGroup) {List, 0,$(!REG_VT_MULTI_SZ),$(NewGroupList)}
        endif
        CloseRegKey $(KeyGroup)
    else
        Debug-Output "AddNDISWANToServiceGroupOrder error opening ServiceGroupOrder key."
    endif
    return

[LanguagesSupported]
    ENG

[StatusUpdatingRegistryENG]
    CreatingRas             = "Please wait while NdisWan Test Tool is installed..."
    WritingRasParams        = "Writing NdisWan Test Tool parameters..."
    WritingRasParamsAdd     = "Writing NdisWan Test Tool parameters...Adding bindings "
    Removingbindings        = "Writing NdisWan Test Tool parameters...Removing bindings"

[Source Media Descriptions]
    1 = "Test Protocol Driver Disk #1" ;, TAGFILE = testp.1
    2 = "Test Protocol Driver Disk #2" ;, TAGFILE = abc

[Files-Common]
1, WANCONN.dll , SIZE=999
1, NDISTEST.DLL , SIZE=999
1, TPDCPFL.INF , SIZE=999
1, H_CORE.DLL, SIZE=999
1, HAPI.EXE , SIZE=999
1, HAPISUM.EXE, SIZE=999
; SCRIPTS ??

[Files-Drivers]
1,NDISTEST.SYS , SIZE=999
; these files copied in tpdcpfl.inf
;1,NDISTAPI.SYS , SIZE=999
;1,NDISWAN.SYS , SIZE=999

[Files-RemoveList]
HAPISUMEXE = $(!STF_WINDOWSSYSPATH)\HAPISUM.EXE
HAPIEXE  = $(!STF_WINDOWSSYSPATH)\HAPI.EXE
WANCONNDLL    = $(!STF_WINDOWSSYSPATH)\WANCONN.DLL
H_COREDLL = $(!STF_WINDOWSSYSPATH)\H_CORE.DLL
NDISTESTDLL = $(!STF_WINDOWSSYSPATH)\NDISTEST.DLL
NDISTESTSYS = $(!STF_WINDOWSSYSPATH)\DRIVERS\NDISTEST.SYS
NDISWANSYS = $(!STF_WINDOWSSYSPATH)\DRIVERS\NDISWAN.SYS
NDISTAPISYS = $(!STF_WINDOWSSYSPATH)\DRIVERS\NDISTAPI.SYS

[FileConstantsENG]
    RasGroup    = "NdisWan Test Tool Service"
    ReadMe      = "Read Me"
    RasHelp     = "NdisWan Test Tool Help"
    ProCaption   = "NdisWan Test Tool Driver Setup"
    ProCancel    = "Cance&l"
    ProCancelMsg = "NdisWan Test Tool Service is not correctly installed. "+
                   "Are you sure you want to cancel copying files?"
    ProCancelCap = "NdisWan Test Tool Service Setup Message"
    ProText1     = "Copying:"
    ProText2     = "To:"
    Error        = "Unable to determine proper source disk location; copy cannot be performed."
    FunctionTitle   ="NdisWan Test Tool Setup"

    !ProductNDISWANDescription  = "Windows NT WAN Wrapper"
    !ProductNDISTESTDescription  = "NdisWan Test Tool"
    !ProductNDISWANTitle             = "Windows NT WAN Wrapper"
    !ProductNDISWANDisplayName       = "Windows NT WAN Wrapper"
    !ProductNDISTESTTitle             = "NdisWan Test Tool"
    !ProductNDISTESTDisplayName       = "NdisWan Test Tool"
    !ProductNDISTAPIDisplayName = "Microsoft NDIS TAPI driver"

[DialogConstantsENG]
    Help        = "&Help"
    Exit        = "E&xit"
    OK          = "OK"
    HelpContext = ""
    Continue    = "C&ontinue"
    Cancel      = "C&ancel"

[FileCopyMesgENG]
    ;Text1   = "Please copy the following files from the NT setup media to "$(LF)+
    ;          "the system directory :"$(LF)$(LF)

    Text1   = "Copying the following files from the NT setup media to "$(LF)+
              "the system directory :"$(LF)$(LF)

[WarningMsgENG]
    Text = "Before installing the NdisWan Test Tool, please install the miniport "$(LF)+
           "driver being tested."$(LF)+
           "If the driver is installed, click 'OK' to continue else click 'CANCEL' to abort"$(LF)+
           "this installation."$(LF)$(LF)+
           "Also, make sure that Windows NT Remote Access Service (RAS) is not installed"$(LF)+
           "before trying to run this tool."

[ShellCodeErrorMsgENG]
    DlgType      = "MessageBox"
    STF_MB_TITLE = "Error: "$(FunctionTitle)
    STF_MB_TEXT  = "An error occured running the shell command. Please "+
                   "restart the system to fix the problem."
    STF_MB_TYPE  = 1
    STF_MB_ICON  = 3
    STF_MB_DEF   = 1

[AbortMessageENG]
    AbortText  =  " Aborting NdisWan Test Tool Setup. Please restart the system "+
                "to fix the problem."

[OptionsTextENG]
    TPD = "NdisWan Test Tool"

[StatusUpdatingRegistryENG]
    CreatingRas             = "Please wait while NdisWan Test Tool is installed..."

